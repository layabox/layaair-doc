
console.log("LayaAir2.0-3D-12345");

var window = window || global;
var document = document || (window.document = {});
/***********************************/
/*http://www.layabox.com  2017/3/23*/
/***********************************/
var Laya=window.Laya=(function(window,document){
	var Laya={
		__internals:[],
		__packages:{},
		__classmap:{'Object':Object,'Function':Function,'Array':Array,'String':String},
		__sysClass:{'object':'Object','array':'Array','string':'String','dictionary':'Dictionary'},
		__propun:{writable: true,enumerable: false,configurable: true},
		__presubstr:String.prototype.substr,
		__substr:function(ofs,sz){return arguments.length==1?Laya.__presubstr.call(this,ofs):Laya.__presubstr.call(this,ofs,sz>0?sz:(this.length+sz));},
		__init:function(_classs){_classs.forEach(function(o){o.__init$ && o.__init$();});},
		__isClass:function(o){return o && (o.__isclass || o==Object || o==String || o==Array);},
		__newvec:function(sz,value){
			var d=[];
			d.length=sz;
			for(var i=0;i<sz;i++) d[i]=value;
			return d;
		},
		__extend:function(d,b){
			for (var p in b){
				if (!b.hasOwnProperty(p)) continue;
				var gs=Object.getOwnPropertyDescriptor(b, p);
				var g = gs.get, s = gs.set; 
				if ( g || s ) {
					if ( g && s)
						Object.defineProperty(d,p,gs);
					else{
						g && Object.defineProperty(d, p, g);
						s && Object.defineProperty(d, p, s);
					}
				}
				else d[p] = b[p];
			}
			function __() { Laya.un(this,'constructor',d); }__.prototype=b.prototype;d.prototype=new __();Laya.un(d.prototype,'__imps',Laya.__copy({},b.prototype.__imps));
		},
		__copy:function(dec,src){
			if(!src) return null;
			dec=dec||{};
			for(var i in src) dec[i]=src[i];
			return dec;
		},
		__package:function(name,o){
			if(Laya.__packages[name]) return;
			Laya.__packages[name]=true;
			var p=window,strs=name.split('.');
			if(strs.length>1){
				for(var i=0,sz=strs.length-1;i<sz;i++){
					var c=p[strs[i]];
					p=c?c:(p[strs[i]]={});
				}
			}
			p[strs[strs.length-1]] || (p[strs[strs.length-1]]=o||{});
		},
		__hasOwnProperty:function(name,o){
			o=o ||this;
		    function classHas(name,o){
				if(Object.hasOwnProperty.call(o.prototype,name)) return true;
				var s=o.prototype.__super;
				return s==null?null:classHas(name,s);
			}
			return (Object.hasOwnProperty.call(o,name)) || classHas(name,o.__class);
		},
		__typeof:function(o,value){
			if(!o || !value) return false;
			if(value===String) return (typeof o==='string');
			if(value===Number) return (typeof o==='number');
			if(value.__interface__) value=value.__interface__;
			else if(typeof value!='string')  return (o instanceof value);
			return (o.__imps && o.__imps[value]) || (o.__class==value);
		},
		__as:function(value,type){
			return (this.__typeof(value,type))?value:null;
		},		
		interface:function(name,_super){
			Laya.__package(name,{});
			var ins=Laya.__internals;
			var a=ins[name]=ins[name] || {self:name};
			if(_super)
			{
				var supers=_super.split(',');
				a.extend=[];
				for(var i=0;i<supers.length;i++){
					var nm=supers[i];
					ins[nm]=ins[nm] || {self:nm};
					a.extend.push(ins[nm]);
				}
			}
			var o=window,words=name.split('.');
			for(var i=0;i<words.length-1;i++) o=o[words[i]];
			o[words[words.length-1]]={__interface__:name};
		},
		class:function(o,fullName,_super,miniName){
			_super && Laya.__extend(o,_super);
			if(fullName){
				Laya.__package(fullName,o);
				Laya.__classmap[fullName]=o;
				if(fullName.indexOf('.')>0){
					if(fullName.indexOf('laya.')==0){
						var paths=fullName.split('.');
						miniName=miniName || paths[paths.length-1];
						if(Laya[miniName]) console.log("Warning!,this class["+miniName+"] already exist:",Laya[miniName]);
						Laya[miniName]=o;
					}
				}
				else {
					if(fullName=="Main")
						window.Main=o;
					else{
						if(Laya[fullName]){
							console.log("Error!,this class["+fullName+"] already exist:",Laya[fullName]);
						}
						Laya[fullName]=o;
					}
				}
			}
			var un=Laya.un,p=o.prototype;
			un(p,'hasOwnProperty',Laya.__hasOwnProperty);
			un(p,'__class',o);
			un(p,'__super',_super);
			un(p,'__className',fullName);
			un(o,'__super',_super);
			un(o,'__className',fullName);
			un(o,'__isclass',true);
			un(o,'super',function(o){this.__super.call(o);});
		},
		imps:function(dec,src){
			if(!src) return null;
			var d=dec.__imps|| Laya.un(dec,'__imps',{});
			function __(name){
				var c,exs;
				if(! (c=Laya.__internals[name]) ) return;
				d[name]=true;
				if(!(exs=c.extend)) return;
				for(var i=0;i<exs.length;i++){
					__(exs[i].self);
				}
			}
			for(var i in src) __(i);
		},
		getset:function(isStatic,o,name,getfn,setfn){
			if(!isStatic){
				getfn && Laya.un(o,'_$get_'+name,getfn);
				setfn && Laya.un(o,'_$set_'+name,setfn);
			}
			else{
				getfn && (o['_$GET_'+name]=getfn);
				setfn && (o['_$SET_'+name]=setfn);
			}
			if(getfn && setfn) 
				Object.defineProperty(o,name,{get:getfn,set:setfn,enumerable:false});
			else{
				getfn && Object.defineProperty(o,name,{get:getfn,enumerable:false});
				setfn && Object.defineProperty(o,name,{set:setfn,enumerable:false});
			}
		},
		static:function(_class,def){
				for(var i=0,sz=def.length;i<sz;i+=2){
					if(def[i]=='length') 
						_class.length=def[i+1].call(_class);
					else{
						function tmp(){
							var name=def[i];
							var getfn=def[i+1];
							Object.defineProperty(_class,name,{
								get:function(){delete this[name];return this[name]=getfn.call(this);},
								set:function(v){delete this[name];this[name]=v;},enumerable: true,configurable: true});
						}
						tmp();
					}
				}
		},		
		un:function(obj,name,value){
			value || (value=obj[name]);
			Laya.__propun.value=value;
			Object.defineProperty(obj, name, Laya.__propun);
			return value;
		},
		uns:function(obj,names){
			names.forEach(function(o){Laya.un(obj,o)});
		}
	};

	window.console=window.console || ({log:function(){}});
	window.trace=window.console.log;
	Error.prototype.throwError=function(){throw arguments;};
	//String.prototype.substr=Laya.__substr;
	Object.defineProperty(Array.prototype,'fixed',{enumerable: false});

	return Laya;
})(window,document);

(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;
	Laya.interface('laya.d3.core.IClone');
	Laya.interface('laya.runtime.IMarket');
	Laya.interface('laya.resource.IDispose');
	Laya.interface('laya.resource.IDestroy');
	Laya.interface('laya.webgl.shapes.IShape');
	Laya.interface('laya.d3.graphics.IVertex');
	Laya.interface('laya.webgl.submit.ISubmit');
	Laya.interface('laya.filters.IFilterAction');
	Laya.interface('laya.d3.core.scene.ITreeNode');
	Laya.interface('laya.webgl.text.ICharSegment');
	Laya.interface('laya.runtime.ICPlatformClass');
	Laya.interface('laya.resource.ICreateResource');
	Laya.interface('laya.webgl.canvas.save.ISaveData');
	Laya.interface('laya.filters.IFilterActionGL','laya.filters.IFilterAction');
	/**
	*<code>Laya</code> 是全局对象的引用入口集。
	*Laya类引用了一些常用的全局对象，比如Laya.stage：舞台，Laya.timer：时间管理器，Laya.loader：加载管理器，使用时注意大小写。
	*/
	//class Laya
	var ___Laya=(function(){
		//function Laya(){};
		/**
		*表示是否捕获全局错误并弹出提示。默认为false。
		*适用于移动设备等不方便调试的时候，设置为true后，如有未知错误，可以弹窗抛出详细错误堆栈。
		*/
		__getset(1,Laya,'alertGlobalError',null,function(value){
			var erralert=0;
			if (value){
				Browser.window.onerror=function (msg,url,line,column,detail){
					if (erralert++< 5 && detail)
						alert("出错啦，请把此信息截图给研发商\n"+msg+"\n"+detail.stack);
				}
				}else {
				Browser.window.onerror=null;
			}
		});

		Laya.init=function(width,height,__plugins){
			var plugins=[];for(var i=2,sz=arguments.length;i<sz;i++)plugins.push(arguments[i]);
			if (Laya._isinit)return;
			Laya._isinit=true;
			if (window.conch)RunDriver.enableNative();
			ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice=Laya._arrayBufferSlice);
			GLCommandEncoder.__init__();
			Browser.__init__();
			Context.__init__();
			Laya.timer=new Timer();
			Laya.loader=new LoaderManager();
			WeakObject.__init__();
			for (var i=0,n=plugins.length;i < n;i++){
				if (plugins[i].enable)plugins[i].enable();
			}
			ResourceManager.__init__();
			CacheManger.beginCheck();
			Laya._currentStage=Laya.stage=new Stage();
			var location=Browser.window.location;
			var pathName=location.pathname;
			pathName=pathName.charAt(2)==':' ? pathName.substring(1):pathName;
			URL.rootPath=URL.basePath=URL.getPath(location.protocol=="file:" ? pathName :location.protocol+"//"+location.host+location.pathname);
			Laya.render=new Render(0,0);
			Laya.stage.size(width,height);
			window.stage=Laya.stage;
			RenderSprite.__init__();
			KeyBoardManager.__init__();
			MouseManager.instance.__init__(Laya.stage,Render.canvas);
			Input.__init__();
			SoundManager.autoStopMusic=true;
			LayaNative2D.__init__();
			return Render.canvas;
		}

		Laya._arrayBufferSlice=function(start,end){
			var arr=this;
			var arrU8List=new Uint8Array(arr,start,end-start);
			var newU8List=new Uint8Array(arrU8List.length);
			newU8List.set(arrU8List);
			return newU8List.buffer;
		}

		Laya.stage=null;
		Laya.timer=null;
		Laya.loader=null;
		Laya.version="1.7.7beta";
		Laya.render=null
		Laya._currentStage=null
		Laya._isinit=false;
		__static(Laya,
		['conchMarket',function(){return this.conchMarket=window.conch?conchMarket:null;},'PlatformClass',function(){return this.PlatformClass=window.PlatformClass;}
		]);
		return Laya;
	})()


	//class laya.webgl.canvas.save.SaveBase
	var SaveBase=(function(){
		function SaveBase(){
			//this._valueName=null;
			//this._value=null;
			//this._dataObj=null;
			//this._newSubmit=false;
		}

		__class(SaveBase,'laya.webgl.canvas.save.SaveBase');
		var __proto=SaveBase.prototype;
		Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
		__proto.isSaveMark=function(){return false;}
		__proto.restore=function(context){
			this._dataObj[this._valueName]=this._value;
			SaveBase.POOL[SaveBase.POOL._length++]=this;
			this._newSubmit && (context._curSubmit=Submit.RENDERBASE);
		}

		SaveBase._createArray=function(){
			var value=[];
			value._length=0;
			return value;
		}

		SaveBase._init=function(){
			var namemap=SaveBase._namemap={};
			namemap[0x1]="ALPHA";
			namemap[0x2]="fillStyle";
			namemap[0x8]="font";
			namemap[0x100]="lineWidth";
			namemap[0x200]="strokeStyle";
			namemap[0x2000]="_mergeID";
			namemap[0x400]=namemap[0x800]=namemap[0x1000]=[];
			namemap[0x4000]="textBaseline";
			namemap[0x8000]="textAlign";
			namemap[0x10000]="_nBlendType";
			namemap[0x100000]="shader";
			namemap[0x200000]="filters";
			return namemap;
		}

		SaveBase.save=function(context,type,dataObj,newSubmit){
			if ((context._saveMark._saveuse & type)!==type){
				context._saveMark._saveuse |=type;
				var cache=SaveBase.POOL;
				var o=cache._length > 0 ? cache[--cache._length] :(new SaveBase());
				o._value=dataObj[o._valueName=SaveBase._namemap[type]];
				o._dataObj=dataObj;
				o._newSubmit=newSubmit;
				var _save=context._save;
				_save[_save._length++]=o;
			}
		}

		SaveBase.POOL=laya.webgl.canvas.save.SaveBase._createArray();
		SaveBase._namemap=SaveBase._init();
		return SaveBase;
	})()


	/**
	*<code>EventDispatcher</code> 类是可调度事件的所有类的基类。
	*/
	//class laya.events.EventDispatcher
	var EventDispatcher=(function(){
		var EventHandler;
		function EventDispatcher(){
			this._$0__events=null;
		}

		__class(EventDispatcher,'laya.events.EventDispatcher');
		var __proto=EventDispatcher.prototype;
		/**
		*检查 EventDispatcher 对象是否为特定事件类型注册了任何侦听器。
		*@param type 事件的类型。
		*@return 如果指定类型的侦听器已注册，则值为 true；否则，值为 false。
		*/
		__proto.hasListener=function(type){
			var listener=this._$0__events && this._$0__events[type];
			return !!listener;
		}

		/**
		*派发事件。
		*@param type 事件类型。
		*@param data （可选）回调数据。<b>注意：</b>如果是需要传递多个参数 p1,p2,p3,...可以使用数组结构如：[p1,p2,p3,...] ；如果需要回调单个参数 p ，且 p 是一个数组，则需要使用结构如：[p]，其他的单个参数 p ，可以直接传入参数 p。
		*@return 此事件类型是否有侦听者，如果有侦听者则值为 true，否则值为 false。
		*/
		__proto.event=function(type,data){
			if (!this._$0__events || !this._$0__events[type])return false;
			var listeners=this._$0__events[type];
			if (listeners.run){
				if (listeners.once)delete this._$0__events[type];
				data !=null ? listeners.runWith(data):listeners.run();
				}else {
				for (var i=0,n=listeners.length;i < n;i++){
					var listener=listeners[i];
					if (listener){
						(data !=null)? listener.runWith(data):listener.run();
					}
					if (!listener || listener.once){
						listeners.splice(i,1);
						i--;
						n--;
					}
				}
				if (listeners.length===0 && this._$0__events)delete this._$0__events[type];
			}
			return true;
		}

		/**
		*使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知。
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args （可选）事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.on=function(type,caller,listener,args){
			return this._createListener(type,caller,listener,args,false);
		}

		/**
		*使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知，此侦听事件响应一次后自动移除。
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args （可选）事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.once=function(type,caller,listener,args){
			return this._createListener(type,caller,listener,args,true);
		}

		/**@private */
		__proto._createListener=function(type,caller,listener,args,once,offBefore){
			(offBefore===void 0)&& (offBefore=true);
			offBefore && this.off(type,caller,listener,once);
			var handler=EventHandler.create(caller || this,listener,args,once);
			this._$0__events || (this._$0__events={});
			var events=this._$0__events;
			if (!events[type])events[type]=handler;
			else {
				if (!events[type].run)events[type].push(handler);
				else events[type]=[events[type],handler];
			}
			return this;
		}

		/**
		*从 EventDispatcher 对象中删除侦听器。
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param onceOnly （可选）如果值为 true ,则只移除通过 once 方法添加的侦听器。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.off=function(type,caller,listener,onceOnly){
			(onceOnly===void 0)&& (onceOnly=false);
			if (!this._$0__events || !this._$0__events[type])return this;
			var listeners=this._$0__events[type];
			if (listener !=null){
				if (listeners.run){
					if ((!caller || listeners.caller===caller)&& listeners.method===listener && (!onceOnly || listeners.once)){
						delete this._$0__events[type];
						listeners.recover();
					}
					}else {
					var count=0;
					for (var i=0,n=listeners.length;i < n;i++){
						var item=listeners[i];
						if (item && (!caller || item.caller===caller)&& item.method===listener && (!onceOnly || item.once)){
							count++;
							listeners[i]=null;
							item.recover();
						}
					}
					if (count===n)delete this._$0__events[type];
				}
			}
			return this;
		}

		/**
		*从 EventDispatcher 对象中删除指定事件类型的所有侦听器。
		*@param type （可选）事件类型，如果值为 null，则移除本对象所有类型的侦听器。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.offAll=function(type){
			var events=this._$0__events;
			if (!events)return this;
			if (type){
				this._recoverHandlers(events[type]);
				delete events[type];
				}else {
				for (var name in events){
					this._recoverHandlers(events[name]);
				}
				this._$0__events=null;
			}
			return this;
		}

		__proto._recoverHandlers=function(arr){
			if (!arr)return;
			if (arr.run){
				arr.recover();
				}else {
				for (var i=arr.length-1;i >-1;i--){
					if (arr[i]){
						arr[i].recover();
						arr[i]=null;
					}
				}
			}
		}

		/**
		*检测指定事件类型是否是鼠标事件。
		*@param type 事件的类型。
		*@return 如果是鼠标事件，则值为 true;否则，值为 false。
		*/
		__proto.isMouseEvent=function(type){
			return EventDispatcher.MOUSE_EVENTS[type] || false;
		}

		EventDispatcher.MOUSE_EVENTS={"rightmousedown":true,"rightmouseup":true,"rightclick":true,"mousedown":true,"mouseup":true,"mousemove":true,"mouseover":true,"mouseout":true,"click":true,"doubleclick":true};
		EventDispatcher.__init$=function(){
			Object.defineProperty(laya.events.EventDispatcher.prototype,"_events",{enumerable:false,writable:true});
			/**@private */
			//class EventHandler extends laya.utils.Handler
			EventHandler=(function(_super){
				function EventHandler(caller,method,args,once){
					EventHandler.__super.call(this,caller,method,args,once);
				}
				__class(EventHandler,'',_super);
				var __proto=EventHandler.prototype;
				__proto.recover=function(){
					if (this._id > 0){
						this._id=0;
						EventHandler._pool.push(this.clear());
					}
				}
				EventHandler.create=function(caller,method,args,once){
					(once===void 0)&& (once=true);
					if (EventHandler._pool.length)return EventHandler._pool.pop().setTo(caller,method,args,once);
					return new EventHandler(caller,method,args,once);
				}
				EventHandler._pool=[];
				return EventHandler;
			})(Handler)
		}

		return EventDispatcher;
	})()


	/**
	*<p><code>Handler</code> 是事件处理器类。</p>
	*<p>推荐使用 Handler.create()方法从对象池创建，减少对象创建消耗。创建的 Handler 对象不再使用后，可以使用 Handler.recover()将其回收到对象池，回收后不要再使用此对象，否则会导致不可预料的错误。</p>
	*<p><b>注意：</b>由于鼠标事件也用本对象池，不正确的回收及调用，可能会影响鼠标事件的执行。</p>
	*/
	//class laya.utils.Handler
	var Handler=(function(){
		function Handler(caller,method,args,once){
			//this.caller=null;
			//this.method=null;
			//this.args=null;
			this.once=false;
			this._id=0;
			(once===void 0)&& (once=false);
			this.setTo(caller,method,args,once);
		}

		__class(Handler,'laya.utils.Handler');
		var __proto=Handler.prototype;
		/**
		*设置此对象的指定属性值。
		*@param caller 执行域(this)。
		*@param method 回调方法。
		*@param args 携带的参数。
		*@param once 是否只执行一次，如果为true，执行后执行recover()进行回收。
		*@return 返回 handler 本身。
		*/
		__proto.setTo=function(caller,method,args,once){
			this._id=Handler._gid++;
			this.caller=caller;
			this.method=method;
			this.args=args;
			this.once=once;
			return this;
		}

		/**
		*执行处理器。
		*/
		__proto.run=function(){
			if (this.method==null)return null;
			var id=this._id;
			var result=this.method.apply(this.caller,this.args);
			this._id===id && this.once && this.recover();
			return result;
		}

		/**
		*执行处理器，并携带额外数据。
		*@param data 附加的回调数据，可以是单数据或者Array(作为多参)。
		*/
		__proto.runWith=function(data){
			if (this.method==null)return null;
			var id=this._id;
			if (data==null)
				var result=this.method.apply(this.caller,this.args);
			else if (!this.args && !data.unshift)result=this.method.call(this.caller,data);
			else if (this.args)result=this.method.apply(this.caller,this.args.concat(data));
			else result=this.method.apply(this.caller,data);
			this._id===id && this.once && this.recover();
			return result;
		}

		/**
		*清理对象引用。
		*/
		__proto.clear=function(){
			this.caller=null;
			this.method=null;
			this.args=null;
			return this;
		}

		/**
		*清理并回收到 Handler 对象池内。
		*/
		__proto.recover=function(){
			if (this._id > 0){
				this._id=0;
				Handler._pool.push(this.clear());
			}
		}

		Handler.create=function(caller,method,args,once){
			(once===void 0)&& (once=true);
			if (Handler._pool.length)return Handler._pool.pop().setTo(caller,method,args,once);
			return new Handler(caller,method,args,once);
		}

		Handler._pool=[];
		Handler._gid=1;
		return Handler;
	})()


	//class sceneModule.SceneLoadDemo
	var SceneLoadDemo=(function(){
		function SceneLoadDemo(){
			this.monkeyRow=15;
			this.monkeyCount=0;
			this.scene=null;
			this.layaMonkey=null;
			var _$this=this;
			Laya3D.init(0,0,true);
			Laya.stage.scaleMode="full";
			Laya.stage.screenMode="none";
			Stat.show();
			this.scene=Scene.load("res/threeDimen/scene/Arena/Arena.ls");
			Laya.stage.addChild(this.scene);
			var camera=this.scene.addChild(new Camera(0,1,100));
			camera.transform.translate(new Vector3(0,5,7));
			camera.transform.rotationEuler=new Vector3(-0.3,0,0);
			camera.addComponent(CameraMoveScript);
			camera.clearFlag=1;
			var skyBox=new SkyBox();
			skyBox.sharedMaterial=SkyBoxMaterial.load("res/threeDimen/skybox/skyBox4/SkyboxMaterial.lmat");
			camera.sky=skyBox;
			this.layaMonkey=Sprite3D.load("res/threeDimen/skinModel/LayaMonkey/LayaMonkey.lh");
			this.layaMonkey.once("hierarchyloaded",this,function(){
				var monkeyAnimator=(_$this.layaMonkey.getChildAt(0)).getComponentByType(Animator);
				monkeyAnimator.clip.islooping=true;
				_$this.layaMonkey.transform.translate(new Vector3(0,0,0));
				_$this.layaMonkey.transform.scale=new Vector3(0.3,0.3,0.3);
				_$this.scene.addChild(_$this.layaMonkey);
				Laya.timer.frameOnce(1,this,_$this.createMonkey);
			});
		}

		__class(SceneLoadDemo,'sceneModule.SceneLoadDemo');
		var __proto=SceneLoadDemo.prototype;
		__proto.createMonkey=function(){
			var i=parseInt(this.monkeyCount/this.monkeyRow);
			var j=parseInt(this.monkeyCount%this.monkeyRow);
			var sp=Sprite3D.instantiate(this.layaMonkey,this.scene,false,new Vector3((-this.monkeyRow / 2+i)*2,0,-2+-j*2));
			sp.transform.scale=new Vector3(0.3,0.3,0.3);
			this.monkeyCount++;
			if (this.monkeyCount < this.monkeyRow*this.monkeyRow){
				Laya.timer.frameOnce(1,this,this.createMonkey);
			}
		}

		return SceneLoadDemo;
	})()


	/**
	*Config 用于配置一些全局参数。如需更改，请在初始化引擎之前设置。
	*/
	//class Config
	var Config=(function(){
		function Config(){};
		__class(Config,'Config');
		Config.WebGLTextCacheCount=500;
		Config.atlasEnable=false;
		Config.animationInterval=50;
		Config.isAntialias=false;
		Config.isAlpha=false;
		Config.premultipliedAlpha=true;
		Config.isStencil=true;
		Config.preserveDrawingBuffer=false;
		Config.smartCache=false;
		Config.webGL2D_MeshAllocMaxMem=true;
		return Config;
	})()


	/**
	*@private
	*静态常量集合
	*/
	//class laya.Const
	var Const=(function(){
		function Const(){};
		__class(Const,'laya.Const');
		Const.DISPLAY=0x01;
		Const.HAS_ZORDER=0x02;
		Const.HAS_MOUSE=0x04;
		Const.DISPLAYED_INSTAGE=0x08;
		return Const;
	})()


	/**
	*<code>BitmapFont</code> 是位图字体类，用于定义位图字体信息。
	*字体制作及使用方法，请参考文章
	*@see http://ldc.layabox.com/doc/?nav=ch-js-1-2-5
	*/
	//class laya.display.BitmapFont
	var BitmapFont=(function(){
		function BitmapFont(){
			this._texture=null;
			this._fontCharDic={};
			this._fontWidthMap={};
			this._complete=null;
			this._path=null;
			this._maxWidth=0;
			this._spaceWidth=10;
			this._padding=null;
			this.fontSize=12;
			this.autoScaleSize=false;
			this.letterSpacing=0;
		}

		__class(BitmapFont,'laya.display.BitmapFont');
		var __proto=BitmapFont.prototype;
		/**
		*通过指定位图字体文件路径，加载位图字体文件，加载完成后会自动解析。
		*@param path 位图字体文件的路径。
		*@param complete 加载并解析完成的回调。
		*/
		__proto.loadFont=function(path,complete){
			this._path=path;
			this._complete=complete;
			if (!path || path.indexOf(".fnt")===-1){
				console.error('Bitmap font configuration information must be a ".fnt" file');
				return;
			}
			Laya.loader.load([{url:path,type:"xml"},{url:path.replace(".fnt",".png"),type:"image"}],Handler.create(this,this._onLoaded));
		}

		/**
		*@private
		*/
		__proto._onLoaded=function(){
			this.parseFont(Loader.getRes(this._path),Loader.getRes(this._path.replace(".fnt",".png")));
			this._complete && this._complete.run();
		}

		/**
		*解析字体文件。
		*@param xml 字体文件XML。
		*@param texture 字体的纹理。
		*/
		__proto.parseFont=function(xml,texture){
			if (xml==null || texture==null)return;
			this._texture=texture;
			var tX=0;
			var tScale=1;
			var tInfo=xml.getElementsByTagName("info");
			this.fontSize=parseInt(tInfo[0].attributes["size"].nodeValue);
			var tPadding=tInfo[0].attributes["padding"].nodeValue;
			var tPaddingArray=tPadding.split(",");
			this._padding=[parseInt(tPaddingArray[0]),parseInt(tPaddingArray[1]),parseInt(tPaddingArray[2]),parseInt(tPaddingArray[3])];
			var chars=xml.getElementsByTagName("char");
			var i=0;
			for (i=0;i < chars.length;i++){
				var tAttribute=chars[i].attributes;
				var tId=parseInt(tAttribute["id"].nodeValue);
				var xOffset=parseInt(tAttribute["xoffset"].nodeValue)/ tScale;
				var yOffset=parseInt(tAttribute["yoffset"].nodeValue)/ tScale;
				var xAdvance=parseInt(tAttribute["xadvance"].nodeValue)/ tScale;
				var region=new Rectangle();
				region.x=parseInt(tAttribute["x"].nodeValue);
				region.y=parseInt(tAttribute["y"].nodeValue);
				region.width=parseInt(tAttribute["width"].nodeValue);
				region.height=parseInt(tAttribute["height"].nodeValue);
				var tTexture=Texture.create(texture,region.x,region.y,region.width,region.height,xOffset,yOffset);
				this._maxWidth=Math.max(this._maxWidth,xAdvance+this.letterSpacing);
				this._fontCharDic[tId]=tTexture;
				this._fontWidthMap[tId]=xAdvance;
			}
		}

		/**
		*获取指定字符的字体纹理对象。
		*@param char 字符。
		*@return 指定的字体纹理对象。
		*/
		__proto.getCharTexture=function(char){
			return this._fontCharDic[char.charCodeAt(0)];
		}

		/**
		*销毁位图字体，调用Text.unregisterBitmapFont 时，默认会销毁。
		*/
		__proto.destroy=function(){
			if (this._texture){
				for (var p in this._fontCharDic){
					var tTexture=this._fontCharDic[p];
					if (tTexture)tTexture.destroy();
				}
				this._texture.destroy();
				this._fontCharDic=null;
				this._fontWidthMap=null;
				this._texture=null;
				this._complete=null;
				this._padding=null;
			}
		}

		/**
		*设置空格的宽（如果字体库有空格，这里就可以不用设置了）。
		*@param spaceWidth 宽度，单位为像素。
		*/
		__proto.setSpaceWidth=function(spaceWidth){
			this._spaceWidth=spaceWidth;
		}

		/**
		*获取指定字符的宽度。
		*@param char 字符。
		*@return 宽度。
		*/
		__proto.getCharWidth=function(char){
			var code=char.charCodeAt(0);
			if (this._fontWidthMap[code])return this._fontWidthMap[code]+this.letterSpacing;
			if (char===" ")return this._spaceWidth+this.letterSpacing;
			return 0;
		}

		/**
		*获取指定文本内容的宽度。
		*@param text 文本内容。
		*@return 宽度。
		*/
		__proto.getTextWidth=function(text){
			var tWidth=0;
			for (var i=0,n=text.length;i < n;i++){
				tWidth+=this.getCharWidth(text.charAt(i));
			}
			return tWidth;
		}

		/**
		*获取最大字符宽度。
		*/
		__proto.getMaxWidth=function(){
			return this._maxWidth;
		}

		/**
		*获取最大字符高度。
		*/
		__proto.getMaxHeight=function(){
			return this.fontSize;
		}

		/**
		*@private
		*将指定的文本绘制到指定的显示对象上。
		*/
		__proto._drawText=function(text,sprite,drawX,drawY,align,width){
			var tWidth=this.getTextWidth(text);
			var tTexture;
			var dx=0;
			align==="center" && (dx=(width-tWidth)/ 2);
			align==="right" && (dx=(width-tWidth));
			var tx=0;
			for (var i=0,n=text.length;i < n;i++){
				tTexture=this.getCharTexture(text.charAt(i));
				if (tTexture){
					sprite.graphics.drawImage(tTexture,drawX+tx+dx,drawY);
					tx+=this.getCharWidth(text.charAt(i));
				}
			}
		}

		return BitmapFont;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.AlphaCmd
	var AlphaCmd=(function(){
		function AlphaCmd(){
			//this._alpha=NaN;
		}

		__class(AlphaCmd,'laya.display.cmd.AlphaCmd');
		var __proto=AlphaCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			Pool.recover("AlphaCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.alpha(this._alpha);
		}

		__getset(0,__proto,'cmdID',function(){
			return "Alpha";
		});

		__getset(0,__proto,'alpha',function(){
			return this._alpha;
			},function(value){
			this._alpha=value;
		});

		AlphaCmd.create=function(alpha){
			var cmd=Pool.getItemByClass("AlphaCmd",AlphaCmd);
			cmd._alpha=alpha;
			return cmd;
		}

		AlphaCmd.ID="Alpha";
		return AlphaCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.ClipRectCmd
	var ClipRectCmd=(function(){
		function ClipRectCmd(){
			//this._x=NaN;
			//this._y=NaN;
			//this._width=NaN;
			//this._height=NaN;
		}

		__class(ClipRectCmd,'laya.display.cmd.ClipRectCmd');
		var __proto=ClipRectCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			Pool.recover("ClipRectCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.clipRect(this._x+gx,this._y+gy,this._width,this._height);
		}

		__getset(0,__proto,'cmdID',function(){
			return "ClipRect";
		});

		__getset(0,__proto,'width',function(){
			return this._width;
			},function(value){
			this._width=value;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'height',function(){
			return this._height;
			},function(value){
			this._height=value;
		});

		ClipRectCmd.create=function(x,y,width,height){
			var cmd=Pool.getItemByClass("ClipRectCmd",ClipRectCmd);
			cmd._x=x;
			cmd._y=y;
			cmd._width=width;
			cmd._height=height;
			return cmd;
		}

		ClipRectCmd.ID="ClipRect";
		return ClipRectCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.DrawCircleCmd
	var DrawCircleCmd=(function(){
		function DrawCircleCmd(){
			//this._x=NaN;
			//this._y=NaN;
			//this._radius=NaN;
			//this._fillColor=null;
			//this._lineColor=null;
			//this._lineWidth=NaN;
			//this._vid=0;
		}

		__class(DrawCircleCmd,'laya.display.cmd.DrawCircleCmd');
		var __proto=DrawCircleCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._fillColor=null;
			this._lineColor=null;
			Pool.recover("DrawCircleCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context._drawCircle(this._x+gx,this._y+gy,this._radius,this._fillColor,this._lineColor,this._lineWidth,this._vid);
		}

		__getset(0,__proto,'lineColor',function(){
			return this._lineColor;
			},function(value){
			this._lineColor=value;
		});

		__getset(0,__proto,'cmdID',function(){
			return "DrawCircle";
		});

		__getset(0,__proto,'fillColor',function(){
			return this._fillColor;
			},function(value){
			this._fillColor=value;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'vid',function(){
			return this._vid;
			},function(value){
			this._vid=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'radius',function(){
			return this._radius;
			},function(value){
			this._radius=value;
		});

		__getset(0,__proto,'lineWidth',function(){
			return this._lineWidth;
			},function(value){
			this._lineWidth=value;
		});

		DrawCircleCmd.create=function(x,y,radius,fillColor,lineColor,lineWidth,vid){
			var cmd=Pool.getItemByClass("DrawCircleCmd",DrawCircleCmd);
			cmd._x=x;
			cmd._y=y;
			cmd._radius=radius;
			cmd._fillColor=fillColor;
			cmd._lineColor=lineColor;
			cmd._lineWidth=lineWidth;
			cmd._vid=vid;
			return cmd;
		}

		DrawCircleCmd.ID="DrawCircle";
		return DrawCircleCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.DrawCurvesCmd
	var DrawCurvesCmd=(function(){
		function DrawCurvesCmd(){
			//this._x=NaN;
			//this._y=NaN;
			//this._points=null;
			//this._lineColor=null;
			//this._lineWidth=NaN;
		}

		__class(DrawCurvesCmd,'laya.display.cmd.DrawCurvesCmd');
		var __proto=DrawCurvesCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._points=null;
			this._lineColor=null;
			Pool.recover("DrawCurvesCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.drawCurves(this._x+gx,this._y+gy,this._points,this._lineColor,this._lineWidth);
		}

		__getset(0,__proto,'lineColor',function(){
			return this._lineColor;
			},function(value){
			this._lineColor=value;
		});

		__getset(0,__proto,'points',function(){
			return this._points;
			},function(value){
			this._points=value;
		});

		__getset(0,__proto,'cmdID',function(){
			return "DrawCurves";
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'lineWidth',function(){
			return this._lineWidth;
			},function(value){
			this._lineWidth=value;
		});

		DrawCurvesCmd.create=function(x,y,points,lineColor,lineWidth){
			var cmd=Pool.getItemByClass("DrawCurvesCmd",DrawCurvesCmd);
			cmd._x=x;
			cmd._y=y;
			cmd._points=points;
			cmd._lineColor=lineColor;
			cmd._lineWidth=lineWidth;
			return cmd;
		}

		DrawCurvesCmd.ID="DrawCurves";
		return DrawCurvesCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.DrawImageCmd
	var DrawImageCmd=(function(){
		function DrawImageCmd(){
			//this._texture=null;
			//this._x=NaN;
			//this._y=NaN;
			//this._width=NaN;
			//this._height=NaN;
		}

		__class(DrawImageCmd,'laya.display.cmd.DrawImageCmd');
		var __proto=DrawImageCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._texture=null;
			Pool.recover("DrawImageCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.drawTexture(this._texture,this._x+gx,this._y+gy,this._width,this._height);
		}

		__getset(0,__proto,'cmdID',function(){
			return "DrawImage";
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'texture',function(){
			return this._texture;
			},function(value){
			this._texture=value;
		});

		__getset(0,__proto,'width',function(){
			return this._width;
			},function(value){
			this._width=value;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'height',function(){
			return this._height;
			},function(value){
			this._height=value;
		});

		DrawImageCmd.create=function(texture,x,y,width,height){
			var cmd=Pool.getItemByClass("DrawImageCmd",DrawImageCmd);
			cmd._texture=texture;
			cmd._x=x;
			cmd._y=y;
			cmd._width=width;
			cmd._height=height;
			return cmd;
		}

		DrawImageCmd.ID="DrawImage";
		return DrawImageCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.DrawLineCmd
	var DrawLineCmd=(function(){
		function DrawLineCmd(){
			//this._fromX=NaN;
			//this._fromY=NaN;
			//this._toX=NaN;
			//this._toY=NaN;
			//this._lineColor=null;
			//this._lineWidth=NaN;
			//this._vid=0;
		}

		__class(DrawLineCmd,'laya.display.cmd.DrawLineCmd');
		var __proto=DrawLineCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			Pool.recover("DrawLineCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context._drawLine(gx,gy,this._fromX,this._fromY,this._toX,this._toY,this._lineColor,this._lineWidth,this._vid);
		}

		__getset(0,__proto,'lineColor',function(){
			return this._lineColor;
			},function(value){
			this._lineColor=value;
		});

		__getset(0,__proto,'cmdID',function(){
			return "DrawLine";
		});

		__getset(0,__proto,'toY',function(){
			return this._toY;
			},function(value){
			this._toY=value;
		});

		__getset(0,__proto,'fromX',function(){
			return this._fromX;
			},function(value){
			this._fromX=value;
		});

		__getset(0,__proto,'vid',function(){
			return this._vid;
			},function(value){
			this._vid=value;
		});

		__getset(0,__proto,'toX',function(){
			return this._toX;
			},function(value){
			this._toX=value;
		});

		__getset(0,__proto,'fromY',function(){
			return this._fromY;
			},function(value){
			this._fromY=value;
		});

		__getset(0,__proto,'lineWidth',function(){
			return this._lineWidth;
			},function(value){
			this._lineWidth=value;
		});

		DrawLineCmd.create=function(fromX,fromY,toX,toY,lineColor,lineWidth,vid){
			var cmd=Pool.getItemByClass("DrawLineCmd",DrawLineCmd);
			cmd._fromX=fromX;
			cmd._fromY=fromY;
			cmd._toX=toX;
			cmd._toY=toY;
			cmd._lineColor=lineColor;
			cmd._lineWidth=lineWidth;
			cmd._vid=vid;
			return cmd;
		}

		DrawLineCmd.ID="DrawLine";
		return DrawLineCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.DrawLinesCmd
	var DrawLinesCmd=(function(){
		function DrawLinesCmd(){
			//this._x=NaN;
			//this._y=NaN;
			//this._points=null;
			//this._lineColor=null;
			//this._lineWidth=NaN;
			//this._vid=0;
		}

		__class(DrawLinesCmd,'laya.display.cmd.DrawLinesCmd');
		var __proto=DrawLinesCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._points=null;
			this._lineColor=null;
			Pool.recover("DrawLinesCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context._drawLines(this._x+gx,this._y+gy,this._points,this._lineColor,this._lineWidth,this._vid);
		}

		__getset(0,__proto,'lineColor',function(){
			return this._lineColor;
			},function(value){
			this._lineColor=value;
		});

		__getset(0,__proto,'points',function(){
			return this._points;
			},function(value){
			this._points=value;
		});

		__getset(0,__proto,'cmdID',function(){
			return "DrawLines";
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'vid',function(){
			return this._vid;
			},function(value){
			this._vid=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'lineWidth',function(){
			return this._lineWidth;
			},function(value){
			this._lineWidth=value;
		});

		DrawLinesCmd.create=function(x,y,points,lineColor,lineWidth,vid){
			var cmd=Pool.getItemByClass("DrawLinesCmd",DrawLinesCmd);
			cmd._x=x;
			cmd._y=y;
			cmd._points=points;
			cmd._lineColor=lineColor;
			cmd._lineWidth=lineWidth;
			cmd._vid=vid;
			return cmd;
		}

		DrawLinesCmd.ID="DrawLines";
		return DrawLinesCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.DrawPathCmd
	var DrawPathCmd=(function(){
		function DrawPathCmd(){
			//this._x=NaN;
			//this._y=NaN;
			//this._paths=null;
			//this._brush=null;
			//this._pen=null;
		}

		__class(DrawPathCmd,'laya.display.cmd.DrawPathCmd');
		var __proto=DrawPathCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._paths=null;
			this._brush=null;
			this._pen=null;
			Pool.recover("DrawPathCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context._drawPath(this._x+gx,this._y+gy,this._paths,this._brush,this._pen);
		}

		__getset(0,__proto,'cmdID',function(){
			return "DrawPath";
		});

		__getset(0,__proto,'paths',function(){
			return this._paths;
			},function(value){
			this._paths=value;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'brush',function(){
			return this._brush;
			},function(value){
			this._brush=value;
		});

		__getset(0,__proto,'pen',function(){
			return this._pen;
			},function(value){
			this._pen=value;
		});

		DrawPathCmd.create=function(x,y,paths,brush,pen){
			var cmd=Pool.getItemByClass("DrawPathCmd",DrawPathCmd);
			cmd._x=x;
			cmd._y=y;
			cmd._paths=paths;
			cmd._brush=brush;
			cmd._pen=pen;
			return cmd;
		}

		DrawPathCmd.ID="DrawPath";
		return DrawPathCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.DrawPieCmd
	var DrawPieCmd=(function(){
		function DrawPieCmd(){
			//this._x=NaN;
			//this._y=NaN;
			//this._radius=NaN;
			//this._startAngle=NaN;
			//this._endAngle=NaN;
			//this._fillColor=null;
			//this._lineColor=null;
			//this._lineWidth=NaN;
			//this._vid=0;
		}

		__class(DrawPieCmd,'laya.display.cmd.DrawPieCmd');
		var __proto=DrawPieCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._fillColor=null;
			this._lineColor=null;
			Pool.recover("DrawPieCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context._drawPie(this._x+gx,this._y+gy,this._radius,this._startAngle,this._endAngle,this._fillColor,this._lineColor,this._lineWidth,this._vid);
		}

		__getset(0,__proto,'lineColor',function(){
			return this._lineColor;
			},function(value){
			this._lineColor=value;
		});

		__getset(0,__proto,'startAngle',function(){
			return this._startAngle;
			},function(value){
			this._startAngle=value;
		});

		__getset(0,__proto,'cmdID',function(){
			return "DrawPie";
		});

		__getset(0,__proto,'fillColor',function(){
			return this._fillColor;
			},function(value){
			this._fillColor=value;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'radius',function(){
			return this._radius;
			},function(value){
			this._radius=value;
		});

		__getset(0,__proto,'endAngle',function(){
			return this._endAngle;
			},function(value){
			this._endAngle=value;
		});

		__getset(0,__proto,'lineWidth',function(){
			return this._lineWidth;
			},function(value){
			this._lineWidth=value;
		});

		__getset(0,__proto,'vid',function(){
			return this._vid;
			},function(value){
			this._vid=value;
		});

		DrawPieCmd.create=function(x,y,radius,startAngle,endAngle,fillColor,lineColor,lineWidth,vid){
			var cmd=Pool.getItemByClass("DrawPieCmd",DrawPieCmd);
			cmd._x=x;
			cmd._y=y;
			cmd._radius=radius;
			cmd._startAngle=startAngle;
			cmd._endAngle=endAngle;
			cmd._fillColor=fillColor;
			cmd._lineColor=lineColor;
			cmd._lineWidth=lineWidth;
			cmd._vid=vid;
			return cmd;
		}

		DrawPieCmd.ID="DrawPie";
		return DrawPieCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.DrawPolyCmd
	var DrawPolyCmd=(function(){
		function DrawPolyCmd(){
			//this._x=NaN;
			//this._y=NaN;
			//this._points=null;
			//this._fillColor=null;
			//this._lineColor=null;
			//this._lineWidth=NaN;
			//this._isConvexPolygon=false;
			//this._vid=0;
		}

		__class(DrawPolyCmd,'laya.display.cmd.DrawPolyCmd');
		var __proto=DrawPolyCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._points=null;
			this._fillColor=null;
			this._lineColor=null;
			Pool.recover("DrawPolyCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context._drawPoly(this._x+gx,this._y+gy,this._points,this._fillColor,this._lineColor,this._lineWidth,this._isConvexPolygon,this._vid);
		}

		__getset(0,__proto,'lineColor',function(){
			return this._lineColor;
			},function(value){
			this._lineColor=value;
		});

		__getset(0,__proto,'points',function(){
			return this._points;
			},function(value){
			this._points=value;
		});

		__getset(0,__proto,'cmdID',function(){
			return "DrawPoly";
		});

		__getset(0,__proto,'fillColor',function(){
			return this._fillColor;
			},function(value){
			this._fillColor=value;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'isConvexPolygon',function(){
			return this._isConvexPolygon;
			},function(value){
			this._isConvexPolygon=value;
		});

		__getset(0,__proto,'vid',function(){
			return this._vid;
			},function(value){
			this._vid=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'lineWidth',function(){
			return this._lineWidth;
			},function(value){
			this._lineWidth=value;
		});

		DrawPolyCmd.create=function(x,y,points,fillColor,lineColor,lineWidth,isConvexPolygon,vid){
			var cmd=Pool.getItemByClass("DrawPolyCmd",DrawPolyCmd);
			cmd._x=x;
			cmd._y=y;
			cmd._points=points;
			cmd._fillColor=fillColor;
			cmd._lineColor=lineColor;
			cmd._lineWidth=lineWidth;
			cmd._isConvexPolygon=isConvexPolygon;
			cmd._vid=vid;
			return cmd;
		}

		DrawPolyCmd.ID="DrawPoly";
		return DrawPolyCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.DrawRectCmd
	var DrawRectCmd=(function(){
		function DrawRectCmd(){
			//this._x=NaN;
			//this._y=NaN;
			//this._width=NaN;
			//this._height=NaN;
			//this._fillColor=null;
			//this._lineColor=null;
			//this._lineWidth=NaN;
		}

		__class(DrawRectCmd,'laya.display.cmd.DrawRectCmd');
		var __proto=DrawRectCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._fillColor=null;
			this._lineColor=null;
			Pool.recover("DrawRectCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.drawRect(this._x+gx,this._y+gy,this._width,this._height,this._fillColor,this._lineColor,this._lineWidth);
		}

		__getset(0,__proto,'lineColor',function(){
			return this._lineColor;
			},function(value){
			this._lineColor=value;
		});

		__getset(0,__proto,'cmdID',function(){
			return "DrawRect";
		});

		__getset(0,__proto,'fillColor',function(){
			return this._fillColor;
			},function(value){
			this._fillColor=value;
		});

		__getset(0,__proto,'width',function(){
			return this._width;
			},function(value){
			this._width=value;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'height',function(){
			return this._height;
			},function(value){
			this._height=value;
		});

		__getset(0,__proto,'lineWidth',function(){
			return this._lineWidth;
			},function(value){
			this._lineWidth=value;
		});

		DrawRectCmd.create=function(x,y,width,height,fillColor,lineColor,lineWidth){
			var cmd=Pool.getItemByClass("DrawRectCmd",DrawRectCmd);
			cmd._x=x;
			cmd._y=y;
			cmd._width=width;
			cmd._height=height;
			cmd._fillColor=fillColor;
			cmd._lineColor=lineColor;
			cmd._lineWidth=lineWidth;
			return cmd;
		}

		DrawRectCmd.ID="DrawRect";
		return DrawRectCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.DrawTextureCmd
	var DrawTextureCmd=(function(){
		function DrawTextureCmd(){
			//this._texture=null;
			//this._x=NaN;
			//this._y=NaN;
			//this._width=NaN;
			//this._height=NaN;
			//this._matrix=null;
			//this._alpha=NaN;
			//this._color=null;
			//this._blendMode=null;
		}

		__class(DrawTextureCmd,'laya.display.cmd.DrawTextureCmd');
		var __proto=DrawTextureCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._texture=null;
			this._matrix=null;
			Pool.recover("DrawTextureCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.drawTextureWithTransform(this._texture,this._x,this._y,this._width,this._height,this._matrix,gx,gy,this._alpha,this._blendMode);
		}

		__getset(0,__proto,'cmdID',function(){
			return "DrawTexture";
		});

		__getset(0,__proto,'matrix',function(){
			return this._matrix;
			},function(value){
			this._matrix=value;
		});

		__getset(0,__proto,'texture',function(){
			return this._texture;
			},function(value){
			this._texture=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'width',function(){
			return this._width;
			},function(value){
			this._width=value;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'height',function(){
			return this._height;
			},function(value){
			this._height=value;
		});

		__getset(0,__proto,'alpha',function(){
			return this._alpha;
			},function(value){
			this._alpha=value;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
			},function(value){
			this._color=value;
		});

		__getset(0,__proto,'blendMode',function(){
			return this._blendMode;
			},function(value){
			this._blendMode=value;
		});

		DrawTextureCmd.create=function(texture,x,y,width,height,matrix,alpha,color,blendMode){
			var cmd=Pool.getItemByClass("DrawTextureCmd",DrawTextureCmd);
			cmd._texture=texture;
			cmd._x=x;
			cmd._y=y;
			cmd._width=width;
			cmd._height=height;
			cmd._matrix=matrix;
			cmd._alpha=alpha;
			cmd._color=color;
			cmd._blendMode=blendMode;
			return cmd;
		}

		DrawTextureCmd.ID="DrawTexture";
		return DrawTextureCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.DrawTexturesCmd
	var DrawTexturesCmd=(function(){
		function DrawTexturesCmd(){
			//this._texture=null;
			//this._pos=null;
		}

		__class(DrawTexturesCmd,'laya.display.cmd.DrawTexturesCmd');
		var __proto=DrawTexturesCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._texture=null;
			this._pos=null;
			Pool.recover("DrawTexturesCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.drawTextures(this._texture,this._pos,gx,gy);
		}

		__getset(0,__proto,'cmdID',function(){
			return "DrawTextures";
		});

		__getset(0,__proto,'texture',function(){
			return this._texture;
			},function(value){
			this._texture=value;
		});

		__getset(0,__proto,'pos',function(){
			return this._pos;
			},function(value){
			this._pos=value;
		});

		DrawTexturesCmd.create=function(texture,pos){
			var cmd=Pool.getItemByClass("DrawTexturesCmd",DrawTexturesCmd);
			cmd._texture=texture;
			cmd._pos=pos;
			return cmd;
		}

		DrawTexturesCmd.ID="DrawTextures";
		return DrawTexturesCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.DrawTrianglesCmd
	var DrawTrianglesCmd=(function(){
		function DrawTrianglesCmd(){
			//this._texture=null;
			//this._x=NaN;
			//this._y=NaN;
			//this._vertices=null;
			//this._uvs=null;
			//this._indices=null;
			//this._matrix=null;
			//this._alpha=NaN;
			//this._color=null;
			//this._blendMode=null;
		}

		__class(DrawTrianglesCmd,'laya.display.cmd.DrawTrianglesCmd');
		var __proto=DrawTrianglesCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._texture=null;
			this._vertices=null;
			this._uvs=null;
			this._indices=null;
			this._matrix=null;
			Pool.recover("DrawTrianglesCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.drawTriangles(this._texture,this._x+gx,this._y+gy,this._vertices,this._uvs,this._indices,this._matrix,this._alpha,this._color,this._blendMode);
		}

		__getset(0,__proto,'vertices',function(){
			return this._vertices;
			},function(value){
			this._vertices=value;
		});

		__getset(0,__proto,'cmdID',function(){
			return "DrawTriangles";
		});

		__getset(0,__proto,'matrix',function(){
			return this._matrix;
			},function(value){
			this._matrix=value;
		});

		__getset(0,__proto,'texture',function(){
			return this._texture;
			},function(value){
			this._texture=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'alpha',function(){
			return this._alpha;
			},function(value){
			this._alpha=value;
		});

		__getset(0,__proto,'uvs',function(){
			return this._uvs;
			},function(value){
			this._uvs=value;
		});

		__getset(0,__proto,'indices',function(){
			return this._indices;
			},function(value){
			this._indices=value;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
			},function(value){
			this._color=value;
		});

		__getset(0,__proto,'blendMode',function(){
			return this._blendMode;
			},function(value){
			this._blendMode=value;
		});

		DrawTrianglesCmd.create=function(texture,x,y,vertices,uvs,indices,matrix,alpha,color,blendMode){
			var cmd=Pool.getItemByClass("DrawTrianglesCmd",DrawTrianglesCmd);
			cmd._texture=texture;
			cmd._x=x;
			cmd._y=y;
			cmd._vertices=vertices;
			cmd._uvs=uvs;
			cmd._indices=indices;
			cmd._matrix=matrix;
			cmd._alpha=alpha;
			cmd._color=color;
			cmd._blendMode=blendMode;
			return cmd;
		}

		DrawTrianglesCmd.ID="DrawTriangles";
		return DrawTrianglesCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.FillBorderTextCmd
	var FillBorderTextCmd=(function(){
		function FillBorderTextCmd(){
			//this._text=null;
			//this._x=NaN;
			//this._y=NaN;
			//this._font=null;
			//this._fillColor=null;
			//this._borderColor=null;
			//this._lineWidth=NaN;
			//this._textAlign=null;
		}

		__class(FillBorderTextCmd,'laya.display.cmd.FillBorderTextCmd');
		var __proto=FillBorderTextCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			Pool.recover("FillBorderTextCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.fillBorderText(this._text,this._x+gx,this._y+gy,this._font,this._fillColor,this._borderColor,this._lineWidth,this._textAlign);
		}

		__getset(0,__proto,'cmdID',function(){
			return "FillBorderText";
		});

		__getset(0,__proto,'borderColor',function(){
			return this._borderColor;
			},function(value){
			this._borderColor=value;
		});

		__getset(0,__proto,'text',function(){
			return this._text;
			},function(value){
			this._text=value;
		});

		__getset(0,__proto,'fillColor',function(){
			return this._fillColor;
			},function(value){
			this._fillColor=value;
		});

		__getset(0,__proto,'textAlign',function(){
			return this._textAlign;
			},function(value){
			this._textAlign=value;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'font',function(){
			return this._font;
			},function(value){
			this._font=value;
		});

		__getset(0,__proto,'lineWidth',function(){
			return this._lineWidth;
			},function(value){
			this._lineWidth=value;
		});

		FillBorderTextCmd.create=function(text,x,y,font,fillColor,borderColor,lineWidth,textAlign){
			var cmd=Pool.getItemByClass("FillBorderTextCmd",FillBorderTextCmd);
			cmd._text=text;
			cmd._x=x;
			cmd._y=y;
			cmd._font=font;
			cmd._fillColor=fillColor;
			cmd._borderColor=borderColor;
			cmd._lineWidth=lineWidth;
			cmd._textAlign=textAlign;
			return cmd;
		}

		FillBorderTextCmd.ID="FillBorderText";
		return FillBorderTextCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.FillBorderWordsCmd
	var FillBorderWordsCmd=(function(){
		function FillBorderWordsCmd(){
			//this._words=null;
			//this._x=NaN;
			//this._y=NaN;
			//this._font=null;
			//this._fillColor=null;
			//this._borderColor=null;
			//this._lineWidth=0;
		}

		__class(FillBorderWordsCmd,'laya.display.cmd.FillBorderWordsCmd');
		var __proto=FillBorderWordsCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._words=null;
			Pool.recover("FillBorderWordsCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.fillBorderWords(this._words,this._x+gx,this._y+gy,this._font,this._fillColor,this._borderColor,this._lineWidth);
		}

		__getset(0,__proto,'borderColor',function(){
			return this._borderColor;
			},function(value){
			this._borderColor=value;
		});

		__getset(0,__proto,'cmdID',function(){
			return "FillBorderWords";
		});

		__getset(0,__proto,'words',function(){
			return this._words;
			},function(value){
			this._words=value;
		});

		__getset(0,__proto,'fillColor',function(){
			return this._fillColor;
			},function(value){
			this._fillColor=value;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'font',function(){
			return this._font;
			},function(value){
			this._font=value;
		});

		__getset(0,__proto,'lineWidth',function(){
			return this._lineWidth;
			},function(value){
			this._lineWidth=value;
		});

		FillBorderWordsCmd.create=function(words,x,y,font,fillColor,borderColor,lineWidth){
			var cmd=Pool.getItemByClass("FillBorderWordsCmd",FillBorderWordsCmd);
			cmd._words=words;
			cmd._x=x;
			cmd._y=y;
			cmd._font=font;
			cmd._fillColor=fillColor;
			cmd._borderColor=borderColor;
			cmd._lineWidth=lineWidth;
			return cmd;
		}

		FillBorderWordsCmd.ID="FillBorderWords";
		return FillBorderWordsCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.FillTextCmd
	var FillTextCmd=(function(){
		function FillTextCmd(){
			//this._text=null;
			//this._x=NaN;
			//this._y=NaN;
			//this._font=null;
			//this._color=null;
			//this._textAlign=null;
		}

		__class(FillTextCmd,'laya.display.cmd.FillTextCmd');
		var __proto=FillTextCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			Pool.recover("FillTextCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.drawText(this._text,this._x+gx,this._y+gy,this._font,this._color,this._textAlign);
		}

		__getset(0,__proto,'text',function(){
			return this._text;
			},function(value){
			this._text=value;
		});

		__getset(0,__proto,'cmdID',function(){
			return "FillText";
		});

		__getset(0,__proto,'textAlign',function(){
			return this._textAlign;
			},function(value){
			this._textAlign=value;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
			},function(value){
			this._color=value;
		});

		__getset(0,__proto,'font',function(){
			return this._font;
			},function(value){
			this._font=value;
		});

		FillTextCmd.create=function(text,x,y,font,color,textAlign){
			var cmd=Pool.getItemByClass("FillTextCmd",FillTextCmd);
			cmd._text=text;
			cmd._x=x;
			cmd._y=y;
			cmd._font=font;
			cmd._color=color;
			cmd._textAlign=textAlign;
			return cmd;
		}

		FillTextCmd.ID="FillText";
		return FillTextCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.FillTextureCmd
	var FillTextureCmd=(function(){
		function FillTextureCmd(){
			//this._texture=null;
			//this._x=NaN;
			//this._y=NaN;
			//this._width=NaN;
			//this._height=NaN;
			//this._type=null;
			//this._offset=null;
			//this._other=null;
		}

		__class(FillTextureCmd,'laya.display.cmd.FillTextureCmd');
		var __proto=FillTextureCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._texture=null;
			this._offset=null;
			this._other=null;
			Pool.recover("FillTextureCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.fillTexture(this._texture,this._x+gx,this._y+gy,this._width,this._height,this._type,this._offset,this._other);
		}

		__getset(0,__proto,'cmdID',function(){
			return "FillTexture";
		});

		__getset(0,__proto,'texture',function(){
			return this._texture;
			},function(value){
			this._texture=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'width',function(){
			return this._width;
			},function(value){
			this._width=value;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'offset',function(){
			return this._offset;
			},function(value){
			this._offset=value;
		});

		__getset(0,__proto,'height',function(){
			return this._height;
			},function(value){
			this._height=value;
		});

		__getset(0,__proto,'other',function(){
			return this._other;
			},function(value){
			this._other=value;
		});

		__getset(0,__proto,'type',function(){
			return this._type;
			},function(value){
			this._type=value;
		});

		FillTextureCmd.create=function(texture,x,y,width,height,type,offset,other){
			var cmd=Pool.getItemByClass("FillTextureCmd",FillTextureCmd);
			cmd._texture=texture;
			cmd._x=x;
			cmd._y=y;
			cmd._width=width;
			cmd._height=height;
			cmd._type=type;
			cmd._offset=offset;
			cmd._other=other;
			return cmd;
		}

		FillTextureCmd.ID="FillTexture";
		return FillTextureCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.FillWordsCmd
	var FillWordsCmd=(function(){
		function FillWordsCmd(){
			//this._words=null;
			//this._x=NaN;
			//this._y=NaN;
			//this._font=null;
			//this._color=null;
		}

		__class(FillWordsCmd,'laya.display.cmd.FillWordsCmd');
		var __proto=FillWordsCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._words=null;
			Pool.recover("FillWordsCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.fillWords(this._words,this._x+gx,this._y+gy,this._font,this._color);
		}

		__getset(0,__proto,'cmdID',function(){
			return "FillWords";
		});

		__getset(0,__proto,'words',function(){
			return this._words;
			},function(value){
			this._words=value;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
			},function(value){
			this._color=value;
		});

		__getset(0,__proto,'font',function(){
			return this._font;
			},function(value){
			this._font=value;
		});

		FillWordsCmd.create=function(words,x,y,font,color){
			var cmd=Pool.getItemByClass("FillWordsCmd",FillWordsCmd);
			cmd._words=words;
			cmd._x=x;
			cmd._y=y;
			cmd._font=font;
			cmd._color=color;
			return cmd;
		}

		FillWordsCmd.ID="FillWords";
		return FillWordsCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.RestoreCmd
	var RestoreCmd=(function(){
		function RestoreCmd(){};
		__class(RestoreCmd,'laya.display.cmd.RestoreCmd');
		var __proto=RestoreCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			Pool.recover("RestoreCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.restore();
		}

		__getset(0,__proto,'cmdID',function(){
			return "Restore";
		});

		RestoreCmd.create=function(){
			var cmd=Pool.getItemByClass("RestoreCmd",RestoreCmd);
			return cmd;
		}

		RestoreCmd.ID="Restore";
		return RestoreCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.RotateCmd
	var RotateCmd=(function(){
		function RotateCmd(){
			//this._angle=NaN;
			//this._pivotX=NaN;
			//this._pivotY=NaN;
		}

		__class(RotateCmd,'laya.display.cmd.RotateCmd');
		var __proto=RotateCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			Pool.recover("RotateCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context._rotate(this._angle,this._pivotX+gx,this._pivotY+gy);
		}

		__getset(0,__proto,'cmdID',function(){
			return "Rotate";
		});

		__getset(0,__proto,'angle',function(){
			return this._angle;
			},function(value){
			this._angle=value;
		});

		__getset(0,__proto,'pivotX',function(){
			return this._pivotX;
			},function(value){
			this._pivotX=value;
		});

		__getset(0,__proto,'pivotY',function(){
			return this._pivotY;
			},function(value){
			this._pivotY=value;
		});

		RotateCmd.create=function(angle,pivotX,pivotY){
			var cmd=Pool.getItemByClass("RotateCmd",RotateCmd);
			cmd._angle=angle;
			cmd._pivotX=pivotX;
			cmd._pivotY=pivotY;
			return cmd;
		}

		RotateCmd.ID="Rotate";
		return RotateCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.SaveCmd
	var SaveCmd=(function(){
		function SaveCmd(){};
		__class(SaveCmd,'laya.display.cmd.SaveCmd');
		var __proto=SaveCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			Pool.recover("SaveCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.save();
		}

		__getset(0,__proto,'cmdID',function(){
			return "Save";
		});

		SaveCmd.create=function(){
			var cmd=Pool.getItemByClass("SaveCmd",SaveCmd);
			return cmd;
		}

		SaveCmd.ID="Save";
		return SaveCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.ScaleCmd
	var ScaleCmd=(function(){
		function ScaleCmd(){
			//this._scaleX=NaN;
			//this._scaleY=NaN;
			//this._pivotX=NaN;
			//this._pivotY=NaN;
		}

		__class(ScaleCmd,'laya.display.cmd.ScaleCmd');
		var __proto=ScaleCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			Pool.recover("ScaleCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context._scale(this._scaleX,this._scaleY,this._pivotX+gx,this._pivotY+gy);
		}

		__getset(0,__proto,'cmdID',function(){
			return "Scale";
		});

		__getset(0,__proto,'scaleX',function(){
			return this._scaleX;
			},function(value){
			this._scaleX=value;
		});

		__getset(0,__proto,'scaleY',function(){
			return this._scaleY;
			},function(value){
			this._scaleY=value;
		});

		__getset(0,__proto,'pivotX',function(){
			return this._pivotX;
			},function(value){
			this._pivotX=value;
		});

		__getset(0,__proto,'pivotY',function(){
			return this._pivotY;
			},function(value){
			this._pivotY=value;
		});

		ScaleCmd.create=function(scaleX,scaleY,pivotX,pivotY){
			var cmd=Pool.getItemByClass("ScaleCmd",ScaleCmd);
			cmd._scaleX=scaleX;
			cmd._scaleY=scaleY;
			cmd._pivotX=pivotX;
			cmd._pivotY=pivotY;
			return cmd;
		}

		ScaleCmd.ID="Scale";
		return ScaleCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.StrokeTextCmd
	var StrokeTextCmd=(function(){
		function StrokeTextCmd(){
			//this._text=null;
			//this._x=NaN;
			//this._y=NaN;
			//this._font=null;
			//this._color=null;
			//this._lineWidth=NaN;
			//this._textAlign=null;
		}

		__class(StrokeTextCmd,'laya.display.cmd.StrokeTextCmd');
		var __proto=StrokeTextCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			Pool.recover("StrokeTextCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.strokeWord(this._text,this._x+gx,this._y+gy,this._font,this._color,this._lineWidth,this._textAlign);
		}

		__getset(0,__proto,'text',function(){
			return this._text;
			},function(value){
			this._text=value;
		});

		__getset(0,__proto,'cmdID',function(){
			return "StrokeText";
		});

		__getset(0,__proto,'textAlign',function(){
			return this._textAlign;
			},function(value){
			this._textAlign=value;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			this._x=value;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			this._y=value;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
			},function(value){
			this._color=value;
		});

		__getset(0,__proto,'font',function(){
			return this._font;
			},function(value){
			this._font=value;
		});

		__getset(0,__proto,'lineWidth',function(){
			return this._lineWidth;
			},function(value){
			this._lineWidth=value;
		});

		StrokeTextCmd.create=function(text,x,y,font,color,lineWidth,textAlign){
			var cmd=Pool.getItemByClass("StrokeTextCmd",StrokeTextCmd);
			cmd._text=text;
			cmd._x=x;
			cmd._y=y;
			cmd._font=font;
			cmd._color=color;
			cmd._lineWidth=lineWidth;
			cmd._textAlign=textAlign;
			return cmd;
		}

		StrokeTextCmd.ID="StrokeText";
		return StrokeTextCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.TransformCmd
	var TransformCmd=(function(){
		function TransformCmd(){
			//this._matrix=null;
			//this._pivotX=NaN;
			//this._pivotY=NaN;
		}

		__class(TransformCmd,'laya.display.cmd.TransformCmd');
		var __proto=TransformCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._matrix=null;
			Pool.recover("TransformCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context._transform(this._matrix,this._pivotX+gx,this._pivotY+gy);
		}

		__getset(0,__proto,'cmdID',function(){
			return "Transform";
		});

		__getset(0,__proto,'matrix',function(){
			return this._matrix;
			},function(value){
			this._matrix=value;
		});

		__getset(0,__proto,'pivotX',function(){
			return this._pivotX;
			},function(value){
			this._pivotX=value;
		});

		__getset(0,__proto,'pivotY',function(){
			return this._pivotY;
			},function(value){
			this._pivotY=value;
		});

		TransformCmd.create=function(matrix,pivotX,pivotY){
			var cmd=Pool.getItemByClass("TransformCmd",TransformCmd);
			cmd._matrix=matrix;
			cmd._pivotX=pivotX;
			cmd._pivotY=pivotY;
			return cmd;
		}

		TransformCmd.ID="Transform";
		return TransformCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmd.TranslateCmd
	var TranslateCmd=(function(){
		function TranslateCmd(){
			//this._tx=NaN;
			//this._ty=NaN;
		}

		__class(TranslateCmd,'laya.display.cmd.TranslateCmd');
		var __proto=TranslateCmd.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			Pool.recover("TranslateCmd",this);
		}

		/**@private */
		__proto.run=function(context,gx,gy){
			context.translate(this._tx,this._ty);
		}

		__getset(0,__proto,'ty',function(){
			return this._ty;
			},function(value){
			this._ty=value;
		});

		__getset(0,__proto,'cmdID',function(){
			return "Translate";
		});

		__getset(0,__proto,'tx',function(){
			return this._tx;
			},function(value){
			this._tx=value;
		});

		TranslateCmd.create=function(tx,ty){
			var cmd=Pool.getItemByClass("TranslateCmd",TranslateCmd);
			cmd._tx=tx;
			cmd._ty=ty;
			return cmd;
		}

		TranslateCmd.ID="Translate";
		return TranslateCmd;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.display.cmdNative.DrawTextureCmdNative
	var DrawTextureCmdNative=(function(){
		function DrawTextureCmdNative(){
			this._commandEncoder=null;
			this._index=0;
		}

		__class(DrawTextureCmdNative,'laya.display.cmdNative.DrawTextureCmdNative');
		var __proto=DrawTextureCmdNative.prototype;
		/**
		*回收到对象池
		*/
		__proto.recover=function(){
			this._commandEncoder=null;
			Pool.recover("DrawTextureCmdNative",this);
		}

		__getset(0,__proto,'cmdID',function(){
			return "DrawTexture";
		});

		DrawTextureCmdNative.create=function(texture,x,y,width,height,matrix,alpha,color,blendMode){
			var cmd=Pool.getItemByClass("DrawTextureCmdNative",DrawTextureCmdNative);
			cmd._commandEncoder=this._commandEncoder;;
			cmd._commandEncoder.useProgramEx(LayaNative2D.PROGRAMEX_DRAWTEXTURE);
			cmd._commandEncoder.useVDO(LayaNative2D.VAO_XYUV);
			cmd._commandEncoder.uniformEx(LayaNative2D.VALUEVIEWS,"u_view");
			cmd._commandEncoder.uniformTexture("u_tex",texture.bitmap._glTextureType,0x84C0,texture.bitmap._glTexture);
			var buffer=new Float32Array([0,0,0,0,texture.bitmap.width,0,1,0,texture.bitmap.width,texture.bitmap.height,1,1,0,texture.bitmap.height,0,1]);
			cmd._commandEncoder.setRectMesh(buffer);
			cmd._commandEncoder.modifyMesh(LayaNative2D.VALUEMATRIX32,0,10);
			LayaGL.syncBufferToRenderThread(cmd._commandEncoder.getPtrID());
			return cmd;
		}

		DrawTextureCmdNative.ID="DrawTexture";
		return DrawTextureCmdNative;
	})()


	/**
	*@private
	*Graphic bounds数据类
	*/
	//class laya.display.css.BoundsStyle
	var BoundsStyle=(function(){
		function BoundsStyle(){
			//this.bounds=null;
			//this.userBounds=null;
			//this.temBM=null;
		}

		__class(BoundsStyle,'laya.display.css.BoundsStyle');
		var __proto=BoundsStyle.prototype;
		/**
		*重置
		*/
		__proto.reset=function(){
			if(this.bounds)this.bounds.recover();
			if(this.userBounds)this.userBounds.recover();
			this.bounds=null;
			this.userBounds=null;
			this.temBM=null;
			return this;
		}

		/**
		*回收
		*/
		__proto.recover=function(){
			Pool.recover("BoundsStyle",this.reset());
		}

		BoundsStyle.create=function(){
			return Pool.getItemByClass("BoundsStyle",BoundsStyle);
		}

		return BoundsStyle;
	})()


	/**
	*@private
	*存储cache相关
	*/
	//class laya.display.css.CacheStyle
	var CacheStyle=(function(){
		function CacheStyle(){
			//this.cacheAs=null;
			//this.enableCanvasRender=false;
			//this.userSetCache=null;
			//this.cacheForFilters=false;
			//this.staticCache=false;
			//this.reCache=false;
			//this.mask=null;
			//this.maskParent=null;
			//this.filters=null;
			//this.cacheRect=null;
			//this.canvas=null;
			//this.filterCache=null;
			//this.hasGlowFilter=false;
			this.reset();
		}

		__class(CacheStyle,'laya.display.css.CacheStyle');
		var __proto=CacheStyle.prototype;
		/**
		*是否需要Bitmap缓存
		*@return
		*/
		__proto.needBitmapCache=function(){
			return this.cacheForFilters || this.mask;
		}

		/**
		*是否需要开启canvas渲染
		*/
		__proto.needEnableCanvasRender=function(){
			return this.userSetCache !="none" || this.cacheForFilters || this.mask;
		}

		/**
		*释放cache的资源
		*/
		__proto.releaseContext=function(){
			if (this.canvas){
				Pool.recover("CacheCanvas",this.canvas);
				this.canvas.size(0,0);
				this.canvas=null;
			}
		}

		__proto.createContext=function(){
			if (!this.canvas){
				this.canvas=Pool.getItem("CacheCanvas")|| HTMLCanvas.create("AUTO");
				var tx=this.canvas.context;
				if (!tx){
					tx=this.canvas.getContext('2d');
					tx.__tx=0;
					tx.__ty=0;
				}
			}
		}

		/**
		*释放滤镜资源
		*/
		__proto.releaseFilterCache=function(){
			var fc=this.filterCache;
			if (fc){
				fc.destroy();
				fc.recycle();
				this.filterCache=null;
			}
		}

		/**
		*回收
		*/
		__proto.recover=function(){
			if (this===CacheStyle.EMPTY)return;
			Pool.recover("SpriteCache",this.reset());
		}

		/**
		*重置
		*/
		__proto.reset=function(){
			this.releaseContext();
			this.releaseFilterCache();
			this.cacheAs="none";
			this.enableCanvasRender=false;
			this.userSetCache="none";
			this.cacheForFilters=false;
			this.staticCache=false;
			this.reCache=true;
			this.mask=null;
			this.maskParent=null;
			this.filterCache=null;
			this.filters=null;
			this.hasGlowFilter=false;
			if(this.cacheRect)this.cacheRect.recover();
			this.cacheRect=null;
			return this
		}

		__proto._calculateCacheRect=function(sprite,tCacheType,x,y){
			var _cacheStyle=sprite._cacheStyle;
			if (!_cacheStyle.cacheRect)
				_cacheStyle.cacheRect=Rectangle.create();
			var tRec;
			if (!Render.isWebGL || tCacheType==="bitmap"){
				tRec=sprite.getSelfBounds();
				tRec.x=tRec.x;
				tRec.y=tRec.y;
				tRec.x=tRec.x-16;
				tRec.y=tRec.y-16;
				tRec.width=tRec.width+32;
				tRec.height=tRec.height+32;
				tRec.x=Math.floor(tRec.x+x)-x;
				tRec.y=Math.floor(tRec.y+y)-y;
				tRec.width=Math.floor(tRec.width);
				tRec.height=Math.floor(tRec.height);
				_cacheStyle.cacheRect.copyFrom(tRec);
				}else {
				_cacheStyle.cacheRect.setTo(-sprite._style.pivotX,-sprite._style.pivotY,1,1);
			}
			tRec=_cacheStyle.cacheRect;
			var scaleX=Render.isWebGL ? 1 :Browser.pixelRatio *Laya.stage.clientScaleX;
			var scaleY=Render.isWebGL ? 1 :Browser.pixelRatio *Laya.stage.clientScaleY;
			if (!Render.isWebGL){
				var chainScaleX=1;
				var chainScaleY=1;
				var tar;
				tar=sprite;
				while (tar && tar !=Laya.stage){
					chainScaleX *=tar.scaleX;
					chainScaleY *=tar.scaleY;
					tar=tar.parent;
				}
				if (chainScaleX > 1)scaleX *=chainScaleX;
				if (chainScaleY > 1)scaleY *=chainScaleY;
			}
			if (sprite._style.scrollRect){
				var scrollRect=sprite._style.scrollRect;
				tRec.x-=scrollRect.x;
				tRec.y-=scrollRect.y;
			}
			CacheStyle._scaleInfo.setTo(scaleX,scaleY);
			return CacheStyle._scaleInfo;
		}

		CacheStyle.create=function(){
			return Pool.getItemByClass("SpriteCache",CacheStyle);
		}

		CacheStyle.EMPTY=new CacheStyle();
		__static(CacheStyle,
		['_scaleInfo',function(){return this._scaleInfo=new Point();}
		]);
		return CacheStyle;
	})()


	/**
	*@private
	*元素样式
	*/
	//class laya.display.css.SpriteStyle
	var SpriteStyle=(function(){
		function SpriteStyle(){
			//this.scaleX=NaN;
			//this.scaleY=NaN;
			//this.skewX=NaN;
			//this.skewY=NaN;
			//this.pivotX=NaN;
			//this.pivotY=NaN;
			//this.rotation=NaN;
			//this.alpha=NaN;
			//this.scrollRect=null;
			//this.viewport=null;
			//this.hitArea=null;
			//this.dragging=null;
			//this.blendMode=null;
			this.reset();
		}

		__class(SpriteStyle,'laya.display.css.SpriteStyle');
		var __proto=SpriteStyle.prototype;
		/**
		*重置，方便下次复用
		*/
		__proto.reset=function(){
			this.scaleX=this.scaleY=1;
			this.skewX=this.skewY=0;
			this.pivotX=this.pivotY=this.rotation=0;
			this.alpha=1;
			if(this.scrollRect)this.scrollRect.recover();
			this.scrollRect=null;
			if(this.viewport)this.viewport.recover();
			this.viewport=null;
			this.hitArea=null;
			this.dragging=null;
			this.blendMode=null;
			return this
		}

		/**
		*回收
		*/
		__proto.recover=function(){
			if (this===SpriteStyle.EMPTY)return;
			Pool.recover("SpriteStyle",this.reset());
		}

		SpriteStyle.create=function(){
			return Pool.getItemByClass("SpriteStyle",SpriteStyle);
		}

		SpriteStyle.EMPTY=new SpriteStyle();
		return SpriteStyle;
	})()


	/**
	*<code>Graphics</code> 类用于创建绘图显示对象。Graphics可以同时绘制多个位图或者矢量图，还可以结合save，restore，transform，scale，rotate，translate，alpha等指令对绘图效果进行变化。
	*Graphics以命令流方式存储，可以通过cmds属性访问所有命令流。Graphics是比Sprite更轻量级的对象，合理使用能提高应用性能(比如把大量的节点绘图改为一个节点的Graphics命令集合，能减少大量节点创建消耗)。
	*@see laya.display.Sprite#graphics
	*/
	//class laya.display.Graphics
	var Graphics=(function(){
		function Graphics(){
			//this._sp=null;
			this._one=null;
			this._cmds=null;
			//this._vectorgraphArray=null;
			//this._graphicBounds=null;
			this._render=this._renderEmpty;
			this._createData();
		}

		__class(Graphics,'laya.display.Graphics');
		var __proto=Graphics.prototype;
		__proto._createData=function(){}
		__proto._clearData=function(){}
		__proto._destroyData=function(){}
		/**
		*<p>销毁此对象。</p>
		*/
		__proto.destroy=function(){
			this.clear(true);
			if (this._graphicBounds)this._graphicBounds.destroy();
			this._graphicBounds=null;
			this._vectorgraphArray=null;
			if (this._sp){
				this._sp._renderType=0;
				this._sp._setRenderType(0);
				this._sp=null;
			}
			this._destroyData();
		}

		/**
		*<p>清空绘制命令。</p>
		*@param recoverCmds 是否回收绘图指令数组，设置为true，则对指令数组进行回收以节省内存开销，建议设置为true进行回收，但如果手动引用了数组，不建议回收
		*/
		__proto.clear=function(recoverCmds){
			(recoverCmds===void 0)&& (recoverCmds=false);
			if (recoverCmds){
				var tCmd=this._one;
				if (this._cmds){
					var i=0,len=this._cmds.length;
					for (i=0;i < len;i++){
						tCmd=this._cmds[i];
						tCmd.recover();
					}
					this._cmds.length=0;
					}else if (tCmd){
					tCmd.recover();
				}
				}else {
				this._cmds=null;
			}
			this._one=null;
			this._render=this._renderEmpty;
			this._clearData();
			if (this._sp){
				this._sp._renderType &=~0x200;
				this._sp._setRenderType(this._sp._renderType);
			}
			this._repaint();
			if (this._vectorgraphArray){
				for (i=0,len=this._vectorgraphArray.length;i < len;i++){
					VectorGraphManager.getInstance().deleteShape(this._vectorgraphArray[i]);
				}
				this._vectorgraphArray.length=0;
			}
		}

		/**@private */
		__proto._clearBoundsCache=function(){
			if(this._graphicBounds)this._graphicBounds.reset();
		}

		/**@private */
		__proto._initGraphicBounds=function(){
			if (!this._graphicBounds){
				this._graphicBounds=GraphicsBounds.create();
				this._graphicBounds._graphics=this;
			}
		}

		/**
		*@private
		*重绘此对象。
		*/
		__proto._repaint=function(){
			this._clearBoundsCache();
			this._sp && this._sp.repaint();
		}

		/**@private */
		__proto._isOnlyOne=function(){
			return !this._cmds || this._cmds.length===0;
		}

		/**
		*获取位置及宽高信息矩阵(比较耗CPU，频繁使用会造成卡顿，尽量少用)。
		*@param realSize （可选）使用图片的真实大小，默认为false
		*@return 位置与宽高组成的 一个 Rectangle 对象。
		*/
		__proto.getBounds=function(realSize){
			(realSize===void 0)&& (realSize=false);
			this._initGraphicBounds();
			return this._graphicBounds.getBounds(realSize);
		}

		/**
		*@private
		*@param realSize （可选）使用图片的真实大小，默认为false
		*获取端点列表。
		*/
		__proto.getBoundPoints=function(realSize){
			(realSize===void 0)&& (realSize=false);
			this._initGraphicBounds();
			return this._graphicBounds.getBoundPoints(realSize);
		}

		/**
		*
		*@param tex
		*@param x
		*@param y
		*@param width
		*@param height
		*/
		__proto.drawImage=function(texture,x,y,width,height){
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(width===void 0)&& (width=0);
			(height===void 0)&& (height=0);
			if (!texture)return null;
			if (!width)width=texture.sourceWidth;
			if (!height)height=texture.sourceHeight;
			if (texture.loaded){
				var wRate=width / texture.sourceWidth;
				var hRate=height / texture.sourceHeight;
				width=texture.width *wRate;
				height=texture.height *hRate;
				if (width <=0 || height <=0)return null;
				x+=texture.offsetX *wRate;
				y+=texture.offsetY *hRate;
			}
			if (this._sp){
				this._sp._renderType |=0x200;
				this._sp._setRenderType(this._sp._renderType);
			};
			var args=DrawImageCmd.create.call(this,texture,x,y,width,height);
			if (this._one==null){
				this._one=args;
				this._render=this._renderOneImg;
				}else {
				this._saveToCmd(null,args);
			}
			this._repaint();
			return args;
		}

		/**@private */
		__proto._isOneImage=function(){
			return this._render===this._renderOneImg;
		}

		/**
		*绘制纹理。
		*@param tex 纹理。
		*@param x （可选）X轴偏移量。
		*@param y （可选）Y轴偏移量。
		*@param width （可选）宽度。
		*@param height （可选）高度。
		*@param matrix （可选）矩阵信息。
		*@param alpha （可选）透明度。
		*/
		__proto.drawTexture=function(texture,x,y,width,height,matrix,alpha,color,blendMode){
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(width===void 0)&& (width=0);
			(height===void 0)&& (height=0);
			(alpha===void 0)&& (alpha=1);
			if (!texture || alpha < 0.01)return null;
			if (!texture.loaded)return null;
			if (!width)width=texture.sourceWidth;
			if (!height)height=texture.sourceHeight;
			if (texture.loaded){
				var wRate=width / texture.sourceWidth;
				var hRate=height / texture.sourceHeight;
				width=texture.width *wRate;
				height=texture.height *hRate;
				if (width <=0 || height <=0)return null;
				x+=texture.offsetX *wRate;
				y+=texture.offsetY *hRate;
			}
			if (this._sp){
				this._sp._renderType |=0x200;
				this._sp._setRenderType(this._sp._renderType);
			}
			if (!Render.isWebGL && (blendMode || color)){
				var canvas=HTMLCanvas.create("2D");
				canvas.size(width,height);
				var ctx=canvas.getContext('2d');
				ctx.drawTexture(texture,0,0,width,height);
				texture=new Texture(canvas);
				if (color){
					var filter=new ColorFilterAction();
					var colorArr=Color.create(color).arrColor;
					filter.data=new ColorFilter().color(colorArr[0] *255,colorArr[1] *255,colorArr[2] *255);
					filter.apply({ctx:{ctx:ctx}});
				}
			};
			var args=DrawTextureCmd.create.call(this,texture,x,y,width,height,matrix,alpha,color,blendMode);
			this._repaint();
			return this._saveToCmd(null,args);
		}

		/**
		*@private 清理贴图并替换为最新的
		*@param tex
		*/
		__proto.cleanByTexture=function(texture,x,y,width,height){
			(width===void 0)&& (width=0);
			(height===void 0)&& (height=0);
			if (!texture)return this.clear(true);
			if (this._one && this._render===this._renderOneImg){
				if (!width)width=texture.sourceWidth;
				if (!height)height=texture.sourceHeight;
				var wRate=width / texture.sourceWidth;
				var hRate=height / texture.sourceHeight;
				width=texture.width *wRate;
				height=texture.height *hRate;
				x+=texture.offsetX *wRate;
				y+=texture.offsetY *hRate;
				var drawImageCmd=this._one;
				drawImageCmd.texture=texture;
				drawImageCmd.x=x;
				drawImageCmd.y=y;
				drawImageCmd.width=width;
				drawImageCmd.height=height;
				this._repaint();
				}else {
				this.clear(true);
				texture && this.drawImage(texture,x,y,width,height);
			}
		}

		/**
		*批量绘制同样纹理。
		*@param tex 纹理。
		*@param pos 绘制次数和坐标。
		*/
		__proto.drawTextures=function(texture,pos){
			if (!texture)return null;
			return this._saveToCmd(Render._context._drawTextures,DrawTexturesCmd.create.call(this,texture,pos));
		}

		/**
		*绘制一组三角形
		*@param texture 纹理。
		*@param x X轴偏移量。
		*@param y Y轴偏移量。
		*@param vertices 顶点数组。
		*@param indices 顶点索引。
		*@param uvData UV数据。
		*@param matrix 缩放矩阵。
		*@param alpha alpha
		*@param color 颜色变换
		*@param blendMode blend模式
		*/
		__proto.drawTriangles=function(texture,x,y,vertices,uvs,indices,matrix,alpha,color,blendMode){
			(alpha===void 0)&& (alpha=1);
			return this._saveToCmd(Render._context.drawTriangles,DrawTrianglesCmd.create.call(this,texture,x,y,vertices,uvs,indices,matrix,alpha,color,blendMode));
		}

		/**
		*用texture填充。
		*@param tex 纹理。
		*@param x X轴偏移量。
		*@param y Y轴偏移量。
		*@param width （可选）宽度。
		*@param height （可选）高度。
		*@param type （可选）填充类型 repeat|repeat-x|repeat-y|no-repeat
		*@param offset （可选）贴图纹理偏移
		*
		*/
		__proto.fillTexture=function(texture,x,y,width,height,type,offset){
			(width===void 0)&& (width=0);
			(height===void 0)&& (height=0);
			(type===void 0)&& (type="repeat");
			if (!texture||!texture.loaded)return null;
			return this._saveToCmd(Render._context._fillTexture,FillTextureCmd.create.call(this,texture,x,y,width,height,type,offset || Point.EMPTY,{}));
		}

		/**
		*@private
		*保存到命令流。
		*/
		__proto._saveToCmd=function(fun,args){
			if (this._sp){
				this._sp._renderType |=0x200;
				this._sp._setRenderType(this._sp._renderType);
			}
			if (this._one==null){
				this._one=args;
				this._render=this._renderOne;
				}else {
				this._render=this._renderAll;
				(this._cmds || (this._cmds=[])).length===0 && this._cmds.push(this._one);
				this._cmds.push(args);
			}
			this._repaint();
			return args;
		}

		/**
		*设置剪裁区域，超出剪裁区域的坐标不显示。
		*@param x X 轴偏移量。
		*@param y Y 轴偏移量。
		*@param width 宽度。
		*@param height 高度。
		*/
		__proto.clipRect=function(x,y,width,height){
			return this._saveToCmd(Render._context._clipRect,ClipRectCmd.create.call(this,x,y,width,height));
		}

		/**
		*在画布上绘制文本。
		*@param text 在画布上输出的文本。
		*@param x 开始绘制文本的 x 坐标位置（相对于画布）。
		*@param y 开始绘制文本的 y 坐标位置（相对于画布）。
		*@param font 定义字号和字体，比如"20px Arial"。
		*@param color 定义文本颜色，比如"#ff0000"。
		*@param textAlign 文本对齐方式，可选值："left"，"center"，"right"。
		*/
		__proto.fillText=function(text,x,y,font,color,textAlign){
			return this._saveToCmd(Render._context._fillText,FillTextCmd.create.call(this,text,x,y,font||Text.defaultFontStr(),color,textAlign));
		}

		/**
		*在画布上绘制“被填充且镶边的”文本。
		*@param text 在画布上输出的文本。
		*@param x 开始绘制文本的 x 坐标位置（相对于画布）。
		*@param y 开始绘制文本的 y 坐标位置（相对于画布）。
		*@param font 定义字体和字号，比如"20px Arial"。
		*@param fillColor 定义文本颜色，比如"#ff0000"。
		*@param borderColor 定义镶边文本颜色。
		*@param lineWidth 镶边线条宽度。
		*@param textAlign 文本对齐方式，可选值："left"，"center"，"right"。
		*/
		__proto.fillBorderText=function(text,x,y,font,fillColor,borderColor,lineWidth,textAlign){
			return this._saveToCmd(Render._context._fillBorderText,FillBorderTextCmd.create.call(this,text,x,y,font||Text.defaultFontStr(),fillColor,borderColor,lineWidth,textAlign));
		}

		/***@private */
		__proto.fillWords=function(words,x,y,font,color){
			return this._saveToCmd(Render._context._fillWords,FillWordsCmd.create.call(this,words,x,y,font||Text.defaultFontStr(),color));
		}

		/***@private */
		__proto.fillBorderWords=function(words,x,y,font,fillColor,borderColor,lineWidth){
			return this._saveToCmd(Render._context._fillBorderWords,FillBorderWordsCmd.create.call(this,words,x,y,font||Text.defaultFontStr(),fillColor,borderColor,lineWidth));
		}

		/**
		*在画布上绘制文本（没有填色）。文本的默认颜色是黑色。
		*@param text 在画布上输出的文本。
		*@param x 开始绘制文本的 x 坐标位置（相对于画布）。
		*@param y 开始绘制文本的 y 坐标位置（相对于画布）。
		*@param font 定义字体和字号，比如"20px Arial"。
		*@param color 定义文本颜色，比如"#ff0000"。
		*@param lineWidth 线条宽度。
		*@param textAlign 文本对齐方式，可选值："left"，"center"，"right"。
		*/
		__proto.strokeText=function(text,x,y,font,color,lineWidth,textAlign){
			return this._saveToCmd(Render._context._strokeText,StrokeTextCmd.create.call(this,text,x,y,font||Text.defaultFontStr(),color,lineWidth,textAlign));
		}

		/**
		*设置透明度。
		*@param value 透明度。
		*/
		__proto.alpha=function(alpha){
			return this._saveToCmd(Render._context._alpha,AlphaCmd.create.call(this,alpha));
		}

		/**
		*替换绘图的当前转换矩阵。
		*@param mat 矩阵。
		*@param pivotX （可选）水平方向轴心点坐标。
		*@param pivotY （可选）垂直方向轴心点坐标。
		*/
		__proto.transform=function(matrix,pivotX,pivotY){
			(pivotX===void 0)&& (pivotX=0);
			(pivotY===void 0)&& (pivotY=0);
			return this._saveToCmd(Render._context._transform,TransformCmd.create.call(this,matrix,pivotX,pivotY));
		}

		/**
		*旋转当前绘图。(推荐使用transform，性能更高)
		*@param angle 旋转角度，以弧度计。
		*@param pivotX （可选）水平方向轴心点坐标。
		*@param pivotY （可选）垂直方向轴心点坐标。
		*/
		__proto.rotate=function(angle,pivotX,pivotY){
			(pivotX===void 0)&& (pivotX=0);
			(pivotY===void 0)&& (pivotY=0);
			return this._saveToCmd(Render._context._rotate,RotateCmd.create.call(this,angle,pivotX,pivotY));
		}

		/**
		*缩放当前绘图至更大或更小。(推荐使用transform，性能更高)
		*@param scaleX 水平方向缩放值。
		*@param scaleY 垂直方向缩放值。
		*@param pivotX （可选）水平方向轴心点坐标。
		*@param pivotY （可选）垂直方向轴心点坐标。
		*/
		__proto.scale=function(scaleX,scaleY,pivotX,pivotY){
			(pivotX===void 0)&& (pivotX=0);
			(pivotY===void 0)&& (pivotY=0);
			return this._saveToCmd(Render._context._scale,ScaleCmd.create.call(this,scaleX,scaleY,pivotX,pivotY));
		}

		/**
		*重新映射画布上的 (0,0)位置。
		*@param x 添加到水平坐标（x）上的值。
		*@param y 添加到垂直坐标（y）上的值。
		*/
		__proto.translate=function(tx,ty){
			return this._saveToCmd(Render._context._translate,TranslateCmd.create.call(this,tx,ty));
		}

		/**
		*保存当前环境的状态。
		*/
		__proto.save=function(){
			return this._saveToCmd(Render._context._save,SaveCmd.create.call(this));
		}

		/**
		*返回之前保存过的路径状态和属性。
		*/
		__proto.restore=function(){
			return this._saveToCmd(Render._context._restore,RestoreCmd.create.call(this));
		}

		/**
		*@private
		*替换文本内容。
		*@param text 文本内容。
		*@return 替换成功则值为true，否则值为flase。
		*/
		__proto.replaceText=function(text){
			this._repaint();
			var cmds=this._cmds;
			if (!cmds){
				if (this._one && this._isTextCmd(this._one)){
					this._one.text=text;
					return true;
				}
				}else {
				for (var i=cmds.length-1;i >-1;i--){
					if (this._isTextCmd(cmds[i])){
						cmds[i].text=text;
						return true;
					}
				}
			}
			return false;
		}

		/**@private */
		__proto._isTextCmd=function(cmd){
			var cmdID=cmd.cmdID;
			return cmdID=="FillText" || cmdID=="StrokeText" || cmdID=="FillBorderText";
		}

		/**
		*@private
		*替换文本颜色。
		*@param color 颜色。
		*/
		__proto.replaceTextColor=function(color){
			this._repaint();
			var cmds=this._cmds;
			if (!cmds){
				if (this._one && this._isTextCmd(this._one)){
					this._setTextCmdColor(this._one,color);
				}
				}else {
				for (var i=cmds.length-1;i >-1;i--){
					if (this._isTextCmd(cmds[i])){
						this._setTextCmdColor(cmds[i],color);
					}
				}
			}
		}

		__proto._setTextCmdColor=function(cmdO,color){
			var cmdID=cmdO.cmdID;
			switch(cmdID){
				case "FillText":
				case "StrokeText":
					cmdO.color=color;
					break ;
				case "FillBorderText":
				case "FillBorderWords":
				case "FillBorderText":
					cmdO.fillColor=color;
					break ;
				}
		}

		/**
		*加载并显示一个图片。
		*@param url 图片地址。
		*@param x （可选）显示图片的x位置。
		*@param y （可选）显示图片的y位置。
		*@param width （可选）显示图片的宽度，设置为0表示使用图片默认宽度。
		*@param height （可选）显示图片的高度，设置为0表示使用图片默认高度。
		*@param complete （可选）加载完成回调。
		*/
		__proto.loadImage=function(url,x,y,width,height,complete){
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(width===void 0)&& (width=0);
			(height===void 0)&& (height=0);
			var tex=Loader.getRes(url);
			if (!tex){
				tex=new Texture();
				tex.load(url);
				Loader.cacheRes(url,tex);
				tex.once("loaded",this,this.drawImage,[tex,x,y,width,height]);
				}else{
				if (!tex.loaded){
					tex.once("loaded",this,this.drawImage,[tex,x,y,width,height]);
				}else
				this.drawImage(tex,x,y,width,height);
			}
			if (complete !=null){
				tex._loaded ? complete.call(this._sp):tex.on("loaded",this._sp,complete);
			}
		}

		/**
		*@private
		*/
		__proto._renderEmpty=function(sprite,context,x,y){}
		/**
		*@private
		*/
		__proto._renderAll=function(sprite,context,x,y){
			var cmds=this._cmds,cmd;
			for (var i=0,n=cmds.length;i < n;i++){
				(cmd=cmds[i]).run(context,x,y);
			}
		}

		/**
		*@private
		*/
		__proto._renderOne=function(sprite,context,x,y){
			this._one.run(context,x,y);
		}

		/**
		*@private
		*/
		__proto._renderOneImg=function(sprite,context,x,y){
			this._one.run(context,x,y);
		}

		/**
		*绘制一条线。
		*@param fromX X轴开始位置。
		*@param fromY Y轴开始位置。
		*@param toX X轴结束位置。
		*@param toY Y轴结束位置。
		*@param lineColor 颜色。
		*@param lineWidth （可选）线条宽度。
		*/
		__proto.drawLine=function(fromX,fromY,toX,toY,lineColor,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var tId=0;
			if (Render.isWebGL){
				tId=VectorGraphManager.getInstance().getId();
				if (this._vectorgraphArray==null)this._vectorgraphArray=[];
				this._vectorgraphArray.push(tId);
			};
			var offset=lineWidth % 2===0 ? 0 :0.5;
			return this._saveToCmd(Render._context._drawLine,DrawLineCmd.create.call(this,fromX+offset,fromY+offset,toX+offset,toY+offset,lineColor,lineWidth,tId));
		}

		/**
		*绘制一系列线段。
		*@param x 开始绘制的X轴位置。
		*@param y 开始绘制的Y轴位置。
		*@param points 线段的点集合。格式:[x1,y1,x2,y2,x3,y3...]。
		*@param lineColor 线段颜色，或者填充绘图的渐变对象。
		*@param lineWidth （可选）线段宽度。
		*/
		__proto.drawLines=function(x,y,points,lineColor,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var tId=0;
			if (!points || points.length < 4)return null;
			if (Render.isWebGL){
				tId=VectorGraphManager.getInstance().getId();
				if (this._vectorgraphArray==null)this._vectorgraphArray=[];
				this._vectorgraphArray.push(tId);
			};
			var offset=lineWidth % 2===0 ? 0 :0.5;
			return this._saveToCmd(Render._context._drawLines,DrawLinesCmd.create.call(this,x+offset,y+offset,points,lineColor,lineWidth,tId));
		}

		/**
		*绘制一系列曲线。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param points 线段的点集合，格式[controlX,controlY,anchorX,anchorY...]。
		*@param lineColor 线段颜色，或者填充绘图的渐变对象。
		*@param lineWidth （可选）线段宽度。
		*/
		__proto.drawCurves=function(x,y,points,lineColor,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			return this._saveToCmd(Render._context._drawCurves,DrawCurvesCmd.create.call(this,x,y,points,lineColor,lineWidth));
		}

		/**
		*绘制矩形。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param width 矩形宽度。
		*@param height 矩形高度。
		*@param fillColor 填充颜色，或者填充绘图的渐变对象。
		*@param lineColor （可选）边框颜色，或者填充绘图的渐变对象。
		*@param lineWidth （可选）边框宽度。
		*/
		__proto.drawRect=function(x,y,width,height,fillColor,lineColor,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var offset=lineColor ? lineWidth / 2 :0;
			var lineOffset=lineColor ? lineWidth :0;
			return this._saveToCmd(Render._context.drawRect,DrawRectCmd.create.call(this,x+offset,y+offset,width-lineOffset,height-lineOffset,fillColor,lineColor,lineWidth));
		}

		/**
		*绘制圆形。
		*@param x 圆点X 轴位置。
		*@param y 圆点Y 轴位置。
		*@param radius 半径。
		*@param fillColor 填充颜色，或者填充绘图的渐变对象。
		*@param lineColor （可选）边框颜色，或者填充绘图的渐变对象。
		*@param lineWidth （可选）边框宽度。
		*/
		__proto.drawCircle=function(x,y,radius,fillColor,lineColor,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var offset=lineColor ? lineWidth / 2 :0;
			var tId=0;
			if (Render.isWebGL){
				tId=VectorGraphManager.getInstance().getId();
				if (this._vectorgraphArray==null)this._vectorgraphArray=[];
				this._vectorgraphArray.push(tId);
			}
			return this._saveToCmd(Render._context._drawCircle,DrawCircleCmd.create.call(this,x,y,radius-offset,fillColor,lineColor,lineWidth,tId));
		}

		/**
		*绘制扇形。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param radius 扇形半径。
		*@param startAngle 开始角度。
		*@param endAngle 结束角度。
		*@param fillColor 填充颜色，或者填充绘图的渐变对象。
		*@param lineColor （可选）边框颜色，或者填充绘图的渐变对象。
		*@param lineWidth （可选）边框宽度。
		*/
		__proto.drawPie=function(x,y,radius,startAngle,endAngle,fillColor,lineColor,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var offset=lineColor ? lineWidth / 2 :0;
			var lineOffset=lineColor ? lineWidth :0;
			var tId=0;
			if (Render.isWebGL){
				tId=VectorGraphManager.getInstance().getId();
				if (this._vectorgraphArray==null)this._vectorgraphArray=[];
				this._vectorgraphArray.push(tId);
			}
			return this._saveToCmd(Render._context._drawPie,DrawPieCmd.create.call(this,x+offset,y+offset,radius-lineOffset,Utils.toRadian(startAngle),Utils.toRadian(endAngle),fillColor,lineColor,lineWidth,tId));
		}

		/**
		*绘制多边形。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param points 多边形的点集合。
		*@param fillColor 填充颜色，或者填充绘图的渐变对象。
		*@param lineColor （可选）边框颜色，或者填充绘图的渐变对象。
		*@param lineWidth （可选）边框宽度。
		*/
		__proto.drawPoly=function(x,y,points,fillColor,lineColor,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var tId=0;
			if (Render.isWebGL){
				tId=VectorGraphManager.getInstance().getId();
				if (this._vectorgraphArray==null)this._vectorgraphArray=[];
				this._vectorgraphArray.push(tId);
				var tIsConvexPolygon=false;
				if (points.length > 6){
					tIsConvexPolygon=false;
					}else {
					tIsConvexPolygon=true;
				}
			};
			var offset=lineColor ? (lineWidth % 2===0 ? 0 :0.5):0;
			return this._saveToCmd(Render._context._drawPoly,DrawPolyCmd.create.call(this,x+offset,y+offset,points,fillColor,lineColor,lineWidth,tIsConvexPolygon,tId));
		}

		/**
		*绘制路径。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param paths 路径集合，路径支持以下格式：[["moveTo",x,y],["lineTo",x,y],["arcTo",x1,y1,x2,y2,r],["closePath"]]。
		*@param brush （可选）刷子定义，支持以下设置{fillStyle:"#FF0000"}。
		*@param pen （可选）画笔定义，支持以下设置{strokeStyle,lineWidth,lineJoin:"bevel|round|miter",lineCap:"butt|round|square",miterLimit}。
		*/
		__proto.drawPath=function(x,y,paths,brush,pen){
			return this._saveToCmd(Render._context._drawPath,DrawPathCmd.create.call(this,x,y,paths,brush,pen));
		}

		/**
		*@private
		*命令流。存储了所有绘制命令。
		*/
		__getset(0,__proto,'cmds',function(){
			return this._cmds;
			},function(value){
			if (this._sp){
				this._sp._renderType |=0x200;
				this._sp._setRenderType(this._sp._renderType);
			}
			this._cmds=value;
			this._render=this._renderAll;
			this._repaint();
		});

		return Graphics;
	})()


	/**
	*@private
	*Graphic bounds数据类
	*/
	//class laya.display.GraphicsBounds
	var GraphicsBounds=(function(){
		function GraphicsBounds(){
			//this._temp=null;
			//this._bounds=null;
			//this._rstBoundPoints=null;
			this._cacheBoundsType=false;
			//this._graphics=null;
		}

		__class(GraphicsBounds,'laya.display.GraphicsBounds');
		var __proto=GraphicsBounds.prototype;
		/**
		*销毁
		*/
		__proto.destroy=function(){
			this._graphics=null;
			this._cacheBoundsType=false;
			if (this._temp)this._temp.length=0;
			if (this._rstBoundPoints)this._rstBoundPoints.length=0;
			if (this._bounds)this._bounds.recover();
			this._bounds=null;
			Pool.recover("GraphicsBounds",this);
		}

		/**
		*重置数据
		*/
		__proto.reset=function(){
			this._temp && (this._temp.length=0);
		}

		/**
		*获取位置及宽高信息矩阵(比较耗CPU，频繁使用会造成卡顿，尽量少用)。
		*@param realSize （可选）使用图片的真实大小，默认为false
		*@return 位置与宽高组成的 一个 Rectangle 对象。
		*/
		__proto.getBounds=function(realSize){
			(realSize===void 0)&& (realSize=false);
			if (!this._bounds || !this._temp || this._temp.length < 1 || realSize !=this._cacheBoundsType){
				this._bounds=Rectangle._getWrapRec(this.getBoundPoints(realSize),this._bounds)
			}
			this._cacheBoundsType=realSize;
			return this._bounds;
		}

		/**
		*@private
		*@param realSize （可选）使用图片的真实大小，默认为false
		*获取端点列表。
		*/
		__proto.getBoundPoints=function(realSize){
			(realSize===void 0)&& (realSize=false);
			if (!this._temp || this._temp.length < 1 || realSize !=this._cacheBoundsType)
				this._temp=this._getCmdPoints(realSize);
			this._cacheBoundsType=realSize;
			return this._rstBoundPoints=Utils.copyArray(this._rstBoundPoints,this._temp);
		}

		__proto._getCmdPoints=function(realSize){
			(realSize===void 0)&& (realSize=false);
			var context=Render._context;
			var cmds=this._graphics.cmds;
			var rst;
			rst=this._temp || (this._temp=[]);
			rst.length=0;
			if (!cmds && this._graphics._one !=null){
				GraphicsBounds._tempCmds.length=0;
				GraphicsBounds._tempCmds.push(this._graphics._one);
				cmds=GraphicsBounds._tempCmds;
			}
			if (!cmds)return rst;
			var matrixs=GraphicsBounds._tempMatrixArrays;
			matrixs.length=0;
			var tMatrix=GraphicsBounds._initMatrix;
			tMatrix.identity();
			var tempMatrix=GraphicsBounds._tempMatrix;
			var cmd;
			var tex;
			for (var i=0,n=cmds.length;i < n;i++){
				cmd=cmds[i];
				switch (cmd.cmdID){
					case "Alpha":
						matrixs.push(tMatrix);
						tMatrix=tMatrix.clone();
						break ;
					case "Restore":
						tMatrix=matrixs.pop();
						break ;
					case "Scale":
						tempMatrix.identity();
						tempMatrix.translate(-cmd.pivotX,-cmd.pivotY);
						tempMatrix.scale(cmd.scaleX,cmd.scaleY);
						tempMatrix.translate(cmd.pivotX,cmd.pivotY);
						this._switchMatrix(tMatrix,tempMatrix);
						break ;
					case "Rotate":
						tempMatrix.identity();
						tempMatrix.translate(-cmd.pivotX,-cmd.pivotY);
						tempMatrix.rotate(cmd.angle);
						tempMatrix.translate(cmd.pivotX,cmd.pivotY);
						this._switchMatrix(tMatrix,tempMatrix);
						break ;
					case "Translate":
						tempMatrix.identity();
						tempMatrix.translate(cmd.tx,cmd.ty);
						this._switchMatrix(tMatrix,tempMatrix);
						break ;
					case "Transform":
						tempMatrix.identity();
						tempMatrix.translate(-cmd.pivotX,-cmd.pivotY);
						tempMatrix.concat(cmd.matrix);
						tempMatrix.translate(cmd.pivotX,cmd.pivotY);
						this._switchMatrix(tMatrix,tempMatrix);
						break ;
					case "DrawImage":
					case "FillTexture":
						GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd.x,cmd.y,cmd.width,cmd.height),tMatrix);
						break ;
					case "DrawTexture":
						tMatrix.copyTo(tempMatrix);
						if(cmd.matrix)
							tempMatrix.concat(cmd.matrix);
						GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd.x,cmd.y,cmd.width,cmd.height),tempMatrix);
						break ;
					case "DrawImage":
						tex=cmd.texture;
						if (realSize){
							if (cmd.width && cmd.height){
								GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd.x,cmd.y,cmd.width,cmd.height),tMatrix);
								}else {
								GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd.x,cmd.y,tex.width,tex.height),tMatrix);
							}
							}else {
							var wRate=(cmd.width || tex.sourceWidth)/ tex.width;
							var hRate=(cmd.height || tex.sourceHeight)/ tex.height;
							var oWidth=wRate *tex.sourceWidth;
							var oHeight=hRate *tex.sourceHeight;
							var offX=tex.offsetX > 0 ? tex.offsetX :0;
							var offY=tex.offsetY > 0 ? tex.offsetY :0;
							offX *=wRate;
							offY *=hRate;
							GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd.x-offX,cmd.y-offY,oWidth,oHeight),tMatrix);
						}
						break ;
					case "FillTexture":
						if (cmd.width && cmd.height){
							GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd.x,cmd.y,cmd.width,cmd.height),tMatrix);
							}else {
							tex=cmd.texture;
							GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd.x,cmd.y,tex.width,tex.height),tMatrix);
						}
						break ;
					case "DrawTexture":;
						var drawMatrix;
						if (cmd.matrix){
							tMatrix.copyTo(tempMatrix);
							tempMatrix.concat(cmd.matrix);
							drawMatrix=tempMatrix;
							}else {
							drawMatrix=tMatrix;
						}
						if (realSize){
							if (cmd.width && cmd.height){
								GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd.x,cmd.y,cmd.width,cmd.height),drawMatrix);
								}else {
								tex=cmd.texture;
								GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd.x,cmd.y,tex.width,tex.height),drawMatrix);
							}
							}else {
							tex=cmd.texture;
							wRate=(cmd.width || tex.sourceWidth)/ tex.width;
							hRate=(cmd.height || tex.sourceHeight)/ tex.height;
							oWidth=wRate *tex.sourceWidth;
							oHeight=hRate *tex.sourceHeight;
							offX=tex.offsetX > 0 ? tex.offsetX :0;
							offY=tex.offsetY > 0 ? tex.offsetY :0;
							offX *=wRate;
							offY *=hRate;
							GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd.x-offX,cmd.y-offY,oWidth,oHeight),drawMatrix);
						}
						break ;
					case "DrawRect":
						GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd.x,cmd.y,cmd.width,cmd.height),tMatrix);
						break ;
					case "DrawCircle":
						GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd.x-cmd.radius,cmd.y-cmd.radius,cmd.x+cmd.radius,cmd.y+cmd.radius),tMatrix);
						break ;
					case "DrawLine":
						GraphicsBounds._tempPoints.length=0;
						var lineWidth=NaN;
						lineWidth=cmd.lineWidth *0.5;
						if (cmd.fromX==cmd.toX){
							GraphicsBounds._tempPoints.push(cmd.fromX+lineWidth,cmd.fromY,cmd.toX+lineWidth,cmd.toY,cmd.fromX-lineWidth,cmd.fromY,cmd.toX-lineWidth,cmd.toY);
							}else if (cmd.fromY==cmd.toY){
							GraphicsBounds._tempPoints.push(cmd.fromX,cmd.fromY+lineWidth,cmd.toX,cmd.toY+lineWidth,cmd.fromX,cmd.fromY-lineWidth,cmd.toX,cmd.toY-lineWidth);
							}else {
							GraphicsBounds._tempPoints.push(cmd.fromX,cmd.fromY,cmd.toX,cmd.toY);
						}
						GraphicsBounds._addPointArrToRst(rst,GraphicsBounds._tempPoints,tMatrix);
						break ;
					case "DrawCurves":
						GraphicsBounds._addPointArrToRst(rst,Bezier.I.getBezierPoints(cmd.points),tMatrix,cmd.x,cmd.y);
						break ;
					case "DrawLines":
					case "DrawPoly":
						GraphicsBounds._addPointArrToRst(rst,cmd.points,tMatrix,cmd.x,cmd.y);
						break ;
					case "DrawPath":
						GraphicsBounds._addPointArrToRst(rst,this._getPathPoints(cmd.paths),tMatrix,cmd.x,cmd.y);
						break ;
					case "DrawPie":
						GraphicsBounds._addPointArrToRst(rst,this._getPiePoints(cmd.x,cmd.y,cmd.radius,cmd.startAngle,cmd.endAngle),tMatrix);
						break ;
					}
			}
			if (rst.length > 200){
				rst=Utils.copyArray(rst,Rectangle._getWrapRec(rst)._getBoundPoints());
			}else if (rst.length > 8)
			rst=GrahamScan.scanPList(rst);
			return rst;
		}

		__proto._switchMatrix=function(tMatix,tempMatrix){
			tempMatrix.concat(tMatix);
			tempMatrix.copyTo(tMatix);
		}

		__proto._getPiePoints=function(x,y,radius,startAngle,endAngle){
			var rst=GraphicsBounds._tempPoints;
			GraphicsBounds._tempPoints.length=0;
			rst.push(x,y);
			var dP=Math.PI / 10;
			var i=NaN;
			for (i=startAngle;i < endAngle;i+=dP){
				rst.push(x+radius *Math.cos(i),y+radius *Math.sin(i));
			}
			if (endAngle !=i){
				rst.push(x+radius *Math.cos(endAngle),y+radius *Math.sin(endAngle));
			}
			return rst;
		}

		__proto._getPathPoints=function(paths){
			var i=0,len=0;
			var rst=GraphicsBounds._tempPoints;
			rst.length=0;
			len=paths.length;
			var tCMD;
			for (i=0;i < len;i++){
				tCMD=paths[i];
				if (tCMD.length > 1){
					rst.push(tCMD[1],tCMD[2]);
					if (tCMD.length > 3){
						rst.push(tCMD[3],tCMD[4]);
					}
				}
			}
			return rst;
		}

		GraphicsBounds.create=function(){
			return Pool.getItemByClass("GraphicsBounds",GraphicsBounds);
		}

		GraphicsBounds._addPointArrToRst=function(rst,points,matrix,dx,dy){
			(dx===void 0)&& (dx=0);
			(dy===void 0)&& (dy=0);
			var i=0,len=0;
			len=points.length;
			for (i=0;i < len;i+=2){
				GraphicsBounds._addPointToRst(rst,points[i]+dx,points[i+1]+dy,matrix);
			}
		}

		GraphicsBounds._addPointToRst=function(rst,x,y,matrix){
			var _tempPoint=Point.TEMP;
			_tempPoint.setTo(x ? x :0,y ? y :0);
			matrix.transformPoint(_tempPoint);
			rst.push(_tempPoint.x,_tempPoint.y);
		}

		GraphicsBounds._tempPoints=[];
		GraphicsBounds._tempMatrixArrays=[];
		GraphicsBounds._tempCmds=[];
		__static(GraphicsBounds,
		['_tempMatrix',function(){return this._tempMatrix=new Matrix();},'_initMatrix',function(){return this._initMatrix=new Matrix();}
		]);
		return GraphicsBounds;
	})()


	/**
	*@private
	*/
	//class laya.display.SpriteConst
	var SpriteConst=(function(){
		function SpriteConst(){};
		__class(SpriteConst,'laya.display.SpriteConst');
		SpriteConst.POSRENDERTYPE=0;
		SpriteConst.POSBUFFERBEGIN=1;
		SpriteConst.POSBUFFEREND=2;
		SpriteConst.POSX=3;
		SpriteConst.POSY=4;
		SpriteConst.POSPIVOTX=5;
		SpriteConst.POSPIVOTY=6;
		SpriteConst.POSSCALEX=7;
		SpriteConst.POSSCALEY=8;
		SpriteConst.POSSKEWX=9;
		SpriteConst.POSSKEWY=10;
		SpriteConst.POSROTATION=11;
		SpriteConst.POSTRANSFORM_FLAG=12;
		SpriteConst.POSMATRIX=13;
		SpriteConst.POSALPHA=19;
		SpriteConst.POSGRAPICS=20;
		SpriteConst.POSLAYAGL3D=21;
		SpriteConst.POSSIZE=22;
		SpriteConst.ALPHA=0x01;
		SpriteConst.TRANSFORM=0x02;
		SpriteConst.BLEND=0x04;
		SpriteConst.CANVAS=0x08;
		SpriteConst.FILTERS=0x10;
		SpriteConst.MASK=0x20;
		SpriteConst.CLIP=0x40;
		SpriteConst.STYLE=0x80;
		SpriteConst.TEXTURE=0x100;
		SpriteConst.GRAPHICS=0x200;
		SpriteConst.LAYAGL3D=0x400;
		SpriteConst.CUSTOM=0x800;
		SpriteConst.ONECHILD=0x1000;
		SpriteConst.CHILDS=0x2000;
		SpriteConst.REPAINT_NONE=0;
		SpriteConst.REPAINT_NODE=0x01;
		SpriteConst.REPAINT_CACHE=0x02;
		SpriteConst.REPAINT_ALL=0x03;
		return SpriteConst;
	})()


	/**
	*<code>Event</code> 是事件类型的集合。一般当发生事件时，<code>Event</code> 对象将作为参数传递给事件侦听器。
	*/
	//class laya.events.Event
	var Event=(function(){
		function Event(){
			//this.type=null;
			//this.nativeEvent=null;
			//this.target=null;
			//this.currentTarget=null;
			//this._stoped=false;
			//this.touchId=0;
			//this.keyCode=0;
			//this.delta=0;
		}

		__class(Event,'laya.events.Event');
		var __proto=Event.prototype;
		/**
		*设置事件数据。
		*@param type 事件类型。
		*@param currentTarget 事件目标触发对象。
		*@param target 事件当前冒泡对象。
		*@return 返回当前 Event 对象。
		*/
		__proto.setTo=function(type,currentTarget,target){
			this.type=type;
			this.currentTarget=currentTarget;
			this.target=target;
			return this;
		}

		/**
		*阻止对事件流中当前节点的后续节点中的所有事件侦听器进行处理。此方法不会影响当前节点 (currentTarget)中的任何事件侦听器。
		*/
		__proto.stopPropagation=function(){
			this._stoped=true;
		}

		/**鼠标在 Stage 上的 Y 轴坐标*/
		__getset(0,__proto,'stageY',function(){
			return Laya.stage.mouseY;
		});

		/**
		*包含按下或释放的键的字符代码值。字符代码值为英文键盘值。
		*/
		__getset(0,__proto,'charCode',function(){
			return this.nativeEvent.charCode;
		});

		/**
		*触摸点列表。
		*/
		__getset(0,__proto,'touches',function(){
			var arr=this.nativeEvent.touches;
			if (arr){
				var stage=Laya.stage;
				for (var i=0,n=arr.length;i < n;i++){
					var e=arr[i];
					var point=Point.TEMP;
					point.setTo(e.clientX,e.clientY);
					stage._canvasTransform.invertTransformPoint(point);
					stage.transform.invertTransformPoint(point);
					e.stageX=point.x;
					e.stageY=point.y;
				}
			}
			return arr;
		});

		/**
		*表示键在键盘上的位置。这对于区分在键盘上多次出现的键非常有用。<br>
		*例如，您可以根据此属性的值来区分左 Shift 键和右 Shift 键：左 Shift 键的值为 KeyLocation.LEFT，右 Shift 键的值为 KeyLocation.RIGHT。另一个示例是区分标准键盘 (KeyLocation.STANDARD)与数字键盘 (KeyLocation.NUM_PAD)上按下的数字键。
		*/
		__getset(0,__proto,'keyLocation',function(){
			return this.nativeEvent.keyLocation;
		});

		/**
		*表示 Ctrl 键是处于活动状态 (true)还是非活动状态 (false)。
		*/
		__getset(0,__proto,'ctrlKey',function(){
			return this.nativeEvent.ctrlKey;
		});

		/**
		*表示 Alt 键是处于活动状态 (true)还是非活动状态 (false)。
		*/
		__getset(0,__proto,'altKey',function(){
			return this.nativeEvent.altKey;
		});

		/**
		*表示 Shift 键是处于活动状态 (true)还是非活动状态 (false)。
		*/
		__getset(0,__proto,'shiftKey',function(){
			return this.nativeEvent.shiftKey;
		});

		/**鼠标在 Stage 上的 X 轴坐标*/
		__getset(0,__proto,'stageX',function(){
			return Laya.stage.mouseX;
		});

		Event.EMPTY=new Event();
		Event.MOUSE_DOWN="mousedown";
		Event.MOUSE_UP="mouseup";
		Event.CLICK="click";
		Event.RIGHT_MOUSE_DOWN="rightmousedown";
		Event.RIGHT_MOUSE_UP="rightmouseup";
		Event.RIGHT_CLICK="rightclick";
		Event.MOUSE_MOVE="mousemove";
		Event.MOUSE_OVER="mouseover";
		Event.MOUSE_OUT="mouseout";
		Event.MOUSE_WHEEL="mousewheel";
		Event.ROLL_OVER="mouseover";
		Event.ROLL_OUT="mouseout";
		Event.DOUBLE_CLICK="doubleclick";
		Event.CHANGE="change";
		Event.CHANGED="changed";
		Event.RESIZE="resize";
		Event.ADDED="added";
		Event.REMOVED="removed";
		Event.DISPLAY="display";
		Event.UNDISPLAY="undisplay";
		Event.ERROR="error";
		Event.COMPLETE="complete";
		Event.LOADED="loaded";
		Event.PROGRESS="progress";
		Event.INPUT="input";
		Event.RENDER="render";
		Event.OPEN="open";
		Event.MESSAGE="message";
		Event.CLOSE="close";
		Event.KEY_DOWN="keydown";
		Event.KEY_PRESS="keypress";
		Event.KEY_UP="keyup";
		Event.FRAME="enterframe";
		Event.DRAG_START="dragstart";
		Event.DRAG_MOVE="dragmove";
		Event.DRAG_END="dragend";
		Event.ENTER="enter";
		Event.SELECT="select";
		Event.BLUR="blur";
		Event.FOCUS="focus";
		Event.VISIBILITY_CHANGE="visibilitychange";
		Event.FOCUS_CHANGE="focuschange";
		Event.PLAYED="played";
		Event.PAUSED="paused";
		Event.STOPPED="stopped";
		Event.START="start";
		Event.END="end";
		Event.ENABLE_CHANGED="enablechanged";
		Event.ACTIVE_IN_HIERARCHY_CHANGED="activeinhierarchychanged";
		Event.COMPONENT_ADDED="componentadded";
		Event.COMPONENT_REMOVED="componentremoved";
		Event.LAYER_CHANGED="layerchanged";
		Event.HIERARCHY_LOADED="hierarchyloaded";
		Event.RECOVERING="recovering";
		Event.RECOVERED="recovered";
		Event.RELEASED="released";
		Event.LINK="link";
		Event.LABEL="label";
		Event.FULL_SCREEN_CHANGE="fullscreenchange";
		Event.DEVICE_LOST="devicelost";
		Event.MESH_CHANGED="meshchanged";
		Event.RENDERQUEUE_CHANGED="renderqueuechanged";
		Event.WORLDMATRIX_NEEDCHANGE="worldmatrixneedchanged";
		Event.ANIMATION_CHANGED="animationchanged";
		return Event;
	})()


	/**
	*<p><code>KeyBoardManager</code> 是键盘事件管理类。该类从浏览器中接收键盘事件，并派发该事件。</p>
	*<p>派发事件时若 Stage.focus 为空则只从 Stage 上派发该事件，否则将从 Stage.focus 对象开始一直冒泡派发该事件。所以在 Laya.stage 上监听键盘事件一定能够收到，如果在其他地方监听，则必须处在Stage.focus的冒泡链上才能收到该事件。</p>
	*<p>用户可以通过代码 Laya.stage.focus=someNode 的方式来设置focus对象。</p>
	*<p>用户可统一的根据事件对象中 e.keyCode 来判断按键类型，该属性兼容了不同浏览器的实现。</p>
	*/
	//class laya.events.KeyBoardManager
	var KeyBoardManager=(function(){
		function KeyBoardManager(){};
		__class(KeyBoardManager,'laya.events.KeyBoardManager');
		KeyBoardManager.__init__=function(){
			KeyBoardManager._addEvent("keydown");
			KeyBoardManager._addEvent("keypress");
			KeyBoardManager._addEvent("keyup");
		}

		KeyBoardManager._addEvent=function(type){
			Browser.document.addEventListener(type,function(e){
				laya.events.KeyBoardManager._dispatch(e,type);
			},true);
		}

		KeyBoardManager._dispatch=function(e,type){
			if (!KeyBoardManager.enabled)return;
			KeyBoardManager._event._stoped=false;
			KeyBoardManager._event.nativeEvent=e;
			KeyBoardManager._event.keyCode=e.keyCode || e.which || e.charCode;
			if (type==="keydown")KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode]=true;
			else if (type==="keyup")KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode]=null;
			var target=(Laya.stage.focus && (Laya.stage.focus.event !=null)&& Laya.stage.focus.displayedInStage)? Laya.stage.focus :Laya.stage;
			var ct=target;
			while (ct){
				ct.event(type,KeyBoardManager._event.setTo(type,ct,target));
				ct=ct.parent;
			}
		}

		KeyBoardManager.hasKeyDown=function(key){
			return KeyBoardManager._pressKeys[key];
		}

		KeyBoardManager._pressKeys={};
		KeyBoardManager.enabled=true;
		__static(KeyBoardManager,
		['_event',function(){return this._event=new Event();}
		]);
		return KeyBoardManager;
	})()


	/**
	*<p><code>MouseManager</code> 是鼠标、触摸交互管理器。</p>
	*<p>鼠标事件流包括捕获阶段、目标阶段、冒泡阶段。<br/>
	*捕获阶段：此阶段引擎会从stage开始递归检测stage及其子对象，直到找到命中的目标对象或者未命中任何对象；<br/>
	*目标阶段：找到命中的目标对象；<br/>
	*冒泡阶段：事件离开目标对象，按节点层级向上逐层通知，直到到达舞台的过程。</p>
	*/
	//class laya.events.MouseManager
	var MouseManager=(function(){
		function MouseManager(){
			this.mouseX=0;
			this.mouseY=0;
			this.disableMouseEvent=false;
			this.mouseDownTime=0;
			this.mouseMoveAccuracy=2;
			this._stage=null;
			this._target=null;
			this._lastMoveTimer=0;
			this._isLeftMouse=false;
			this._eventList=[];
			this._touchIDs={};
			this._id=1;
			this._tTouchID=0;
			this._event=new Event();
			this._matrix=new Matrix();
			this._point=new Point();
			this._rect=new Rectangle();
			this._prePoint=new Point();
			this._curTouchID=NaN;
		}

		__class(MouseManager,'laya.events.MouseManager');
		var __proto=MouseManager.prototype;
		/**
		*@private
		*初始化。
		*/
		__proto.__init__=function(stage,canvas){
			this._stage=stage;
			var _this=this;
			var list=this._eventList;
			canvas.oncontextmenu=function (e){
				if (MouseManager.enabled)return false;
			}
			canvas.addEventListener('mousedown',function(e){
				if (MouseManager.enabled){
					if (!Browser.onIE)e.preventDefault();
					list.push(e);
					_this.mouseDownTime=Browser.now();
				}
			});
			canvas.addEventListener('mouseup',function(e){
				if (MouseManager.enabled){
					e.preventDefault();
					list.push(e);
					_this.mouseDownTime=-Browser.now();
				}
			},true);
			canvas.addEventListener('mousemove',function(e){
				if (MouseManager.enabled){
					e.preventDefault();
					var now=Browser.now();
					if (now-_this._lastMoveTimer < 10)return;
					_this._lastMoveTimer=now;
					list.push(e);
				}
			},true);
			canvas.addEventListener("mouseout",function(e){
				if (MouseManager.enabled)list.push(e);
			})
			canvas.addEventListener("mouseover",function(e){
				if (MouseManager.enabled)list.push(e);
			})
			canvas.addEventListener("touchstart",function(e){
				if (MouseManager.enabled){
					list.push(e);
					if (!Input.isInputting)e.preventDefault();
					_this.mouseDownTime=Browser.now();
				}
			});
			canvas.addEventListener("touchend",function(e){
				if (MouseManager.enabled){
					if (!Input.isInputting)e.preventDefault();
					list.push(e);
					_this.mouseDownTime=-Browser.now();
				}
			},true);
			canvas.addEventListener("touchmove",function(e){
				if (MouseManager.enabled){
					e.preventDefault();
					list.push(e);
				}
			},true);
			canvas.addEventListener("touchcancel",function(e){
				if (MouseManager.enabled){
					e.preventDefault();
					list.push(e);
				}
			},true);
			canvas.addEventListener('mousewheel',function(e){
				if (MouseManager.enabled)list.push(e);
			});
			canvas.addEventListener('DOMMouseScroll',function(e){
				if (MouseManager.enabled)list.push(e);
			});
		}

		__proto.initEvent=function(e,nativeEvent){
			var _this=this;
			_this._event._stoped=false;
			_this._event.nativeEvent=nativeEvent || e;
			_this._target=null;
			this._point.setTo(e.pageX || e.clientX,e.pageY || e.clientY);
			this._stage._canvasTransform.invertTransformPoint(this._point);
			_this.mouseX=this._point.x;
			_this.mouseY=this._point.y;
			_this._event.touchId=e.identifier || 0;
			this._tTouchID=_this._event.touchId;
			var evt;
			evt=TouchManager.I._event;
			evt._stoped=false;
			evt.nativeEvent=_this._event.nativeEvent;
			evt.touchId=_this._event.touchId;
		}

		__proto.checkMouseWheel=function(e){
			this._event.delta=e.wheelDelta ? e.wheelDelta *0.025 :-e.detail;
			var _lastOvers=TouchManager.I.getLastOvers();
			for (var i=0,n=_lastOvers.length;i < n;i++){
				var ele=_lastOvers[i];
				ele.event("mousewheel",this._event.setTo("mousewheel",ele,this._target));
			}
		}

		// _stage.event(Event.MOUSE_WHEEL,_event.setTo(Event.MOUSE_WHEEL,_stage,_target));
		__proto.onMouseMove=function(ele){
			TouchManager.I.onMouseMove(ele,this._tTouchID);
		}

		__proto.onMouseDown=function(ele){
			if (Input.isInputting && Laya.stage.focus && Laya.stage.focus["focus"] && !Laya.stage.focus.contains(this._target)){
				var pre_input=Laya.stage.focus['_tf'] || Laya.stage.focus;
				var new_input=ele['_tf'] || ele;
				if ((new_input instanceof laya.display.Input )&& new_input.multiline==pre_input.multiline)
					pre_input['_focusOut']();
				else
				pre_input.focus=false;
			}
			TouchManager.I.onMouseDown(ele,this._tTouchID,this._isLeftMouse);
		}

		__proto.onMouseUp=function(ele){
			TouchManager.I.onMouseUp(ele,this._tTouchID,this._isLeftMouse);
		}

		__proto.check=function(sp,mouseX,mouseY,callBack){
			this._point.setTo(mouseX,mouseY);
			sp.fromParentPoint(this._point);
			mouseX=this._point.x;
			mouseY=this._point.y;
			var scrollRect=sp._style.scrollRect;
			if (scrollRect){
				this._rect.setTo(scrollRect.x,scrollRect.y,scrollRect.width,scrollRect.height);
				if (!this._rect.contains(mouseX,mouseY))return false;
			}
			if (!this.disableMouseEvent){
				if (sp.hitTestPrior && !sp.mouseThrough && !this.hitTest(sp,mouseX,mouseY)){
					return false;
				}
				for (var i=sp._children.length-1;i >-1;i--){
					var child=sp._children[i];
					if (!child.destroyed && child._mouseState > 1 && child._visible){
						if (this.check(child,mouseX,mouseY,callBack))return true;
					}
				}
			};
			var isHit=(sp.hitTestPrior && !sp.mouseThrough && !this.disableMouseEvent)? true :this.hitTest(sp,mouseX,mouseY);
			if (isHit){
				this._target=sp;
				callBack.call(this,sp);
				}else if (callBack===this.onMouseUp && sp===this._stage){
				this._target=this._stage;
				callBack.call(this,this._target);
			}
			return isHit;
		}

		__proto.hitTest=function(sp,mouseX,mouseY){
			var isHit=false;
			if (sp.scrollRect){
				mouseX-=sp._style.scrollRect.x;
				mouseY-=sp._style.scrollRect.y;
			};
			var hitArea=sp._style.hitArea;
			if (hitArea && hitArea.isHitGraphic){
				return hitArea.isHit(mouseX,mouseY);
			}
			if (sp.width > 0 && sp.height > 0 || sp.mouseThrough || hitArea){
				if (!sp.mouseThrough){
					isHit=(hitArea ? hitArea :this._rect.setTo(0,0,sp.width,sp.height)).contains(mouseX,mouseY);
					}else {
					isHit=sp.getGraphicBounds().contains(mouseX,mouseY);
				}
			}
			return isHit;
		}

		/**
		*执行事件处理。
		*/
		__proto.runEvent=function(){
			var len=this._eventList.length;
			if (!len)return;
			var _this=this;
			var i=0;
			while (i < len){
				var evt=this._eventList[i];
				if (evt.type!=='mousemove')this._prePoint.x=this._prePoint.y=-1000000;
				switch (evt.type){
					case 'mousedown':
						this._touchIDs[0]=this._id++;
						if (!MouseManager._isTouchRespond){
							_this._isLeftMouse=evt.button===0;
							_this.initEvent(evt);
							_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseDown);
						}else
						MouseManager._isTouchRespond=false;
						break ;
					case 'mouseup':
						_this._isLeftMouse=evt.button===0;
						_this.initEvent(evt);
						_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseUp);
						break ;
					case 'mousemove':
						if ((Math.abs(this._prePoint.x-evt.clientX)+Math.abs(this._prePoint.y-evt.clientY))>=this.mouseMoveAccuracy){
							this._prePoint.x=evt.clientX;
							this._prePoint.y=evt.clientY;
							_this.initEvent(evt);
							_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseMove);
						}
						break ;
					case "touchstart":
						MouseManager._isTouchRespond=true;
						_this._isLeftMouse=true;
						var touches=evt.changedTouches;
						for (var j=0,n=touches.length;j < n;j++){
							var touch=touches[j];
							if (MouseManager.multiTouchEnabled || isNaN(this._curTouchID)){
								this._curTouchID=touch.identifier;
								if (this._id % 200===0)this._touchIDs={};
								this._touchIDs[touch.identifier]=this._id++;
								_this.initEvent(touch,evt);
								_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseDown);
							}
						}
						break ;
					case "touchend":
					case "touchcancel":
						MouseManager._isTouchRespond=true;
						_this._isLeftMouse=true;
						var touchends=evt.changedTouches;
						for (j=0,n=touchends.length;j < n;j++){
							touch=touchends[j];
							if (MouseManager.multiTouchEnabled || touch.identifier==this._curTouchID){
								this._curTouchID=NaN;
								_this.initEvent(touch,evt);
								var isChecked=false;
								isChecked=_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseUp);
								if (!isChecked){
									_this.onMouseUp(null);
								}
							}
						}
						break ;
					case "touchmove":;
						var touchemoves=evt.changedTouches;
						for (j=0,n=touchemoves.length;j < n;j++){
							touch=touchemoves[j];
							if (MouseManager.multiTouchEnabled || touch.identifier==this._curTouchID){
								_this.initEvent(touch,evt);
								_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseMove);
							}
						}
						break ;
					case "wheel":
					case "mousewheel":
					case "DOMMouseScroll":
						_this.checkMouseWheel(evt);
						break ;
					case "mouseout":
						_this._stage.event("mouseout",_this._event.setTo("mouseout",_this._stage,_this._stage));
						break ;
					case "mouseover":
						_this._stage.event("mouseover",_this._event.setTo("mouseover",_this._stage,_this._stage));
						break ;
					}
				i++;
			}
			this._eventList.length=0;
		}

		MouseManager.enabled=true;
		MouseManager.multiTouchEnabled=true;
		MouseManager._isTouchRespond=false;
		__static(MouseManager,
		['instance',function(){return this.instance=new MouseManager();}
		]);
		return MouseManager;
	})()


	/**
	*@private
	*Touch事件管理类，处理多点触控下的鼠标事件
	*/
	//class laya.events.TouchManager
	var TouchManager=(function(){
		function TouchManager(){
			this.preOvers=[];
			this.preDowns=[];
			this.preRightDowns=[];
			this.enable=true;
			this._lastClickTime=0;
			this._event=new Event();
		}

		__class(TouchManager,'laya.events.TouchManager');
		var __proto=TouchManager.prototype;
		/**
		*从touch表里查找对应touchID的数据
		*@param touchID touch ID
		*@param arr touch表
		*@return
		*
		*/
		__proto.getTouchFromArr=function(touchID,arr){
			var i=0,len=0;
			len=arr.length;
			var tTouchO;
			for (i=0;i < len;i++){
				tTouchO=arr[i];
				if (tTouchO.id==touchID){
					return tTouchO;
				}
			}
			return null;
		}

		/**
		*从touch表里移除一个元素
		*@param touchID touch ID
		*@param arr touch表
		*
		*/
		__proto.removeTouchFromArr=function(touchID,arr){
			var i=0;
			for (i=arr.length-1;i >=0;i--){
				if (arr[i].id==touchID){
					arr.splice(i,1);
				}
			}
		}

		/**
		*创建一个touch数据
		*@param ele 当前的根节点
		*@param touchID touchID
		*@return
		*
		*/
		__proto.createTouchO=function(ele,touchID){
			var rst;
			rst=Pool.getItem("TouchData")|| {};
			rst.id=touchID;
			rst.tar=ele;
			return rst;
		}

		/**
		*处理touchStart
		*@param ele 根节点
		*@param touchID touchID
		*@param isLeft （可选）是否为左键
		*/
		__proto.onMouseDown=function(ele,touchID,isLeft){
			(isLeft===void 0)&& (isLeft=false);
			if (!this.enable)
				return;
			var preO;
			var tO;
			var arrs;
			preO=this.getTouchFromArr(touchID,this.preOvers);
			arrs=this.getEles(ele,null,TouchManager._tEleArr);
			if (!preO){
				tO=this.createTouchO(ele,touchID);
				this.preOvers.push(tO);
				}else {
				preO.tar=ele;
			}
			if (Browser.onMobile)
				this.sendEvents(arrs,"mouseover",touchID);
			var preDowns;
			preDowns=isLeft ? this.preDowns :this.preRightDowns;
			preO=this.getTouchFromArr(touchID,preDowns);
			if (!preO){
				tO=this.createTouchO(ele,touchID);
				preDowns.push(tO);
				}else {
				preO.tar=ele;
			}
			this.sendEvents(arrs,isLeft ? "mousedown" :"rightmousedown",touchID);
		}

		/**
		*派发事件。
		*@param eles 对象列表。
		*@param type 事件类型。
		*@param touchID （可选）touchID，默认为0。
		*/
		__proto.sendEvents=function(eles,type,touchID){
			(touchID===void 0)&& (touchID=0);
			var i=0,len=0;
			len=eles.length;
			this._event._stoped=false;
			var _target;
			_target=eles[0];
			var tE;
			for (i=0;i < len;i++){
				tE=eles[i];
				if (tE.destroyed)return;
				tE.event(type,this._event.setTo(type,tE,_target));
				if (this._event._stoped)
					break ;
			}
		}

		/**
		*获取对象列表。
		*@param start 起始节点。
		*@param end 结束节点。
		*@param rst 返回值。如果此值不为空，则将其赋值为计算结果，从而避免创建新数组；如果此值为空，则创建新数组返回。
		*@return Array 返回节点列表。
		*/
		__proto.getEles=function(start,end,rst){
			if (!rst){
				rst=[];
				}else {
				rst.length=0;
			}
			while (start && start !=end){
				rst.push(start);
				start=start._parent;
			}
			return rst;
		}

		/**
		*touchMove时处理out事件和over时间。
		*@param eleNew 新的根节点。
		*@param elePre 旧的根节点。
		*@param touchID （可选）touchID，默认为0。
		*/
		__proto.checkMouseOutAndOverOfMove=function(eleNew,elePre,touchID){
			(touchID===void 0)&& (touchID=0);
			if (elePre==eleNew)
				return;
			var tar;
			var arrs;
			var i=0,len=0;
			if (elePre.contains(eleNew)){
				arrs=this.getEles(eleNew,elePre,TouchManager._tEleArr);
				this.sendEvents(arrs,"mouseover",touchID);
				}else if (eleNew.contains(elePre)){
				arrs=this.getEles(elePre,eleNew,TouchManager._tEleArr);
				this.sendEvents(arrs,"mouseout",touchID);
				}else {
				arrs=TouchManager._tEleArr;
				arrs.length=0;
				var oldArr;
				oldArr=this.getEles(elePre,null,TouchManager._oldArr);
				var newArr;
				newArr=this.getEles(eleNew,null,TouchManager._newArr);
				len=oldArr.length;
				var tIndex=0;
				for (i=0;i < len;i++){
					tar=oldArr[i];
					tIndex=newArr.indexOf(tar);
					if (tIndex >=0){
						newArr.splice(tIndex,newArr.length-tIndex);
						break ;
						}else {
						arrs.push(tar);
					}
				}
				if (arrs.length > 0){
					this.sendEvents(arrs,"mouseout",touchID);
				}
				if (newArr.length > 0){
					this.sendEvents(newArr,"mouseover",touchID);
				}
			}
		}

		/**
		*处理TouchMove事件
		*@param ele 根节点
		*@param touchID touchID
		*
		*/
		__proto.onMouseMove=function(ele,touchID){
			if (!this.enable)
				return;
			var preO;
			preO=this.getTouchFromArr(touchID,this.preOvers);
			var arrs;
			var tO;
			if (!preO){
				arrs=this.getEles(ele,null,TouchManager._tEleArr);
				this.sendEvents(arrs,"mouseover",touchID);
				this.preOvers.push(this.createTouchO(ele,touchID));
				}else {
				this.checkMouseOutAndOverOfMove(ele,preO.tar);
				preO.tar=ele;
				arrs=this.getEles(ele,null,TouchManager._tEleArr);
			}
			this.sendEvents(arrs,"mousemove",touchID);
		}

		__proto.getLastOvers=function(){
			TouchManager._tEleArr.length=0;
			if (this.preOvers.length > 0 && this.preOvers[0].tar){
				return this.getEles(this.preOvers[0].tar,null,TouchManager._tEleArr);
			}
			TouchManager._tEleArr.push(Laya.stage);
			return TouchManager._tEleArr;
		}

		/**
		*处理TouchEnd事件
		*@param ele 根节点
		*@param touchID touchID
		*@param isLeft 是否为左键
		*/
		__proto.onMouseUp=function(ele,touchID,isLeft){
			(isLeft===void 0)&& (isLeft=false);
			if (!this.enable)
				return;
			var preO;
			var tO;
			var arrs;
			var oldArr;
			var i=0,len=0;
			var tar;
			var sendArr;
			var onMobile=Browser.onMobile;
			arrs=this.getEles(ele,null,TouchManager._tEleArr);
			this.sendEvents(arrs,isLeft ? "mouseup" :"rightmouseup",touchID);
			var preDowns;
			preDowns=isLeft ? this.preDowns :this.preRightDowns;
			preO=this.getTouchFromArr(touchID,preDowns);
			if (!preO){
				}else {
				var isDouble=false;
				var now=Browser.now();
				isDouble=now-this._lastClickTime < 300;
				this._lastClickTime=now;
				if (ele==preO.tar){
					sendArr=arrs;
					}else {
					oldArr=this.getEles(preO.tar,null,TouchManager._oldArr);
					sendArr=TouchManager._newArr;
					sendArr.length=0;
					len=oldArr.length;
					for (i=0;i < len;i++){
						tar=oldArr[i];
						if (arrs.indexOf(tar)>=0){
							sendArr.push(tar);
						}
					}
				}
				if (sendArr.length > 0){
					this.sendEvents(sendArr,isLeft ? "click" :"rightclick",touchID);
				}
				if (isLeft && isDouble){
					this.sendEvents(sendArr,"doubleclick",touchID);
				}
				this.removeTouchFromArr(touchID,preDowns);
				preO.tar=null;
				Pool.recover("TouchData",preO);
			}
			preO=this.getTouchFromArr(touchID,this.preOvers);
			if (!preO){
				}else {
				if (onMobile){
					sendArr=this.getEles(preO.tar,null,sendArr);
					if (sendArr && sendArr.length > 0){
						this.sendEvents(sendArr,"mouseout",touchID);
					}
					this.removeTouchFromArr(touchID,this.preOvers);
					preO.tar=null;
					Pool.recover("TouchData",preO);
				}
			}
		}

		TouchManager._oldArr=[];
		TouchManager._newArr=[];
		TouchManager._tEleArr=[];
		__static(TouchManager,
		['I',function(){return this.I=new TouchManager();}
		]);
		return TouchManager;
	})()


	/**
	*<code>Filter</code> 是滤镜基类。
	*/
	//class laya.filters.Filter
	var Filter=(function(){
		function Filter(){
			this._action=null;
		}

		__class(Filter,'laya.filters.Filter');
		var __proto=Filter.prototype;
		Laya.imps(__proto,{"laya.filters.IFilter":true})
		/**@private 滤镜类型。*/
		__getset(0,__proto,'type',function(){return-1});
		/**@private 滤镜动作。*/
		__getset(0,__proto,'action',function(){return this._action });
		Filter.BLUR=0x10;
		Filter.COLOR=0x20;
		Filter.GLOW=0x08;
		return Filter;
	})()


	/**
	*@private
	*<code>ColorFilterAction</code> 是一个颜色滤镜应用类。
	*/
	//class laya.filters.ColorFilterAction
	var ColorFilterAction=(function(){
		function ColorFilterAction(){
			this.data=null;
		}

		__class(ColorFilterAction,'laya.filters.ColorFilterAction');
		var __proto=ColorFilterAction.prototype;
		Laya.imps(__proto,{"laya.filters.IFilterAction":true})
		/**
		*给指定的对象应用颜色滤镜。
		*@param srcCanvas 需要应用画布对象。
		*@return 应用了滤镜后的画布对象。
		*/
		__proto.apply=function(srcCanvas){
			var canvas=srcCanvas.canvas;
			var ctx=canvas.context;
			if (canvas.width==0 || canvas.height==0)return canvas;
			var imgdata=ctx.getImageData(0,0,canvas.width,canvas.height);
			var data=imgdata.data;
			var nData;
			for (var i=0,n=data.length;i < n;i+=4){
				nData=this.getColor(data[i],data[i+1],data[i+2],data[i+3]);
				if (data[i+3]==0)continue ;
				data[i]=nData[0];
				data[i+1]=nData[1];
				data[i+2]=nData[2];
				data[i+3]=nData[3];
			}
			ctx.putImageData(imgdata,0,0);
			return srcCanvas;
		}

		__proto.getColor=function(red,green,blue,alpha){
			var rst=[];
			if (this.data._mat && this.data._alpha){
				var mat=this.data._mat;
				var tempAlpha=this.data._alpha;
				rst[0]=mat[0] *red+mat[1] *green+mat[2] *blue+mat[3] *alpha+tempAlpha[0];
				rst[1]=mat[4] *red+mat[5] *green+mat[6] *blue+mat[7] *alpha+tempAlpha[1];
				rst[2]=mat[8] *red+mat[9] *green+mat[10] *blue+mat[11] *alpha+tempAlpha[2];
				rst[3]=mat[12] *red+mat[13] *green+mat[14] *blue+mat[15] *alpha+tempAlpha[3];
			}
			return rst;
		}

		return ColorFilterAction;
	})()


	/**
	*@private
	*计算贝塞尔曲线的工具类。
	*/
	//class laya.maths.Bezier
	var Bezier=(function(){
		function Bezier(){
			this._controlPoints=[new Point(),new Point(),new Point()];
			this._calFun=this.getPoint2;
		}

		__class(Bezier,'laya.maths.Bezier');
		var __proto=Bezier.prototype;
		/**@private */
		__proto._switchPoint=function(x,y){
			var tPoint=this._controlPoints.shift();
			tPoint.setTo(x,y);
			this._controlPoints.push(tPoint);
		}

		/**
		*计算二次贝塞尔点。
		*/
		__proto.getPoint2=function(t,rst){
			var p1=this._controlPoints[0];
			var p2=this._controlPoints[1];
			var p3=this._controlPoints[2];
			var lineX=Math.pow((1-t),2)*p1.x+2 *t *(1-t)*p2.x+Math.pow(t,2)*p3.x;
			var lineY=Math.pow((1-t),2)*p1.y+2 *t *(1-t)*p2.y+Math.pow(t,2)*p3.y;
			rst.push(lineX,lineY);
		}

		/**
		*计算三次贝塞尔点
		*/
		__proto.getPoint3=function(t,rst){
			var p1=this._controlPoints[0];
			var p2=this._controlPoints[1];
			var p3=this._controlPoints[2];
			var p4=this._controlPoints[3];
			var lineX=Math.pow((1-t),3)*p1.x+3 *p2.x *t *(1-t)*(1-t)+3 *p3.x *t *t *(1-t)+p4.x *Math.pow(t,3);
			var lineY=Math.pow((1-t),3)*p1.y+3 *p2.y *t *(1-t)*(1-t)+3 *p3.y *t *t *(1-t)+p4.y *Math.pow(t,3);
			rst.push(lineX,lineY);
		}

		/**
		*计算贝塞尔点序列
		*/
		__proto.insertPoints=function(count,rst){
			var i=NaN;
			count=count > 0 ? count :5;
			var dLen=NaN;
			dLen=1 / count;
			for (i=0;i <=1;i+=dLen){
				this._calFun(i,rst);
			}
		}

		/**
		*获取贝塞尔曲线上的点。
		*@param pList 控制点[x0,y0,x1,y1...]
		*@param inSertCount 每次曲线的插值数量
		*/
		__proto.getBezierPoints=function(pList,inSertCount,count){
			(inSertCount===void 0)&& (inSertCount=5);
			(count===void 0)&& (count=2);
			var i=0,len=0;
			len=pList.length;
			if (len < (count+1)*2)return [];
			var rst=[];
			switch (count){
				case 2:
					this._calFun=this.getPoint2;
					break ;
				case 3:
					this._calFun=this.getPoint3;
					break ;
				default :
					return [];
				}
			while (this._controlPoints.length <=count){
				this._controlPoints.push(Point.create());
			}
			for (i=0;i < count *2;i+=2){
				this._switchPoint(pList[i],pList[i+1]);
			}
			for (i=count *2;i < len;i+=2){
				this._switchPoint(pList[i],pList[i+1]);
				if ((i / 2)% count==0)this.insertPoints(inSertCount,rst);
			}
			return rst;
		}

		__static(Bezier,
		['I',function(){return this.I=new Bezier();}
		]);
		return Bezier;
	})()


	/**
	*@private
	*凸包算法。
	*/
	//class laya.maths.GrahamScan
	var GrahamScan=(function(){
		function GrahamScan(){};
		__class(GrahamScan,'laya.maths.GrahamScan');
		GrahamScan.multiply=function(p1,p2,p0){
			return ((p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y));
		}

		GrahamScan.dis=function(p1,p2){
			return (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y);
		}

		GrahamScan._getPoints=function(count,tempUse,rst){
			(tempUse===void 0)&& (tempUse=false);
			if (!GrahamScan._mPointList)GrahamScan._mPointList=[];
			while (GrahamScan._mPointList.length < count)GrahamScan._mPointList.push(new Point());
			if (!rst)rst=[];
			rst.length=0;
			if (tempUse){
				GrahamScan.getFrom(rst,GrahamScan._mPointList,count);
				}else {
				GrahamScan.getFromR(rst,GrahamScan._mPointList,count);
			}
			return rst;
		}

		GrahamScan.getFrom=function(rst,src,count){
			var i=0;
			for (i=0;i < count;i++){
				rst.push(src[i]);
			}
			return rst;
		}

		GrahamScan.getFromR=function(rst,src,count){
			var i=0;
			for (i=0;i < count;i++){
				rst.push(src.pop());
			}
			return rst;
		}

		GrahamScan.pListToPointList=function(pList,tempUse){
			(tempUse===void 0)&& (tempUse=false);
			var i=0,len=pList.length / 2,rst=GrahamScan._getPoints(len,tempUse,GrahamScan._tempPointList);
			for (i=0;i < len;i++){
				rst[i].setTo(pList[i+i],pList[i+i+1]);
			}
			return rst;
		}

		GrahamScan.pointListToPlist=function(pointList){
			var i=0,len=pointList.length,rst=GrahamScan._temPList,tPoint;
			rst.length=0;
			for (i=0;i < len;i++){
				tPoint=pointList[i];
				rst.push(tPoint.x,tPoint.y);
			}
			return rst;
		}

		GrahamScan.scanPList=function(pList){
			return Utils.copyArray(pList,GrahamScan.pointListToPlist(GrahamScan.scan(GrahamScan.pListToPointList(pList,true))));
		}

		GrahamScan.scan=function(PointSet){
			var i=0,j=0,k=0,top=2,tmp,n=PointSet.length,ch;
			var _tmpDic={};
			var key;
			ch=GrahamScan._temArr;
			ch.length=0;
			n=PointSet.length;
			for (i=n-1;i >=0;i--){
				tmp=PointSet[i];
				key=tmp.x+"_"+tmp.y;
				if (!_tmpDic.hasOwnProperty(key)){
					_tmpDic[key]=true;
					ch.push(tmp);
				}
			}
			n=ch.length;
			Utils.copyArray(PointSet,ch);
			for (i=1;i < n;i++)
			if ((PointSet[i].y < PointSet[k].y)|| ((PointSet[i].y==PointSet[k].y)&& (PointSet[i].x < PointSet[k].x)))
				k=i;
			tmp=PointSet[0];
			PointSet[0]=PointSet[k];
			PointSet[k]=tmp;
			for (i=1;i < n-1;i++){
				k=i;
				for (j=i+1;j < n;j++)
				if ((GrahamScan.multiply(PointSet[j],PointSet[k],PointSet[0])> 0)|| ((GrahamScan.multiply(PointSet[j],PointSet[k],PointSet[0])==0)&& (GrahamScan.dis(PointSet[0],PointSet[j])< GrahamScan.dis(PointSet[0],PointSet[k]))))
					k=j;
				tmp=PointSet[i];
				PointSet[i]=PointSet[k];
				PointSet[k]=tmp;
			}
			ch=GrahamScan._temArr;
			ch.length=0;
			if (PointSet.length < 3){
				return Utils.copyArray(ch,PointSet);
			}
			ch.push(PointSet[0],PointSet[1],PointSet[2]);
			for (i=3;i < n;i++){
				while (ch.length >=2 && GrahamScan.multiply(PointSet[i],ch[ch.length-1],ch[ch.length-2])>=0)ch.pop();
				PointSet[i] && ch.push(PointSet[i]);
			}
			return ch;
		}

		GrahamScan._mPointList=null
		GrahamScan._tempPointList=[];
		GrahamScan._temPList=[];
		GrahamScan._temArr=[];
		return GrahamScan;
	})()


	/**
	*@private
	*<code>MathUtil</code> 是一个数据处理工具类。
	*/
	//class laya.maths.MathUtil
	var MathUtil=(function(){
		function MathUtil(){};
		__class(MathUtil,'laya.maths.MathUtil');
		MathUtil.subtractVector3=function(l,r,o){
			o[0]=l[0]-r[0];
			o[1]=l[1]-r[1];
			o[2]=l[2]-r[2];
		}

		MathUtil.lerp=function(left,right,amount){
			return left *(1-amount)+right *amount;
		}

		MathUtil.scaleVector3=function(f,b,e){
			e[0]=f[0] *b;
			e[1]=f[1] *b;
			e[2]=f[2] *b;
		}

		MathUtil.lerpVector3=function(l,r,t,o){
			var ax=l[0],ay=l[1],az=l[2];
			o[0]=ax+t *(r[0]-ax);
			o[1]=ay+t *(r[1]-ay);
			o[2]=az+t *(r[2]-az);
		}

		MathUtil.lerpVector4=function(l,r,t,o){
			var ax=l[0],ay=l[1],az=l[2],aw=l[3];
			o[0]=ax+t *(r[0]-ax);
			o[1]=ay+t *(r[1]-ay);
			o[2]=az+t *(r[2]-az);
			o[3]=aw+t *(r[3]-aw);
		}

		MathUtil.slerpQuaternionArray=function(a,Offset1,b,Offset2,t,out,Offset3){
			var ax=a[Offset1+0],ay=a[Offset1+1],az=a[Offset1+2],aw=a[Offset1+3],bx=b[Offset2+0],by=b[Offset2+1],bz=b[Offset2+2],bw=b[Offset2+3];
			var omega,cosom,sinom,scale0,scale1;
			cosom=ax *bx+ay *by+az *bz+aw *bw;
			if (cosom < 0.0){
				cosom=-cosom;
				bx=-bx;
				by=-by;
				bz=-bz;
				bw=-bw;
			}
			if ((1.0-cosom)> 0.000001){
				omega=Math.acos(cosom);
				sinom=Math.sin(omega);
				scale0=Math.sin((1.0-t)*omega)/ sinom;
				scale1=Math.sin(t *omega)/ sinom;
				}else {
				scale0=1.0-t;
				scale1=t;
			}
			out[Offset3+0]=scale0 *ax+scale1 *bx;
			out[Offset3+1]=scale0 *ay+scale1 *by;
			out[Offset3+2]=scale0 *az+scale1 *bz;
			out[Offset3+3]=scale0 *aw+scale1 *bw;
			return out;
		}

		MathUtil.getRotation=function(x0,y0,x1,y1){
			return Math.atan2(y1-y0,x1-x0)/ Math.PI *180;
		}

		MathUtil.sortBigFirst=function(a,b){
			if (a==b)return 0;
			return b > a ? 1 :-1;
		}

		MathUtil.sortSmallFirst=function(a,b){
			if (a==b)return 0;
			return b > a ?-1 :1;
		}

		MathUtil.sortNumBigFirst=function(a,b){
			return parseFloat(b)-parseFloat(a);
		}

		MathUtil.sortNumSmallFirst=function(a,b){
			return parseFloat(a)-parseFloat(b);
		}

		MathUtil.sortByKey=function(key,bigFirst,forceNum){
			(bigFirst===void 0)&& (bigFirst=false);
			(forceNum===void 0)&& (forceNum=true);
			var _sortFun;
			if (bigFirst){
				_sortFun=forceNum ? MathUtil.sortNumBigFirst :MathUtil.sortBigFirst;
				}else {
				_sortFun=forceNum ? MathUtil.sortNumSmallFirst :MathUtil.sortSmallFirst;
			}
			return function (a,b){
				return _sortFun(a[key],b[key]);
			}
		}

		return MathUtil;
	})()


	/**
	*<p> <code>Matrix</code> 类表示一个转换矩阵，它确定如何将点从一个坐标空间映射到另一个坐标空间。</p>
	*<p>您可以对一个显示对象执行不同的图形转换，方法是设置 Matrix 对象的属性，将该 Matrix 对象应用于 Transform 对象的 matrix 属性，然后应用该 Transform 对象作为显示对象的 transform 属性。这些转换函数包括平移（x 和 y 重新定位）、旋转、缩放和倾斜。</p>
	*/
	//class laya.maths.Matrix
	var Matrix=(function(){
		function Matrix(a,b,c,d,tx,ty,nums){
			//this.a=NaN;
			//this.b=NaN;
			//this.c=NaN;
			//this.d=NaN;
			//this.tx=NaN;
			//this.ty=NaN;
			this._bTransform=false;
			(a===void 0)&& (a=1);
			(b===void 0)&& (b=0);
			(c===void 0)&& (c=0);
			(d===void 0)&& (d=1);
			(tx===void 0)&& (tx=0);
			(ty===void 0)&& (ty=0);
			(nums===void 0)&& (nums=0);
			if (Matrix._createFun!=null){
				return Matrix._createFun(a,b,c,d,tx,ty,nums);
			}
			this.a=a;
			this.b=b;
			this.c=c;
			this.d=d;
			this.tx=tx;
			this.ty=ty;
			this._checkTransform();
		}

		__class(Matrix,'laya.maths.Matrix');
		var __proto=Matrix.prototype;
		/**
		*将本矩阵设置为单位矩阵。
		*@return 返回当前矩形。
		*/
		__proto.identity=function(){
			this.a=this.d=1;
			this.b=this.tx=this.ty=this.c=0;
			this._bTransform=false;
			return this;
		}

		/**@private */
		__proto._checkTransform=function(){
			return this._bTransform=(this.a!==1 || this.b!==0 || this.c!==0 || this.d!==1);
		}

		/**
		*设置沿 x 、y 轴平移每个点的距离。
		*@param x 沿 x 轴平移每个点的距离。
		*@param y 沿 y 轴平移每个点的距离。
		*@return 返回对象本身
		*/
		__proto.setTranslate=function(x,y){
			this.tx=x;
			this.ty=y;
			return this;
		}

		/**
		*沿 x 和 y 轴平移矩阵，平移的变化量由 x 和 y 参数指定。
		*@param x 沿 x 轴向右移动的量（以像素为单位）。
		*@param y 沿 y 轴向下移动的量（以像素为单位）。
		*@return 返回此矩形对象。
		*/
		__proto.translate=function(x,y){
			this.tx+=x;
			this.ty+=y;
			return this;
		}

		/**
		*对矩阵应用缩放转换。
		*@param x 用于沿 x 轴缩放对象的乘数。
		*@param y 用于沿 y 轴缩放对象的乘数。
		*@return 返回矩阵对象本身
		*/
		__proto.scale=function(x,y){
			this.a *=x;
			this.d *=y;
			this.c *=x;
			this.b *=y;
			this.tx *=x;
			this.ty *=y;
			this._bTransform=true;
			return this;
		}

		/**
		*对 Matrix 对象应用旋转转换。
		*@param angle 以弧度为单位的旋转角度。
		*@return 返回矩阵对象本身
		*/
		__proto.rotate=function(angle){
			var cos=Math.cos(angle);
			var sin=Math.sin(angle);
			var a1=this.a;
			var c1=this.c;
			var tx1=this.tx;
			this.a=a1 *cos-this.b *sin;
			this.b=a1 *sin+this.b *cos;
			this.c=c1 *cos-this.d *sin;
			this.d=c1 *sin+this.d *cos;
			this.tx=tx1 *cos-this.ty *sin;
			this.ty=tx1 *sin+this.ty *cos;
			this._bTransform=true;
			return this;
		}

		/**
		*对 Matrix 对象应用倾斜转换。
		*@param x 沿着 X 轴的 2D 倾斜弧度。
		*@param y 沿着 Y 轴的 2D 倾斜弧度。
		*@return 当前 Matrix 对象。
		*/
		__proto.skew=function(x,y){
			var tanX=Math.tan(x);
			var tanY=Math.tan(y);
			var a1=this.a;
			var b1=this.b;
			this.a+=tanY *this.c;
			this.b+=tanY *this.d;
			this.c+=tanX *a1;
			this.d+=tanX *b1;
			return this;
		}

		/**
		*对指定的点应用当前矩阵的逆转化并返回此点。
		*@param out 待转化的点 Point 对象。
		*@return 返回out
		*/
		__proto.invertTransformPoint=function(out){
			var a1=this.a;
			var b1=this.b;
			var c1=this.c;
			var d1=this.d;
			var tx1=this.tx;
			var n=a1 *d1-b1 *c1;
			var a2=d1 / n;
			var b2=-b1 / n;
			var c2=-c1 / n;
			var d2=a1 / n;
			var tx2=(c1 *this.ty-d1 *tx1)/ n;
			var ty2=-(a1 *this.ty-b1 *tx1)/ n;
			return out.setTo(a2 *out.x+c2 *out.y+tx2,b2 *out.x+d2 *out.y+ty2);
		}

		/**
		*将 Matrix 对象表示的几何转换应用于指定点。
		*@param out 用来设定输出结果的点。
		*@return 返回out
		*/
		__proto.transformPoint=function(out){
			return out.setTo(this.a *out.x+this.c *out.y+this.tx,this.b *out.x+this.d *out.y+this.ty);
		}

		/**
		*将 Matrix 对象表示的几何转换应用于指定点，忽略tx、ty。
		*@param out 用来设定输出结果的点。
		*@return 返回out
		*/
		__proto.transformPointN=function(out){
			return out.setTo(this.a *out.x+this.c *out.y ,this.b *out.x+this.d *out.y);
		}

		/**
		*@private
		*将 Matrix 对象表示的几何转换应用于指定点。
		*@param data 点集合。
		*@param out 存储应用转化的点的列表。
		*@return 返回out数组
		*/
		__proto.transformPointArray=function(data,out){
			var len=data.length;
			for (var i=0;i < len;i+=2){
				var x=data[i],y=data[i+1];
				out[i]=this.a *x+this.c *y+this.tx;
				out[i+1]=this.b *x+this.d *y+this.ty;
			}
			return out;
		}

		/**
		*获取 X 轴缩放值。
		*@return X 轴缩放值。
		*/
		__proto.getScaleX=function(){
			return this.b===0 ? this.a :Math.sqrt(this.a *this.a+this.b *this.b);
		}

		/**
		*获取 Y 轴缩放值。
		*@return Y 轴缩放值。
		*/
		__proto.getScaleY=function(){
			return this.c===0 ? this.d :Math.sqrt(this.c *this.c+this.d *this.d);
		}

		/**
		*执行原始矩阵的逆转换。
		*@return 当前矩阵对象。
		*/
		__proto.invert=function(){
			var a1=this.a;
			var b1=this.b;
			var c1=this.c;
			var d1=this.d;
			var tx1=this.tx;
			var n=a1 *d1-b1 *c1;
			this.a=d1 / n;
			this.b=-b1 / n;
			this.c=-c1 / n;
			this.d=a1 / n;
			this.tx=(c1 *this.ty-d1 *tx1)/ n;
			this.ty=-(a1 *this.ty-b1 *tx1)/ n;
			return this;
		}

		/**
		*将 Matrix 的成员设置为指定值。
		*@param a 缩放或旋转图像时影响像素沿 x 轴定位的值。
		*@param b 旋转或倾斜图像时影响像素沿 y 轴定位的值。
		*@param c 旋转或倾斜图像时影响像素沿 x 轴定位的值。
		*@param d 缩放或旋转图像时影响像素沿 y 轴定位的值。
		*@param tx 沿 x 轴平移每个点的距离。
		*@param ty 沿 y 轴平移每个点的距离。
		*@return 当前矩阵对象。
		*/
		__proto.setTo=function(a,b,c,d,tx,ty){
			this.a=a,this.b=b,this.c=c,this.d=d,this.tx=tx,this.ty=ty;
			return this;
		}

		/**
		*将指定矩阵与当前矩阵连接，从而将这两个矩阵的几何效果有效地结合在一起。
		*@param matrix 要连接到源矩阵的矩阵。
		*@return 当前矩阵。
		*/
		__proto.concat=function(matrix){
			var a=this.a;
			var c=this.c;
			var tx=this.tx;
			this.a=a *matrix.a+this.b *matrix.c;
			this.b=a *matrix.b+this.b *matrix.d;
			this.c=c *matrix.a+this.d *matrix.c;
			this.d=c *matrix.b+this.d *matrix.d;
			this.tx=tx *matrix.a+this.ty *matrix.c+matrix.tx;
			this.ty=tx *matrix.b+this.ty *matrix.d+matrix.ty;
			return this;
		}

		/**
		*@private
		*对矩阵应用缩放转换。反向相乘
		*@param x 用于沿 x 轴缩放对象的乘数。
		*@param y 用于沿 y 轴缩放对象的乘数。
		*/
		__proto.scaleEx=function(x,y){
			var ba=this.a,bb=this.b,bc=this.c,bd=this.d;
			if (bb!==0 || bc!==0){
				this.a=x *ba;
				this.b=x *bb;
				this.c=y *bc;
				this.d=y *bd;
				}else {
				this.a=x *ba;
				this.b=0 *bd;
				this.c=0 *ba;
				this.d=y *bd;
			}
			this._bTransform=true;
		}

		/**
		*@private
		*对 Matrix 对象应用旋转转换。反向相乘
		*@param angle 以弧度为单位的旋转角度。
		*/
		__proto.rotateEx=function(angle){
			var cos=Math.cos(angle);
			var sin=Math.sin(angle);
			var ba=this.a,bb=this.b,bc=this.c,bd=this.d;
			if (bb!==0 || bc!==0){
				this.a=cos *ba+sin *bc;
				this.b=cos *bb+sin *bd;
				this.c=-sin *ba+cos *bc;
				this.d=-sin *bb+cos *bd;
				}else {
				this.a=cos *ba;
				this.b=sin *bd;
				this.c=-sin *ba;
				this.d=cos *bd;
			}
			this._bTransform=true;
		}

		/**
		*返回此 Matrix 对象的副本。
		*@return 与原始实例具有完全相同的属性的新 Matrix 实例。
		*/
		__proto.clone=function(){
			var dec=Matrix.create();
			dec.a=this.a;
			dec.b=this.b;
			dec.c=this.c;
			dec.d=this.d;
			dec.tx=this.tx;
			dec.ty=this.ty;
			dec._bTransform=this._bTransform;
			return dec;
		}

		/**
		*将当前 Matrix 对象中的所有矩阵数据复制到指定的 Matrix 对象中。
		*@param dec 要复制当前矩阵数据的 Matrix 对象。
		*@return 已复制当前矩阵数据的 Matrix 对象。
		*/
		__proto.copyTo=function(dec){
			dec.a=this.a;
			dec.b=this.b;
			dec.c=this.c;
			dec.d=this.d;
			dec.tx=this.tx;
			dec.ty=this.ty;
			dec._bTransform=this._bTransform;
			return dec;
		}

		/**
		*返回列出该 Matrix 对象属性的文本值。
		*@return 一个字符串，它包含 Matrix 对象的属性值：a、b、c、d、tx 和 ty。
		*/
		__proto.toString=function(){
			return this.a+","+this.b+","+this.c+","+this.d+","+this.tx+","+this.ty;
		}

		/**
		*销毁此对象。
		*/
		__proto.destroy=function(){
			this.recover();
		}

		/**
		*回收到对象池，方便复用
		*/
		__proto.recover=function(){
			Pool.recover("Matrix",this.identity());
		}

		Matrix.mul=function(m1,m2,out){
			var aa=m1.a,ab=m1.b,ac=m1.c,ad=m1.d,atx=m1.tx,aty=m1.ty;
			var ba=m2.a,bb=m2.b,bc=m2.c,bd=m2.d,btx=m2.tx,bty=m2.ty;
			if (bb!==0 || bc!==0){
				out.a=aa *ba+ab *bc;
				out.b=aa *bb+ab *bd;
				out.c=ac *ba+ad *bc;
				out.d=ac *bb+ad *bd;
				out.tx=ba *atx+bc *aty+btx;
				out.ty=bb *atx+bd *aty+bty;
				}else {
				out.a=aa *ba;
				out.b=ab *bd;
				out.c=ac *ba;
				out.d=ad *bd;
				out.tx=ba *atx+btx;
				out.ty=bd *aty+bty;
			}
			return out;
		}

		Matrix.mul16=function(m1,m2,out){
			var aa=m1.a,ab=m1.b,ac=m1.c,ad=m1.d,atx=m1.tx,aty=m1.ty;
			var ba=m2.a,bb=m2.b,bc=m2.c,bd=m2.d,btx=m2.tx,bty=m2.ty;
			if (bb!==0 || bc!==0){
				out[0]=aa *ba+ab *bc;
				out[1]=aa *bb+ab *bd;
				out[4]=ac *ba+ad *bc;
				out[5]=ac *bb+ad *bd;
				out[12]=ba *atx+bc *aty+btx;
				out[13]=bb *atx+bd *aty+bty;
				}else {
				out[0]=aa *ba;
				out[1]=ab *bd;
				out[4]=ac *ba;
				out[5]=ad *bd;
				out[12]=ba *atx+btx;
				out[13]=bd *aty+bty;
			}
			return out;
		}

		Matrix.mulPre=function(m1,ba,bb,bc,bd,btx,bty,out){
			var aa=m1.a,ab=m1.b,ac=m1.c,ad=m1.d,atx=m1.tx,aty=m1.ty;
			if (bb!==0 || bc!==0){
				out.a=aa *ba+ab *bc;
				out.b=aa *bb+ab *bd;
				out.c=ac *ba+ad *bc;
				out.d=ac *bb+ad *bd;
				out.tx=ba *atx+bc *aty+btx;
				out.ty=bb *atx+bd *aty+bty;
				}else {
				out.a=aa *ba;
				out.b=ab *bd;
				out.c=ac *ba;
				out.d=ad *bd;
				out.tx=ba *atx+btx;
				out.ty=bd *aty+bty;
			}
			return out;
		}

		Matrix.mulPos=function(m1,aa,ab,ac,ad,atx,aty,out){
			var ba=m1.a,bb=m1.b,bc=m1.c,bd=m1.d,btx=m1.tx,bty=m1.ty;
			if (bb!==0 || bc!==0){
				out.a=aa *ba+ab *bc;
				out.b=aa *bb+ab *bd;
				out.c=ac *ba+ad *bc;
				out.d=ac *bb+ad *bd;
				out.tx=ba *atx+bc *aty+btx;
				out.ty=bb *atx+bd *aty+bty;
				}else {
				out.a=aa *ba;
				out.b=ab *bd;
				out.c=ac *ba;
				out.d=ad *bd;
				out.tx=ba *atx+btx;
				out.ty=bd *aty+bty;
			}
			return out;
		}

		Matrix.preMul=function(parent,self,out){
			var pa=parent.a,pb=parent.b,pc=parent.c,pd=parent.d;
			var na=self.a,nb=self.b,nc=self.c,nd=self.d,ntx=self.tx,nty=self.ty;
			out.a=na *pa;
			out.b=out.c=0;
			out.d=nd *pd;
			out.tx=ntx *pa+parent.tx;
			out.ty=nty *pd+parent.ty;
			if (nb!==0 || nc!==0 || pb!==0 || pc!==0){
				out.a+=nb *pc;
				out.d+=nc *pb;
				out.b+=na *pb+nb *pd;
				out.c+=nc *pa+nd *pc;
				out.tx+=nty *pc;
				out.ty+=ntx *pb;
			}
			return out;
		}

		Matrix.preMulXY=function(parent,x,y,out){
			var pa=parent.a,pb=parent.b,pc=parent.c,pd=parent.d;
			out.a=pa;
			out.b=pb;
			out.c=pc;
			out.d=pd;
			out.tx=x *pa+parent.tx+y *pc;
			out.ty=y *pd+parent.ty+x *pb;
			return out;
		}

		Matrix.create=function(){
			return Pool.getItemByClass("Matrix",Matrix);
		}

		Matrix.EMPTY=new Matrix();
		Matrix.TEMP=new Matrix();
		Matrix._createFun=null;
		return Matrix;
	})()


	/**
	*<code>Point</code> 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。
	*/
	//class laya.maths.Point
	var Point=(function(){
		function Point(x,y){
			//this.x=NaN;
			//this.y=NaN;
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			this.x=x;
			this.y=y;
		}

		__class(Point,'laya.maths.Point');
		var __proto=Point.prototype;
		/**
		*将 <code>Point</code> 的成员设置为指定值。
		*@param x 水平坐标。
		*@param y 垂直坐标。
		*@return 当前 Point 对象。
		*/
		__proto.setTo=function(x,y){
			this.x=x;
			this.y=y;
			return this;
		}

		/**
		*重置
		*/
		__proto.reset=function(){
			this.x=this.y=0;
			return this;
		}

		/**
		*回收到对象池，方便复用
		*/
		__proto.recover=function(){
			Pool.recover("Point",this.reset());
		}

		/**
		*计算当前点和目标点(x，y)的距离。
		*@param x 水平坐标。
		*@param y 垂直坐标。
		*@return 返回当前点和目标点之间的距离。
		*/
		__proto.distance=function(x,y){
			return Math.sqrt((this.x-x)*(this.x-x)+(this.y-y)*(this.y-y));
		}

		/**返回包含 x 和 y 坐标的值的字符串。*/
		__proto.toString=function(){
			return this.x+","+this.y;
		}

		/**
		*标准化向量。
		*/
		__proto.normalize=function(){
			var d=Math.sqrt(this.x *this.x+this.y *this.y);
			if (d > 0){
				var id=1.0 / d;
				this.x *=id;
				this.y *=id;
			}
		}

		Point.create=function(){
			return Pool.getItemByClass("Point",Point);
		}

		Point.TEMP=new Point();
		Point.EMPTY=new Point();
		return Point;
	})()


	/**
	*<p><code>Rectangle</code> 对象是按其位置（由它左上角的点 (x,y)确定）以及宽度和高度定义的区域。</p>
	*<p>Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其他属性。</p>
	*/
	//class laya.maths.Rectangle
	var Rectangle=(function(){
		function Rectangle(x,y,width,height){
			//this.x=NaN;
			//this.y=NaN;
			//this.width=NaN;
			//this.height=NaN;
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(width===void 0)&& (width=0);
			(height===void 0)&& (height=0);
			this.x=x;
			this.y=y;
			this.width=width;
			this.height=height;
		}

		__class(Rectangle,'laya.maths.Rectangle');
		var __proto=Rectangle.prototype;
		/**
		*将 Rectangle 的属性设置为指定值。
		*@param x x 矩形左上角的 X 轴坐标。
		*@param y x 矩形左上角的 Y 轴坐标。
		*@param width 矩形的宽度。
		*@param height 矩形的高。
		*@return 返回属性值修改后的矩形对象本身。
		*/
		__proto.setTo=function(x,y,width,height){
			this.x=x;
			this.y=y;
			this.width=width;
			this.height=height;
			return this;
		}

		/**
		*重置
		*/
		__proto.reset=function(){
			this.x=this.y=this.width=this.height=0;
			return this;
		}

		/**
		*回收
		*/
		__proto.recover=function(){
			Pool.recover("Rectangle",this.reset());
		}

		/**
		*复制 source 对象的属性值到此矩形对象中。
		*@param sourceRect 源 Rectangle 对象。
		*@return 返回属性值修改后的矩形对象本身。
		*/
		__proto.copyFrom=function(source){
			this.x=source.x;
			this.y=source.y;
			this.width=source.width;
			this.height=source.height;
			return this;
		}

		/**
		*确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。
		*@param x 点的 X 轴坐标值（水平位置）。
		*@param y 点的 Y 轴坐标值（垂直位置）。
		*@return 如果 Rectangle 对象包含指定的点，则值为 true；否则为 false。
		*/
		__proto.contains=function(x,y){
			if (this.width <=0 || this.height <=0)return false;
			if (x >=this.x && x < this.right){
				if (y >=this.y && y < this.bottom){
					return true;
				}
			}
			return false;
		}

		/**
		*确定在 rect 参数中指定的对象是否与此 Rectangle 对象相交。此方法检查指定的 Rectangle 对象的 x、y、width 和 height 属性，以查看它是否与此 Rectangle 对象相交。
		*@param rect Rectangle 对象。
		*@return 如果传入的矩形对象与此对象相交，则返回 true 值，否则返回 false。
		*/
		__proto.intersects=function(rect){
			return !(rect.x > (this.x+this.width)|| (rect.x+rect.width)< this.x || rect.y > (this.y+this.height)|| (rect.y+rect.height)< this.y);
		}

		/**
		*如果在 rect 参数中指定的 Rectangle 对象与此 Rectangle 对象相交，则返回交集区域作为 Rectangle 对象。如果矩形不相交，则此方法返回null。
		*@param rect 待比较的矩形区域。
		*@param out （可选）待输出的矩形区域。如果为空则创建一个新的。建议：尽量复用对象，减少对象创建消耗。
		*@return 返回相交的矩形区域对象。
		*/
		__proto.intersection=function(rect,out){
			if (!this.intersects(rect))return null;
			out || (out=new Rectangle());
			out.x=Math.max(this.x,rect.x);
			out.y=Math.max(this.y,rect.y);
			out.width=Math.min(this.right,rect.right)-out.x;
			out.height=Math.min(this.bottom,rect.bottom)-out.y;
			return out;
		}

		/**
		*<p>矩形联合，通过填充两个矩形之间的水平和垂直空间，将这两个矩形组合在一起以创建一个新的 Rectangle 对象。</p>
		*<p>注意：union()方法忽略高度或宽度值为 0 的矩形，如：var rect2:Rectangle=new Rectangle(300,300,50,0);</p>
		*@param 要添加到此 Rectangle 对象的 Rectangle 对象。
		*@param out 用于存储输出结果的矩形对象。如果为空，则创建一个新的。建议：尽量复用对象，减少对象创建消耗。Rectangle.TEMP对象用于对象复用。
		*@return 充当两个矩形的联合的新 Rectangle 对象。
		*/
		__proto.union=function(source,out){
			out || (out=new Rectangle());
			this.clone(out);
			if (source.width <=0 || source.height <=0)return out;
			out.addPoint(source.x,source.y);
			out.addPoint(source.right,source.bottom);
			return this;
		}

		/**
		*返回一个 Rectangle 对象，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
		*@param out （可选）用于存储结果的矩形对象。如果为空，则创建一个新的。建议：尽量复用对象，减少对象创建消耗。。Rectangle.TEMP对象用于对象复用。
		*@return Rectangle 对象，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
		*/
		__proto.clone=function(out){
			out || (out=new Rectangle());
			out.x=this.x;
			out.y=this.y;
			out.width=this.width;
			out.height=this.height;
			return out;
		}

		/**
		*当前 Rectangle 对象的水平位置 x 和垂直位置 y 以及高度 width 和宽度 height 以逗号连接成的字符串。
		*/
		__proto.toString=function(){
			return this.x+","+this.y+","+this.width+","+this.height;
		}

		/**
		*检测传入的 Rectangle 对象的属性是否与当前 Rectangle 对象的属性 x、y、width、height 属性值都相等。
		*@param rect 待比较的 Rectangle 对象。
		*@return 如果判断的属性都相等，则返回 true ,否则返回 false。
		*/
		__proto.equals=function(rect){
			if (!rect || rect.x!==this.x || rect.y!==this.y || rect.width!==this.width || rect.height!==this.height)return false;
			return true;
		}

		/**
		*<p>为当前矩形对象加一个点，以使当前矩形扩展为包含当前矩形和此点的最小矩形。</p>
		*<p>此方法会修改本对象。</p>
		*@param x 点的 X 坐标。
		*@param y 点的 Y 坐标。
		*@return 返回此 Rectangle 对象。
		*/
		__proto.addPoint=function(x,y){
			this.x > x && (this.width+=this.x-x,this.x=x);
			this.y > y && (this.height+=this.y-y,this.y=y);
			if (this.width < x-this.x)this.width=x-this.x;
			if (this.height < y-this.y)this.height=y-this.y;
			return this;
		}

		/**
		*@private
		*返回代表当前矩形的顶点数据。
		*@return 顶点数据。
		*/
		__proto._getBoundPoints=function(){
			var rst=Rectangle._temB;
			rst.length=0;
			if (this.width==0 || this.height==0)return rst;
			rst.push(this.x,this.y,this.x+this.width,this.y,this.x,this.y+this.height,this.x+this.width,this.y+this.height);
			return rst;
		}

		/**
		*确定此 Rectangle 对象是否为空。
		*@return 如果 Rectangle 对象的宽度或高度小于等于 0，则返回 true 值，否则返回 false。
		*/
		__proto.isEmpty=function(){
			if (this.width <=0 || this.height <=0)return true;
			return false;
		}

		/**此矩形右侧的 X 轴坐标。 x 和 width 属性的和。*/
		__getset(0,__proto,'right',function(){
			return this.x+this.width;
		});

		/**此矩形底端的 Y 轴坐标。y 和 height 属性的和。*/
		__getset(0,__proto,'bottom',function(){
			return this.y+this.height;
		});

		Rectangle.create=function(){
			return Pool.getItemByClass("Rectangle",Rectangle);
		}

		Rectangle._getBoundPointS=function(x,y,width,height){
			var rst=Rectangle._temA;
			rst.length=0;
			if (width==0 || height==0)return rst;
			rst.push(x,y,x+width,y,x,y+height,x+width,y+height);
			return rst;
		}

		Rectangle._getWrapRec=function(pointList,rst){
			if (!pointList || pointList.length < 1)return rst ? rst.setTo(0,0,0,0):Rectangle.TEMP.setTo(0,0,0,0);
			rst=rst ? rst :laya.maths.Rectangle.create();
			var i,len=pointList.length,minX,maxX,minY,maxY,tPoint=Point.TEMP;
			minX=minY=99999;
			maxX=maxY=-minX;
			for (i=0;i < len;i+=2){
				tPoint.x=pointList[i];
				tPoint.y=pointList[i+1];
				minX=minX < tPoint.x ? minX :tPoint.x;
				minY=minY < tPoint.y ? minY :tPoint.y;
				maxX=maxX > tPoint.x ? maxX :tPoint.x;
				maxY=maxY > tPoint.y ? maxY :tPoint.y;
			}
			return rst.setTo(minX,minY,maxX-minX,maxY-minY);
		}

		Rectangle.EMPTY=new Rectangle();
		Rectangle.TEMP=new Rectangle();
		Rectangle._temB=[];
		Rectangle._temA=[];
		return Rectangle;
	})()


	/**
	*<code>SoundManager</code> 是一个声音管理类。提供了对背景音乐、音效的播放控制方法。
	*引擎默认有两套声音方案：WebAudio和H5Audio
	*播放音效，优先使用WebAudio播放声音，如果WebAudio不可用，则用H5Audio播放，H5Audio在部分机器上有兼容问题（比如不能混音，播放有延迟等）。
	*播放背景音乐，则使用H5Audio播放（使用WebAudio会增加特别大的内存，并且要等加载完毕后才能播放，有延迟）
	*建议背景音乐用mp3类型，音效用wav或者mp3类型（如果打包为app，音效只能用wav格式）。
	*详细教程及声音格式请参考：http://ldc.layabox.com/doc/?nav=ch-as-1-7-0
	*/
	//class laya.media.SoundManager
	var SoundManager=(function(){
		function SoundManager(){};
		__class(SoundManager,'laya.media.SoundManager');
		/**
		*失去焦点后是否自动停止背景音乐。
		*/
		__getset(1,SoundManager,'autoStopMusic',function(){
			return SoundManager._autoStopMusic;
			},function(v){
			Laya.stage.off("blur",null,SoundManager._stageOnBlur);
			Laya.stage.off("focus",null,SoundManager._stageOnFocus);
			Laya.stage.off("visibilitychange",null,SoundManager._visibilityChange);
			SoundManager._autoStopMusic=v;
			if (v){
				Laya.stage.on("blur",null,SoundManager._stageOnBlur);
				Laya.stage.on("focus",null,SoundManager._stageOnFocus);
				Laya.stage.on("visibilitychange",null,SoundManager._visibilityChange);
			}
		});

		/**
		*背景音乐和所有音效是否静音。
		*/
		__getset(1,SoundManager,'muted',function(){
			return SoundManager._muted;
			},function(value){
			if (value)SoundManager.stopAllSound();
			SoundManager.musicMuted=value;
			SoundManager._muted=value;
		});

		/**
		*背景音乐（不包括音效）是否静音。
		*/
		__getset(1,SoundManager,'musicMuted',function(){
			return SoundManager._musicMuted;
			},function(value){
			if (value){
				if (SoundManager._bgMusic)SoundManager.stopSound(SoundManager._bgMusic);
				SoundManager._musicMuted=value;
				}else {
				SoundManager._musicMuted=value;
				if (SoundManager._bgMusic)SoundManager.playMusic(SoundManager._bgMusic);
			}
		});

		/**
		*所有音效（不包括背景音乐）是否静音。
		*/
		__getset(1,SoundManager,'soundMuted',function(){
			return SoundManager._soundMuted;
			},function(value){
			SoundManager._soundMuted=value;
		});

		SoundManager.__init__=function(){
			var win=Browser.window;
			var supportWebAudio=win["AudioContext"] || win["webkitAudioContext"] || win["mozAudioContext"] ? true :false;
			if (supportWebAudio)WebAudioSound.initWebAudio();
			SoundManager._soundClass=supportWebAudio?WebAudioSound:AudioSound;
			return supportWebAudio;
		}

		SoundManager.addChannel=function(channel){
			if (SoundManager._channels.indexOf(channel)>=0)return;
			SoundManager._channels.push(channel);
		}

		SoundManager.removeChannel=function(channel){
			for (var i=SoundManager._channels.length-1;i >=0;i--){
				if (SoundManager._channels[i]===channel){
					SoundManager._channels.splice(i,1);
					return;
				}
			}
		}

		SoundManager._visibilityChange=function(){
			if (Laya.stage.isVisibility)SoundManager._stageOnFocus();
			else SoundManager._stageOnBlur();
		}

		SoundManager._stageOnBlur=function(){
			SoundManager._isActive=false;
			if (SoundManager._musicChannel){
				if (!SoundManager._musicChannel.isStopped){
					SoundManager._blurPaused=true;
					SoundManager._musicLoops=SoundManager._musicChannel.loops;
					SoundManager._musicCompleteHandler=SoundManager._musicChannel.completeHandler;
					SoundManager._musicPosition=SoundManager._musicChannel.position;
					SoundManager._musicChannel.stop();
					Laya.stage.once("mousedown",null,SoundManager._stageOnFocus);
				}
			}
			SoundManager.stopAllSound();
		}

		SoundManager._stageOnFocus=function(){
			SoundManager._isActive=true;
			Laya.stage.off("mousedown",null,SoundManager._stageOnFocus);
			if (SoundManager._blurPaused){
				if (SoundManager._bgMusic)SoundManager.playMusic(SoundManager._bgMusic,SoundManager._musicLoops,SoundManager._musicCompleteHandler,SoundManager._musicPosition);
				SoundManager._blurPaused=false;
			}
		}

		SoundManager.playSound=function(url,loops,complete,soundClass,startTime){
			(loops===void 0)&& (loops=1);
			(startTime===void 0)&& (startTime=0);
			if (!SoundManager._isActive)return null;
			if (SoundManager._muted)return null;
			url=URL.formatURL(url);
			if (url===SoundManager._bgMusic){
				if (SoundManager._musicMuted)return null;
				}else {
				if (Render.isConchApp){
					var ext=Utils.getFileExtension(url);
					if (ext !="wav" && ext !="ogg"){
						alert("The sound only supports wav or ogg format,for optimal performance reason,please refer to the official website document.");
						return null;
					}
				}
				if (SoundManager._soundMuted)return null;
			};
			var tSound=Laya.loader.getRes(url);
			if (!soundClass)soundClass=SoundManager._soundClass;
			if (!tSound){
				tSound=new soundClass();
				tSound.load(url);
				Loader.cacheRes(url,tSound);
			};
			var channel;
			channel=tSound.play(startTime,loops);
			channel.url=url;
			channel.volume=(url===SoundManager._bgMusic)? SoundManager.musicVolume :SoundManager.soundVolume;
			channel.completeHandler=complete;
			return channel;
		}

		SoundManager.destroySound=function(url){
			var tSound=Laya.loader.getRes(url);
			if (tSound){
				Loader.clearRes(url);
				tSound.dispose();
			}
		}

		SoundManager.playMusic=function(url,loops,complete,startTime){
			(loops===void 0)&& (loops=0);
			(startTime===void 0)&& (startTime=0);
			url=URL.formatURL(url);
			SoundManager._bgMusic=url;
			if (SoundManager._musicChannel)SoundManager._musicChannel.stop();
			return SoundManager._musicChannel=SoundManager.playSound(url,loops,complete,null,startTime);
		}

		SoundManager.stopSound=function(url){
			url=URL.formatURL(url);
			var channel;
			for (var i=SoundManager._channels.length-1;i >=0;i--){
				channel=SoundManager._channels[i];
				if (channel.url===url){
					channel.stop();
				}
			}
		}

		SoundManager.stopAll=function(){
			SoundManager._bgMusic=null;
			var channel;
			for (var i=SoundManager._channels.length-1;i >=0;i--){
				channel=SoundManager._channels[i];
				channel.stop();
			}
		}

		SoundManager.stopAllSound=function(){
			var channel;
			for (var i=SoundManager._channels.length-1;i >=0;i--){
				channel=SoundManager._channels[i];
				if (channel.url!==SoundManager._bgMusic){
					channel.stop();
				}
			}
		}

		SoundManager.stopMusic=function(){
			SoundManager._bgMusic=null;
			if (SoundManager._musicChannel)SoundManager._musicChannel.stop();
		}

		SoundManager.setSoundVolume=function(volume,url){
			if (url){
				url=URL.formatURL(url);
				SoundManager._setVolume(url,volume);
				}else {
				SoundManager.soundVolume=volume;
				var channel;
				for (var i=SoundManager._channels.length-1;i >=0;i--){
					channel=SoundManager._channels[i];
					if (channel.url!==SoundManager._bgMusic){
						channel.volume=volume;
					}
				}
			}
		}

		SoundManager.setMusicVolume=function(volume){
			SoundManager.musicVolume=volume;
			SoundManager._setVolume(SoundManager._bgMusic,volume);
		}

		SoundManager._setVolume=function(url,volume){
			url=URL.formatURL(url);
			var channel;
			for (var i=SoundManager._channels.length-1;i >=0;i--){
				channel=SoundManager._channels[i];
				if (channel.url===url){
					channel.volume=volume;
				}
			}
		}

		SoundManager.musicVolume=1;
		SoundManager.soundVolume=1;
		SoundManager.playbackRate=1;
		SoundManager._muted=false;
		SoundManager._soundMuted=false;
		SoundManager._musicMuted=false;
		SoundManager._bgMusic=null;
		SoundManager._musicChannel=null;
		SoundManager._channels=[];
		SoundManager._autoStopMusic=false;
		SoundManager._blurPaused=false;
		SoundManager._isActive=true;
		SoundManager._musicLoops=0;
		SoundManager._musicPosition=0;
		SoundManager._musicCompleteHandler=null;
		SoundManager._soundClass=null
		return SoundManager;
	})()


	/**
	*<p> <code>LocalStorage</code> 类用于没有时间限制的本地数据存储。</p>
	*/
	//class laya.net.LocalStorage
	var LocalStorage=(function(){
		function LocalStorage(){};
		__class(LocalStorage,'laya.net.LocalStorage');
		LocalStorage.__init__=function(){
			var window=Browser.window;
			if (window.localStorage){
				try {
					LocalStorage.items=window.localStorage;
					LocalStorage.setItem('laya','1');
					LocalStorage.removeItem('laya');
					LocalStorage.support=true;
				}catch (e){}
			}
			if (!LocalStorage.support)console.warn('LocalStorage is not supprot or browser is private mode.');
			return LocalStorage.support;
		}

		LocalStorage.setItem=function(key,value){
			try {
				LocalStorage.support && LocalStorage.items.setItem(key,value);
				}catch (e){
				console.warn("set localStorage failed",e);
			}
		}

		LocalStorage.getItem=function(key){
			return LocalStorage.support ? LocalStorage.items.getItem(key):null;
		}

		LocalStorage.setJSON=function(key,value){
			try {
				LocalStorage.support && LocalStorage.items.setItem(key,JSON.stringify(value));
				}catch (e){
				console.log("set localStorage failed",e);
			}
		}

		LocalStorage.getJSON=function(key){
			return LocalStorage.support ? JSON.parse(LocalStorage.items.getItem(key)):null;
		}

		LocalStorage.removeItem=function(key){
			LocalStorage.support && LocalStorage.items.removeItem(key);
		}

		LocalStorage.clear=function(){
			LocalStorage.support && LocalStorage.items.clear();
		}

		LocalStorage.items=null
		LocalStorage.support=false;
		return LocalStorage;
	})()


	/**
	*<p><code>URL</code> 提供URL格式化，URL版本管理的类。</p>
	*<p>引擎加载资源的时候，会自动调用formatURL函数格式化URL路径</p>
	*<p>通过basePath属性可以设置网络基础路径</p>
	*<p>通过设置customFormat函数，可以自定义URL格式化的方式</p>
	*<p>除了默认的通过增加后缀的格式化外，通过VersionManager类，可以开启IDE提供的，基于目录的管理方式来替代 "?v=" 的管理方式</p>
	*@see laya.net.VersionManager
	*/
	//class laya.net.URL
	var URL=(function(){
		function URL(url){
			this._url=null;
			this._path=null;
			this._url=URL.formatURL(url);
			this._path=URL.getPath(url);
		}

		__class(URL,'laya.net.URL');
		var __proto=URL.prototype;
		/**地址的文件夹路径（不包括文件名）。*/
		__getset(0,__proto,'path',function(){
			return this._path;
		});

		/**格式化后的地址。*/
		__getset(0,__proto,'url',function(){
			return this._url;
		});

		URL.formatURL=function(url){
			if (!url)return "null path";
			if (url.indexOf(":")> 0)return url;
			if (URL.customFormat !=null)url=URL.customFormat(url);
			var char1=url.charAt(0);
			if (char1==="."){
				return URL._formatRelativePath (URL.basePath+url);
				}else if (char1==='~'){
				return URL.rootPath+url.substring(1);
				}else if (char1==="d"){
				if (url.indexOf("data:image")===0)return url;
				}else if (char1==="/"){
				return url;
			}
			return URL.basePath+url;
		}

		URL._formatRelativePath=function(value){
			var parts=value.split("/");
			for (var i=0,len=parts.length;i < len;i++){
				if (parts[i]=='..'){
					parts.splice(i-1,2);
					i-=2;
				}
			}
			return parts.join('/');
		}

		URL.getPath=function(url){
			var ofs=url.lastIndexOf('/');
			return ofs > 0 ? url.substr(0,ofs+1):"";
		}

		URL.getFileName=function(url){
			var ofs=url.lastIndexOf('/');
			return ofs > 0 ? url.substr(ofs+1):url;
		}

		URL.version={};
		URL.basePath="";
		URL.rootPath="";
		URL.customFormat=function(url){
			var newUrl=URL.version[url];
			if (!Render.isConchApp && newUrl)url+="?v="+newUrl;
			return url;
		}

		return URL;
	})()


	/**
	*@private
	*GLCommandEncoder
	*/
	//class laya.renders.layagl.GLCommandEncoder
	var GLCommandEncoder=(function(){
		var ProgramLocationTable;
		function GLCommandEncoder(layagl,reserveSize,adjustSize,isSyncToRenderThread,isUseArray){
			this._idata=null;
			this._fdata=null;
			this._byteArray=null;
			this._buffer=null;
			this._adjustSize=0;
			this._byteLen=0;
			this._isUseArray=false;
			this._layagl=null;
			this._isSyncToRenderThread=false;
			(isUseArray===void 0)&& (isUseArray=true);
			this._isSyncToRenderThread=isSyncToRenderThread;
			this._layagl=layagl;
			this._isUseArray=isUseArray;
			this._byteLen=reserveSize;
			this._adjustSize=adjustSize;
			this._init(isUseArray,isSyncToRenderThread);
		}

		__class(GLCommandEncoder,'laya.renders.layagl.GLCommandEncoder');
		var __proto=GLCommandEncoder.prototype;
		__proto._init=function(isUseArray,isSyncToRenderThread){
			if (isUseArray){
				this._buffer=this._idata=this._fdata=[];
			}
			else{
				this._buffer=new ArrayBuffer(this._byteLen);
				this._idata=new Int32Array(this._buffer);
				this._fdata=new Float32Array(this._buffer);
				this._byteArray=new Uint8Array(this._buffer);
				this._idata[0]=1;
			}
		}

		__proto._initWithNative=function(isUseArray,isSyncToRenderThread){
			this._buffer=new ArrayBuffer(this._byteLen);
			this._idata=new Int32Array(this._buffer);
			this._fdata=new Float32Array(this._buffer);
			this._byteArray=new Uint8Array(this._buffer);
			LayaGL.createArrayBufferRef(this._buffer,1,isSyncToRenderThread);
			this._idata[0]=1;
		}

		__proto.getPtrID=function(){
			return this._buffer["_ptrID"];
		}

		__proto.beginEncoding=function(){
			this._layagl.beginCommandEncoding(this);
		}

		__proto.endEncoding=function(){
			this._layagl.endCommandEncoding(this);
		}

		__proto.clearEncoding=function(){
			if (this._isUseArray){
				this._idata.length=0;
			}
			else{
				this._idata[0]=1;
			}
		}

		__proto.getCount=function(){
			if (this._isUseArray){
				return this._idata.length;
			}
			else{
				return this._idata[0];
			}
		}

		__proto.clearEncodingForNative=function(){
			this._idata[0]=1;
		}

		__proto.getCountForNative=function(){
			return this._idata[0];
		}

		__proto._need=function(sz){
			if (this._isUseArray==false){
				if ((this._byteLen-(this._idata[0] << 2))>=sz)return;
				this._byteLen+=(sz > this._adjustSize)? sz :this._adjustSize;
				var pre=this._idata;
				this._buffer=new ArrayBuffer(this._byteLen);
				this._idata=new Int32Array(this._buffer);
				this._fdata=new Float32Array(this._buffer);
				this._byteArray=new Uint8Array(this._buffer);
				pre && this._idata.set(pre,0);
			}
		}

		__proto._needWithNative=function(sz){
			if ((this._byteLen-(this._idata[0] << 2))>=sz)return;
			this._byteLen+=(sz > this._adjustSize)? sz :this._adjustSize;
			var pre=this._idata;
			var preConchRef=this._buffer["conchRef"];
			var prePtrID=this._buffer["_ptrID"];
			this._buffer=new ArrayBuffer(this._byteLen);
			this._idata=new Int32Array(this._buffer);
			this._fdata=new Float32Array(this._buffer);
			this._byteArray=new Uint8Array(this._buffer);
			this._buffer["conchRef"]=preConchRef;
			this._buffer["_ptrID"]=prePtrID;
			pre && this._idata.set(pre,0);
			window.conch.updateArrayBufferRef(this._buffer["_ptrID"],preConchRef.isSyncToRender(),this._buffer);
		}

		__proto.add_ShaderValue=function(o){
			this._idata.push(o);
		}

		__proto.add_i=function(i){
			this._need(4);
			this._idata[this._idata[0]++]=i;
		}

		__proto.add_f=function(a){
			this._need(4);
			this._fdata[this._idata[0]++]=a;
		}

		__proto.add_ff=function(a,b){
			this._need(8);
			var i=this._idata[0];
			this._fdata[i++]=a;
			this._fdata[i++]=b;
			this._idata[0]=i;
		}

		__proto.add_ii=function(a,b){
			this._need(8);
			var i=this._idata[0];
			this._idata[i++]=a;
			this._idata[i++]=b;
			this._idata[0]=i;
		}

		__proto.add_if=function(a,b){
			this._need(8);
			var i=this._idata[0];
			this._idata[i++]=a;
			this._fdata[i++]=b;
			this._idata[0]=i;
		}

		__proto.add_iii=function(a,b,c){
			this._need(12);
			var idata=this._idata;
			var i=this._idata[0];
			idata[i++]=a;
			idata[i++]=b;
			idata[i++]=c;
			this._idata[0]=i;
		}

		__proto.add_iif=function(a,b,c){
			this._need(12);
			var idata=this._idata;
			var i=this._idata[0];
			idata[i++]=a;
			idata[i++]=b;
			this._fdata[i++]=c;
			this._idata[0]=i;
		}

		__proto.add_ifi=function(a,b,c){
			this._need(12);
			var idata=this._idata;
			var i=this._idata[0];
			idata[i++]=a;
			this._fdata[i++]=b;
			idata[i++]=c;
			this._idata[0]=i;
		}

		__proto.add_iiii=function(a,b,c,d){
			this._need(16);
			var idata=this._idata;
			var i=this._idata[0];
			idata[i++]=a;
			idata[i++]=b;
			idata[i++]=c;
			idata[i++]=d;
			idata[0]=i;
		}

		__proto.add_iiif=function(a,b,c,d){
			this._need(16);
			var idata=this._idata;
			var i=idata[0];
			idata[i++]=a;
			idata[i++]=b;
			idata[i++]=c;
			this._fdata[i++]=d;
			idata[0]=i;
		}

		__proto.add_iiiff=function(a,b,c,d,e){
			this._need(20);
			var idata=this._idata;
			var i=idata[0];
			idata[i++]=a;
			idata[i++]=b;
			idata[i++]=c;
			this._fdata[i++]=d;
			this._fdata[i++]=e;
			idata[0]=i;
		}

		__proto.add_iiifff=function(a,b,c,d,e,f){
			this._need(24);
			var idata=this._idata;
			var i=idata[0];
			idata[i++]=a;
			idata[i++]=b;
			idata[i++]=c;
			this._fdata[i++]=d;
			this._fdata[i++]=e;
			this._fdata[i++]=f;
			idata[0]=i;
		}

		__proto.add_iiiffff=function(a,b,c,d,e,f,g){
			this._need(28);
			var idata=this._idata;
			var i=idata[0];
			idata[i++]=a;
			idata[i++]=b;
			idata[i++]=c;
			this._fdata[i++]=d;
			this._fdata[i++]=e;
			this._fdata[i++]=f;
			this._fdata[i++]=g;
			idata[0]=i;
		}

		__proto.add_iiff=function(a,b,c,d){
			this._need(16);
			var idata=this._idata;
			var fdata=this._fdata;
			var i=idata[0];
			idata[i++]=a;
			idata[i++]=b;
			fdata[i++]=c;
			fdata[i++]=d;
			idata[0]=i;
		}

		__proto.add_iifff=function(a,b,c,d,e){
			this._need(20);
			var idata=this._idata;
			var fdata=this._fdata;
			var i=idata[0];
			idata[i++]=a;
			idata[i++]=b;
			fdata[i++]=c;
			fdata[i++]=d;
			fdata[i++]=e;
			idata[0]=i;
		}

		__proto.add_iiffff=function(a,b,c,d,e,f){
			this._need(24);
			var idata=this._idata;
			var fdata=this._fdata;
			var i=idata[0];
			idata[i++]=a;
			idata[i++]=b;
			fdata[i++]=c;
			fdata[i++]=d;
			fdata[i++]=e;
			fdata[i++]=f;
			idata[0]=i;
		}

		__proto.add_iiiii=function(a,b,c,d,e){
			this._need(20);
			var idata=this._idata;
			var i=idata[0];
			idata[i++]=a;
			idata[i++]=b;
			idata[i++]=c;
			idata[i++]=d;
			idata[i++]=e;
			idata[0]=i;
		}

		__proto.add_iiiiii=function(a,b,c,d,e,f){
			this._need(24);
			var idata=this._idata;
			var i=idata[0];
			idata[i++]=a;
			idata[i++]=b;
			idata[i++]=c;
			idata[i++]=d;
			idata[i++]=e;
			idata[i++]=f;
			idata[0]=i;
		}

		__proto.add_iiiiiii=function(a,b,c,d,e,f,g){
			this._need(28);
			var idata=this._idata;
			var i=idata[0];
			idata[i++]=a;
			idata[i++]=b;
			idata[i++]=c;
			idata[i++]=d;
			idata[i++]=e;
			idata[i++]=f;
			idata[i++]=g;
			idata[0]=i;
		}

		__proto.add_iiiiiiiiiiii=function(a,b,c,d,e,f,g,h,j,k,l,m){
			this._need(48);
			var idata=this._idata;
			var i=idata[0];
			idata[i++]=a;
			idata[i++]=b;
			idata[i++]=c;
			idata[i++]=d;
			idata[i++]=e;
			idata[i++]=f;
			idata[i++]=g;
			idata[i++]=h;
			idata[i++]=j;
			idata[i++]=k;
			idata[i++]=l;
			idata[i++]=m;
			idata[0]=i;
		}

		__proto.add_iff=function(a,b,c){
			this._need(12);
			var i=this._idata[0];
			this._idata[i++]=a;
			this._fdata[i++]=b;
			this._fdata[i++]=c;
			this._idata[0]=i;
		}

		__proto.add_iffi=function(a,b,c,d){
			this._need(16);
			var i=this._idata[0];
			this._idata[i++]=a;
			this._fdata[i++]=b;
			this._fdata[i++]=c;
			this._idata[i++]=d;
			this._idata[0]=i;
		}

		__proto.add_ifffi=function(a,b,c,d,e){
			this._need(20);
			var i=this._idata[0];
			this._idata[i++]=a;
			this._fdata[i++]=b;
			this._fdata[i++]=c;
			this._fdata[i++]=d;
			this._idata[i++]=e;
			this._idata[0]=i;
		}

		__proto.add_iffff=function(a,b,c,d,e){
			this._need(20);
			var i=this._idata[0];
			var fdata=this._fdata;
			this._idata[i++]=a;
			fdata[i++]=b;
			fdata[i++]=c;
			fdata[i++]=d;
			fdata[i++]=e;
			this._idata[0]=i;
		}

		__proto.add_iffffi=function(a,b,c,d,e,f){
			this._need(24);
			var i=this._idata[0];
			var fdata=this._fdata;
			this._idata[i++]=a;
			fdata[i++]=b;
			fdata[i++]=c;
			fdata[i++]=d;
			fdata[i++]=e;
			this._idata[i++]=f;
			this._idata[0]=i;
		}

		__proto.add_ifffffi=function(a,b,c,d,e,f,g){
			this._need(28);
			var i=this._idata[0];
			var fdata=this._fdata;
			this._idata[i++]=a;
			fdata[i++]=b;
			fdata[i++]=c;
			fdata[i++]=d;
			fdata[i++]=e;
			fdata[i++]=f;
			this._idata[i++]=g;
			this._idata[0]=i;
		}

		__proto.add_iffffiif=function(a,b,c,d,e,f,g,h){
			this._need(28);
			var i=this._idata[0];
			var fdata=this._fdata;
			this._idata[i++]=a;
			fdata[i++]=b;
			fdata[i++]=c;
			fdata[i++]=d;
			fdata[i++]=e;
			this._idata[i++]=f;
			this._idata[i++]=g;
			fdata[i++]=h;
			this._idata[0]=i;
		}

		__proto.add_iffffiii=function(a,b,c,d,e,f,g,h){
			this._need(32);
			var i=this._idata[0];
			var fdata=this._fdata;
			this._idata[i++]=a;
			fdata[i++]=b;
			fdata[i++]=c;
			fdata[i++]=d;
			fdata[i++]=e;
			this._idata[i++]=f;
			this._idata[i++]=g;
			this._idata[i++]=h;
			this._idata[0]=i;
		}

		__proto.add_iiiiiiii=function(a,b,c,d,e,f,g,h){
			this._need(32);
			var i=this._idata[0];
			var idata=this._idata;
			idata[i++]=a;
			idata[i++]=b;
			idata[i++]=c;
			idata[i++]=d;
			idata[i++]=e;
			idata[i++]=f;
			idata[i++]=g;
			idata[i++]=h;
			idata[0]=i;
		}

		__proto.add_iiiiiiiii=function(a,b,c,d,e,f,g,h,j){
			this._need(36);
			var idata=this._idata;
			var i=idata[0];
			idata[i++]=a;
			idata[i++]=b;
			idata[i++]=c;
			idata[i++]=d;
			idata[i++]=e;
			idata[i++]=f;
			idata[i++]=g;
			idata[i++]=h;
			idata[i++]=j;
			idata[0]=i;
		}

		__proto.add_StringForNative=function(str){
			var ab=window.conch.strTobufer(str);
			var len=ab.byteLength;
			this._need(len+4);
			this._idata[this._idata[0]++]=len;
			if (len==0)return;
			var uint8array=new Uint8Array(ab);
			this._byteArray.set(uint8array,this._idata[0] *4);
			this._idata[0]+=len / 4;
		}

		__proto.add_String=function(str){
			this._idata.push(str);
		}

		__proto.add_blockStart=function(a,data){
			this._need(8);
			var idata=this._idata;
			idata[idata[0]++]=a;
			idata[idata[0]++]=data._data["_ptrID"];
		}

		__proto.add_blockEnd=function(a,data){
			this._need(8);
			var idata=this._idata;
			idata[idata[0]++]=a;
			idata[idata[0]++]=data._data["_ptrID"];
		}

		__proto.wab=function(arraybuffer,length,offset){
			(offset===void 0)&& (offset=0);
			offset=offset ? offset :0;
			var nAlignLength=(length+3)& 0xfffffffc;
			this._need(nAlignLength+4);
			this._idata[this._idata[0]++]=length;
			var ab=null;
			if ((arraybuffer instanceof ArrayBuffer)){
				ab=arraybuffer;
			}
			else if (arraybuffer.buffer){
				ab=arraybuffer.buffer;
			}
			else{
				console.log("not arraybuffer/dataview ");
				return;
			};
			var uint8array=new Uint8Array(ab,offset,length);
			this._byteArray.set(uint8array,this._idata[0] *4);
			this._idata[0]+=nAlignLength / 4;
		}

		__proto.copyBuffer=function(arraybuffer,length,offset){
			(offset===void 0)&& (offset=0);
			offset=offset ? offset :0;
			this._need(length);
			var ab=null;
			if ((arraybuffer instanceof ArrayBuffer)){
				ab=arraybuffer;
			}
			else if (arraybuffer.buffer){
				ab=arraybuffer.buffer;
			}
			else{
				console.log("not arraybuffer/dataview ");
				return;
			};
			var uint8array=new Uint8Array(ab,offset,length);
			this._byteArray.set(uint8array,this._idata[0] *4);
			this._idata[0]+=length / 4;
		}

		//------------------------------------------------------------------------------
		__proto.getContextAttributes=function(){
			console.log("getContextAttributes can't support");
			return null;
		}

		__proto.isContextLost=function(){
			console.log("isContextLost can't support");
			return false;
		}

		__proto.getSupportedExtensions=function(){
			console.log("getSupportedExtensions can't support");
			return 0;
		}

		__proto.getExtension=function(name){
			console.log("getExtension can't support");
			return null;
		}

		__proto.activeTexture=function(texture){
			this.add_ii(68,texture);
		}

		__proto.attachShader=function(program,shader){
			this.add_iii(69,program,shader);
		}

		__proto.bindAttribLocation=function(program,index,name){
			this.add_iii(70,program,index);
			this.add_String(name);
		}

		__proto.bindBuffer=function(target,buffer){
			this.add_iii(71,target,buffer);
		}

		__proto.bindFramebuffer=function(target,framebuffer){
			this.add_iii(72,target,framebuffer);
		}

		__proto.bindRenderbuffer=function(target,renderbuffer){
			this.add_iii(73,target,renderbuffer);
		}

		__proto.bindTexture=function(target,texture){
			this.add_iii(74,target,texture);
		}

		__proto.useTexture=function(value){
			this.add_ii(75,value);
		}

		__proto.blendColor=function(red,green,blue,alpha){
			this.add_iffff(76,red,green,blue,alpha);
		}

		__proto.blendEquation=function(mode){
			this.add_ii(77,mode);
		}

		__proto.blendEquationSeparate=function(modeRGB,modeAlpha){
			this.add_iii(78,modeRGB,modeAlpha);
		}

		__proto.blendFunc=function(sfactor,dfactor){
			this.add_iii(79,sfactor,dfactor);
		}

		__proto.blendFuncSeparate=function(srcRGB,dstRGB,srcAlpha,dstAlpha){
			this.add_iiiii(80,srcRGB,dstRGB,srcAlpha,dstAlpha);
		}

		__proto.bufferData=function(target,sizeOrArray,usage){
			if ((typeof sizeOrArray=='number')){
				this.add_iiii(81,target,sizeOrArray,usage);
			}
			else{
				this.add_iii(82,target,usage);
				this.wab(sizeOrArray,sizeOrArray.byteLength);
			}
		}

		__proto.bufferSubData=function(target,offset,data){
			this.add_iii(83,target,offset);
			this.wab(data,data.byteLength);
		}

		__proto.checkFramebufferStatus=function(target){
			console.log("checkFramebufferStatus can't support");
			return true;
		}

		__proto.clear=function(mask){
			this.add_ii(85,mask);
		}

		__proto.clearColor=function(red,green,blue,alpha){
			this.add_iffff(86,red,green,blue,alpha);
		}

		__proto.clearDepth=function(depth){
			this.add_if(87,depth);
		}

		__proto.clearStencil=function(s){
			this.add_ii(88,s);
		}

		__proto.colorMask=function(red,green,blue,alpha){
			this.add_iiiii(89,red,green,blue,alpha);
		}

		__proto.compileShader=function(shader){
			this.add_ii(90,shader);
		}

		__proto.copyTexImage2D=function(target,level,internalformat,x,y,width,height,border){
			this.add_iiiiiiiii(91,target,level,internalformat,x,y,width,height,border);
		}

		__proto.copyTexSubImage2D=function(target,level,xoffset,yoffset,x,y,width,height){
			this.add_iiiiiiiii(92,target,level,xoffset,yoffset,x,y,width,height);
		}

		__proto.createBuffer=function(){
			var fakeID=this.createFakeID();
			this.add_ii(93,fakeID);
			return fakeID;
		}

		__proto.createFramebuffer=function(){
			var fakeID=this.createFakeID();
			this.add_ii(94,fakeID);
			return fakeID;
		}

		__proto.createProgram=function(){
			var fakeID=this.createFakeID();
			this.add_ii(95,fakeID);
			return fakeID;
		}

		__proto.createRenderbuffer=function(){
			var fakeID=this.createFakeID();
			this.add_ii(96,fakeID);
			return fakeID;
		}

		__proto.createShader=function(type){
			var fakeID=this.createFakeID();
			this.add_iii(97,fakeID,type);
			return fakeID;
		}

		__proto.createTexture=function(){
			var fakeID=this.createFakeID();
			this.add_ii(98,fakeID);
			return fakeID;
		}

		__proto.cullFace=function(mode){
			this.add_ii(99,mode);
		}

		__proto.deleteBuffer=function(buffer){
			this.add_ii(100,buffer);
		}

		__proto.deleteFramebuffer=function(framebuffer){
			this.add_ii(101,framebuffer);
		}

		__proto.deleteProgram=function(program){
			this.add_ii(102,program);
		}

		__proto.deleteRenderbuffer=function(renderbuffer){
			this.add_ii(103,renderbuffer);
		}

		__proto.deleteShader=function(shader){
			this.add_ii(104,shader);
		}

		__proto.deleteTexture=function(texture){
			this.add_ii(105,texture);
		}

		__proto.depthFunc=function(func){
			this.add_ii(106,func);
		}

		__proto.depthMask=function(flag){
			this.add_ii(107,flag);
		}

		__proto.depthRange=function(zNear,zFar){
			this.add_iff(108,zNear,zFar);
		}

		__proto.detachShader=function(program,shader){
			this.add_iii(109,program,shader);
		}

		__proto.disable=function(cap){
			this.add_ii(110,cap);
		}

		__proto.disableVertexAttribArray=function(index){
			this.add_ii(111,index);
		}

		__proto.drawArrays=function(mode,first,count){
			this.add_iiii(112,mode,first,count);
		}

		__proto.drawElements=function(mode,count,type,offset){
			this.add_iiiii(113,mode,count,type,offset);
		}

		__proto.enable=function(cap){
			this.add_ii(114,cap);
		}

		__proto.enableVertexAttribArray=function(index){
			this.add_ii(115,index);
		}

		__proto.finish=function(){
			this.add_i(116);
		}

		__proto.flush=function(){
			this.add_i(117);
		}

		__proto.framebufferRenderbuffer=function(target,attachment,renderbuffertarget,renderbuffer){
			this.add_iiiii(118,target,attachment,renderbuffertarget,renderbuffer);
		}

		__proto.framebufferTexture2D=function(target,attachment,textarget,texture,level){
			this.add_iiiiii(119,target,attachment,textarget,texture,level);
		}

		__proto.frontFace=function(mode){
			this.add_ii(120,mode);
		}

		__proto.generateMipmap=function(target){
			this.add_ii(121,target);
		}

		__proto.getActiveAttrib=function(program,index){
			alert("getActiveAttrib");
			console.log("getActiveAttrib can't support");
		}

		__proto.getActiveUniform=function(program,index){
			alert("getActiveUniform");
			console.log("getActiveUniform can't support");
		}

		__proto.getAttribLocation=function(program,name){
			var fakeLoc=GLCommandEncoder._locTable.getFakeLocation(program,name);
			this.add_iii(124,program,fakeLoc);
			this.add_String(name);
			return fakeLoc;
		}

		__proto.getParameter=function(pname){
			var fakeID=this.createFakeID();
			this.add_iii(125,pname,fakeID);
			return fakeID;
		}

		__proto.getBufferParameter=function(target,pname){
			console.log("getBufferParameter can't support");
			return 0;
		}

		__proto.getError=function(){
			console.log("getError can't support");
			return 0;
		}

		__proto.getFramebufferAttachmentParameter=function(target,attachment,pname){
			console.log("getFramebufferAttachmentParameter can't support");
		}

		__proto.getProgramParameter=function(program,pname){
			console.log("getProgramParameter can't support");
			return 0;
		}

		__proto.getProgramInfoLog=function(program){
			console.log("getProgramInfoLog can't support");
			return 0;
		}

		__proto.getRenderbufferParameter=function(target,pname){
			console.log("getRenderbufferParameter can't support");
		}

		__proto.getShaderPrecisionFormat=function(__arg){
			var arg=arguments;
			console.log("getShaderPrecision can't support");
		}

		__proto.getShaderParameter=function(shader,pname){
			console.log("getShaderParameter can't support");
		}

		__proto.getShaderInfoLog=function(shader){
			console.log("getShaderInfoLog can't support");
		}

		__proto.getShaderSource=function(shader){
			console.log("getShaderSource can't support");
		}

		__proto.getTexParameter=function(target,pname){
			console.log("getTexParameter can't support");
		}

		__proto.getUniform=function(program,location){
			console.log("getUniform can't support");
		}

		__proto.getUniformLocation=function(program,name){
			var fakeLoc=GLCommandEncoder._locTable.getFakeLocation(program,name);
			this.add_iii(138,program,fakeLoc);
			this.add_String(name);
			return fakeLoc;
		}

		__proto.getVertexAttrib=function(index,pname){
			console.log("getVertexAttrib can't support");
			return 0;
		}

		__proto.getVertexAttribOffset=function(index,pname){
			console.log("getVertexAttribOffset can't support");
			return 0;
		}

		__proto.hint=function(target,mode){
			this.add_iii(141,target,mode);
		}

		__proto.isBuffer=function(buffer){
			console.log("isBuffer can't support");
			return true;
		}

		__proto.isEnabled=function(cap){
			console.log("isEnabled can't support");
			return true;
		}

		__proto.isFramebuffer=function(framebuffer){
			console.log("isFramebuffer can't support");
			return true;
		}

		__proto.isProgram=function(program){
			console.log("isProgram can't support");
			return true;
		}

		__proto.isRenderbuffer=function(renderbuffer){
			console.log("isRenderbuffer can't support");
			return true;
		}

		__proto.isShader=function(shader){
			console.log("isShader can't support");
			return true;
		}

		__proto.isTexture=function(texture){
			console.log("isTexture can't support");
			return true;
		}

		__proto.lineWidth=function(width){
			this.add_if(149,width);
		}

		__proto.linkProgram=function(program){
			this.add_ii(150,program);
		}

		__proto.pixelStorei=function(pname,param){
			this.add_iii(151,pname,param);
		}

		__proto.polygonOffset=function(factor,units){
			this.add_iff(152,factor,units);
		}

		__proto.readPixels=function(x,y,width,height,format,type,pixels){
			console.log("readPixels can't support");
		}

		__proto.renderbufferStorage=function(target,internalformat,width,height){
			this.add_iiiii(154,target,internalformat,width,height);
		}

		__proto.sampleCoverage=function(value,invert){
			this.add_ifi(155,value,invert);
		}

		__proto.scissor=function(x,y,width,height){
			this.add_iiiii(156,x,y,width,height);
		}

		__proto.shaderSource=function(shader,source){
			this.add_ii(157,shader);
			this.add_String(source);
		}

		__proto.stencilFunc=function(func,ref,mask){
			this.add_iiii(158,func,ref,mask);
		}

		__proto.stencilFuncSeparate=function(face,func,ref,mask){
			this.add_iiiii(159,face,func,ref,mask);
		}

		__proto.stencilMask=function(mask){
			this.add_ii(160,mask);
		}

		__proto.stencilMaskSeparate=function(face,mask){
			this.add_iii(161,face,mask);
		}

		__proto.stencilOp=function(fail,zfail,zpass){
			this.add_iiii(162,fail,zfail,zpass);
		}

		__proto.stencilOpSeparate=function(face,fail,zfail,zpass){
			this.add_iiiii(163,face,fail,zfail,zpass);
		}

		__proto.texImage2D=function(__args){
			var args=arguments;
			if (args.length==6){
				if (args[5]._nativeObj){
					this.add_iiiiiii(164,args[0],args[1],args[2],args[3],args[4],args[5]._nativeObj.conchImgId);
				}
			}
		}

		__proto.texParameterf=function(target,pname,param){
			this.add_iiif(165,target,pname,param);
		}

		__proto.texParameteri=function(target,pname,param){
			this.add_iiii(166,target,pname,param);
		}

		__proto.texSubImage2D=function(__args){
			var args=arguments;
			if (args.length==7){
				if (args[6]._nativeObj){
					this.add_iiiiiiii(167,args[0],args[1],args[2],args[3],args[4],args[5],args[6]._nativeObj.conchImgId);
				}
			}
		}

		__proto.uniform1f=function(location,x){
			this.add_iif(168,location,x);
		}

		__proto.uniform1fv=function(location,values){
			this.add_ii(169,location);
			this.wab(values,values.byteLength);
		}

		__proto.uniform1i=function(location,x){
			this.add_iii(170,location,x);
		}

		__proto.uniform1iv=function(location,values){
			this.add_ii(171,location);
			this.wab(values,values.byteLength);
		}

		__proto.uniform2f=function(location,x,y){
			this.add_iiff(172,location,x,y);
		}

		__proto.uniform2fv=function(location,values){
			this.add_ii(173,location);
			this.wab(values,values.byteLength);
		}

		__proto.uniform2i=function(location,x,y){
			this.add_iiii(174,location,x,y);
		}

		__proto.uniform2iv=function(location,values){
			this.add_ii(175,location);
			this.wab(values,values.byteLength);
		}

		__proto.uniform3f=function(location,x,y,z){
			this.add_iifff(176,location,x,y,z);
		}

		__proto.uniform3fv=function(location,values){
			this.add_ii(177,location);
			this.wab(values,values.byteLength);
		}

		__proto.uniform3i=function(location,x,y,z){
			this.add_iiiii(178,location,x,y,z);
		}

		__proto.uniform3iv=function(location,values){
			this.add_ii(179,location);
			this.wab(values,values.byteLength);
		}

		__proto.uniform4f=function(location,x,y,z,w){
			this.add_iiffff(180,location,x,y,z,w);
		}

		__proto.uniform4fv=function(location,values){
			this.add_ii(181,location);
			this.wab(values,values.byteLength);
		}

		__proto.uniform4i=function(location,x,y,z,w){
			this.add_iiiiii(182,location,x,y,z,w);
		}

		__proto.uniform4iv=function(location,values){
			this.add_ii(183,location);
			this.wab(values,values.byteLength);
		}

		__proto.uniformMatrix2fv=function(location,transpose,value){
			this.add_iii(184,location,transpose);
			this.wab(value,value.byteLength);
		}

		__proto.uniformMatrix3fv=function(location,transpose,value){
			this.add_iii(185,location,transpose);
			this.wab(value,value.byteLength);
		}

		__proto.uniformMatrix4fv=function(location,transpose,value){
			this.add_iii(186,location,transpose);
			this.wab(value,value.byteLength);
		}

		__proto.useProgram=function(program){
			this.add_ii(187,program);
		}

		__proto.validateProgram=function(program){
			this.add_ii(188,program);
		}

		__proto.vertexAttrib1f=function(indx,x){
			this.add_iif(189,indx,x);
		}

		__proto.vertexAttrib1fv=function(indx,values){
			this.add_ii(190,indx);
			this.wab(values,values.byteLength);
		}

		__proto.vertexAttrib2f=function(indx,x,y){
			this.add_iiff(191,indx,x,y);
		}

		__proto.vertexAttrib2fv=function(indx,values){
			this.add_ii(192,indx);
			this.wab(values,values.byteLength);
		}

		__proto.vertexAttrib3f=function(indx,x,y,z){
			this.add_iifff(193,indx,x,y,z);
		}

		__proto.vertexAttrib3fv=function(indx,values){
			this.add_ii(194,indx);
			this.wab(values,values.byteLength);
		}

		__proto.vertexAttrib4f=function(indx,x,y,z,w){
			this.add_iiffff(195,indx,x,y,z,w);
		}

		__proto.vertexAttrib4fv=function(indx,values){
			this.add_ii(196,indx);
			this.wab(values,values.byteLength);
		}

		__proto.vertexAttribPointer=function(indx,size,type,normalized,stride,offset){
			this.add_iiiiiii(197,indx,size,type,normalized,stride,offset);
		}

		__proto.viewport=function(x,y,width,height){
			this.add_iiiii(198,x,y,width,height);
		}

		__proto.configureBackBuffer=function(width,height,antiAlias,enableDepthAndStencil,wantsBestResolution){
			(enableDepthAndStencil===void 0)&& (enableDepthAndStencil=true);
			(wantsBestResolution===void 0)&& (wantsBestResolution=false);
			console.log("configureBackBuffer can't support");
		}

		//add_iiiiii(CONFIGUREBACKBUFFER,width,height,antiAlias,enableDepthAndStencil,wantsBestResolution);
		__proto.compressedTexImage2D=function(__args){
			var args=arguments;
			console.log("compressedTexImage2D can't support");
		}

		__proto.uniformMatrix2fvEx=function(location,transpose,value){
			if (!value["_ptrID"]){
				LayaGL.createArrayBufferRef(value,0,true);
			};
			var nID=value["_ptrID"];
			LayaGL.syncBufferToRenderThread(nID);
			this.add_iiii(4,location,transpose,nID);
		}

		__proto.uniformMatrix3fvEx=function(location,transpose,value){
			if (!value["_ptrID"]){
				LayaGL.createArrayBufferRef(value,0,true);
			};
			var nID=value["_ptrID"];
			LayaGL.syncBufferToRenderThread(nID);
			this.add_iiii(5,location,transpose,nID);
		}

		__proto.uniformMatrix4fvEx=function(location,transpose,value){
			if (!value["_ptrID"]){
				LayaGL.createArrayBufferRef(value,0,true);
			};
			var nID=value["_ptrID"];
			LayaGL.syncBufferToRenderThread(nID);
			this.add_iiii(6,location,transpose,nID);
		}

		__proto.addShaderAttribute=function(one){
			this.add_ShaderValue(one);
		}

		__proto.addShaderUniform=function(one){
			this.add_ShaderValue(one);
		}

		__proto.addShaderAttributeForNative=function(one){
			LayaGL.syncBufferToRenderThread(this._buffer["_ptrID"]);
			this.add_iiii(7,one.location,one.type,one.dataOffset);
		}

		__proto.addShaderUniformForNative=function(one){
			var funID=0;
			var isArray=one.isArray;
			switch (one.type){
				case 0x1404:
					funID=isArray ? 3 :2;
					break ;
				case 0x1406:
					funID=isArray ? 1 :0;
					break ;
				case 0x8B50:
					funID=isArray ? 5 :4;
					break ;
				case 0x8B51:
					funID=isArray ? 9 :8;
					break ;
				case 0x8B52:
					funID=isArray ? 13 :12;
					break ;
				case 0x8B5E:
					funID=19;
					break ;
				case 0x8B60:
					funID=20;
					break ;
				case 0x8B5C:
					funID=18;
					break ;
				case 0x8B56:
					funID=2;
					break ;
				case 0x8B5A:
					funID=16;
					break ;
				case 0x8B5B:
					funID=17;
					break ;
				default :
					throw new Error("compile shader err!");
					break ;
				}
			LayaGL.syncBufferToRenderThread(this._buffer["_ptrID"]);
			this.add_iiiiii(8,funID,one.location,one.type,one.dataOffset,one.textureID);
		}

		__proto.uploadShaderAttributes=function(commandEncoder,data){
			var dataID=data["_ptrID"];
			LayaGL.syncBufferToRenderThread(dataID);
			this.add_iii(9,commandEncoder._buffer["_ptrID"],dataID);
			return 0;
		}

		__proto.uploadShaderUniforms=function(commandEncoder,data){
			var dataID=data["_ptrID"];
			LayaGL.syncBufferToRenderThread(dataID);
			this.add_iii(10,commandEncoder._buffer["_ptrID"],dataID);
			return 0;
		}

		__proto.uploadShaderParam=function(shaderParamBuffer,attrValue,sceneValue,cameraValue,spriteValue,materialValue){
			var shaderParamID=shaderParamBuffer["_ptrID"];
			var attrValueID=attrValue["_ptrID"];
			var sceneValue=sceneValue["_ptrID"];
			var cameraValue=cameraValue["_ptrID"];
			var spriteValue=spriteValue["_ptrID"];
			var materialValue=materialValue["_ptrID"];
			var nCurentFrame=LayaGL._frameCount;
			var syncArrayBufferList=LayaGL._syncArrayBufferList;
			syncArrayBufferList[shaderParamID]=nCurentFrame;
			syncArrayBufferList[attrValueID]=nCurentFrame;
			syncArrayBufferList[sceneValue]=nCurentFrame;
			syncArrayBufferList[cameraValue]=nCurentFrame;
			syncArrayBufferList[spriteValue]=nCurentFrame;
			syncArrayBufferList[materialValue]=nCurentFrame;
			this.add_iiiiiii(11,shaderParamID,attrValueID,sceneValue,cameraValue,spriteValue,materialValue);
			return 0;
		}

		__proto.createFakeID=function(){
			return++GLCommandEncoder._fakeIDCount;
		}

		__proto.save=function(){
			this.add_i(2);
		}

		__proto.restore=function(){
			this.add_i(this.restore);
		}

		__proto.blockStart=function(data){
			return this.add_blockStart(0,data);
		}

		__proto.blockEnd=function(data){
			return this.add_blockEnd(1,data);
		}

		__proto.block=function(data){
			this._need(16);
			var idata=this._idata;
			var i=idata[0];
			idata[i++]=0;
			idata[i++]=data._data["_ptrID"];
			idata[i++]=1;
			idata[i++]=data._data["_ptrID"];
			idata[0]=i;
		}

		__proto.setValueWithShareData=function(valueID,dataOffset,operateType){
			this.add_iiii(12,valueID,dataOffset,operateType);
		}

		__proto.useCommandEncoder=function(id){
			this.add_ii(13,id);
		}

		__proto.createProgramEx=function(vs,ps,attribBindingInfo){
			var fakeID=this.createFakeID();
			this.add_ii(14,fakeID);
			this.add_String(vs);
			this.add_String(ps);
			this.add_String(attribBindingInfo);
			return fakeID;
		}

		__proto.createVDO=function(data){
			var fakeID=this.createFakeID();
			this.add_ii(15,fakeID);
			this.wab(data,data.byteLength);
			return fakeID;
		}

		__proto.createVertexDesc=function(desc){
			var fakeID=this.createFakeID();
			this.add_ii(16,fakeID);
			this.wab(desc,desc.byteLength);
			return fakeID;
		}

		__proto.useProgramEx=function(nProgramID){
			this.add_ii(17,nProgramID);
		}

		__proto.useVDO=function(nVDOID){
			this.add_ii(18,nVDOID);
		}

		__proto.uniformEx=function(nValueID,sUniformName){
			this.add_ii(19,nValueID);
			this.add_String(sUniformName);
			this.add_i(-1);
		}

		__proto.setRectMesh=function(data){
			this.add_i(20);
			this.wab(data,data.byteLength);
		}

		__proto.modifyMesh=function(nValueID,nVertexDescID,operatorType){
			this.add_iiii(21,nValueID,nVertexDescID,operatorType);
		}

		__proto.uniformTexture=function(name,type,texLocation,texture){
			this.add_iiii(22,type,texLocation,texture);
			this.add_String(name);
		}

		__proto.setValue=function(valueID,data,operateType){
			this.add_iii(23,valueID,operateType);
			this.wab(data,data.byteLength);
		}

		__proto.setValue1i=function(valueID,operateType,value){
			this.add_iiii(24,valueID,operateType,value);
		}

		__proto.setValue2i=function(valueID,operateType,value1,value2){
			this.add_iiiii(25,valueID,operateType,value1,value2);
		}

		__proto.setValue3i=function(valueID,operateType,value1,value2,value3){
			this.add_iiiiii(26,valueID,operateType,value1,value2,value3);
		}

		__proto.setValue4i=function(valueID,operateType,value1,value2,value3,value4){
			this.add_iiiiiii(27,valueID,operateType,value1,value2,value3,value4);
		}

		__proto.setValue1f=function(valueID,operateType,value){
			this.add_iiif(28,valueID,operateType,value);
		}

		__proto.setValue2f=function(valueID,operateType,value1,value2){
			this.add_iiiff(29,valueID,operateType,value1,value2);
		}

		__proto.setValue3f=function(valueID,operateType,value1,value2,value3){
			this.add_iiifff(30,valueID,operateType,value1,value2,value3);
		}

		__proto.setValue4f=function(valueID,operateType,value1,value2,value3,value4){
			this.add_iiiffff(31,valueID,operateType,value1,value2,value3,value4);
		}

		__proto.setShareData=function(dataID,offset){
			this.add_iii(32,dataID,offset);
		}

		__proto.setMesh=function(vbdata,ibdata){
			this.add_i(33);
			this.wab(vbdata,vbdata.byteLength);
			this.wab(ibdata,ibdata.byteLength);
		}

		__proto.setShaderDefine=function(sValue){
			this.add_i(34);
			this.add_String(sValue);
		}

		__proto.forceNoMerge=function(){
			this.add_i(35);
		}

		__proto.calcLocalMatrix32=function(transformFlag,matrixResultID,x,y,pivotX,pivotY,scaleX,scaleY,skewX,skewY,rotate){
			this.add_iiiiiiiiiiii(36,transformFlag,matrixResultID,x,y,pivotX,pivotY,scaleX,scaleY,skewX,skewY,rotate);
		}

		GLCommandEncoder.__init__=function(){
			if (Render.isConchApp){
				GLCommandEncoder._locTable=new ProgramLocationTable();
			}
		}

		GLCommandEncoder._fakeIDCount=0;
		GLCommandEncoder._locTable=null
		GLCommandEncoder.BLOCK_START_ID=0;
		GLCommandEncoder.BLOCK_END_ID=1;
		GLCommandEncoder.SAVE=2;
		GLCommandEncoder.RESTORE=3;
		GLCommandEncoder.UNIFORMMATRIX2FVEX=4;
		GLCommandEncoder.UNIFORMMATRIX3FVEX=5;
		GLCommandEncoder.UNIFORMMATRIX4FVEX=6;
		GLCommandEncoder.ADDSHADERATTRIBUTE=7;
		GLCommandEncoder.ADDSHADERUNIFORM=8;
		GLCommandEncoder.UPLOADSHADERATTRIBUTES=9;
		GLCommandEncoder.UPLOADSHADERUNIFORMS=10;
		GLCommandEncoder.UPLOADSHADERPARAMS=11;
		GLCommandEncoder.SETVALUEWITHSHAREDATA=12;
		GLCommandEncoder.USECOMMANDENCODER=13;
		GLCommandEncoder.CREATEPROGRAMEX=14;
		GLCommandEncoder.CREATEVDO=15;
		GLCommandEncoder.CREATEVERTEXDESC=16;
		GLCommandEncoder.USEPROGRAMEX=17;
		GLCommandEncoder.USEVDO=18;
		GLCommandEncoder.UNIFORMEX=19;
		GLCommandEncoder.SETRECTMESH=20;
		GLCommandEncoder.MODIFYMESH=21;
		GLCommandEncoder.UNIFORMTEXTURE=22;
		GLCommandEncoder.SETVALUE=23;
		GLCommandEncoder.SETVALUE1I=24;
		GLCommandEncoder.SETVALUE2I=25;
		GLCommandEncoder.SETVALUE3I=26;
		GLCommandEncoder.SETVALUE4I=27;
		GLCommandEncoder.SETVALUE1F=28;
		GLCommandEncoder.SETVALUE2F=29;
		GLCommandEncoder.SETVALUE3F=30;
		GLCommandEncoder.SETVALUE4F=31;
		GLCommandEncoder.SETSHAREDATA=32;
		GLCommandEncoder.SETMESH=33;
		GLCommandEncoder.SETSHADERDEFINE=34;
		GLCommandEncoder.FORCENOMERGE=35;
		GLCommandEncoder.CALCLOCALMATRIX32=36;
		GLCommandEncoder.GETCONTEXTATTRIBUTES=64;
		GLCommandEncoder.ISCONTEXTLOST=65;
		GLCommandEncoder.GETSUPPORTEDEXTENSIONS=66;
		GLCommandEncoder.GETEXTENSION=67;
		GLCommandEncoder.ACTIVETEXTURE=68;
		GLCommandEncoder.ATTACHSHADER=69;
		GLCommandEncoder.BINDATTRIBLOCATION=70;
		GLCommandEncoder.BINDBUFFER=71;
		GLCommandEncoder.BINDFRAMEBUFFER=72;
		GLCommandEncoder.BINDRENDERBUFFER=73;
		GLCommandEncoder.BINDTEXTURE=74;
		GLCommandEncoder.USETEXTURE=75;
		GLCommandEncoder.BLENDCOLOR=76;
		GLCommandEncoder.BLENDEQUATION=77;
		GLCommandEncoder.BLENDEQUATIONSEPARATE=78;
		GLCommandEncoder.BLENDFUNC=79;
		GLCommandEncoder.BLENDFUNCSEPARATE=80;
		GLCommandEncoder.BUFFERDATA_SIZE=81;
		GLCommandEncoder.BUFFERDATA_ARRAYBUFFER=82;
		GLCommandEncoder.BUFFERSUBDATA=83;
		GLCommandEncoder.CHECKFRAMEBUFFERSTATUS=84;
		GLCommandEncoder.CLEAR=85;
		GLCommandEncoder.CLEARCOLOR=86;
		GLCommandEncoder.CLEARDEPTH=87;
		GLCommandEncoder.CLEARSTENCIL=88;
		GLCommandEncoder.COLORMASK=89;
		GLCommandEncoder.COMPILESHADER=90;
		GLCommandEncoder.COPYTEXIMAGE2D=91;
		GLCommandEncoder.COPYTEXSUBIMAGE2D=92;
		GLCommandEncoder.CREATEBUFFER=93;
		GLCommandEncoder.CREATEFRAMEBUFFER=94;
		GLCommandEncoder.CREATEPROGRAM=95;
		GLCommandEncoder.CREATERENDERBUFFER=96;
		GLCommandEncoder.CREATESHADER=97;
		GLCommandEncoder.CREATETEXTURE=98;
		GLCommandEncoder.CULLFACE=99;
		GLCommandEncoder.DELETEBUFFER=100;
		GLCommandEncoder.DELETEFRAMEBUFFER=101;
		GLCommandEncoder.DELETEPROGRAM=102;
		GLCommandEncoder.DELETERENDERBUFFER=103;
		GLCommandEncoder.DELETESHADER=104;
		GLCommandEncoder.DELETETEXTURE=105;
		GLCommandEncoder.DEPTHFUNC=106;
		GLCommandEncoder.DEPTHMASK=107;
		GLCommandEncoder.DEPTHRANGE=108;
		GLCommandEncoder.DETACHSHADER=109;
		GLCommandEncoder.DISABLE=110;
		GLCommandEncoder.DISABLEVERTEXATTRIBARRAY=111;
		GLCommandEncoder.DRAWARRAYS=112;
		GLCommandEncoder.DRAWELEMENTS=113;
		GLCommandEncoder.ENABLE=114;
		GLCommandEncoder.ENABLEVERTEXATTRIBARRAY=115;
		GLCommandEncoder.FINISH=116;
		GLCommandEncoder.FLUSH=117;
		GLCommandEncoder.FRAMEBUFFERRENDERBUFFER=118;
		GLCommandEncoder.FRAMEBUFFERTEXTURE2D=119;
		GLCommandEncoder.FRONTFACE=120;
		GLCommandEncoder.GENERATEMIPMAP=121;
		GLCommandEncoder.GETACTIVEATTRIB=122;
		GLCommandEncoder.GETACTIVEUNIFORM=123;
		GLCommandEncoder.GETATTRIBLOCATION=124;
		GLCommandEncoder.GETPARAMETER=125;
		GLCommandEncoder.GETBUFFERPARAMETER=126;
		GLCommandEncoder.GETERROR=127;
		GLCommandEncoder.GETFRAMEBUFFERATTACHMENTPARAMETER=128;
		GLCommandEncoder.GETPROGRAMPARAMETER=129;
		GLCommandEncoder.GETPROGRAMINFOLOG=130;
		GLCommandEncoder.GETRENDERBUFFERPARAMETER=131;
		GLCommandEncoder.GETSHADERPRECISIONFORMAT=132;
		GLCommandEncoder.GETSHADERPARAMETER=133;
		GLCommandEncoder.GETSHADERINFOLOG=134;
		GLCommandEncoder.GETSHADERSOURCE=135;
		GLCommandEncoder.GETTEXPARAMETER=136;
		GLCommandEncoder.GETUNIFORM=137;
		GLCommandEncoder.GETUNIFORMLOCATION=138;
		GLCommandEncoder.GETVERTEXATTRIB=139;
		GLCommandEncoder.GETVERTEXATTRIBOFFSET=140;
		GLCommandEncoder.HINT=141;
		GLCommandEncoder.ISBUFFER=142;
		GLCommandEncoder.ISENABLED=143;
		GLCommandEncoder.ISFRAMEBUFFER=144;
		GLCommandEncoder.ISPROGRAM=145;
		GLCommandEncoder.ISRENDERBUFFER=146;
		GLCommandEncoder.ISSHADER=147;
		GLCommandEncoder.ISTEXTURE=148;
		GLCommandEncoder.LINEWIDTH=149;
		GLCommandEncoder.LINKPROGRAM=150;
		GLCommandEncoder.PIXELSTOREI=151;
		GLCommandEncoder.POLYGONOFFSET=152;
		GLCommandEncoder.READPIXELS=153;
		GLCommandEncoder.RENDERBUFFERSTORAGE=154;
		GLCommandEncoder.SAMPLECOVERAGE=155;
		GLCommandEncoder.SCISSOR=156;
		GLCommandEncoder.SHADERSOURCE=157;
		GLCommandEncoder.STENCILFUNC=158;
		GLCommandEncoder.STENCILFUNCSEPARATE=159;
		GLCommandEncoder.STENCILMASK=160;
		GLCommandEncoder.STENCILMASKSEPARATE=161;
		GLCommandEncoder.STENCILOP=162;
		GLCommandEncoder.STENCILOPSEPARATE=163;
		GLCommandEncoder.TEXIMAGE2D=164;
		GLCommandEncoder.TEXPARAMETERF=165;
		GLCommandEncoder.TEXPARAMETERI=166;
		GLCommandEncoder.TEXSUBIMAGE2D=167;
		GLCommandEncoder.UNIFORM1F=168;
		GLCommandEncoder.UNIFORM1FV=169;
		GLCommandEncoder.UNIFORM1I=170;
		GLCommandEncoder.UNIFORM1IV=171;
		GLCommandEncoder.UNIFORM2F=172;
		GLCommandEncoder.UNIFORM2FV=173;
		GLCommandEncoder.UNIFORM2I=174;
		GLCommandEncoder.UNIFORM2IV=175;
		GLCommandEncoder.UNIFORM3F=176;
		GLCommandEncoder.UNIFORM3FV=177;
		GLCommandEncoder.UNIFORM3I=178;
		GLCommandEncoder.UNIFORM3IV=179;
		GLCommandEncoder.UNIFORM4F=180;
		GLCommandEncoder.UNIFORM4FV=181;
		GLCommandEncoder.UNIFORM4I=182;
		GLCommandEncoder.UNIFORM4IV=183;
		GLCommandEncoder.UNIFORMMATRIX2FV=184;
		GLCommandEncoder.UNIFORMMATRIX3FV=185;
		GLCommandEncoder.UNIFORMMATRIX4FV=186;
		GLCommandEncoder.USEPROGRAM=187;
		GLCommandEncoder.VALIDATEPROGRAM=188;
		GLCommandEncoder.VERTEXATTRIB1F=189;
		GLCommandEncoder.VERTEXATTRIB1FV=190;
		GLCommandEncoder.VERTEXATTRIB2F=191;
		GLCommandEncoder.VERTEXATTRIB2FV=192;
		GLCommandEncoder.VERTEXATTRIB3F=193;
		GLCommandEncoder.VERTEXATTRIB3FV=194;
		GLCommandEncoder.VERTEXATTRIB4F=195;
		GLCommandEncoder.VERTEXATTRIB4FV=196;
		GLCommandEncoder.VERTEXATTRIBPOINTER=197;
		GLCommandEncoder.VIEWPORT=198;
		GLCommandEncoder.CONFIGUREBACKBUFFER=199;
		GLCommandEncoder.COMPRESSEDTEXIMAGE2D=200;
		GLCommandEncoder.INTERIOR_UNIFORM1F=0;
		GLCommandEncoder.INTERIOR_UNIFORM1FV=1;
		GLCommandEncoder.INTERIOR_UNIFORM1I=2;
		GLCommandEncoder.INTERIOR_UNIFORM1IV=3;
		GLCommandEncoder.INTERIOR_UNIFORM2F=4;
		GLCommandEncoder.INTERIOR_UNIFORM2FV=5;
		GLCommandEncoder.INTERIOR_UNIFORM2I=6;
		GLCommandEncoder.INTERIOR_UNIFORM2IV=7;
		GLCommandEncoder.INTERIOR_UNIFORM3F=8;
		GLCommandEncoder.INTERIOR_UNIFORM3FV=9;
		GLCommandEncoder.INTERIOR_UNIFORM3I=10;
		GLCommandEncoder.INTERIOR_UNIFORM3IV=11;
		GLCommandEncoder.INTERIOR_UNIFORM4F=12;
		GLCommandEncoder.INTERIOR_UNIFORM4FV=13;
		GLCommandEncoder.INTERIOR_UNIFORM4I=14;
		GLCommandEncoder.INTERIOR_UNIFORM4IV=15;
		GLCommandEncoder.INTERIOR_UNIFORMMATRIX2FV=16;
		GLCommandEncoder.INTERIOR_UNIFORMMATRIX3FV=17;
		GLCommandEncoder.INTERIOR_UNIFORMMATRIX4FV=18;
		GLCommandEncoder.INTERIOR_UNIFORMSAMPLER_2D=19;
		GLCommandEncoder.INTERIOR_UNIFORMSAMPLER_CUBE=20;
		GLCommandEncoder.__init$=function(){
			//class ProgramLocationTable
			ProgramLocationTable=(function(){
				function ProgramLocationTable(){
					this._fakeLocationNum=0;
					this._map={};
				}
				__class(ProgramLocationTable,'');
				var __proto=ProgramLocationTable.prototype;
				__proto.getFakeLocation=function(fakeProgramID,name){
					var key=fakeProgramID+"-"+name;
					var fakeID=this._map[key];
					if (!fakeID){
						fakeID=this._fakeLocationNum++;
						this._map[key]=fakeID;
					}
					return fakeID;
				}
				return ProgramLocationTable;
			})()
		}

		return GLCommandEncoder;
	})()


	/**
	*@private
	*封装GL命令
	*/
	//class laya.renders.layagl.LayaGL
	var LayaGL=(function(){
		function LayaGL(c){
			this._canvas=null;
			this.__tx=0;
			this.__ty=0;
			this._mainContext=null;
			this.width=0;
			this.height=0;
			this._webGLContext=null;
			this._defaultEncoder=null;
			this._defaultEncoder1=null;
			this._currentContext=null;
			this._saveCommandEncoder=new Array();
			if (!LayaGL.instance){
				LayaGL.instance=this;
			}
			else{
				alert("LayaGL只能有一个");
				return;
			}
			if (Render.isConchApp){
				this._canvas=c;
				this._mainContext=this._canvas._source.getContext("2d");
				this._mainContext._canvas=this._canvas;
				this._mainContext.setSyncArrayBufferID(LayaGL._syncBufferList["_ptrID"]);
				this._defaultEncoder=new GLCommandEncoder(this,102400,1280,false,false);
				this._defaultEncoder1=new GLCommandEncoder(this,102400,1280,false,false);
				this._currentContext=this._defaultEncoder;
			}
			else{
				this._webGLContext=c;
				this._currentContext=this._webGLContext;
			}
			this._saveCommandEncoder.push(this._currentContext);
		}

		__class(LayaGL,'laya.renders.layagl.LayaGL');
		var __proto=LayaGL.prototype;
		__proto.commit=function(){
			this._mainContext.setRootCommandEncoder(this._defaultEncoder._buffer["_ptrID"],LayaGL._frameCount);
			LayaGL._tempGLEncoder=this._defaultEncoder1;
			this._defaultEncoder1=this._defaultEncoder;
			this._defaultEncoder=LayaGL._tempGLEncoder;
			this._currentContext=this._defaultEncoder;
			this._saveCommandEncoder[0]=this._currentContext;
			LayaGL._frameCount++;
		}

		__proto.addValueDefine=function(modifyType,type,size,defaultData){
			return this._mainContext.addValueDefine(modifyType,type,size,defaultData);
		}

		__proto.endValueDefine=function(){
			this._mainContext.endValueDefine();
		}

		__proto.size=function(w,h){
			this.width=w;
			this.height=h;
		}

		__proto.setIsMainContext=function(){
			this._mainContext.size=function (w,h){};
			this._mainContext.__tx=0;
			this._mainContext.__ty=0;
		}

		__proto.copyCmdBuffer=function(begin,end){
			this._defaultEncoder.copyBuffer(this._defaultEncoder1._buffer,end-begin,begin);
		}

		__proto.createCommandEncoder=function(reserveSize,adjustSize,isSyncToRenderThread,isUseArray){
			(reserveSize===void 0)&& (reserveSize=128);
			(adjustSize===void 0)&& (adjustSize=64);
			(isSyncToRenderThread===void 0)&& (isSyncToRenderThread=false);
			(isUseArray===void 0)&& (isUseArray=true);
			return new GLCommandEncoder(this,reserveSize,adjustSize,isSyncToRenderThread,isUseArray);
		}

		__proto.beginCommandEncoding=function(commandEncoder){
			commandEncoder=commandEncoder ? commandEncoder :this._webGLContext;
			this._saveCommandEncoder.push(commandEncoder);
			this._currentContext=commandEncoder;
		}

		__proto.beginCommandEncodingForNative=function(commandEncoder){
			commandEncoder=commandEncoder ? commandEncoder :this._defaultEncoder;
			this._saveCommandEncoder.push(commandEncoder);
			this._currentContext=commandEncoder;
		}

		__proto.endCommandEncoding=function(){
			this._saveCommandEncoder.pop();
			this._currentContext=this._saveCommandEncoder[this._saveCommandEncoder.length-1];
		}

		__proto.save=function(){
			this._currentContext.save();
		}

		__proto.restore=function(){
			this._currentContext.restore();
		}

		__proto.blockStart=function(data){
			return this._currentContext.blockStart(data);
		}

		__proto.blockEnd=function(data){
			return this._currentContext.blockEnd(data);
		}

		__proto.block=function(data){
			return this._currentContext.block(data);
		}

		__proto.getContextAttributes=function(){
			return this._currentContext.getContextAttributes();
		}

		__proto.isContextLost=function(){
			this._currentContext.isContextLost();
		}

		__proto.getSupportedExtensions=function(){
			return this._currentContext.getSupportedExtensions();
		}

		__proto.getExtension=function(name){
			return this._currentContext.getExtension(name);
		}

		__proto.activeTexture=function(texture){
			this._currentContext.activeTexture(texture);
		}

		__proto.attachShader=function(program,shader){
			this._currentContext.attachShader(program,shader);
		}

		__proto.bindAttribLocation=function(program,index,name){
			this._currentContext.bindAttribLocation(program,index,name);
		}

		__proto.bindBuffer=function(target,buffer){
			this._currentContext.bindBuffer(target,buffer);
		}

		__proto.bindFramebuffer=function(target,framebuffer){
			this._currentContext.bindFramebuffer(target,framebuffer);
		}

		__proto.bindRenderbuffer=function(target,renderbuffer){
			this._currentContext.bindRenderbuffer(target,renderbuffer);
		}

		__proto.bindTexture=function(target,texture){
			this._currentContext.bindTexture(target,texture);
		}

		__proto.useTexture=function(value){
			this._currentContext.useTexture(value);
		}

		__proto.blendColor=function(red,green,blue,alpha){
			this._currentContext.blendColor(red,green,blue,alpha);
		}

		__proto.blendEquation=function(mode){
			this._currentContext.blendEquation(mode);
		}

		__proto.blendEquationSeparate=function(modeRGB,modeAlpha){
			this._currentContext.blendEquationSeparate(modeRGB,modeAlpha);
		}

		__proto.blendFunc=function(sfactor,dfactor){
			this._currentContext.blendFunc(sfactor,dfactor);
		}

		__proto.blendFuncSeparate=function(srcRGB,dstRGB,srcAlpha,dstAlpha){
			this._currentContext.blendFuncSeparate(srcRGB,dstRGB,srcAlpha,dstAlpha);
		}

		__proto.bufferData=function(target,size,usage){
			this._currentContext.bufferData(target,size,usage);
		}

		__proto.bufferSubData=function(target,offset,data){
			this._currentContext.bufferSubData(target,offset,data);
		}

		__proto.checkFramebufferStatus=function(target){
			return this._currentContext.checkFramebufferStatus(target);
		}

		__proto.clear=function(mask){
			this._currentContext.clear(mask);
		}

		__proto.clearColor=function(red,green,blue,alpha){
			this._currentContext.clearColor(red,green,blue,alpha);
		}

		__proto.clearDepth=function(depth){
			this._currentContext.clearDepth(depth);
		}

		__proto.clearStencil=function(s){
			this._currentContext.clearStencil(s);
		}

		__proto.colorMask=function(red,green,blue,alpha){
			this._currentContext.colorMask(red,green,blue,alpha);
		}

		__proto.compileShader=function(shader){
			this._currentContext.compileShader(shader);
		}

		__proto.copyTexImage2D=function(target,level,internalformat,x,y,width,height,border){
			this._currentContext.copyTexImage2D(target,level,internalformat,x,y,width,height,border);
		}

		__proto.copyTexSubImage2D=function(target,level,xoffset,yoffset,x,y,width,height){
			this._currentContext.copyTexSubImage2D(target,level,xoffset,yoffset,x,y,width,height);
		}

		__proto.createBuffer=function(){
			return this._currentContext.createBuffer();
		}

		__proto.createFramebuffer=function(){
			return this._currentContext.createFramebuffer();
		}

		__proto.createProgram=function(){
			return this._currentContext.createProgram();
		}

		__proto.createRenderbuffer=function(){
			return this._currentContext.createRenderbuffer();
		}

		__proto.createShader=function(type){
			return this._currentContext.createShader(type);
		}

		__proto.createTexture=function(){
			return this._currentContext.createTexture();
		}

		__proto.cullFace=function(mode){
			this._currentContext.cullFace(mode);
		}

		__proto.deleteBuffer=function(buffer){
			this._currentContext.deleteBuffer(buffer);
		}

		__proto.deleteFramebuffer=function(framebuffer){
			this._currentContext.deleteFramebuffer(framebuffer);
		}

		__proto.deleteProgram=function(program){
			this._currentContext.deleteProgram(program);
		}

		__proto.deleteRenderbuffer=function(renderbuffer){
			this._currentContext.deleteRenderbuffer(renderbuffer);
		}

		__proto.deleteShader=function(shader){
			this._currentContext.deleteShader(shader);
		}

		__proto.deleteTexture=function(texture){
			this._currentContext.deleteTexture(texture);
		}

		__proto.depthFunc=function(func){
			this._currentContext.depthFunc(func);
		}

		__proto.depthMask=function(flag){
			this._currentContext.depthMask(flag);
		}

		__proto.depthRange=function(zNear,zFar){
			this._currentContext.depthRange(zNear,zFar);
		}

		__proto.detachShader=function(program,shader){
			this._currentContext.detachShader(program,shader);
		}

		__proto.disable=function(cap){
			this._currentContext.disable(cap);
		}

		__proto.disableVertexAttribArray=function(index){
			this._currentContext.disableVertexAttribArray(index);
		}

		__proto.drawArrays=function(mode,first,count){
			this._currentContext.drawArrays(mode,first,count);
		}

		__proto.drawElements=function(mode,count,type,offset){
			this._currentContext.drawElements(mode,count,type,offset);
		}

		__proto.enable=function(cap){
			this._currentContext.enable(cap);
		}

		__proto.enableVertexAttribArray=function(index){
			this._currentContext.enableVertexAttribArray(index);
		}

		__proto.finish=function(){
			this._currentContext.finish();
		}

		__proto.flush=function(){
			this._currentContext.flush();
		}

		__proto.framebufferRenderbuffer=function(target,attachment,renderbuffertarget,renderbuffer){
			this._currentContext.framebufferRenderbuffer(target,attachment,renderbuffertarget,renderbuffer);
		}

		__proto.framebufferTexture2D=function(target,attachment,textarget,texture,level){
			this._currentContext.framebufferTexture2D(target,attachment,textarget,texture,level);
		}

		__proto.frontFace=function(mode){
			return this._currentContext.frontFace(mode);
		}

		__proto.generateMipmap=function(target){
			return this._currentContext.generateMipmap(target);
		}

		__proto.getActiveAttrib=function(program,index){
			return this._currentContext.getActiveAttrib(program,index);
		}

		__proto.getActiveUniform=function(program,index){
			return this._currentContext.getActiveUniform(program,index);
		}

		__proto.getAttribLocation=function(program,name){
			return this._currentContext.getAttribLocation(program,name);
		}

		__proto.getParameter=function(pname){
			return this._currentContext.getParameter(pname);
		}

		__proto.getBufferParameter=function(target,pname){
			return this._currentContext.getBufferParameter(target,pname);
		}

		__proto.getError=function(){
			return this._currentContext.getError();
		}

		__proto.getFramebufferAttachmentParameter=function(target,attachment,pname){
			this._currentContext.getFramebufferAttachmentParameter(target,attachment,pname);
		}

		__proto.getProgramParameter=function(program,pname){
			return this._currentContext.getProgramParameter(program,pname);
		}

		__proto.getProgramInfoLog=function(program){
			return this._currentContext.getProgramInfoLog(program);
		}

		__proto.getRenderbufferParameter=function(target,pname){
			return this._currentContext.getRenderbufferParameter(target,pname);
		}

		__proto.getShaderPrecisionFormat=function(__arg){
			var arg=arguments;
			return this._currentContext.getShaderPrecisionFormat(arg);
		}

		__proto.getShaderParameter=function(shader,pname){
			this._currentContext.getShaderParameter(shader,pname);
		}

		__proto.getShaderInfoLog=function(shader){
			return this._currentContext.getShaderInfoLog(shader);
		}

		__proto.getShaderSource=function(shader){
			return this._currentContext.getShaderSource(shader);
		}

		__proto.getTexParameter=function(target,pname){
			this._currentContext.getTexParameter(target,pname);
		}

		__proto.getUniform=function(program,location){
			this._currentContext.getUniform(program,location);
		}

		__proto.getUniformLocation=function(program,name){
			return this._currentContext.getUniformLocation(program,name);
		}

		__proto.getVertexAttrib=function(index,pname){
			return this._currentContext.getVertexAttrib(index,pname);
		}

		__proto.getVertexAttribOffset=function(index,pname){
			return this._currentContext.getVertexAttribOffset(index,pname);
		}

		__proto.hint=function(target,mode){
			this._currentContext.hint(target,mode);
		}

		__proto.isBuffer=function(buffer){
			this._currentContext.isBuffer(buffer);
		}

		__proto.isEnabled=function(cap){
			this._currentContext.isEnabled(cap);
		}

		__proto.isFramebuffer=function(framebuffer){
			this._currentContext.isFramebuffer(framebuffer);
		}

		__proto.isProgram=function(program){
			this._currentContext.isProgram(program);
		}

		__proto.isRenderbuffer=function(renderbuffer){
			this._currentContext.isRenderbuffer(renderbuffer);
		}

		__proto.isShader=function(shader){
			this._currentContext.isShader(shader);
		}

		__proto.isTexture=function(texture){
			this._currentContext.isTexture(texture);
		}

		__proto.lineWidth=function(width){
			this._currentContext.lineWidth(width);
		}

		__proto.linkProgram=function(program){
			this._currentContext.linkProgram(program);
		}

		__proto.pixelStorei=function(pname,param){
			this._currentContext.pixelStorei(pname,param);
		}

		__proto.polygonOffset=function(factor,units){
			this._currentContext.polygonOffset(factor,units);
		}

		__proto.readPixels=function(x,y,width,height,format,type,pixels){
			this._currentContext.readPixels(x,y,width,height,format,type,pixels);
		}

		__proto.renderbufferStorage=function(target,internalformat,width,height){
			this._currentContext.renderbufferStorage(target,internalformat,width,height);
		}

		__proto.sampleCoverage=function(value,invert){
			this._currentContext.sampleCoverage(value,invert);
		}

		__proto.scissor=function(x,y,width,height){
			this._currentContext.scissor(x,y,width,height);
		}

		__proto.shaderSource=function(shader,source){
			this._currentContext.shaderSource(shader,source);
		}

		__proto.stencilFunc=function(func,ref,mask){
			this._currentContext.stencilFunc(func,ref,mask);
		}

		__proto.stencilFuncSeparate=function(face,func,ref,mask){
			this._currentContext.stencilFuncSeparate(face,func,ref,mask);
		}

		__proto.stencilMask=function(mask){
			this._currentContext.stencilMask(mask);
		}

		__proto.stencilMaskSeparate=function(face,mask){
			this._currentContext.stencilMaskSeparate(face,mask);
		}

		__proto.stencilOp=function(fail,zfail,zpass){
			this._currentContext.stencilOp(fail,zfail,zpass);
		}

		__proto.stencilOpSeparate=function(face,fail,zfail,zpass){
			this._currentContext.stencilOpSeparate(face,fail,zfail,zpass);
		}

		__proto.texImage2D=function(__args){
			var args=arguments;
			this._currentContext.texImage2D.apply(this._currentContext,args);
		}

		__proto.texParameterf=function(target,pname,param){
			this._currentContext.texParameterf(target,pname,param);
		}

		__proto.texParameteri=function(target,pname,param){
			this._currentContext.texParameteri(target,pname,param);
		}

		__proto.texSubImage2D=function(__args){
			var args=arguments;
			this._currentContext.texSubImage2D.apply(this._currentContext,args);
		}

		__proto.uniform1f=function(location,x){
			this._currentContext.uniform1f(location,x);
		}

		__proto.uniform1fv=function(location,v){
			this._currentContext.uniform1fv(location,v);
		}

		__proto.uniform1i=function(location,x){
			this._currentContext.uniform1i(location,x);
		}

		__proto.uniform1iv=function(location,v){
			this._currentContext.uniform1iv(location,v);
		}

		__proto.uniform2f=function(location,x,y){
			this._currentContext.uniform2f(location,x,y);
		}

		__proto.uniform2fv=function(location,v){
			this._currentContext.uniform2fv(location,v);
		}

		__proto.uniform2i=function(location,x,y){
			this._currentContext.uniform2i(location,x,y);
		}

		__proto.uniform2iv=function(location,v){
			this._currentContext.uniform2iv(location,v);
		}

		__proto.uniform3f=function(location,x,y,z){
			this._currentContext.uniform3f(location,x,y,z);
		}

		__proto.uniform3fv=function(location,v){
			this._currentContext.uniform3fv(location,v);
		}

		__proto.uniform3i=function(location,x,y,z){
			this._currentContext.uniform3i(location,x,y,z);
		}

		__proto.uniform3iv=function(location,v){
			this._currentContext.uniform3iv(location,v);
		}

		__proto.uniform4f=function(location,x,y,z,w){
			this._currentContext.uniform4f(location,x,y,z,w);
		}

		__proto.uniform4fv=function(location,v){
			this._currentContext.uniform4fv(location,v);
		}

		__proto.uniform4i=function(location,x,y,z,w){
			this._currentContext.uniform4i(location,x,y,z,w);
		}

		__proto.uniform4iv=function(location,v){
			this._currentContext.uniform4iv(location,v);
		}

		__proto.uniformMatrix2fv=function(location,transpose,value){
			this._currentContext.uniformMatrix2fv(location,transpose,value);
		}

		__proto.uniformMatrix3fv=function(location,transpose,value){
			this._currentContext.uniformMatrix3fv(location,transpose,value);
		}

		__proto.uniformMatrix4fv=function(location,transpose,value){
			this._currentContext.uniformMatrix4fv(location,transpose,value);
		}

		__proto.useProgram=function(program){
			this._currentContext.useProgram(program);
		}

		__proto.validateProgram=function(program){
			this._currentContext.validateProgram(program);
		}

		__proto.vertexAttrib1f=function(indx,x){
			this._currentContext.vertexAttrib1f(indx,x);
		}

		__proto.vertexAttrib1fv=function(indx,values){
			this._currentContext.vertexAttrib1fv(indx,values);
		}

		__proto.vertexAttrib2f=function(indx,x,y){
			this._currentContext.vertexAttrib2f(indx,x,y);
		}

		__proto.vertexAttrib2fv=function(indx,values){
			this._currentContext.vertexAttrib2fv(indx,values);
		}

		__proto.vertexAttrib3f=function(indx,x,y,z){
			this._currentContext.vertexAttrib3f(indx,x,y,z);
		}

		__proto.vertexAttrib3fv=function(indx,values){
			this._currentContext.vertexAttrib3fv(indx,values);
		}

		__proto.vertexAttrib4f=function(indx,x,y,z,w){
			this._currentContext.vertexAttrib4f(indx,x,y,z,w);
		}

		__proto.vertexAttrib4fv=function(indx,values){
			this._currentContext.vertexAttrib4fv(indx,values);
		}

		__proto.vertexAttribPointer=function(indx,size,type,normalized,stride,offset){
			this._currentContext.vertexAttribPointer(indx,size,type,normalized,stride,offset);
		}

		__proto.viewport=function(x,y,width,height){
			this._currentContext.viewport(x,y,width,height);
		}

		__proto.configureBackBuffer=function(width,height,antiAlias,enableDepthAndStencil,wantsBestResolution){
			(enableDepthAndStencil===void 0)&& (enableDepthAndStencil=true);
			(wantsBestResolution===void 0)&& (wantsBestResolution=false);
			this._currentContext.configureBackBuffer(width,height,antiAlias,enableDepthAndStencil,wantsBestResolution);
		}

		__proto.compressedTexImage2D=function(__args){
			var args=arguments;
			this._currentContext.compressedTexImage2D.apply(this._currentContext,args);
		}

		__proto.uniformMatrix2fvEx=function(location,transpose,value){
			this._currentContext.uniformMatrix2fvEx(location,transpose,value);
		}

		__proto.uniformMatrix3fvEx=function(location,transpose,value){
			this._currentContext.uniformMatrix3fvEx(location,transpose,value);
		}

		__proto.uniformMatrix4fvEx=function(location,transpose,value){
			this._currentContext.uniformMatrix4fvEx(location,transpose,value);
		}

		__proto.addShaderAttribute=function(one){
			this._currentContext.addShaderAttribute(one);
		}

		__proto.addShaderUniform=function(one){
			this._currentContext.addShaderUniform(one);
		}

		__proto.uploadShaderAttributes=function(commandEncoder,data){
			this._currentContext.uploadShaderAttributes(commandEncoder,data);
			return 0;
		}

		__proto.uploadShaderUniforms=function(commandEncoder,data){
			this._currentContext.uploadShaderUniforms(commandEncoder,data);
			return 0;
		}

		__proto.setValueWithShareData=function(valueID,dataOffset,operateType){
			this._currentContext.setValueWithShareData(valueID,dataOffset,operateType);
		}

		__proto.useCommandEncoder=function(id){
			this._currentContext.useCommandEncoder(id);
		}

		__proto.createProgramEx=function(vs,ps,attribBindingInfo){
			return this._currentContext.createProgramEx(vs,ps,attribBindingInfo);
		}

		__proto.createVDO=function(data){
			return this._currentContext.createVDO(data);
		}

		__proto.createVertexDesc=function(desc){
			return this._currentContext.createVertexDesc(desc);
		}

		__proto.useProgramEx=function(nProgramID){
			this._currentContext.useProgramEx(nProgramID);
		}

		__proto.useVDO=function(nVDOID){
			this._currentContext.useVAO(nVDOID);
		}

		__proto.uniformEx=function(nValueID,sUniformName){
			this._currentContext.uniformEx(nValueID,sUniformName);
		}

		__proto.setRectMesh=function(data){
			this._currentContext.setRectMesh(data);
		}

		__proto.modifyMesh=function(nValueID,nVertexDescID,operatorType){
			this._currentContext.modifyMesh(nValueID,nVertexDescID,operatorType);
		}

		__proto.uniformTexture=function(name,type,texLocation,texture){
			this._currentContext.uniformTexture(name,type,texLocation,texture);
		}

		__proto.setValue=function(valueID,data,operateType){
			this._currentContext.setValue(valueID,data,operateType);
		}

		__proto.setValue1i=function(valueID,operateType,value){
			this._currentContext.setValue1i(valueID,operateType,value);
		}

		__proto.setValue2i=function(valueID,operateType,value1,value2){
			this._currentContext.setValue2i(valueID,operateType,value1,value2);
		}

		__proto.setValue3i=function(valueID,operateType,value1,value2,value3){
			this._currentContext.setValue3i(valueID,operateType,value1,value2,value3);
		}

		__proto.setValue4i=function(valueID,operateType,value1,value2,value3,value4){
			this._currentContext.setValue4i(valueID,operateType,value1,value2,value3,value4);
		}

		__proto.setValue1f=function(valueID,operateType,value){
			this._currentContext.setValue1f(valueID,operateType,value);
		}

		__proto.setValue2f=function(valueID,operateType,value1,value2){
			this._currentContext.setValue2f(valueID,operateType,value1,value2);
		}

		__proto.setValue3f=function(valueID,operateType,value1,value2,value3){
			this._currentContext.setValue3f(valueID,operateType,value1,value2,value3);
		}

		__proto.setValue4f=function(valueID,operateType,value1,value2,value3,value4){
			this._currentContext.setValue4f(valueID,operateType,value1,value2,value3,value4);
		}

		__proto.setShareData=function(dataID,offset){
			this._currentContext.setShareData(dataID,offset);
		}

		__proto.setMesh=function(vbdata,ibdata){
			this._currentContext.setMesh(vbdata,ibdata);
		}

		__proto.setShaderDefine=function(sValue){
			this._currentContext.setShaderDefine(sValue);
		}

		__proto.forceNoMerge=function(){
			this._currentContext.forceNoMerge();
		}

		__proto.calcLocalMatrix32=function(transformFlag,matrixResultID,x,y,pivotX,pivotY,scaleX,scaleY,skewX,skewY,rotate){
			this._currentContext.calcLocalMatrix32(transformFlag,matrixResultID,x,y,pivotX,pivotY,scaleX,scaleY,skewX,skewY,rotate);
		}

		LayaGL.__init__=function(){
			if (Render.isConchApp){
				LayaGL._syncBufferList=new Int32Array(LayaGL._syncBufferSize);
				LayaGL._syncBufferList["conchRef"]=window.conch.createArrayBufferRef(LayaGL._syncBufferList,0,false);
				LayaGL._syncBufferList["_ptrID"]=LayaGL._syncBufferList["conchRef"].id;
			}
		}

		LayaGL.createArrayBufferRef=function(arrayBuffer,type,syncRender){
			var bufferConchRef=window.conch.createArrayBufferRef(arrayBuffer,type,syncRender);
			if (syncRender==true && bufferConchRef.id >=LayaGL._syncBufferSize){
				var pre=LayaGL._syncBufferList;
				var preConchRef=LayaGL._syncBufferList["conchRef"];
				var prePtrID=LayaGL._syncBufferList["_ptrID"];
				LayaGL._syncBufferSize+=4096;
				LayaGL._syncBufferList=new Int32Array(LayaGL._syncBufferSize);
				LayaGL._syncBufferList["conchRef"]=preConchRef;
				LayaGL._syncBufferList["_ptrID"]=prePtrID;
				pre && LayaGL._syncBufferList.set(pre,0);
				window.conch.updateArrayBufferRef(LayaGL._syncBufferList["_ptrID"],false,LayaGL._syncBufferList);
			}
			arrayBuffer["conchRef"]=bufferConchRef;
			arrayBuffer["_ptrID"]=bufferConchRef.id;
			return bufferConchRef;
		}

		LayaGL.syncBufferToRenderThread=function(id){
			LayaGL._syncBufferList[id]=LayaGL._frameCount;
		}

		LayaGL._SYNC_ARRAYBUFFER_SIZE_=4096;
		LayaGL._syncBufferSize=4096;
		LayaGL._syncBufferList=null
		LayaGL._frameCount=0;
		LayaGL._tempGLEncoder=null;
		LayaGL.instance=null
		LayaGL.VALUE_OPERATE_EXECUTE_JS_THREAD_BUFFER=0;
		LayaGL.VALUE_OPERATE_EXECUTE_RENDER_THREAD_BUFFER=1;
		LayaGL.VALUE_OPERATE_EXECUTE_COPY_TO_RENDER=2;
		LayaGL.VALUE_OPERATE_ADD=3;
		LayaGL.VALUE_OPERATE_SUB=4;
		LayaGL.VALUE_OPERATE_MUL=5;
		LayaGL.VALUE_OPERATE_DIV=6;
		LayaGL.VALUE_OPERATE_M2_MUL=7;
		LayaGL.VALUE_OPERATE_M3_MUL=8;
		LayaGL.VALUE_OPERATE_M4_MUL=9;
		LayaGL.VALUE_OPERATE_M32_MUL=10;
		return LayaGL;
	})()


	/**
	*@private
	*快速节点命令执行器
	*多个指令组合才有意义，单个指令没必要在下面加
	*/
	//class laya.renders.layagl.LayaGLQuickRunner
	var LayaGLQuickRunner=(function(){
		function LayaGLQuickRunner(){};
		__class(LayaGLQuickRunner,'laya.renders.layagl.LayaGLQuickRunner');
		LayaGLQuickRunner.__init__=function(){
			return;
			LayaGLQuickRunner.map[0x01 | 0x02 | 0x200]=LayaGLQuickRunner.alpha_transform_drawLayaGL;
			LayaGLQuickRunner.map[0x01 | 0x200]=LayaGLQuickRunner.alpha_drawLayaGL;
			LayaGLQuickRunner.map[0x02 | 0x200]=LayaGLQuickRunner.transform_drawLayaGL;
			LayaGLQuickRunner.map[0x02 | 0x2000]=LayaGLQuickRunner.transform_drawNodes;
			LayaGLQuickRunner.map[0x01 | 0x02 | 0x100]=LayaGLQuickRunner.alpha_transform_drawTexture;
			LayaGLQuickRunner.map[0x01 | 0x100]=LayaGLQuickRunner.alpha_drawTexture;
			LayaGLQuickRunner.map[0x02 | 0x100]=LayaGLQuickRunner.transform_drawTexture;
			LayaGLQuickRunner.map[0x200 | 0x2000]=LayaGLQuickRunner.drawLayaGL_drawNodes;
		}

		LayaGLQuickRunner.transform_drawTexture=function(sprite,context,x,y){
			var style=sprite._style;
			var tex=sprite.texture;
			context.saveTransform(LayaGLQuickRunner.curMat);
			context.transformByMatrix(sprite.transform,x+style.pivotX,y+style.pivotY);
			context.drawTexture(tex,-style.pivotX,-style.pivotY,tex.width,tex.height);
			context.restoreTransform(LayaGLQuickRunner.curMat);
		}

		LayaGLQuickRunner.alpha_drawTexture=function(sprite,context,x,y){
			var style=sprite._style;
			var alpha=NaN;
			var tex=sprite.texture;
			if ((alpha=style.alpha)> 0.01 || sprite._needRepaint()){
				var temp=context.globalAlpha;
				context.globalAlpha *=alpha;
				context.drawTexture(tex,-style.pivotX,-style.pivotY,tex.width,tex.height);
				context.globalAlpha=temp;
			}
		}

		LayaGLQuickRunner.alpha_transform_drawTexture=function(sprite,context,x,y){
			var style=sprite._style;
			var alpha=NaN;
			var tex=sprite.texture;
			if ((alpha=style.alpha)> 0.01 || sprite._needRepaint()){
				var temp=context.globalAlpha;
				context.globalAlpha *=alpha;
				context.saveTransform(LayaGLQuickRunner.curMat);
				context.transformByMatrix(sprite.transform,x+style.pivotX,y+style.pivotY);
				context.drawTexture(tex,-style.pivotX,-style.pivotY,tex.width,tex.height);
				context.restoreTransform(LayaGLQuickRunner.curMat);
				context.globalAlpha=temp;
			}
		}

		LayaGLQuickRunner.alpha_transform_drawLayaGL=function(sprite,context,x,y){
			var style=sprite._style;
			var alpha=NaN;
			if ((alpha=style.alpha)> 0.01 || sprite._needRepaint()){
				var temp=context.globalAlpha;
				var transform=sprite.transform;
				context.globalAlpha *=alpha;
				context.saveTransform(LayaGLQuickRunner.curMat);
				context.transformByMatrix(sprite.transform,x+style.pivotX,y+style.pivotY);
				sprite._graphics && sprite._graphics._render(sprite,context,-style.pivotX,-style.pivotY);
				context.restoreTransform(LayaGLQuickRunner.curMat);
				context.globalAlpha=temp;
			}
		}

		LayaGLQuickRunner.alpha_drawLayaGL=function(sprite,context,x,y){
			var style=sprite._style;
			var alpha=NaN;
			if ((alpha=style.alpha)> 0.01 || sprite._needRepaint()){
				var temp=context.globalAlpha;
				context.globalAlpha *=alpha;
				sprite._graphics && sprite._graphics._render(sprite,context,x,y);
				context.globalAlpha=temp;
			}
		}

		LayaGLQuickRunner.transform_drawLayaGL=function(sprite,context,x,y){
			var style=sprite._style;
			var transform=sprite.transform;
			context.saveTransform(LayaGLQuickRunner.curMat);
			context.transformByMatrix(sprite.transform,x+style.pivotX,y+style.pivotY);
			sprite._graphics && sprite._graphics._render(sprite,context,-style.pivotX,-style.pivotY);
			context.restoreTransform(LayaGLQuickRunner.curMat);
		}

		LayaGLQuickRunner.transform_drawNodes=function(sprite,context,x,y){
			var transform=sprite.transform;
			var style=sprite._style;
			context.saveTransform(LayaGLQuickRunner.curMat);
			context.transformByMatrix(sprite.transform,x+style.pivotX,y+style.pivotY);
			x=-style.pivotX;
			y=-style.pivotY;
			var childs=sprite._children,n=childs.length,ele;
			if (style.viewport){
				var rect=style.viewport;
				var left=rect.x;
				var top=rect.y;
				var right=rect.right;
				var bottom=rect.bottom;
				var _x=NaN,_y=NaN;
				for (i=0;i < n;++i){
					if ((ele=childs [i])._visible && ((_x=ele._x)< right && (_x+ele.width)> left && (_y=ele._y)< bottom && (_y+ele.height)> top)){
						ele.render(context,x,y);
					}
				}
				}else {
				for (var i=0;i < n;++i)
				(ele=(childs [i]))._visible && ele.render(context,x,y);
			}
			context.restoreTransform(LayaGLQuickRunner.curMat);
		}

		LayaGLQuickRunner.drawNode=function(renderData,x,y){
			debugger;
		}

		LayaGLQuickRunner.drawLayaGL=function(sprite,context,x,y){
			sprite._graphics && sprite._graphics._render(sprite,context,x,y);
		}

		LayaGLQuickRunner.drawLayaGL_drawNodes=function(sprite,context,x,y){
			sprite._graphics && sprite._graphics._render(sprite,context,x,y);
			var style=sprite._style;
			var childs=sprite._children,n=childs.length,ele;
			if (style.viewport){
				var rect=style.viewport;
				var left=rect.x;
				var top=rect.y;
				var right=rect.right;
				var bottom=rect.bottom;
				var _x=NaN,_y=NaN;
				for (i=0;i < n;++i){
					if ((ele=childs [i])._visible && ((_x=ele._x)< right && (_x+ele.width)> left && (_y=ele._y)< bottom && (_y+ele.height)> top)){
						ele.render(context,x,y);
					}
				}
				}else {
				for (var i=0;i < n;++i)
				(ele=(childs [i]))._visible && ele.render(context,x,y);
			}
		}

		LayaGLQuickRunner.map={};
		__static(LayaGLQuickRunner,
		['curMat',function(){return this.curMat=new Matrix();}
		]);
		return LayaGLQuickRunner;
	})()


	/**
	*@private
	*普通命令执行器
	*/
	//class laya.renders.layagl.LayaGLRunner
	var LayaGLRunner=(function(){
		function LayaGLRunner(){};
		__class(LayaGLRunner,'laya.renders.layagl.LayaGLRunner');
		LayaGLRunner.uploadShaderAttributes=function(layaGL,commandEncoder,data){
			var attributeParamsMap=commandEncoder._buffer;
			var value;
			var one,shaderCall=0;
			for (var i=0,n=attributeParamsMap.length;i < n;i++){
				one=attributeParamsMap[i];
				value=data[one.dataOffset];
				if (value !=null)
					shaderCall+=one.fun.call(one.caller,one,value);
			}
			return shaderCall;
		}

		LayaGLRunner.uploadShaderUniforms=function(layaGL,commandEncoder,data,uploadUnTexture){
			var shaderUniform=commandEncoder._buffer;
			var shaderCall=0;
			for (var i=0,n=shaderUniform.length;i < n;i++){
				var one=shaderUniform[i];
				if (uploadUnTexture || one.textureID!==-1){
					var value=data[one.dataOffset];
					if (value !=null)
						shaderCall+=one.fun.call(one.caller,one,value);
				}
			}
			return shaderCall;
		}

		LayaGLRunner.uploadCustomUniform=function(layaGL,custom,index,data){
			var shaderCall=0;
			var one=custom[index];
			if (one && data !=null)
				shaderCall+=one.fun.call(one.caller,one,data);
			return shaderCall;
		}

		LayaGLRunner.uploadShaderAttributesForNative=function(layaGL,commandEncoder,data){
			return layaGL.uploadShaderAttributes(commandEncoder,data);
		}

		LayaGLRunner.uploadShaderUniformsForNative=function(layaGL,commandEncoder,data){
			return layaGL.uploadShaderUniforms(commandEncoder,data);
		}

		return LayaGLRunner;
	})()


	/**
	*...
	*@author James
	*/
	//class laya.renders.layagl.LayaNative2D
	var LayaNative2D=(function(){
		function LayaNative2D(){}
		__class(LayaNative2D,'laya.renders.layagl.LayaNative2D');
		LayaNative2D.__init__=function(){
			if (Render.isConchApp){
				LayaNative2D.VALUEMATRIX32=LayaGL.instance.addValueDefine(0,0x1406,6,new Float32Array([1,0,0,1,0,0]));
				LayaNative2D.VALUEALPHA=LayaGL.instance.addValueDefine(1,0x1406,1,new Float32Array([1]));
				LayaGL.instance.endValueDefine();
				LayaNative2D.PROGRAMEX_DRAWTEXTURE=LayaGL.instance.createProgramEx("attribute vec2 position; \
				attribute vec2 texcoord;\
				uniform vec4 u_view;\
				varying vec2 v_texCoord;\
				void main()\
				{\
					vec4 tPos=vec4(position.xy,0.,1. );\
					float cx=(tPos.x*2.0/u_view.x)-1.0;\
					float cy=-(tPos.y*2.0/u_view.y)+1.0;\
					gl_Position=vec4(cx,cy,0.5,1.0);\
					v_texCoord=texcoord;\
				}",
				"precision mediump float;\
				uniform float u_alpha;\
				varying vec2 v_texCoord;\
				uniform sampler2D u_tex;\
				void main()\
				{\
					gl_FragColor=texture2D(u_tex,v_texCoord.xy);\
				}","position,texcoord");
				LayaNative2D.VAO_XYUV=LayaGL.instance.createVDO(new Int32Array([0x1406,0,2,16,0x1406,8,2,16,]));
				LayaGLTemplate.__init__();
			}
		}

		LayaNative2D.PROGRAMEX_DRAWTEXTURE=0;
		LayaNative2D.VAO_XYUV=0;
		LayaNative2D.VERTEXDESC_XYUV=0;
		LayaNative2D.VALUEVIEWS=1;
		LayaNative2D.VALUEMATRIX32=0;
		LayaNative2D.VALUEALPHA=0;
		return LayaNative2D;
	})()


	/**
	*@private
	*精灵参数数据
	*/
	//class laya.renders.layagl.ParamData
	var ParamData=(function(){
		function ParamData(sz){
			this._data=null;
			this._int32Data=null;
			this._float32Data=null;
			this._data=new ArrayBuffer(sz *4);
			this._int32Data=new Int32Array(this._data);
			this._float32Data=new Float32Array(this._data);
			if (Render.isConchApp){
				LayaGL.createArrayBufferRef(this._data,0,false);
			}
		}

		__class(ParamData,'laya.renders.layagl.ParamData');
		var __proto=ParamData.prototype;
		__proto.setI=function(name,value){
			this._int32Data[SpriteConst.SPRITE_DATA[name]]=value;
		}

		__proto.getI=function(name){
			return this._int32Data[SpriteConst.SPRITE_DATA[name]];
		}

		__proto.setF=function(name,value){
			this._float32Data[SpriteConst.SPRITE_DATA[name]]=value;
		}

		__proto.getF=function(name){
			return this._float32Data[SpriteConst.SPRITE_DATA[name]];
		}

		__proto.setColor=function(name,value){
			this._int32Data[SpriteConst.SPRITE_DATA[name]]=Color.create(value).numColor;
		}

		ParamData.create=function(sz){
			return new ParamData(sz);
		}

		ParamData._pool=[];
		return ParamData;
	})()


	/**
	*@private
	*<code>Render</code> 是渲染管理类。它是一个单例，可以使用 Laya.render 访问。
	*/
	//class laya.renders.Render
	var Render=(function(){
		function Render(width,height){
			this._timeId=0;
			var style=Render._mainCanvas.source.style;
			style.position='absolute';
			style.top=style.left="0px";
			style.background="#000000";
			Render._mainCanvas.source.id="layaCanvas";
			var isWebGl=laya.renders.Render.isWebGL;
			Render._mainCanvas.source.width=width;
			Render._mainCanvas.source.height=height;
			isWebGl && Render.WebGL.init(Render._mainCanvas,width,height);
			Browser.container.appendChild(Render._mainCanvas.source);
			function getContext (width,height,canvas){
				if (canvas){
					Render._context=canvas.getContext('2d');
					Render._context.__tx=0;
					Render._context.__ty=0;
					}else {
					canvas=HTMLCanvas.create("3D");
					Render._context=RunDriver.createWebGLContext2D(canvas);
					canvas._setContext(Render._context);
				}
				canvas.size(width,height);
				return Render._context;
			}
			Render._context=getContext(width,height,isWebGl ? null :Render._mainCanvas);
			Render._context.setIsMainContext();
			Browser.window.requestAnimationFrame(loop);
			function loop (){
				Laya.stage._loop();
				Browser.window.requestAnimationFrame(loop);
			}
			Laya.stage.on("visibilitychange",this,this._onVisibilitychange);
		}

		__class(Render,'laya.renders.Render');
		var __proto=Render.prototype;
		/**@private */
		__proto._onVisibilitychange=function(){
			if (!Laya.stage.isVisibility){
				this._timeId=Browser.window.setInterval(this._enterFrame,1000);
				}else if (this._timeId !=0){
				Browser.window.clearInterval(this._timeId);
			}
		}

		/**@private */
		__proto._enterFrame=function(e){
			Laya.stage._loop();
		}

		/**目前使用的渲染器。*/
		__getset(1,Render,'context',function(){
			return Render._context;
		});

		/**渲染使用的原生画布引用。 */
		__getset(1,Render,'canvas',function(){
			return Render._mainCanvas.source;
		});

		Render._context=null
		Render._mainCanvas=null
		Render.WebGL=null
		Render.isConchApp=false;
		Render.isWebGL=false;
		Render.is3DMode=false;
		Render.optimizeTextureMemory=function(url,texture){
			return true;
		}

		Render.__init$=function(){{
				Render.isConchApp=(window.conch !=null);
			};;
		}

		return Render;
	})()


	/**
	*@private
	*渲染环境
	*/
	//class laya.renders.RenderContext
	var RenderContext=(function(){
		function RenderContext(width,height,canvas){
			this.x=0;
			this.y=0;
			//this.canvas=null;
			//this.ctx=null;
			this._drawTexture=function(x,y,args){}
			this._fillTexture=function(x,y,args){
				if (args[0]._loaded)this.ctx.fillTexture(args[0],args[1]+x,args[2]+y,args[3],args[4],args[5],args[6],args[7]);
			}
			this._drawTextureWithTransform=function(x,y,args){
				if (args[0]._loaded)this.ctx.drawTextureWithTransform(args[0],args[1],args[2],args[3],args[4],args[5],x,y,args[6],args[7]);
			}
			this._fillQuadrangle=function(x,y,args){
				this.ctx.fillQuadrangle(args[0],args[1],args[2],args[3],args[4]);
			}
			this._drawPie=function(x,y,args){
				var ctx=this.ctx;
				Render.isWebGL && ctx.setPathId(args[8]);
				ctx.beginPath();
				if (Render.isWebGL){
					ctx.movePath(args[0]+x,args[1]+y);
					ctx.moveTo(0,0);
					}else {
					ctx.moveTo(x+args[0],y+args[1]);
				}
				ctx.arc(x+args[0],y+args[1],args[2],args[3],args[4]);
				ctx.closePath();
				this._fillAndStroke(args[5],args[6],args[7],true);
			}
			this._clipRect=function(x,y,args){
				this.ctx.clipRect(x+args[0],y+args[1],args[2],args[3]);
			}
			this._fillRect=function(x,y,args){
				this.ctx._drawRect(x+args[0],y+args[1],args[2],args[3],args[4]);
			}
			this._setShader=function(x,y,args){
				this.ctx.setShader(args[0]);
			}
			this._drawLine=function(x,y,args){
				var ctx=this.ctx;
				Render.isWebGL && ctx.setPathId(args[6]);
				ctx.beginPath();
				ctx.strokeStyle=args[4];
				ctx.lineWidth=args[5];
				if (Render.isWebGL){
					ctx.movePath(x,y);
					ctx.moveTo(args[0],args[1]);
					ctx.lineTo(args[2],args[3]);
					}else {
					ctx.moveTo(x+args[0],y+args[1]);
					ctx.lineTo(x+args[2],y+args[3]);
				}
				ctx.stroke();
			}
			this._drawLines=function(x,y,args){
				var ctx=this.ctx;
				Render.isWebGL && ctx.setPathId(args[5]);
				ctx.beginPath();
				x+=args[0],y+=args[1];
				Render.isWebGL && ctx.movePath(x,y);
				ctx.strokeStyle=args[3];
				ctx.lineWidth=args[4];
				var points=args[2];
				var i=2,n=points.length;
				if (Render.isWebGL){
					ctx.moveTo(points[0],points[1]);
					while (i < n){
						ctx.lineTo(points[i++],points[i++]);
					}
					}else {
					ctx.moveTo(x+points[0],y+points[1]);
					while (i < n){
						ctx.lineTo(x+points[i++],y+points[i++]);
					}
				}
				ctx.stroke();
			}
			this._drawLinesWebGL=function(x,y,args){
				this.ctx.drawLines(x+this.x+args[0],y+this.y+args[1],args[2],args[3],args[4]);
			}
			this._drawCurves=function(x,y,args){}
			this._draw=function(x,y,args){
				args[0].call(null,this,x,y);
			}
			this._transformByMatrix=function(x,y,args){
				this.ctx.transformByMatrix(args[0]);
			}
			this._setTransform=function(x,y,args){
				this.ctx.setTransform(args[0],args[1],args[2],args[3],args[4],args[5]);
			}
			this._setTransformByMatrix=function(x,y,args){
				this.ctx.setTransformByMatrix(args[0]);
			}
			this._save=function(x,y,args){
				this.ctx.save();
			}
			this._restore=function(x,y,args){
				this.ctx.restore();
			}
			this._translate=function(x,y,args){
				this.ctx.translate(args[0],args[1]);
			}
			this._transform=function(x,y,args){
				this.ctx.translate(args[1]+x,args[2]+y);
				var mat=args[0];
				this.ctx.transform(mat.a,mat.b,mat.c,mat.d,mat.tx,mat.ty);
				this.ctx.translate(-x-args[1],-y-args[2]);
			}
			this._rotate=function(x,y,args){
				this.ctx.translate(args[1]+x,args[2]+y);
				this.ctx.rotate(args[0]);
				this.ctx.translate(-x-args[1],-y-args[2]);
			}
			this._scale=function(x,y,args){
				this.ctx.translate(args[2]+x,args[3]+y);
				this.ctx.scale(args[0],args[1]);
				this.ctx.translate(-x-args[2],-y-args[3]);
			}
			this._alpha=function(x,y,args){
				this.ctx.globalAlpha *=args[0];
			}
			this._setAlpha=function(x,y,args){
				this.ctx.globalAlpha=args[0];
			}
			this._fillText=function(x,y,args){
				this.ctx.drawText(args[0],args[1]+x,args[2]+y,args[3],args[4],args[5]);
			}
			this._strokeText=function(x,y,args){
				this.ctx.strokeWord(args[0],args[1]+x,args[2]+y,args[3],args[4],args[5],args[6]);
			}
			this._fillBorderText=function(x,y,args){
				this.ctx.fillBorderText(args[0],args[1]+x,args[2]+y,args[3],args[4],args[5],args[6],args[7]);
			}
			this._fillWords=function(x,y,args){
				this.ctx.fillWords(args[0],args[1]+x,args[2]+y,args[3],args[4]);
			}
			this._fillBorderWords=function(x,y,args){
				this.ctx.fillBorderWords(args[0],args[1]+x,args[2]+y,args[3],args[4],args[5],args[6]);
			}
			this._blendMode=function(x,y,args){
				this.ctx.globalCompositeOperation=args[0];
			}
			this._beginClip=function(x,y,args){
				this.ctx.beginClip && this.ctx.beginClip(x+args[0],y+args[1],args[2],args[3]);
			}
			this._setIBVB=function(x,y,args){
				this.ctx.setIBVB(args[0]+x,args[1]+y,args[2],args[3],args[4],args[5],args[6],args[7]);
			}
			this._fillTrangles=function(x,y,args){
				this.ctx.fillTrangles(args[0],args[1]+x,args[2]+y,args[3],args[4]);
			}
			this._drawPath=function(x,y,args){
				var ctx=this.ctx;
				Render.isWebGL && ctx.setPathId(-1);
				ctx.beginPath();
				x+=args[0],y+=args[1];
				var paths=args[2];
				for (var i=0,n=paths.length;i < n;i++){
					var path=paths[i];
					switch (path[0]){
						case "moveTo":
							ctx.moveTo(x+path[1],y+path[2]);
							break ;
						case "lineTo":
							ctx.lineTo(x+path[1],y+path[2]);
							break ;
						case "arcTo":
							ctx.arcTo(x+path[1],y+path[2],x+path[3],y+path[4],path[5]);
							break ;
						case "closePath":
							ctx.closePath();
							break ;
						}
				};
				var brush=args[3];
				if (brush !=null){
					ctx.fillStyle=brush.fillStyle;
					ctx.fill();
				};
				var pen=args[4];
				if (pen !=null){
					ctx.strokeStyle=pen.strokeStyle;
					ctx.lineWidth=pen.lineWidth || 1;
					ctx.lineJoin=pen.lineJoin;
					ctx.lineCap=pen.lineCap;
					ctx.miterLimit=pen.miterLimit;
					ctx.stroke();
				}
			}
			this.drawPoly=function(x,y,args){
				this.ctx.drawPoly(x+this.x+args[0],y+this.y+args[1],args[2],args[3],args[4],args[5],args[6]);
			}
			this._drawPoly=function(x,y,args){
				var ctx=this.ctx;
				var points=args[2];
				var i=2,n=points.length;
				if (Render.isWebGL){
					ctx.setPathId(args[6]);
					ctx.beginPath();
					x+=args[0],y+=args[1];
					ctx.movePath(x,y);
					ctx.moveTo(points[0],points[1]);
					while (i < n){
						ctx.lineTo(points[i++],points[i++]);
					}
					}else {
					ctx.beginPath();
					x+=args[0],y+=args[1];
					ctx.moveTo(x+points[0],y+points[1]);
					while (i < n){
						ctx.lineTo(x+points[i++],y+points[i++]);
					}
				}
				ctx.closePath();
				this._fillAndStroke(args[3],args[4],args[5],args[7]);
			}
			this._drawSkin=function(x,y,args){
				var tSprite=args[0];
				if (tSprite){
					var ctx=this.ctx;
					tSprite.render(ctx,x,y);
				}
			}
			this._drawParticle=function(x,y,args){
				this.ctx.drawParticle(x+this.x,y+this.y,args[0]);
			}
			if (canvas){
				this.ctx=canvas.getContext('2d');
				}else {
				canvas=HTMLCanvas.create("3D");
				this.ctx=RunDriver.createWebGLContext2D(canvas);
				canvas._setContext(this.ctx);
			}
			canvas.size(width,height);
			this.canvas=canvas;
		}

		__class(RenderContext,'laya.renders.RenderContext');
		var __proto=RenderContext.prototype;
		/**销毁当前渲染环境*/
		__proto.destroy=function(){
			if (this.canvas){
				this.canvas.destroy();
				this.canvas=null;
			}
			if (this.ctx){
				this.ctx.destroy();
				this.ctx=null;
			}
		}

		__proto.drawTexture=function(tex,x,y,width,height){}
		//if (args[0]._loaded)this.ctx.drawTexture(args[0],args[1],args[2],args[3],args[4],x,y);
		__proto._drawTextures=function(x,y,args){
			if (args[0]._loaded)this.ctx.drawTextures(args[0],args[1],x+this.x,y+this.y);
		}

		__proto.fillQuadrangle=function(tex,x,y,point4,m){
			this.ctx.fillQuadrangle(tex,x,y,point4,m);
		}

		__proto.drawCanvas=function(canvas,x,y,width,height){
			this.ctx.drawCanvas(canvas,x+this.x,y+this.y,width,height);
		}

		__proto.drawRect=function(x,y,width,height,fillColor,lineColor,lineWidth){
			var ctx=this.ctx;
			if (fillColor !=null){
				ctx.fillStyle=fillColor;
				ctx.fillRect(x,y,width,height);
			}
			if (lineColor !=null){
				ctx.strokeStyle=lineColor;
				ctx.lineWidth=lineWidth;
				ctx.strokeRect(x,y,width,height);
			}
		}

		__proto._fillAndStroke=function(fillColor,strokeColor,lineWidth,isConvexPolygon){
			(isConvexPolygon===void 0)&& (isConvexPolygon=false);
			var ctx=this.ctx;
			if (fillColor !=null){
				ctx.fillStyle=fillColor;
				if (Render.isWebGL){
					ctx.fill(isConvexPolygon);
					}else {
					ctx.fill();
				}
			}
			if (strokeColor !=null && lineWidth > 0){
				ctx.strokeStyle=strokeColor;
				ctx.lineWidth=lineWidth;
				ctx.stroke();
			}
		}

		//ctx.translate(-x-args[0],-y-args[1]);
		__proto.clipRect=function(x,y,width,height){
			this.ctx.clipRect(x+this.x,y+this.y,width,height);
		}

		__proto.fillRect=function(x,y,width,height,fillStyle){
			this.ctx._drawRect(x+this.x,y+this.y,width,height,fillStyle);
		}

		__proto.drawCircle=function(x,y,radius,color,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			Stat.drawCall++;
			var ctx=this.ctx;
			ctx.beginPath();
			ctx.strokeStyle=color;
			ctx.lineWidth=lineWidth;
			ctx.arc(x+this.x,y+this.y,radius,0,RenderContext.PI2);
			ctx.stroke();
		}

		__proto._drawCircle=function(x,y,args){
			var ctx=this.ctx;
			Render.isWebGL && ctx.setPathId(args[6]);
			Stat.drawCall++;
			ctx.beginPath();
			Render.isWebGL && ctx.movePath(args[0]+x,args[1]+y);
			ctx.arc(args[0]+x,args[1]+y,args[2],0,RenderContext.PI2);
			ctx.closePath();
			this._fillAndStroke(args[3],args[4],args[5],true);
		}

		/**
		*绘制三角形
		*@param x
		*@param y
		*@param tex
		*@param args [x,y,texture,vertices,indices,uvs,matrix]
		*/
		__proto.drawTriangles=function(x,y,args){
			var indices=args[4];
			var i=0,len=indices.length;
			var ctx=this.ctx;
			for (i=0;i < len;i+=3){
				var index0=indices[i] *2;
				var index1=indices[i+1] *2;
				var index2=indices[i+2] *2;
				ctx.drawTriangle(args[2],args[3],args[5],index0,index1,index2,args[6],true);
			}
		}

		__proto.fillCircle=function(x,y,radius,color){
			Stat.drawCall++;
			var ctx=this.ctx;
			ctx.beginPath();
			ctx.fillStyle=color;
			ctx.arc(x+this.x,y+this.y,radius,0,RenderContext.PI2);
			ctx.fill();
		}

		/**
		*绘制圆形
		*@param x
		*@param y
		*@param args [radius:Number,color:String]
		*/
		__proto._fillCircle=function(x,y,args){
			Stat.drawCall++;
			var ctx=this.ctx;
			ctx.beginPath();
			ctx.fillStyle=args[3];
			ctx.arc(args[0]+x,args[1]+y,args[2],0,RenderContext.PI2);
			ctx.fill();
		}

		__proto.setShader=function(shader){
			this.ctx.setShader(shader);
		}

		__proto.drawLine=function(fromX,fromY,toX,toY,color,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var ctx=this.ctx;
			ctx.beginPath();
			ctx.strokeStyle=color;
			ctx.lineWidth=lineWidth;
			ctx.moveTo(this.x+fromX,this.y+fromY);
			ctx.lineTo(this.x+toX,this.y+toY);
			ctx.stroke();
		}

		__proto.clear=function(){
			this.ctx.clear();
		}

		__proto.transformByMatrix=function(value){
			this.ctx.transformByMatrix(value);
		}

		__proto.setTransform=function(a,b,c,d,tx,ty){
			this.ctx.setTransform(a,b,c,d,tx,ty);
		}

		__proto.setTransformByMatrix=function(value){
			this.ctx.setTransformByMatrix(value);
		}

		__proto.save=function(){
			this.ctx.save();
		}

		__proto.restore=function(){
			this.ctx.restore();
		}

		__proto.translate=function(x,y){
			this.ctx.translate(x,y);
		}

		__proto.transform=function(a,b,c,d,tx,ty){
			this.ctx.transform(a,b,c,d,tx,ty);
		}

		__proto.rotate=function(angle){
			this.ctx.rotate(angle);
		}

		__proto.scale=function(scaleX,scaleY){
			this.ctx.scale(scaleX,scaleY);
		}

		__proto.alpha=function(value){
			this.ctx.globalAlpha *=value;
		}

		__proto.setAlpha=function(value){
			this.ctx.globalAlpha=value;
		}

		__proto.fillText=function(text,x,y,font,color,textAlign){
			this.ctx.drawText(text,x+this.x,y+this.y,font,color,textAlign);
		}

		__proto.strokeText=function(text,x,y,font,color,lineWidth,textAlign){
			this.ctx.strokeWord(text,x+this.x,y+this.y,font,color,lineWidth,textAlign);
		}

		__proto.blendMode=function(type){
			this.ctx.globalCompositeOperation=type;
		}

		__proto.flush=function(){
			this.ctx.flush && this.ctx.flush();
		}

		__proto.addRenderObject=function(o){
			this.ctx.addRenderObject(o);
		}

		__proto.beginClip=function(x,y,w,h){
			this.ctx.beginClip && this.ctx.beginClip(x,y,w,h);
		}

		__proto.endClip=function(){
			this.ctx.endClip && this.ctx.endClip();
		}

		__proto.fillTrangles=function(x,y,args){
			this.ctx.fillTrangles(args[0],args[1],args[2],args[3],args.length > 4 ? args[4] :null);
		}

		RenderContext.PI2=2 *Math.PI;
		return RenderContext;
	})()


	//TODO:是否还有用
	//class laya.renders.RenderData
	var RenderData=(function(){
		function RenderData(){
			this.context=null;
			this.sprite=null;
			this.data=null;
			this.x=NaN;
			this.y=NaN;
		}

		__class(RenderData,'laya.renders.RenderData');
		return RenderData;
	})()


	/**
	*@private
	*精灵渲染器
	*/
	//class laya.renders.RenderSprite
	var RenderSprite=(function(){
		function RenderSprite(type,next){
			//this._next=null;
			//this._fun=null;
			if (LayaGLQuickRunner.map[type]){
				this._fun=LayaGLQuickRunner.map[type];
				this._next=RenderSprite.NORENDER;
				return;
			}
			this._next=next || RenderSprite.NORENDER;
			switch (type){
				case 0:
					this._fun=this._no;
					return;
				case 0x01:
					this._fun=this._alpha;
					return;
				case 0x02:
					this._fun=this._transform;
					return;
				case 0x04:
					this._fun=this._blend;
					return;
				case 0x08:
					this._fun=this._canvas;
					return;
				case 0x20:
					this._fun=this._mask;
					return;
				case 0x40:
					this._fun=this._clip;
					return;
				case 0x80:
					this._fun=this._style;
					return;
				case 0x200:
					this._fun=this._graphics;
					return;
				case 0x2000:
					this._fun=this._childs;
					return;
				case 0x800:
					this._fun=this._custom;
					return;
				case 0x100:
					this._fun=this._texture;
					return;
				case 0x10:
					this._fun=Filter._filter;
					return;
				case 0x11111:
					this._fun=RenderSprite._initRenderFun;
					return;
				}
			this.onCreate(type);
		}

		__class(RenderSprite,'laya.renders.RenderSprite');
		var __proto=RenderSprite.prototype;
		__proto.onCreate=function(type){}
		__proto._style=function(sprite,context,x,y){
			var style=sprite._style;
			if (style.render !=null)style.render(sprite,context,x,y);
			var next=this._next;
			next._fun.call(next,sprite,context,x,y);
		}

		__proto._no=function(sprite,context,x,y){}
		__proto._custom=function(sprite,context,x,y){
			sprite.customRender(context,x,y);
			this._next._fun.call(this._next,sprite,context,x,y);
		}

		__proto._clip=function(sprite,context,x,y){
			var next=this._next;
			if (next==RenderSprite.NORENDER)return;
			var r=sprite._style.scrollRect;
			context.save();
			context.clipRect(x,y,r.width,r.height);
			next._fun.call(next,sprite,context,x-r.x,y-r.y);
			context.restore();
		}

		__proto._blend=function(sprite,context,x,y){
			var style=sprite._style;
			if (style.blendMode){
				context.globalCompositeOperation=style.blendMode;
			};
			var next=this._next;
			next._fun.call(next,sprite,context,x,y);
			context.globalCompositeOperation="source-over";
		}

		__proto._mask=function(sprite,context,x,y){
			var next=this._next;
			next._fun.call(next,sprite,context,x,y);
			var mask=sprite.mask;
			if (mask){
				context.globalCompositeOperation="destination-in";
				if (mask.numChildren > 0 || !mask.graphics._isOnlyOne()){
					mask.cacheAs="bitmap";
				}
				mask.render(context,x-sprite._style.pivotX,y-sprite._style.pivotY);
			}
			context.globalCompositeOperation="source-over";
		}

		__proto._texture=function(sprite,context,x,y){
			var tex;
			tex=sprite.texture;
			context.drawTexture(tex,x,y,tex.width,tex.height);
			var next=this._next;
			next._fun.call(next,sprite,context,x,y);
		}

		__proto._graphics=function(sprite,context,x,y){
			sprite._graphics && sprite._graphics._render(sprite,context,x,y);
			var next=this._next;
			next._fun.call(next,sprite,context,x,y);
		}

		__proto._image=function(sprite,context,x,y){
			var style=sprite._style;
			context.drawTexture2(x,y,style.pivotX,style.pivotY,sprite.transform,sprite._graphics._one);
		}

		__proto._image2=function(sprite,context,x,y){
			var style=sprite._style;
			context.drawTexture2(x,y,style.pivotX,style.pivotY,sprite.transform,sprite._graphics._one);
		}

		__proto._alpha=function(sprite,context,x,y){
			var style=sprite._style;
			var alpha;
			if ((alpha=style.alpha)> 0.01 || sprite._needRepaint()){
				var temp=context.globalAlpha;
				context.globalAlpha *=alpha;
				var next=this._next;
				next._fun.call(next,sprite,context,x,y);
				context.globalAlpha=temp;
			}
		}

		__proto._transform=function(sprite,context,x,y){
			var transform=sprite.transform,_next=this._next;
			var style=sprite._style;
			if (transform && _next !=RenderSprite.NORENDER){
				context.save();
				context.transform(transform.a,transform.b,transform.c,transform.d,transform.tx+x+style.pivotX,transform.ty+y+style.pivotY);
				_next._fun.call(_next,sprite,context,-style.pivotX,-style.pivotY);
				context.restore();
			}else
			_next._fun.call(_next,sprite,context,x,y);
		}

		__proto._childs=function(sprite,context,x,y){
			var style=sprite._style;
			var childs=sprite._children,n=childs.length,ele;
			if (style.viewport){
				var rect=style.viewport;
				var left=rect.x;
				var top=rect.y;
				var right=rect.right;
				var bottom=rect.bottom;
				var _x=NaN,_y=NaN;
				for (i=0;i < n;++i){
					if ((ele=childs [i])._visible && ((_x=ele._x)< right && (_x+ele.width)> left && (_y=ele._y)< bottom && (_y+ele.height)> top)){
						ele.render(context,x,y);
					}
				}
				}else {
				for (var i=0;i < n;++i)
				(ele=(childs [i]))._visible && ele.render(context,x,y);
			}
		}

		__proto._canvas=function(sprite,context,x,y){
			var _cacheStyle=sprite._cacheStyle;
			var _next=this._next;
			if (!_cacheStyle.enableCanvasRender){
				_next._fun.call(_next,sprite,context,x,y);
				return;
			}
			_cacheStyle.cacheAs==='bitmap' ? (Stat.canvasBitmap++):(Stat.canvasNormal++);
			if (sprite._needRepaint()|| (!_cacheStyle.canvas)){
				this._canvas_repaint(sprite,context,x,y);
				}else {
				var tRec=_cacheStyle.cacheRect;
				context.drawCanvas(_cacheStyle.canvas,x+tRec.x,y+tRec.y,tRec.width,tRec.height);
			}
		}

		__proto._canvas_repaint=function(sprite,context,x,y){
			var _cacheStyle=sprite._cacheStyle;
			var _next=this._next;
			var tx;
			var canvas=_cacheStyle.canvas;
			var left;
			var top;
			var tRec;
			var tCacheType=_cacheStyle.cacheAs;
			var w,h;
			var scaleX,scaleY;
			var scaleInfo;
			scaleInfo=_cacheStyle._calculateCacheRect(sprite,tCacheType,x,y);
			scaleX=scaleInfo.x;
			scaleY=scaleInfo.y;
			tRec=_cacheStyle.cacheRect;
			w=tRec.width *scaleX;
			h=tRec.height *scaleY;
			left=tRec.x;
			top=tRec.y;
			if (Render.isWebGL && tCacheType==='bitmap' && (w > 2048 || h > 2048)){
				console.warn("cache bitmap size larger than 2048,cache ignored");
				_cacheStyle.releaseContext();
				_next._fun.call(_next,sprite,context,x,y);
				return;
			}
			if (!canvas){
				_cacheStyle.createContext();
				canvas=_cacheStyle.canvas;
			}
			tx=canvas.context;
			canvas.context.sprite=sprite;
			(canvas.width !=w || canvas.height !=h)&& canvas.size(w,h);
			if (tCacheType==='bitmap')canvas.context.asBitmap=true;
			else if (tCacheType==='normal')canvas.context.asBitmap=false;
			canvas.clear();
			if (scaleX !=1 || scaleY !=1){
				var ctx=tx;
				ctx.save();
				ctx.scale(scaleX,scaleY);
				_next._fun.call(_next,sprite,tx,-left,-top);
				ctx.restore();
				sprite._applyFilters();
				}else {
				ctx=tx;
				_next._fun.call(_next,sprite,tx,-left,-top);
				sprite._applyFilters();
			}
			if (_cacheStyle.staticCache)_cacheStyle.reCache=false;
			Stat.canvasReCache++;
			context.drawCanvas(canvas,x+left,y+top,tRec.width,tRec.height);
		}

		RenderSprite.__init__=function(){
			LayaGLQuickRunner.__init__();
			var i=0,len=0;
			var initRender;
			initRender=RunDriver.createRenderSprite(0x11111,null);
			len=RenderSprite.renders.length=0x2000 *2;
			for (i=0;i < len;i++)
			RenderSprite.renders[i]=initRender;
			RenderSprite.renders[0]=RunDriver.createRenderSprite(0,null);
			function _initSame (value,o){
				var n=0;
				for (var i=0;i < value.length;i++){
					n |=value[i];
					RenderSprite.renders[n]=o;
				}
			}
		}

		RenderSprite._initRenderFun=function(sprite,context,x,y){
			var type=sprite._renderType;
			var r=RenderSprite.renders[type]=RenderSprite._getTypeRender(type);
			r._fun(sprite,context,x,y);
		}

		RenderSprite._getTypeRender=function(type){
			if (LayaGLQuickRunner.map[type])return RunDriver.createRenderSprite(type,null);
			var rst=null;
			var tType=0x2000;
			while (tType > 1){
				if (tType & type)
					rst=RunDriver.createRenderSprite(tType,rst);
				tType=tType >> 1;
			}
			return rst;
		}

		RenderSprite.INIT=0x11111;
		RenderSprite.renders=[];
		RenderSprite.NORENDER=new RenderSprite(0,null);
		return RenderSprite;
	})()


	/**
	*@private
	*Context扩展类
	*/
	//class laya.resource.Context
	var Context=(function(){
		function Context(){
			//this._canvas=null;
		}

		__class(Context,'laya.resource.Context');
		var __proto=Context.prototype;
		__proto.setIsMainContext=function(){}
		/**@private */
		__proto.drawCanvas=function(canvas,x,y,width,height){
			Stat.drawCall++;
			this.drawImage(canvas._source,x,y,width,height);
		}

		/**@private */
		__proto._drawRect=function(x,y,width,height,style){
			Stat.drawCall++;
			style && (this.fillStyle=style);
			this.fillRect(x,y,width,height);
		}

		/**@private */
		__proto.drawText=function(text,x,y,font,color,textAlign){
			Stat.drawCall++;
			if (arguments.length > 3 && font !=null){
				this.font=font;
				this.fillStyle=color;
				this.textAlign=textAlign;
				this.textBaseline="top";
			}
			this.fillText(text,x,y);
		}

		/**@private */
		__proto.fillBorderText=function(text,x,y,font,fillColor,borderColor,lineWidth,textAlign){
			Stat.drawCall++;
			this.font=font;
			this.fillStyle=fillColor;
			this.textBaseline="top";
			this.strokeStyle=borderColor;
			this.lineWidth=lineWidth;
			this.textAlign=textAlign;
			this.strokeText(text,x,y);
			this.fillText(text,x,y);
		}

		/***@private */
		__proto.fillWords=function(words,x,y,font,color){
			font && (this.font=font);
			color && (this.fillStyle=color);
			this.textBaseline="top";
			this.textAlign='left';
			for (var i=0,n=words.length;i < n;i++){
				var a=words[i];
				this.fillText(a.char,a.x+x,a.y+y);
			}
		}

		/***@private */
		__proto.fillBorderWords=function(words,x,y,font,color,borderColor,lineWidth){
			font && (this.font=font);
			color && (this.fillStyle=color);
			this.textBaseline="top";
			this.lineWidth=lineWidth;
			this.textAlign='left';
			this.strokeStyle=borderColor;
			for (var i=0,n=words.length;i < n;i++){
				var a=words[i];
				this.strokeText(a.char,a.x+x,a.y+y);
				this.fillText(a.char,a.x+x,a.y+y);
			}
		}

		/**@private */
		__proto.strokeWord=function(text,x,y,font,color,lineWidth,textAlign){
			Stat.drawCall++;
			if (arguments.length > 3 && font !=null){
				this.font=font;
				this.strokeStyle=color;
				this.lineWidth=lineWidth;
				this.textAlign=textAlign;
				this.textBaseline="top";
			}
			this.strokeText(text,x,y);
		}

		/**@private */
		__proto.setTransformByMatrix=function(value){
			this.setTransform(value.a,value.b,value.c,value.d,value.tx,value.ty);
		}

		/**@private */
		__proto.clipRect=function(x,y,width,height){
			Stat.drawCall++;
			this.beginPath();
			this.rect(x,y,width,height);
			this.clip();
		}

		/**@private */
		__proto.drawTextureWithTransform=function(tex,tx,ty,width,height,m,gx,gy,alpha,blendMode){
			'use strict';
			if (!tex.getEnabled())
				return;
			Stat.drawCall++;
			var alphaChanged=alpha!==1;
			if (alphaChanged){
				var temp=this.globalAlpha;
				this.globalAlpha *=alpha;
			}
			if (blendMode)
				this.globalCompositeOperation=blendMode;
			var uv=tex.uv,w=tex.bitmap._w,h=tex.bitmap._h;
			if (m){
				this.save();
				this.transform(m.a,m.b,m.c,m.d,m.tx+gx,m.ty+gy);
				this.drawImage(tex.bitmap._source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,tx,ty,width,height);
				this.restore();
				}else {
				this.drawImage(tex.bitmap._source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,gx+tx,gy+ty,width,height);
			}
			if (alphaChanged)
				this.globalAlpha=temp;
			if (blendMode)
				this.globalCompositeOperation="source-over";
		}

		/**@private */
		__proto.drawTexture2=function(x,y,pivotX,pivotY,m,args2){
			'use strict';
			var tex=args2[0];
			if (!tex.getEnabled())
				return;
			Stat.drawCall++;
			var uv=tex.uv,w=tex.bitmap._w,h=tex.bitmap._h;
			if (m){
				this.save();
				this.transform(m.a,m.b,m.c,m.d,m.tx+x,m.ty+y);
				this.drawImage(tex.bitmap._source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,args2[1]-pivotX,args2[2]-pivotY,args2[3],args2[4]);
				this.restore();
				}else {
				this.drawImage(tex.bitmap._source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,args2[1]-pivotX+x,args2[2]-pivotY+y,args2[3],args2[4]);
			}
		}

		__proto.fillTexture=function(texture,x,y,width,height,type,offset,other){
			if (!other.pat){
				if (texture.uv !=Texture.DEF_UV){
					var canvas=new HTMLCanvas("2D");
					canvas.getContext('2d');
					canvas.size(texture.width,texture.height);
					canvas.context.drawTexture(texture,0,0,texture.width,texture.height);
					texture=new Texture(canvas);
				}
				other.pat=this.createPattern(texture.bitmap.source,type);
			};
			var oX=x,oY=y;
			var sX=0,sY=0;
			if (offset){
				oX+=offset.x % texture.width;
				oY+=offset.y % texture.height;
				sX-=offset.x % texture.width;
				sY-=offset.y % texture.height;
			}
			this.translate(oX,oY);
			this._drawRect(sX,sY,width,height,other.pat);
			this.translate(-oX,-oY);
		}

		/**@private */
		__proto.flush=function(){
			return 0;
		}

		/**@private */
		__proto.destroy=function(){
			this.canvas.width=this.canvas.height=0;
		}

		/**@private */
		__proto.clear=function(){
			this.clearRect(0,0,this._canvas.width,this._canvas.height);
		}

		__proto.drawTriangle=function(texture,vertices,uvs,index0,index1,index2,matrix,canvasPadding){
			var source=texture.bitmap;
			var textureSource=source.source;
			var textureWidth=texture.width;
			var textureHeight=texture.height;
			var sourceWidth=source.width;
			var sourceHeight=source.height;
			var u0=uvs[index0] *sourceWidth;
			var u1=uvs[index1] *sourceWidth;
			var u2=uvs[index2] *sourceWidth;
			var v0=uvs[index0+1] *sourceHeight;
			var v1=uvs[index1+1] *sourceHeight;
			var v2=uvs[index2+1] *sourceHeight;
			var x0=vertices[index0];
			var x1=vertices[index1];
			var x2=vertices[index2];
			var y0=vertices[index0+1];
			var y1=vertices[index1+1];
			var y2=vertices[index2+1];
			if (canvasPadding){
				var paddingX=1;
				var paddingY=1;
				var centerX=(x0+x1+x2)/ 3;
				var centerY=(y0+y1+y2)/ 3;
				var normX=x0-centerX;
				var normY=y0-centerY;
				var dist=Math.sqrt((normX *normX)+(normY *normY));
				x0=centerX+((normX / dist)*(dist+paddingX));
				y0=centerY+((normY / dist)*(dist+paddingY));
				normX=x1-centerX;
				normY=y1-centerY;
				dist=Math.sqrt((normX *normX)+(normY *normY));
				x1=centerX+((normX / dist)*(dist+paddingX));
				y1=centerY+((normY / dist)*(dist+paddingY));
				normX=x2-centerX;
				normY=y2-centerY;
				dist=Math.sqrt((normX *normX)+(normY *normY));
				x2=centerX+((normX / dist)*(dist+paddingX));
				y2=centerY+((normY / dist)*(dist+paddingY));
			}
			this.save();
			if (matrix)
				this.transform(matrix.a,matrix.b,matrix.c,matrix.d,matrix.tx,matrix.ty);
			this.beginPath();
			this.moveTo(x0,y0);
			this.lineTo(x1,y1);
			this.lineTo(x2,y2);
			this.closePath();
			this.clip();
			var delta=(u0 *v1)+(v0 *u2)+(u1 *v2)-(v1 *u2)-(v0 *u1)-(u0 *v2);
			var dDelta=1 / delta;
			var deltaA=(x0 *v1)+(v0 *x2)+(x1 *v2)-(v1 *x2)-(v0 *x1)-(x0 *v2);
			var deltaB=(u0 *x1)+(x0 *u2)+(u1 *x2)-(x1 *u2)-(x0 *u1)-(u0 *x2);
			var deltaC=(u0 *v1 *x2)+(v0 *x1 *u2)+(x0 *u1 *v2)-(x0 *v1 *u2)-(v0 *u1 *x2)-(u0 *x1 *v2);
			var deltaD=(y0 *v1)+(v0 *y2)+(y1 *v2)-(v1 *y2)-(v0 *y1)-(y0 *v2);
			var deltaE=(u0 *y1)+(y0 *u2)+(u1 *y2)-(y1 *u2)-(y0 *u1)-(u0 *y2);
			var deltaF=(u0 *v1 *y2)+(v0 *y1 *u2)+(y0 *u1 *v2)-(y0 *v1 *u2)-(v0 *u1 *y2)-(u0 *y1 *v2);
			this.transform(deltaA *dDelta,deltaD *dDelta,deltaB *dDelta,deltaE *dDelta,deltaC *dDelta,deltaF *dDelta);
			this.drawImage(textureSource,texture.uv[0] *sourceWidth,texture.uv[1] *sourceHeight,textureWidth,textureHeight,texture.uv[0] *sourceWidth,texture.uv[1] *sourceHeight,textureWidth,textureHeight);
			this.restore();
		}

		//=============新增==================
		__proto.transformByMatrix=function(matrix,tx,ty){
			this.transform(matrix.a,matrix.b,matrix.c,matrix.d,matrix.tx+tx,matrix.ty+ty);
		}

		__proto.saveTransform=function(matrix){
			this.save();
		}

		__proto.restoreTransform=function(matrix){
			this.restore();
		}

		__proto.drawRect=function(x,y,width,height,fillColor,lineColor,lineWidth){
			var ctx=this;
			if (fillColor !=null){
				ctx.fillStyle=fillColor;
				ctx.fillRect(x,y,width,height);
			}
			if (lineColor !=null){
				ctx.strokeStyle=lineColor;
				ctx.lineWidth=lineWidth;
				ctx.strokeRect(x,y,width,height);
			}
		}

		/**@private */
		__proto.drawTexture=function(tex,x,y,width,height){
			if (!tex.loaded)return;
			Stat.drawCall++;
			var uv=tex.uv,w=tex.bitmap.width,h=tex.bitmap.height;
			this.drawImage(tex.bitmap._source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,x,y,width,height);
		}

		__proto.drawTextures=function(tex,pos,tx,ty){
			Stat.drawCall+=pos.length / 2;
			var w=tex.width;
			var h=tex.height;
			for (var i=0,sz=pos.length;i < sz;i+=2){
				this.drawTexture(tex,pos[i]+tx,pos[i+1]+ty,w,h);
			}
		}

		/**
		*绘制三角形
		*@param x
		*@param y
		*@param tex
		*@param args [x,y,texture,vertices,indices,uvs,matrix]
		*/
		__proto.drawTriangles=function(texture,x,y,vertices,uvs,indices,matrix,alpha,color,blendMode){
			var i=0,len=indices.length;
			this.translate(x,y);
			for (i=0;i < len;i+=3){
				var index0=indices[i] *2;
				var index1=indices[i+1] *2;
				var index2=indices[i+2] *2;
				this.drawTriangle(texture,vertices,uvs,index0,index1,index2,matrix,true);
			}
			this.translate(-x,-y);
		}

		__proto.alpha=function(value){
			this.globalAlpha *=value;
		}

		__proto._transform=function(mat,pivotX,pivotY){
			this.translate(pivotX,pivotY);
			this.transform(mat.a,mat.b,mat.c,mat.d,mat.tx,mat.ty);
			this.translate(-pivotX,-pivotY);
		}

		__proto._rotate=function(angle,pivotX,pivotY){
			this.translate(pivotX,pivotY);
			this.rotate(angle);
			this.translate(-pivotX,-pivotY);
		}

		__proto._scale=function(scaleX,scaleY,pivotX,pivotY){
			this.translate(pivotX,pivotY);
			this.scale(scaleX,scaleY);
			this.translate(-pivotX,-pivotY);
		}

		__proto._drawLine=function(x,y,fromX,fromY,toX,toY,lineColor,lineWidth,vid){
			var ctx=this.ctx;
			this.beginPath();
			this.strokeStyle=lineColor;
			this.lineWidth=lineWidth;
			this.moveTo(x+fromX,y+fromY);
			this.lineTo(x+toX,y+toY);
			this.stroke();
		}

		__proto._drawLines=function(x,y,points,lineColor,lineWidth,vid){
			Render.isWebGL && this.setPathId(vid);
			this.beginPath();
			this.strokeStyle=lineColor;
			this.lineWidth=lineWidth;
			var i=2,n=points.length;
			if (Render.isWebGL){
				this.addPath(points.slice(),false,false,x,y);
				}else {
				this.moveTo(x+points[0],y+points[1]);
				while (i < n){
					this.lineTo(x+points[i++],y+points[i++]);
				}
			}
			this.stroke();
		}

		__proto.drawCurves=function(x,y,points,lineColor,lineWidth){
			this.beginPath();
			this.strokeStyle=lineColor;
			this.lineWidth=lineWidth;
			this.moveTo(x+points[0],y+points[1]);
			var i=2,n=points.length;
			while (i < n){
				this.quadraticCurveTo(x+points[i++],y+points[i++],x+points[i++],y+points[i++]);
			}
			this.stroke();
		}

		__proto._fillAndStroke=function(fillColor,strokeColor,lineWidth,isConvexPolygon){
			(isConvexPolygon===void 0)&& (isConvexPolygon=false);
			if (fillColor !=null){
				this.fillStyle=fillColor;
				this.fill();
			}
			if (strokeColor !=null && lineWidth > 0){
				this.strokeStyle=strokeColor;
				this.lineWidth=lineWidth;
				this.stroke();
			}
		}

		__proto._drawCircle=function(x,y,radius,fillColor,lineColor,lineWidth,vid){
			Stat.drawCall++;
			Render.isWebGL? this.beginPath(true):this.beginPath();
			this.arc(x,y,radius,0,Context.PI2);
			this.closePath();
			this._fillAndStroke(fillColor,lineColor,lineWidth);
		}

		//矢量方法
		__proto._drawPie=function(x,y,radius,startAngle,endAngle,fillColor,lineColor,lineWidth,vid){
			this.beginPath();
			this.moveTo(x ,y);
			this.arc(x,y,radius,startAngle,endAngle);
			this.closePath();
			this._fillAndStroke(fillColor,lineColor,lineWidth);
		}

		//ctx.translate(-x-args[0],-y-args[1]);
		__proto._drawPoly=function(x,y,points,fillColor,lineColor,lineWidth,isConvexPolygon,vid){
			var i=2,n=points.length;
			this.beginPath();
			if (Render.isWebGL){
				this.setPathId(vid);
				this.addPath(points.slice(),true,isConvexPolygon,x,y);
				}else {
				this.moveTo(x+points[0],y+points[1]);
				while (i < n){
					this.lineTo(x+points[i++],y+points[i++]);
				}
			}
			this.closePath();
			this._fillAndStroke(fillColor,lineColor,lineWidth,isConvexPolygon);
		}

		__proto._drawPath=function(x,y,paths,brush,pen){
			var ctx=this.ctx;
			this.beginPath();
			for (var i=0,n=paths.length;i < n;i++){
				var path=paths[i];
				switch (path[0]){
					case "moveTo":
						this.moveTo(x+path[1],y+path[2]);
						break ;
					case "lineTo":
						this.lineTo(x+path[1],y+path[2]);
						break ;
					case "arcTo":
						this.arcTo(x+path[1],y+path[2],x+path[3],y+path[4],path[5]);
						break ;
					case "closePath":
						this.closePath();
						break ;
					}
			}
			if (brush !=null){
				this.fillStyle=brush.fillStyle;
				this.fill();
			}
			if (pen !=null){
				this.strokeStyle=pen.strokeStyle;
				this.lineWidth=pen.lineWidth || 1;
				this.lineJoin=pen.lineJoin;
				this.lineCap=pen.lineCap;
				this.miterLimit=pen.miterLimit;
				this.stroke();
			}
		}

		Context.__init__=function(to){
			var from=laya.resource.Context.prototype;
			to=to || CanvasRenderingContext2D.prototype;
			var funs=["saveTransform","restoreTransform","transformByMatrix","drawTriangles","drawTriangle",'drawTextures','fillWords','fillBorderWords','setIsMainContext','drawRect','strokeWord','drawText','fillTexture','setTransformByMatrix','clipRect','drawTexture','drawTexture2','drawTextureWithTransform','flush','clear','destroy','drawCanvas','fillBorderText','drawCurves',"_drawRect","alpha","_transform","_rotate","_scale","_drawLine","_drawLines","_drawCircle","_fillAndStroke","_drawPie","_drawPoly","_drawPath","drawTextureWithTransform"];
			funs.forEach(function(i){
				to[i]=from[i];
			});
		}

		Context.PI2=2 *Math.PI;
		return Context;
	})()


	/**
	*@private
	*<code>ResourceManager</code> 是资源管理类。它用于资源的载入、获取、销毁。
	*/
	//class laya.resource.ResourceManager
	var ResourceManager=(function(){
		function ResourceManager(name){
			this._id=0;
			this._name=null;
			this._resources=null;
			this._memorySize=0;
			this._garbageCollectionRate=NaN;
			this._isOverflow=false;
			this.autoRelease=false;
			this.autoReleaseMaxSize=0;
			this._id=++ResourceManager._uniqueIDCounter;
			this._name=name ? name :"Content Manager";
			ResourceManager._isResourceManagersSorted=false;
			this._memorySize=0;
			this._isOverflow=false;
			this.autoRelease=false;
			this.autoReleaseMaxSize=1024 *1024 *512;
			this._garbageCollectionRate=0.2;
			ResourceManager._resourceManagers.push(this);
			this._resources=[];
		}

		__class(ResourceManager,'laya.resource.ResourceManager');
		var __proto=ResourceManager.prototype;
		Laya.imps(__proto,{"laya.resource.IDispose":true})
		/**
		*获取指定索引的资源 Resource 对象。
		*@param 索引。
		*@return 资源 Resource 对象。
		*/
		__proto.getResourceByIndex=function(index){
			return this._resources[index];
		}

		/**
		*获取此管理器所管理的资源个数。
		*@return 资源个数。
		*/
		__proto.getResourcesLength=function(){
			return this._resources.length;
		}

		/**
		*添加指定资源。
		*@param resource 需要添加的资源 Resource 对象。
		*@return 是否添加成功。
		*/
		__proto.addResource=function(resource){
			if (resource.resourceManager)
				resource.resourceManager.removeResource(resource);
			var index=this._resources.indexOf(resource);
			if (index===-1){
				resource._resourceManager=this;
				this._resources.push(resource);
				this.addSize(resource.memorySize);
				return true;
			}
			return false;
		}

		/**
		*移除指定资源。
		*@param resource 需要移除的资源 Resource 对象
		*@return 是否移除成功。
		*/
		__proto.removeResource=function(resource){
			var index=this._resources.indexOf(resource);
			if (index!==-1){
				this._resources.splice(index,1);
				resource._resourceManager=null;
				this._memorySize-=resource.memorySize;
				return true;
			}
			return false;
		}

		/**
		*卸载此资源管理器载入的资源。
		*/
		__proto.unload=function(){
			var tempResources=this._resources.slice(0,this._resources.length);
			for (var i=0;i < tempResources.length;i++){
				var resource=tempResources[i];
				resource.destroy();
			}
			tempResources.length=0;
		}

		/**释放资源。*/
		__proto.dispose=function(){
			if (this===ResourceManager._systemResourceManager)
				throw new Error("systemResourceManager不能被释放！");
			ResourceManager._resourceManagers.splice(ResourceManager._resourceManagers.indexOf(this),1);
			ResourceManager._isResourceManagersSorted=false;
			var tempResources=this._resources.slice(0,this._resources.length);
			for (var i=0;i < tempResources.length;i++){
				var resource=tempResources[i];
				resource.resourceManager.removeResource(resource);
				resource.destroy();
			}
			tempResources.length=0;
		}

		/**
		*增加内存。
		*@param add 需要增加的内存大小。
		*/
		__proto.addSize=function(add){
			if (add){
				if (this.autoRelease && add > 0)
					((this._memorySize+add)> this.autoReleaseMaxSize)&& (this.garbageCollection((1-this._garbageCollectionRate)*this.autoReleaseMaxSize));
				this._memorySize+=add;
			}
		}

		/**
		*垃圾回收。
		*@param reserveSize 保留尺寸。
		*/
		__proto.garbageCollection=function(reserveSize){
			var all=this._resources;
			all=all.slice();
			all.sort(function(a,b){
				if (!a || !b)
					throw new Error("a或b不能为空！");
				if (a.released && b.released)
					return 0;
				else if (a.released)
				return 1;
				else if (b.released)
				return-1;
				return a._lastUseFrameCount-b._lastUseFrameCount;
			});
			var currentFrameCount=Stat.loopCount;
			for (var i=0,n=all.length;i < n;i++){
				var resou=all[i];
				if (currentFrameCount-resou._lastUseFrameCount > 1){
					resou.releaseResource();
					}else {
					if (this._memorySize >=reserveSize)
						this._isOverflow=true;
					return;
				}
				if (this._memorySize < reserveSize){
					this._isOverflow=false;
					return;
				}
			}
		}

		/**
		*唯一标识 ID 。
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		/**
		*名字。
		*/
		__getset(0,__proto,'name',function(){
			return this._name;
			},function(value){
			if ((value || value!=="")&& this._name!==value){
				this._name=value;
				ResourceManager._isResourceManagersSorted=false;
			}
		});

		/**
		*此管理器所管理资源的累计内存，以字节为单位。
		*/
		__getset(0,__proto,'memorySize',function(){
			return this._memorySize;
		});

		/**
		*系统资源管理器。
		*/
		__getset(1,ResourceManager,'systemResourceManager',function(){
			return ResourceManager._systemResourceManager;
		});

		ResourceManager.__init__=function(){
			ResourceManager.currentResourceManager=ResourceManager.systemResourceManager;
		}

		ResourceManager.getLoadedResourceManagerByIndex=function(index){
			return ResourceManager._resourceManagers[index];
		}

		ResourceManager.getLoadedResourceManagersCount=function(){
			return ResourceManager._resourceManagers.length;
		}

		ResourceManager.recreateContentManagers=function(force){
			(force===void 0)&& (force=false);
			var temp=ResourceManager.currentResourceManager;
			for (var i=0;i < ResourceManager._resourceManagers.length;i++){
				ResourceManager.currentResourceManager=ResourceManager._resourceManagers[i];
				for (var j=0;j < ResourceManager.currentResourceManager._resources.length;j++){
					ResourceManager.currentResourceManager._resources[j].releaseResource(force);
					ResourceManager.currentResourceManager._resources[j].activeResource(force);
				}
			}
			ResourceManager.currentResourceManager=temp;
		}

		ResourceManager.releaseContentManagers=function(force){
			(force===void 0)&& (force=false);
			var temp=ResourceManager.currentResourceManager;
			for (var i=0;i < ResourceManager._resourceManagers.length;i++){
				ResourceManager.currentResourceManager=ResourceManager._resourceManagers[i];
				for (var j=0;j < ResourceManager.currentResourceManager._resources.length;j++){
					var resource=ResourceManager.currentResourceManager._resources[j];
					(!resource.released)&& (resource.releaseResource(force));
				}
			}
			ResourceManager.currentResourceManager=temp;
		}

		ResourceManager._uniqueIDCounter=0;
		ResourceManager._isResourceManagersSorted=false;
		ResourceManager._resourceManagers=[];
		__static(ResourceManager,
		['_systemResourceManager',function(){return this._systemResourceManager=new ResourceManager("System Resource Manager");},'currentResourceManager',function(){return this.currentResourceManager=ResourceManager._systemResourceManager;}
		]);
		return ResourceManager;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.runtime.ConchCmdReplace
	var ConchCmdReplace=(function(){
		function ConchCmdReplace(){}
		__class(ConchCmdReplace,'laya.runtime.ConchCmdReplace');
		ConchCmdReplace.__init__=function(){
			DrawTextureCmdNative;
			var cmdO=laya.display.cmd;
			var cmdONative=laya.display.cmdNative;
			var key;
			for (key in cmdO){
				if (cmdONative[key+"Native"]){
					cmdO[key].create=cmdONative[key+"Native"].create;
				}
			}
		}

		return ConchCmdReplace;
	})()


	/**
	*...
	*@author ww
	*/
	//class laya.runtime.ConchGraphicsAdpt
	var ConchGraphicsAdpt=(function(){
		function ConchGraphicsAdpt(){
			this._commandEncoder=null;
		}

		__class(ConchGraphicsAdpt,'laya.runtime.ConchGraphicsAdpt');
		var __proto=ConchGraphicsAdpt.prototype;
		__proto._createData=function(){
			this._commandEncoder=LayaGL.instance.createCommandEncoder(128,64,true,false);
		}

		__proto._clearData=function(){
			if (this._commandEncoder)this._commandEncoder.clearEncoding();
		}

		__proto._destroyData=function(){
			if (this._commandEncoder){
				this._commandEncoder.clearEncoding();
				this._commandEncoder=null;
			}
		}

		ConchGraphicsAdpt.__init__=function(){
			var spP=Graphics["prototype"];
			var mP=ConchGraphicsAdpt["prototype"];
			var funs=[
			"_createData",
			"_clearData",
			"_destroyData"];
			var i=0,len=0;
			len=funs.length;
			var tFunName;
			for (i=0;i < len;i++){
				tFunName=funs[i];
				spP[tFunName]=mP[tFunName];
			}
		}

		return ConchGraphicsAdpt;
	})()


	/**
	*@private
	*命令模板，用来优化合并命令执行
	*/
	//class laya.runtime.LayaGLTemplate
	var LayaGLTemplate=(function(){
		function LayaGLTemplate(){
			this._commStr="";
			this._id=0;
			this._commandEncoder=LayaGL.instance.createCommandEncoder(64,16,false);
		}

		__class(LayaGLTemplate,'laya.runtime.LayaGLTemplate');
		var __proto=LayaGLTemplate.prototype;
		__proto.addComd=function(valueID,offset,operate){
			this._commStr+="setValueWithShareData("+valueID+","+offset+","+operate+");";
			this._commandEncoder.setValueWithShareData(valueID,offset,operate);
		}

		__proto.addCalcLocalDataCommd=function(){
			this._commandEncoder.calcLocalMatrix32(12*4,13*4,3*4,4*4,5*4,
			6*4,7*4,8*4,9*4,10*4,11*4);
		}

		LayaGLTemplate.createByRenderType=function(renderType){
			var template=LayaGLTemplate.GLS[renderType]=new LayaGLTemplate();
			if (Render.isConchApp){
				window.conch.setGLTemplate(renderType,template._commandEncoder._buffer["_ptrID"]);
			};
			var n=0x01;
			while (n <=0x2000){
				var tempType=renderType & n;
				if (tempType && LayaGLTemplate.__FUN_PARAM__[n]){
					if (tempType==0x02){
						template.addCalcLocalDataCommd();
					};
					var obj=LayaGLTemplate.__FUN_PARAM__[n];
					template.addComd(obj.valueID,obj.offset,obj.operate);
				}
				n <<=1;
			}
			template._id=renderType;
			console.log("template="+template._commStr);
			return template;
		}

		LayaGLTemplate.__init__=function(){
			LayaGLTemplate.__FUN_PARAM__[0x01]={valueID:LayaNative2D.VALUEALPHA,offset:19*4,operate:5 };
			LayaGLTemplate.__FUN_PARAM__[0x02]={valueID:LayaNative2D.VALUEMATRIX32,offset:13 *4,operate:10 };
			LayaGLTemplate.__FUN_PARAM__[0x200]={valueID:-1,offset:20*4,operate:1 };
			LayaGLTemplate.__FUN_PARAM__[0x400]={valueID:-1,offset:21*4,operate:2 };
		}

		LayaGLTemplate.GLS=[];
		LayaGLTemplate.__FUN_PARAM__=[];
		return LayaGLTemplate;
	})()


	/**
	*<p> <code>Matrix</code> 类表示一个转换矩阵，它确定如何将点从一个坐标空间映射到另一个坐标空间。</p>
	*<p>您可以对一个显示对象执行不同的图形转换，方法是设置 Matrix 对象的属性，将该 Matrix 对象应用于 Transform 对象的 matrix 属性，然后应用该 Transform 对象作为显示对象的 transform 属性。这些转换函数包括平移（x 和 y 重新定位）、旋转、缩放和倾斜。</p>
	*/
	//class laya.runtime.MatrixConch
	var MatrixConch=(function(){
		function MatrixConch(a,b,c,d,tx,ty,nums){
			//this._nums=null;
			//this._bTransform=false;
			(a===void 0)&& (a=1);
			(b===void 0)&& (b=0);
			(c===void 0)&& (c=0);
			(d===void 0)&& (d=1);
			(tx===void 0)&& (tx=0);
			(ty===void 0)&& (ty=0);
			this._nums=nums=nums ? nums :new Float32Array(6);
			nums[0]=a;
			nums[1]=b;
			nums[2]=c;
			nums[3]=d;
			nums[4]=tx;
			nums[5]=ty;
			this._checkTransform();
		}

		__class(MatrixConch,'laya.runtime.MatrixConch');
		var __proto=MatrixConch.prototype;
		/**
		*将本矩阵设置为单位矩阵。
		*@return 返回矩阵对象本身
		*/
		__proto.identity=function(){
			var nums=this._nums;
			nums[0]=nums[3]=1;
			nums[1]=nums[4]=nums[5]=nums[2]=0;
			this._bTransform=false;
			return this;
		}

		/**@private */
		__proto._checkTransform=function(){
			var nums=this._nums;
			return this._bTransform=(nums[0]!==1 || nums[1]!==0 || nums[2]!==0 || nums[3]!==1);
		}

		/**
		*设置沿 x 、y 轴平移每个点的距离。
		*@param x 沿 x 轴平移每个点的距离。
		*@param y 沿 y 轴平移每个点的距离。
		*@return 返回矩阵对象本身
		*/
		__proto.setTranslate=function(x,y){
			this._nums[4]=x;
			this._nums[5]=y;
			return this;
		}

		/**
		*沿 x 和 y 轴平移矩阵，平移的变化量由 x 和 y 参数指定。
		*@param x 沿 x 轴向右移动的量（以像素为单位）。
		*@param y 沿 y 轴向下移动的量（以像素为单位）。
		*@return 返回矩阵对象本身
		*/
		__proto.translate=function(x,y){
			this._nums[4]+=x;
			this._nums[5]+=y;
			return this;
		}

		/**
		*对矩阵应用缩放转换。
		*@param x 用于沿 x 轴缩放对象的乘数。
		*@param y 用于沿 y 轴缩放对象的乘数。
		*@return 返回矩阵对象本身
		*/
		__proto.scale=function(x,y){
			var nums=this._nums;
			nums[0] *=x;
			nums[3] *=y;
			nums[2] *=x;
			nums[1] *=y;
			nums[4] *=x;
			nums[5] *=y;
			this._bTransform=true;
			return this;
		}

		/**
		*对 Matrix 对象应用旋转转换。
		*@param angle 以弧度为单位的旋转角度。
		*@return 返回矩阵对象本身
		*/
		__proto.rotate=function(angle){
			var nums=this._nums;
			var cos=Math.cos(angle);
			var sin=Math.sin(angle);
			var a1=nums[0];
			var c1=nums[2];
			var tx1=nums[4];
			nums[0]=a1 *cos-nums[1] *sin;
			nums[1]=a1 *sin+nums[1] *cos;
			nums[2]=c1 *cos-nums[3] *sin;
			nums[3]=c1 *sin+nums[3] *cos;
			nums[4]=tx1 *cos-nums[5] *sin;
			nums[5]=tx1 *sin+nums[5] *cos;
			this._bTransform=true;
			return this;
		}

		/**
		*对 Matrix 对象应用倾斜转换。
		*@param x 沿着 X 轴的 2D 倾斜弧度。
		*@param y 沿着 Y 轴的 2D 倾斜弧度。
		*@return 返回矩阵对象本身
		*/
		__proto.skew=function(x,y){
			var nums=this._nums;
			var tanX=Math.tan(x);
			var tanY=Math.tan(y);
			var a1=nums[0];
			var b1=nums[1];
			nums[0]+=tanY *nums[2];
			nums[1]+=tanY *nums[3];
			nums[2]+=tanX *a1;
			nums[3]+=tanX *b1;
			return this;
		}

		/**
		*对指定的点应用当前矩阵的逆转化并返回此点。
		*@param out 待转化的点 Point 对象。
		*@return 返回out
		*/
		__proto.invertTransformPoint=function(out){
			var nums=this._nums;
			var a1=nums[0];
			var b1=nums[1];
			var c1=nums[2];
			var d1=nums[3];
			var tx1=nums[4];
			var n=a1 *d1-b1 *c1;
			var a2=d1 / n;
			var b2=-b1 / n;
			var c2=-c1 / n;
			var d2=a1 / n;
			var tx2=(c1 *nums[5]-d1 *tx1)/ n;
			var ty2=-(a1 *nums[5]-b1 *tx1)/ n;
			return out.setTo(a2 *out.x+c2 *out.y+tx2,b2 *out.x+d2 *out.y+ty2);
		}

		/**
		*将 Matrix 对象表示的几何转换应用于指定点。
		*@param out 用来设定输出结果的点。
		*@return 返回out
		*/
		__proto.transformPoint=function(out){
			var nums=this._nums;
			return out.setTo(nums[0] *out.x+nums[2] *out.y+nums[4],nums[1] *out.x+nums[3] *out.y+nums[5]);
		}

		/**
		*将 Matrix 对象表示的几何转换应用于指定点，忽略tx、ty。
		*@param out 用来设定输出结果的点。
		*@return 返回out
		*/
		__proto.transformPointN=function(out){
			var nums=this._nums;
			return out.setTo(nums[0] *out.x+nums[2] *out.y ,nums[1] *out.x+nums[3] *out.y);
		}

		/**
		*获取 X 轴缩放值。
		*@return X 轴缩放值。
		*/
		__proto.getScaleX=function(){
			var nums=this._nums;
			return nums[1]===0 ? this.a :Math.sqrt(nums[0] *nums[0]+nums[1] *nums[1]);
		}

		/**
		*获取 Y 轴缩放值。
		*@return Y 轴缩放值。
		*/
		__proto.getScaleY=function(){
			var nums=this._nums;
			return nums[2]===0 ? nums[3] :Math.sqrt(nums[2] *nums[2]+nums[3] *nums[3]);
		}

		/**
		*执行原始矩阵的逆转换。
		*@return 返回矩阵对象本身
		*/
		__proto.invert=function(){
			var nums=this._nums;
			var a1=nums[0];
			var b1=nums[1];
			var c1=nums[2];
			var d1=nums[3];
			var tx1=nums[4];
			var n=a1 *d1-b1 *c1;
			nums[0]=d1 / n;
			nums[1]=-b1 / n;
			nums[2]=-c1 / n;
			nums[3]=a1 / n;
			nums[4]=(c1 *this.ty-d1 *tx1)/ n;
			nums[5]=-(a1 *this.ty-b1 *tx1)/ n;
			return this;
		}

		/**
		*将 Matrix 的成员设置为指定值。
		*@param a 缩放或旋转图像时影响像素沿 x 轴定位的值。
		*@param b 旋转或倾斜图像时影响像素沿 y 轴定位的值。
		*@param c 旋转或倾斜图像时影响像素沿 x 轴定位的值。
		*@param d 缩放或旋转图像时影响像素沿 y 轴定位的值。
		*@param tx 沿 x 轴平移每个点的距离。
		*@param ty 沿 y 轴平移每个点的距离。
		*@return 返回矩阵对象本身
		*/
		__proto.setTo=function(a,b,c,d,tx,ty){
			var nums=this._nums;
			nums[0]=a,nums[1]=b,nums[2]=c,nums[3]=d,nums[4]=tx,nums[5]=ty;
			return this;
		}

		/**
		*将指定矩阵与当前矩阵连接，从而将这两个矩阵的几何效果有效地结合在一起。
		*@param matrix 要连接到源矩阵的矩阵。
		*@return 当前矩阵。
		*/
		__proto.concat=function(matrix){
			var nums=this._nums;
			var aNums=matrix._nums;
			var a=nums[0];
			var c=nums[2];
			var tx=nums[4];
			nums[0]=a *aNums[0]+nums[1] *aNums[2];
			nums[1]=a *aNums[1]+nums[1] *aNums[3];
			nums[2]=c *aNums[0]+nums[3] *aNums[2];
			nums[3]=c *aNums[1]+nums[3] *aNums[3];
			nums[4]=tx *aNums[0]+nums[5] *aNums[2]+aNums[4];
			nums[5]=tx *aNums[1]+nums[5] *aNums[3]+aNums[5];
			return this;
		}

		/**
		*@private
		*对矩阵应用缩放转换。反向相乘
		*@param x 用于沿 x 轴缩放对象的乘数。
		*@param y 用于沿 y 轴缩放对象的乘数。
		*/
		__proto.scaleEx=function(x,y){
			var nums=this._nums;
			var ba=nums[0],bb=nums[1],bc=nums[2],bd=nums[3];
			if (bb!==0 || bc!==0){
				nums[0]=x *ba;
				nums[1]=x *bb;
				nums[2]=y *bc;
				nums[3]=y *bd;
				}else {
				nums[0]=x *ba;
				nums[1]=0 *bd;
				nums[2]=0 *ba;
				nums[3]=y *bd;
			}
			this._bTransform=true;
		}

		/**
		*@private
		*对 Matrix 对象应用旋转转换。反向相乘
		*@param angle 以弧度为单位的旋转角度。
		*/
		__proto.rotateEx=function(angle){
			var nums=this._nums;
			var cos=Math.cos(angle);
			var sin=Math.sin(angle);
			var ba=nums[0],bb=nums[1],bc=nums[2],bd=nums[3];
			if (bb!==0 || bc!==0){
				nums[0]=cos *ba+sin *bc;
				nums[1]=cos *bb+sin *bd;
				nums[2]=-sin *ba+cos *bc;
				nums[3]=-sin *bb+cos *bd;
				}else {
				nums[0]=cos *ba;
				nums[1]=sin *bd;
				nums[2]=-sin *ba;
				nums[3]=cos *bd;
			}
			this._bTransform=true;
		}

		/**
		*返回此 Matrix 对象的副本。
		*@return 与原始实例具有完全相同的属性的新 Matrix 实例。
		*/
		__proto.clone=function(){
			var nums=this._nums;
			var dec=MatrixConch.create();
			var dNums=dec._nums;
			dNums[0]=nums[0];
			dNums[1]=nums[1];
			dNums[2]=nums[2];
			dNums[3]=nums[3];
			dNums[4]=nums[4];
			dNums[5]=nums[5];
			dec._bTransform=this._bTransform;
			return dec;
		}

		/**
		*将当前 Matrix 对象中的所有矩阵数据复制到指定的 Matrix 对象中。
		*@param dec 要复制当前矩阵数据的 Matrix 对象。
		*@return 已复制当前矩阵数据的 Matrix 对象。
		*/
		__proto.copyTo=function(dec){
			var nums=this._nums;
			var dNums=dec._nums;
			dNums[0]=nums[0];
			dNums[1]=nums[1];
			dNums[2]=nums[2];
			dNums[3]=nums[3];
			dNums[4]=nums[4];
			dNums[5]=nums[5];
			dec._bTransform=this._bTransform;
			return dec;
		}

		/**
		*返回列出该 Matrix 对象属性的文本值。
		*@return 一个字符串，它包含 Matrix 对象的属性值：a、b、c、d、tx 和 ty。
		*/
		__proto.toString=function(){
			return this.a+","+this.b+","+this.c+","+this.d+","+this.tx+","+this.ty;
		}

		/**
		*销毁此对象。
		*/
		__proto.destroy=function(){
			this.recover();
		}

		/**
		*回收到对象池，方便复用
		*/
		__proto.recover=function(){
			MatrixConch._pool.push(this);
		}

		/**缩放或旋转图像时影响像素沿 x 轴定位的值。*/
		__getset(0,__proto,'a',function(){
			return this._nums[0];
			},function(value){
			this._nums[0]=value;
		});

		/**旋转或倾斜图像时影响像素沿 y 轴定位的值。*/
		__getset(0,__proto,'b',function(){
			return this._nums[1];
			},function(value){
			this._nums[1]=value;
		});

		/**旋转或倾斜图像时影响像素沿 x 轴定位的值。*/
		__getset(0,__proto,'c',function(){
			return this._nums[2];
			},function(value){
			this._nums[2]=value;
		});

		/**缩放或旋转图像时影响像素沿 y 轴定位的值。*/
		__getset(0,__proto,'d',function(){
			return this._nums[3];
			},function(value){
			this._nums[3]=value;
		});

		/**沿 x 轴平移每个点的距离。*/
		__getset(0,__proto,'tx',function(){
			return this._nums[4];
			},function(value){
			this._nums[4]=value;
		});

		/**沿 y 轴平移每个点的距离。*/
		__getset(0,__proto,'ty',function(){
			return this._nums[5];
			},function(value){
			this._nums[5]=value;
		});

		MatrixConch.mul=function(m1,m2,out){
			var m1Nums=m1._nums;
			var m2Nums=m2._nums;
			var oNums=out._nums;
			var aa=m1Nums[0],ab=m1Nums[1],ac=m1Nums[2],ad=m1Nums[3],atx=m1Nums[4],aty=m1Nums[5];
			var ba=m2Nums[0],bb=m2Nums[1],bc=m2Nums[2],bd=m2Nums[3],btx=m2Nums[4],bty=m2Nums[5];
			if (bb!==0 || bc!==0){
				oNums[0]=aa *ba+ab *bc;
				oNums[1]=aa *bb+ab *bd;
				oNums[2]=ac *ba+ad *bc;
				oNums[3]=ac *bb+ad *bd;
				oNums[4]=ba *atx+bc *aty+btx;
				oNums[5]=bb *atx+bd *aty+bty;
				}else {
				oNums[0]=aa *ba;
				oNums[1]=ab *bd;
				oNums[2]=ac *ba;
				oNums[3]=ad *bd;
				oNums[4]=ba *atx+btx;
				oNums[5]=bd *aty+bty;
			}
			return out;
		}

		MatrixConch.mul16=function(m1,m2,out){
			var m1Nums=m1._nums;
			var m2Nums=m2._nums;
			var aa=m1Nums[0],ab=m1Nums[1],ac=m1Nums[2],ad=m1Nums[3],atx=m1Nums[4],aty=m1Nums[5];
			var ba=m2Nums[0],bb=m2Nums[1],bc=m2Nums[2],bd=m2Nums[3],btx=m2Nums[4],bty=m2Nums[5];
			if (bb!==0 || bc!==0){
				out[0]=aa *ba+ab *bc;
				out[1]=aa *bb+ab *bd;
				out[4]=ac *ba+ad *bc;
				out[5]=ac *bb+ad *bd;
				out[12]=ba *atx+bc *aty+btx;
				out[13]=bb *atx+bd *aty+bty;
				}else {
				out[0]=aa *ba;
				out[1]=ab *bd;
				out[4]=ac *ba;
				out[5]=ad *bd;
				out[12]=ba *atx+btx;
				out[13]=bd *aty+bty;
			}
			return out;
		}

		MatrixConch.mulPre=function(m1,ba,bb,bc,bd,btx,bty,out){
			var m1Nums=m1._nums;
			var oNums=out._nums;
			var aa=m1Nums[0],ab=m1Nums[1],ac=m1Nums[2],ad=m1Nums[3],atx=m1Nums[4],aty=m1Nums[5];
			if (bb!==0 || bc!==0){
				oNums[0]=aa *ba+ab *bc;
				oNums[1]=aa *bb+ab *bd;
				oNums[2]=ac *ba+ad *bc;
				oNums[3]=ac *bb+ad *bd;
				oNums[4]=ba *atx+bc *aty+btx;
				oNums[5]=bb *atx+bd *aty+bty;
				}else {
				oNums[0]=aa *ba;
				oNums[1]=ab *bd;
				oNums[2]=ac *ba;
				oNums[3]=ad *bd;
				oNums[4]=ba *atx+btx;
				oNums[5]=bd *aty+bty;
			}
			return out;
		}

		MatrixConch.mulPos=function(m1,aa,ab,ac,ad,atx,aty,out){
			var m1Nums=m1._nums;
			var oNums=out._nums;
			var ba=m1Nums[0],bb=m1Nums[1],bc=m1Nums[2],bd=m1Nums[3],btx=m1Nums[4],bty=m1Nums[5];
			if (bb!==0 || bc!==0){
				oNums[0]=aa *ba+ab *bc;
				oNums[1]=aa *bb+ab *bd;
				oNums[2]=ac *ba+ad *bc;
				oNums[3]=ac *bb+ad *bd;
				oNums[4]=ba *atx+bc *aty+btx;
				oNums[5]=bb *atx+bd *aty+bty;
				}else {
				oNums[0]=aa *ba;
				oNums[1]=ab *bd;
				oNums[2]=ac *ba;
				oNums[3]=ad *bd;
				oNums[4]=ba *atx+btx;
				oNums[5]=bd *aty+bty;
			}
			return out;
		}

		MatrixConch.preMul=function(parent,self,out){
			var pNums=parent._nums;
			var sNums=self._nums;
			var oNums=out._nums;
			var pa=pNums[0],pb=pNums[1],pc=pNums[2],pd=pNums[3];
			var na=sNums[0],nb=sNums[1],nc=sNums[2],nd=sNums[3],ntx=sNums[4],nty=sNums[5];
			oNums[0]=na *pa;
			oNums[1]=oNums[2]=0;
			oNums[3]=nd *pd;
			oNums[4]=ntx *pa+pNums[4];
			oNums[5]=nty *pd+pNums[5];
			if (nb!==0 || nc!==0 || pb!==0 || pc!==0){
				oNums[0]+=nb *pc;
				oNums[3]+=nc *pb;
				oNums[1]+=na *pb+nb *pd;
				oNums[2]+=nc *pa+nd *pc;
				oNums[4]+=nty *pc;
				oNums[5]+=ntx *pb;
			}
			return out;
		}

		MatrixConch.preMulXY=function(parent,x,y,out){
			var pNums=parent._nums;
			var oNums=out._nums;
			var pa=pNums[0],pb=pNums[1],pc=pNums[2],pd=pNums[3];
			oNums[0]=pa;
			oNums[1]=pb;
			oNums[2]=pc;
			oNums[3]=pd;
			oNums[4]=x *pa+pNums[4]+y *pc;
			oNums[5]=y *pd+pNums[5]+x *pb;
			return out;
		}

		MatrixConch.create=function(nums){
			var m;
			if (MatrixConch._pool.length){
				m=MatrixConch._pool.pop();
				nums && (m._nums=nums);
				m.identity();
				return m;
			}else return new MatrixConch(1,0,0,1,0,0,nums);
		}

		MatrixConch.A=0;
		MatrixConch.B=1;
		MatrixConch.C=2;
		MatrixConch.D=3;
		MatrixConch.TX=4;
		MatrixConch.TY=5;
		MatrixConch.EMPTY=new MatrixConch();
		MatrixConch.TEMP=new MatrixConch();
		MatrixConch._pool=[];
		return MatrixConch;
	})()


	/**
	*@private
	*/
	//class laya.system.System
	var System=(function(){
		function System(){};
		__class(System,'laya.system.System');
		System.changeDefinition=function(name,classObj){
			Laya[name]=classObj;
			var str=name+"=classObj";
			eval(str);
		}

		System.__init__=function(){
			if (Render.isConchApp && window.conch){
				window.conch.disableConchResManager();
				window.conch.disableConchAutoRestoreLostedDevice();
			}
		}

		return System;
	})()


	/**
	*<code>Browser</code> 是浏览器代理类。封装浏览器及原生 js 提供的一些功能。
	*/
	//class laya.utils.Browser
	var Browser=(function(){
		function Browser(){};
		__class(Browser,'laya.utils.Browser');
		/**获得设备像素比。*/
		__getset(1,Browser,'pixelRatio',function(){
			if (Browser._pixelRatio < 0){
				Browser.__init__();
				if (Browser.userAgent.indexOf("Mozilla/6.0(Linux; Android 6.0; HUAWEI NXT-AL10 Build/HUAWEINXT-AL10)")>-1)Browser._pixelRatio=2;
				else {
					var ctx=Browser.context;
					var backingStore=ctx.backingStorePixelRatio || ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
					Browser._pixelRatio=(Browser._window.devicePixelRatio || 1)/ backingStore;
					if (Browser._pixelRatio < 1)Browser._pixelRatio=1;
				}
			}
			return Browser._pixelRatio;
		});

		/**浏览器窗口物理高度。考虑了设备像素比。*/
		__getset(1,Browser,'height',function(){
			Browser.__init__();
			return ((Laya.stage && Laya.stage.canvasRotation)? Browser.clientWidth :Browser.clientHeight)*Browser.pixelRatio;
		});

		/**
		*浏览器窗口可视宽度。
		*通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerWidth(包含滚动条宽度)> document.body.clientWidth(不包含滚动条宽度)，如果前者为0或为空，则选择后者。
		*/
		__getset(1,Browser,'clientWidth',function(){
			Browser.__init__();
			return Browser._window.innerWidth || Browser._document.body.clientWidth;
		});

		/**浏览器原生 window 对象的引用。*/
		__getset(1,Browser,'window',function(){
			return Browser._window || Browser.__init__();
		});

		/**
		*浏览器窗口可视高度。
		*通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerHeight(包含滚动条高度)> document.body.clientHeight(不包含滚动条高度)> document.documentElement.clientHeight(不包含滚动条高度)，如果前者为0或为空，则选择后者。
		*/
		__getset(1,Browser,'clientHeight',function(){
			Browser.__init__();
			return Browser._window.innerHeight || Browser._document.body.clientHeight || Browser._document.documentElement.clientHeight;
		});

		/**浏览器窗口物理宽度。考虑了设备像素比。*/
		__getset(1,Browser,'width',function(){
			Browser.__init__();
			return ((Laya.stage && Laya.stage.canvasRotation)? Browser.clientHeight :Browser.clientWidth)*Browser.pixelRatio;
		});

		/**画布容器，用来盛放画布的容器。方便对画布进行控制*/
		__getset(1,Browser,'container',function(){
			if (!Browser._container){
				Browser.__init__();
				Browser._container=Browser.createElement("div");
				Browser._container.id="layaContainer";
				Browser._document.body.appendChild(Browser._container);
			}
			return Browser._container;
			},function(value){
			Browser._container=value;
		});

		/**浏览器原生 document 对象的引用。*/
		__getset(1,Browser,'document',function(){
			Browser.__init__();
			return Browser._document;
		});

		Browser.__init__=function(){
			if (Browser._window)return Browser._window;
			var win=Browser._window=window;
			var doc=Browser._document=win.document;
			win.requestAnimationFrame=win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || function (fun){
				return win.setTimeout(fun,1000 / 60);
			};
			var bodyStyle=doc.body.style;
			bodyStyle.margin=0;
			bodyStyle.overflow='hidden';
			var metas=doc.getElementsByTagName('meta');
			var i=0,flag=false,content='width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no';
			while (i < metas.length){
				var meta=metas[i];
				if (meta.name=='viewport'){
					meta.content=content;
					flag=true;
					break ;
				}
				i++;
			}
			if (!flag){
				meta=doc.createElement('meta');
				meta.name='viewport',meta.content=content;
				doc.getElementsByTagName('head')[0].appendChild(meta);
			};
			var u=Browser.userAgent=win.navigator.userAgent;
			Browser.onMobile=u.indexOf("Mobile")>-1;
			Browser.onIOS=!!u.match(/\(i[^;]+;(U;)? CPU.+Mac OS X/);
			Browser.onIPhone=u.indexOf("iPhone")>-1;
			Browser.onIPad=u.indexOf("iPad")>-1;
			Browser.onAndroid=u.indexOf('Android')>-1 || u.indexOf('Adr')>-1;
			Browser.onWP=u.indexOf("Windows Phone")>-1;
			Browser.onQQBrowser=u.indexOf("QQBrowser")>-1;
			Browser.onMQQBrowser=u.indexOf("MQQBrowser")>-1 ||(u.indexOf("Mobile")>-1 && u.indexOf("QQ")>-1);
			Browser.onIE=!!win.ActiveXObject || "ActiveXObject" in win;
			Browser.onWeiXin=u.indexOf('MicroMessenger')>-1;
			Browser.onSafari=!!u.match(/Version\/\d+\.\d\x20Mobile\/\S+\x20Safari/);
			Browser.onPC=!Browser.onMobile;
			Browser.supportLocalStorage=LocalStorage.__init__();
			Browser.supportWebAudio=SoundManager.__init__();
			Render._mainCanvas=HTMLCanvas.create('2D');
			Browser.canvas=HTMLCanvas.create('2D');
			Browser.context=Browser.canvas.getContext('2d');
			return win;
		}

		Browser.createElement=function(type){
			Browser.__init__();
			return Browser._document.createElement(type);
		}

		Browser.getElementById=function(type){
			Browser.__init__();
			return Browser._document.getElementById(type);
		}

		Browser.removeElement=function(ele){
			if (ele && ele.parentNode)ele.parentNode.removeChild(ele);
		}

		Browser.now=function(){
			return Date.now();;
		}

		Browser.userAgent=null
		Browser.onMobile=false;
		Browser.onIOS=false;
		Browser.onIPhone=false;
		Browser.onIPad=false;
		Browser.onAndroid=false;
		Browser.onWP=false;
		Browser.onQQBrowser=false;
		Browser.onMQQBrowser=false;
		Browser.onSafari=false;
		Browser.onIE=false;
		Browser.onWeiXin=false;
		Browser.onPC=false;
		Browser.supportWebAudio=false;
		Browser.supportLocalStorage=false;
		Browser.canvas=null
		Browser.context=null
		Browser._window=null
		Browser._document=null
		Browser._container=null
		Browser._pixelRatio=-1;
		return Browser;
	})()


	/**
	*<p> <code>Byte</code> 类提供用于优化读取、写入以及处理二进制数据的方法和属性。</p>
	*<p> <code>Byte</code> 类适用于需要在字节层访问数据的高级开发人员。</p>
	*/
	//class laya.utils.Byte
	var Byte=(function(){
		function Byte(data){
			this._xd_=true;
			this._allocated_=8;
			//this._d_=null;
			//this._u8d_=null;
			this._pos_=0;
			this._length=0;
			if (data){
				this._u8d_=new Uint8Array(data);
				this._d_=new DataView(this._u8d_.buffer);
				this._length=this._d_.byteLength;
				}else {
				this._resizeBuffer(this._allocated_);
			}
		}

		__class(Byte,'laya.utils.Byte');
		var __proto=Byte.prototype;
		/**@private */
		__proto._resizeBuffer=function(len){
			try {
				var newByteView=new Uint8Array(len);
				if (this._u8d_ !=null){
					if (this._u8d_.length <=len)newByteView.set(this._u8d_);
					else newByteView.set(this._u8d_.subarray(0,len));
				}
				this._u8d_=newByteView;
				this._d_=new DataView(newByteView.buffer);
				}catch (err){
				throw "Invalid typed array length:"+len;
			}
		}

		/**
		*@private
		*<p>常用于解析固定格式的字节流。</p>
		*<p>先从字节流的当前字节偏移位置处读取一个 <code>Uint16</code> 值，然后以此值为长度，读取此长度的字符串。</p>
		*@return 读取的字符串。
		*/
		__proto.getString=function(){
			return this.readString();
		}

		/**
		*<p>常用于解析固定格式的字节流。</p>
		*<p>先从字节流的当前字节偏移位置处读取一个 <code>Uint16</code> 值，然后以此值为长度，读取此长度的字符串。</p>
		*@return 读取的字符串。
		*/
		__proto.readString=function(){
			return this._rUTF(this.getUint16());
		}

		/**
		*@private
		*<p>从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Float32Array</code> 对象并返回此对象。</p>
		*<p><b>注意：</b>返回的 Float32Array 对象，在 JavaScript 环境下，是原生的 HTML5 Float32Array 对象，对此对象的读取操作都是基于运行此程序的当前主机字节序，此顺序可能与实际数据的字节序不同，如果使用此对象进行读取，需要用户知晓实际数据的字节序和当前主机字节序，如果相同，可正常读取，否则需要用户对实际数据(Float32Array.buffer)包装一层 DataView ，使用 DataView 对象可按照指定的字节序进行读取。</p>
		*@param start 开始位置。
		*@param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
		*@return 读取的 Float32Array 对象。
		*/
		__proto.getFloat32Array=function(start,len){
			return this.readFloat32Array(start,len);
		}

		/**
		*从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Float32Array</code> 对象并返回此对象。
		*@param start 开始位置。
		*@param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
		*@return 读取的 Float32Array 对象。
		*/
		__proto.readFloat32Array=function(start,len){
			var end=start+len;
			end=(end > this._length)? this._length :end;
			var v=new Float32Array(this._d_.buffer.slice(start,end));
			this._pos_=end;
			return v;
		}

		/**
		*@private
		*从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Uint8Array</code> 对象并返回此对象。
		*@param start 开始位置。
		*@param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
		*@return 读取的 Uint8Array 对象。
		*/
		__proto.getUint8Array=function(start,len){
			return this.readUint8Array(start,len);
		}

		/**
		*从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Uint8Array</code> 对象并返回此对象。
		*@param start 开始位置。
		*@param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
		*@return 读取的 Uint8Array 对象。
		*/
		__proto.readUint8Array=function(start,len){
			var end=start+len;
			end=(end > this._length)? this._length :end;
			var v=new Uint8Array(this._d_.buffer.slice(start,end));
			this._pos_=end;
			return v;
		}

		/**
		*@private
		*<p>从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Int16Array</code> 对象并返回此对象。</p>
		*<p><b>注意：</b>返回的 Int16Array 对象，在 JavaScript 环境下，是原生的 HTML5 Int16Array 对象，对此对象的读取操作都是基于运行此程序的当前主机字节序，此顺序可能与实际数据的字节序不同，如果使用此对象进行读取，需要用户知晓实际数据的字节序和当前主机字节序，如果相同，可正常读取，否则需要用户对实际数据(Int16Array.buffer)包装一层 DataView ，使用 DataView 对象可按照指定的字节序进行读取。</p>
		*@param start 开始读取的字节偏移量位置。
		*@param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
		*@return 读取的 Int16Array 对象。
		*/
		__proto.getInt16Array=function(start,len){
			return this.readInt16Array(start,len);
		}

		/**
		*从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Int16Array</code> 对象并返回此对象。
		*@param start 开始读取的字节偏移量位置。
		*@param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
		*@return 读取的 Uint8Array 对象。
		*/
		__proto.readInt16Array=function(start,len){
			var end=start+len;
			end=(end > this._length)? this._length :end;
			var v=new Int16Array(this._d_.buffer.slice(start,end));
			this._pos_=end;
			return v;
		}

		/**
		*@private
		*从字节流的当前字节偏移位置处读取一个 IEEE 754 单精度（32 位）浮点数。
		*@return 单精度（32 位）浮点数。
		*/
		__proto.getFloat32=function(){
			return this.readFloat32();
		}

		/**
		*从字节流的当前字节偏移位置处读取一个 IEEE 754 单精度（32 位）浮点数。
		*@return 单精度（32 位）浮点数。
		*/
		__proto.readFloat32=function(){
			if (this._pos_+4 > this._length)throw "getFloat32 error - Out of bounds";
			var v=this._d_.getFloat32(this._pos_,this._xd_);
			this._pos_+=4;
			return v;
		}

		/**
		*@private
		*从字节流的当前字节偏移量位置处读取一个 IEEE 754 双精度（64 位）浮点数。
		*@return 双精度（64 位）浮点数。
		*/
		__proto.getFloat64=function(){
			return this.readFloat64();
		}

		/**
		*从字节流的当前字节偏移量位置处读取一个 IEEE 754 双精度（64 位）浮点数。
		*@return 双精度（64 位）浮点数。
		*/
		__proto.readFloat64=function(){
			if (this._pos_+8 > this._length)throw "getFloat64 error - Out of bounds";
			var v=this._d_.getFloat64(this._pos_,this._xd_);
			this._pos_+=8;
			return v;
		}

		/**
		*在字节流的当前字节偏移量位置处写入一个 IEEE 754 单精度（32 位）浮点数。
		*@param value 单精度（32 位）浮点数。
		*/
		__proto.writeFloat32=function(value){
			this._ensureWrite(this._pos_+4);
			this._d_.setFloat32(this._pos_,value,this._xd_);
			this._pos_+=4;
		}

		/**
		*在字节流的当前字节偏移量位置处写入一个 IEEE 754 双精度（64 位）浮点数。
		*@param value 双精度（64 位）浮点数。
		*/
		__proto.writeFloat64=function(value){
			this._ensureWrite(this._pos_+8);
			this._d_.setFloat64(this._pos_,value,this._xd_);
			this._pos_+=8;
		}

		/**
		*@private
		*从字节流的当前字节偏移量位置处读取一个 Int32 值。
		*@return Int32 值。
		*/
		__proto.getInt32=function(){
			return this.readInt32();
		}

		/**
		*从字节流的当前字节偏移量位置处读取一个 Int32 值。
		*@return Int32 值。
		*/
		__proto.readInt32=function(){
			if (this._pos_+4 > this._length)throw "getInt32 error - Out of bounds";
			var float=this._d_.getInt32(this._pos_,this._xd_);
			this._pos_+=4;
			return float;
		}

		/**
		*@private
		*从字节流的当前字节偏移量位置处读取一个 Uint32 值。
		*@return Uint32 值。
		*/
		__proto.getUint32=function(){
			return this.readUint32();
		}

		/**
		*从字节流的当前字节偏移量位置处读取一个 Uint32 值。
		*@return Uint32 值。
		*/
		__proto.readUint32=function(){
			if (this._pos_+4 > this._length)throw "getUint32 error - Out of bounds";
			var v=this._d_.getUint32(this._pos_,this._xd_);
			this._pos_+=4;
			return v;
		}

		/**
		*在字节流的当前字节偏移量位置处写入指定的 Int32 值。
		*@param value 需要写入的 Int32 值。
		*/
		__proto.writeInt32=function(value){
			this._ensureWrite(this._pos_+4);
			this._d_.setInt32(this._pos_,value,this._xd_);
			this._pos_+=4;
		}

		/**
		*在字节流的当前字节偏移量位置处写入 Uint32 值。
		*@param value 需要写入的 Uint32 值。
		*/
		__proto.writeUint32=function(value){
			this._ensureWrite(this._pos_+4);
			this._d_.setUint32(this._pos_,value,this._xd_);
			this._pos_+=4;
		}

		/**
		*@private
		*从字节流的当前字节偏移量位置处读取一个 Int16 值。
		*@return Int16 值。
		*/
		__proto.getInt16=function(){
			return this.readInt16();
		}

		/**
		*从字节流的当前字节偏移量位置处读取一个 Int16 值。
		*@return Int16 值。
		*/
		__proto.readInt16=function(){
			if (this._pos_+2 > this._length)throw "getInt16 error - Out of bounds";
			var us=this._d_.getInt16(this._pos_,this._xd_);
			this._pos_+=2;
			return us;
		}

		/**
		*@private
		*从字节流的当前字节偏移量位置处读取一个 Uint16 值。
		*@return Uint16 值。
		*/
		__proto.getUint16=function(){
			return this.readUint16();
		}

		/**
		*从字节流的当前字节偏移量位置处读取一个 Uint16 值。
		*@return Uint16 值。
		*/
		__proto.readUint16=function(){
			if (this._pos_+2 > this._length)throw "getUint16 error - Out of bounds";
			var us=this._d_.getUint16(this._pos_,this._xd_);
			this._pos_+=2;
			return us;
		}

		/**
		*在字节流的当前字节偏移量位置处写入指定的 Uint16 值。
		*@param value 需要写入的Uint16 值。
		*/
		__proto.writeUint16=function(value){
			this._ensureWrite(this._pos_+2);
			this._d_.setUint16(this._pos_,value,this._xd_);
			this._pos_+=2;
		}

		/**
		*在字节流的当前字节偏移量位置处写入指定的 Int16 值。
		*@param value 需要写入的 Int16 值。
		*/
		__proto.writeInt16=function(value){
			this._ensureWrite(this._pos_+2);
			this._d_.setInt16(this._pos_,value,this._xd_);
			this._pos_+=2;
		}

		/**
		*@private
		*从字节流的当前字节偏移量位置处读取一个 Uint8 值。
		*@return Uint8 值。
		*/
		__proto.getUint8=function(){
			return this.readUint8();
		}

		/**
		*从字节流的当前字节偏移量位置处读取一个 Uint8 值。
		*@return Uint8 值。
		*/
		__proto.readUint8=function(){
			if (this._pos_+1 > this._length)throw "getUint8 error - Out of bounds";
			return this._d_.getUint8(this._pos_++);
		}

		/**
		*在字节流的当前字节偏移量位置处写入指定的 Uint8 值。
		*@param value 需要写入的 Uint8 值。
		*/
		__proto.writeUint8=function(value){
			this._ensureWrite(this._pos_+1);
			this._d_.setUint8(this._pos_,value);
			this._pos_++;
		}

		/**
		*@private
		*从字节流的指定字节偏移量位置处读取一个 Uint8 值。
		*@param pos 字节读取位置。
		*@return Uint8 值。
		*/
		__proto._getUInt8=function(pos){
			return this._readUInt8(pos);
		}

		/**
		*@private
		*从字节流的指定字节偏移量位置处读取一个 Uint8 值。
		*@param pos 字节读取位置。
		*@return Uint8 值。
		*/
		__proto._readUInt8=function(pos){
			return this._d_.getUint8(pos);
		}

		/**
		*@private
		*从字节流的指定字节偏移量位置处读取一个 Uint16 值。
		*@param pos 字节读取位置。
		*@return Uint16 值。
		*/
		__proto._getUint16=function(pos){
			return this._readUint16(pos);
		}

		/**
		*@private
		*从字节流的指定字节偏移量位置处读取一个 Uint16 值。
		*@param pos 字节读取位置。
		*@return Uint16 值。
		*/
		__proto._readUint16=function(pos){
			return this._d_.getUint16(pos,this._xd_);
		}

		/**
		*@private
		*使用 getFloat32()读取6个值，用于创建并返回一个 Matrix 对象。
		*@return Matrix 对象。
		*/
		__proto._getMatrix=function(){
			return this._readMatrix();
		}

		/**
		*@private
		*使用 getFloat32()读取6个值，用于创建并返回一个 Matrix 对象。
		*@return Matrix 对象。
		*/
		__proto._readMatrix=function(){
			var rst=new Matrix(this.getFloat32(),this.getFloat32(),this.getFloat32(),this.getFloat32(),this.getFloat32(),this.getFloat32());
			return rst;
		}

		/**
		*@private
		*读取指定长度的 UTF 型字符串。
		*@param len 需要读取的长度。
		*@return 读取的字符串。
		*/
		__proto._rUTF=function(len){
			var v="",max=this._pos_+len,c=0,c2=0,c3=0,f=String.fromCharCode;
			var u=this._u8d_,i=0;
			while (this._pos_ < max){
				c=u[this._pos_++];
				if (c < 0x80){
					if (c !=0)v+=f(c);
					}else if (c < 0xE0){
					v+=f(((c & 0x3F)<< 6)| (u[this._pos_++] & 0x7F));
					}else if (c < 0xF0){
					c2=u[this._pos_++];
					v+=f(((c & 0x1F)<< 12)| ((c2 & 0x7F)<< 6)| (u[this._pos_++] & 0x7F));
					}else {
					c2=u[this._pos_++];
					c3=u[this._pos_++];
					v+=f(((c & 0x0F)<< 18)| ((c2 & 0x7F)<< 12)| ((c3 << 6)& 0x7F)| (u[this._pos_++] & 0x7F));
				}
				i++;
			}
			return v;
		}

		/**
		*@private
		*读取 <code>len</code> 参数指定的长度的字符串。
		*@param len 要读取的字符串的长度。
		*@return 指定长度的字符串。
		*/
		__proto.getCustomString=function(len){
			return this.readCustomString(len);
		}

		/**
		*@private
		*读取 <code>len</code> 参数指定的长度的字符串。
		*@param len 要读取的字符串的长度。
		*@return 指定长度的字符串。
		*/
		__proto.readCustomString=function(len){
			var v="",ulen=0,c=0,c2=0,f=String.fromCharCode;
			var u=this._u8d_,i=0;
			while (len > 0){
				c=u[this._pos_];
				if (c < 0x80){
					v+=f(c);
					this._pos_++;
					len--;
					}else {
					ulen=c-0x80;
					this._pos_++;
					len-=ulen;
					while (ulen > 0){
						c=u[this._pos_++];
						c2=u[this._pos_++];
						v+=f((c2 << 8)| c);
						ulen--;
					}
				}
			}
			return v;
		}

		/**
		*清除字节数组的内容，并将 length 和 pos 属性重置为 0。调用此方法将释放 Byte 实例占用的内存。
		*/
		__proto.clear=function(){
			this._pos_=0;
			this.length=0;
		}

		/**
		*@private
		*获取此对象的 ArrayBuffer 引用。
		*@return
		*/
		__proto.__getBuffer=function(){
			return this._d_.buffer;
		}

		/**
		*<p>将 UTF-8 字符串写入字节流。类似于 writeUTF()方法，但 writeUTFBytes()不使用 16 位长度的字为字符串添加前缀。</p>
		*<p>对应的读取方法为： getUTFBytes 。</p>
		*@param value 要写入的字符串。
		*/
		__proto.writeUTFBytes=function(value){
			value=value+"";
			for (var i=0,sz=value.length;i < sz;i++){
				var c=value.charCodeAt(i);
				if (c <=0x7F){
					this.writeByte(c);
					}else if (c <=0x7FF){
					this._ensureWrite(this._pos_+2);
					this._u8d_.set([0xC0 | (c >> 6),0x80 | (c & 0x3F)],this._pos_);
					this._pos_+=2;
					}else if (c <=0xFFFF){
					this._ensureWrite(this._pos_+3);
					this._u8d_.set([0xE0 | (c >> 12),0x80 | ((c >> 6)& 0x3F),0x80 | (c & 0x3F)],this._pos_);
					this._pos_+=3;
					}else {
					this._ensureWrite(this._pos_+4);
					this._u8d_.set([0xF0 | (c >> 18),0x80 | ((c >> 12)& 0x3F),0x80 | ((c >> 6)& 0x3F),0x80 | (c & 0x3F)],this._pos_);
					this._pos_+=4;
				}
			}
		}

		/**
		*<p>将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节。</p>
		*<p>对应的读取方法为： getUTFString 。</p>
		*@param value 要写入的字符串值。
		*/
		__proto.writeUTFString=function(value){
			var tPos=this.pos;
			this.writeUint16(1);
			this.writeUTFBytes(value);
			var dPos=this.pos-tPos-2;
			this._d_.setUint16(tPos,dPos,this._xd_);
		}

		/**
		*@private
		*读取 UTF-8 字符串。
		*@return 读取的字符串。
		*/
		__proto.readUTFString=function(){
			return this.readUTFBytes(this.getUint16());
		}

		/**
		*<p>从字节流中读取一个 UTF-8 字符串。假定字符串的前缀是一个无符号的短整型（以此字节表示要读取的长度）。</p>
		*<p>对应的写入方法为： writeUTFString 。</p>
		*@return 读取的字符串。
		*/
		__proto.getUTFString=function(){
			return this.readUTFString();
		}

		/**
		*@private
		*读字符串，必须是 writeUTFBytes 方法写入的字符串。
		*@param len 要读的buffer长度，默认将读取缓冲区全部数据。
		*@return 读取的字符串。
		*/
		__proto.readUTFBytes=function(len){
			(len===void 0)&& (len=-1);
			if (len===0)return "";
			var lastBytes=this.bytesAvailable;
			if (len > lastBytes)throw "readUTFBytes error - Out of bounds";
			len=len > 0 ? len :lastBytes;
			return this._rUTF(len);
		}

		/**
		*<p>从字节流中读取一个由 length 参数指定的长度的 UTF-8 字节序列，并返回一个字符串。</p>
		*<p>一般读取的是由 writeUTFBytes 方法写入的字符串。</p>
		*@param len 要读的buffer长度，默认将读取缓冲区全部数据。
		*@return 读取的字符串。
		*/
		__proto.getUTFBytes=function(len){
			(len===void 0)&& (len=-1);
			return this.readUTFBytes(len);
		}

		/**
		*<p>在字节流中写入一个字节。</p>
		*<p>使用参数的低 8 位。忽略高 24 位。</p>
		*@param value
		*/
		__proto.writeByte=function(value){
			this._ensureWrite(this._pos_+1);
			this._d_.setInt8(this._pos_,value);
			this._pos_+=1;
		}

		/**
		*<p>从字节流中读取带符号的字节。</p>
		*<p>返回值的范围是从-128 到 127。</p>
		*@return 介于-128 和 127 之间的整数。
		*/
		__proto.readByte=function(){
			if (this._pos_+1 > this._length)throw "readByte error - Out of bounds";
			return this._d_.getInt8(this._pos_++);
		}

		/**
		*@private
		*从字节流中读取带符号的字节。
		*/
		__proto.getByte=function(){
			return this.readByte();
		}

		/**
		*@private
		*<p>保证该字节流的可用长度不小于 <code>lengthToEnsure</code> 参数指定的值。</p>
		*@param lengthToEnsure 指定的长度。
		*/
		__proto._ensureWrite=function(lengthToEnsure){
			if (this._length < lengthToEnsure)this._length=lengthToEnsure;
			if (this._allocated_ < lengthToEnsure)this.length=lengthToEnsure;
		}

		/**
		*<p>将指定 arraybuffer 对象中的以 offset 为起始偏移量， length 为长度的字节序列写入字节流。</p>
		*<p>如果省略 length 参数，则使用默认长度 0，该方法将从 offset 开始写入整个缓冲区；如果还省略了 offset 参数，则写入整个缓冲区。</p>
		*<p>如果 offset 或 length 小于0，本函数将抛出异常。</p>
		*@param arraybuffer 需要写入的 Arraybuffer 对象。
		*@param offset Arraybuffer 对象的索引的偏移量（以字节为单位）
		*@param length 从 Arraybuffer 对象写入到 Byte 对象的长度（以字节为单位）
		*/
		__proto.writeArrayBuffer=function(arraybuffer,offset,length){
			(offset===void 0)&& (offset=0);
			(length===void 0)&& (length=0);
			if (offset < 0 || length < 0)throw "writeArrayBuffer error - Out of bounds";
			if (length==0)length=arraybuffer.byteLength-offset;
			this._ensureWrite(this._pos_+length);
			var uint8array=new Uint8Array(arraybuffer);
			this._u8d_.set(uint8array.subarray(offset,offset+length),this._pos_);
			this._pos_+=length;
		}

		/**
		*获取此对象的 ArrayBuffer 数据，数据只包含有效数据部分。
		*/
		__getset(0,__proto,'buffer',function(){
			var rstBuffer=this._d_.buffer;
			if (rstBuffer.byteLength===this._length)return rstBuffer;
			return rstBuffer.slice(0,this._length);
		});

		/**
		*<p> <code>Byte</code> 实例的字节序。取值为：<code>BIG_ENDIAN</code> 或 <code>BIG_ENDIAN</code> 。</p>
		*<p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。通过 <code>getSystemEndian</code> 可以获取当前系统的字节序。</p>
		*<p> <code>BIG_ENDIAN</code> ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。<br/>
		*<code>LITTLE_ENDIAN</code> ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
		*/
		__getset(0,__proto,'endian',function(){
			return this._xd_ ? "littleEndian" :"bigEndian";
			},function(value){
			this._xd_=(value==="littleEndian");
		});

		/**
		*<p> <code>Byte</code> 对象的长度（以字节为单位）。</p>
		*<p>如果将长度设置为大于当前长度的值，则用零填充字节数组的右侧；如果将长度设置为小于当前长度的值，将会截断该字节数组。</p>
		*<p>如果要设置的长度大于当前已分配的内存空间的字节长度，则重新分配内存空间，大小为以下两者较大者：要设置的长度、当前已分配的长度的2倍，并将原有数据拷贝到新的内存空间中；如果要设置的长度小于当前已分配的内存空间的字节长度，也会重新分配内存空间，大小为要设置的长度，并将原有数据从头截断为要设置的长度存入新的内存空间中。</p>
		*/
		__getset(0,__proto,'length',function(){
			return this._length;
			},function(value){
			if (this._allocated_ < value)this._resizeBuffer(this._allocated_=Math.floor(Math.max(value,this._allocated_ *2)));
			else if (this._allocated_ > value)this._resizeBuffer(this._allocated_=value);
			this._length=value;
		});

		/**
		*移动或返回 Byte 对象的读写指针的当前位置（以字节为单位）。下一次调用读取方法时将在此位置开始读取，或者下一次调用写入方法时将在此位置开始写入。
		*/
		__getset(0,__proto,'pos',function(){
			return this._pos_;
			},function(value){
			this._pos_=value;
		});

		/**
		*可从字节流的当前位置到末尾读取的数据的字节数。
		*/
		__getset(0,__proto,'bytesAvailable',function(){
			return this._length-this._pos_;
		});

		Byte.getSystemEndian=function(){
			if (!Byte._sysEndian){
				var buffer=new ArrayBuffer(2);
				new DataView(buffer).setInt16(0,256,true);
				Byte._sysEndian=(new Int16Array(buffer))[0]===256 ? "littleEndian" :"bigEndian";
			}
			return Byte._sysEndian;
		}

		Byte.BIG_ENDIAN="bigEndian";
		Byte.LITTLE_ENDIAN="littleEndian";
		Byte._sysEndian=null;
		return Byte;
	})()


	/**
	*@private
	*对象缓存统一管理类
	*/
	//class laya.utils.CacheManger
	var CacheManger=(function(){
		function CacheManger(){}
		__class(CacheManger,'laya.utils.CacheManger');
		CacheManger.regCacheByFunction=function(disposeFunction,getCacheListFunction){
			CacheManger.unRegCacheByFunction(disposeFunction,getCacheListFunction);
			var cache;
			cache={tryDispose:disposeFunction,getCacheList:getCacheListFunction};
			CacheManger._cacheList.push(cache);
		}

		CacheManger.unRegCacheByFunction=function(disposeFunction,getCacheListFunction){
			var i=0,len=0;
			len=CacheManger._cacheList.length;
			for (i=0;i < len;i++){
				if (CacheManger._cacheList[i].tryDispose==disposeFunction && CacheManger._cacheList[i].getCacheList==getCacheListFunction){
					CacheManger._cacheList.splice(i,1);
					return;
				}
			}
		}

		CacheManger.forceDispose=function(){
			var i=0,len=CacheManger._cacheList.length;
			for (i=0;i < len;i++){
				CacheManger._cacheList[i].tryDispose(true);
			}
		}

		CacheManger.beginCheck=function(waitTime){
			(waitTime===void 0)&& (waitTime=15000);
			Laya.timer.loop(waitTime,null,CacheManger._checkLoop);
		}

		CacheManger.stopCheck=function(){
			Laya.timer.clear(null,CacheManger._checkLoop);
		}

		CacheManger._checkLoop=function(){
			var cacheList=CacheManger._cacheList;
			if (cacheList.length < 1)return;
			var tTime=Browser.now();
			var count=0;
			var len=0;
			len=count=cacheList.length;
			while (count > 0){
				CacheManger._index++;
				CacheManger._index=CacheManger._index % len;
				cacheList[CacheManger._index].tryDispose(false);
				if (Browser.now()-tTime > CacheManger.loopTimeLimit)break ;
				count--;
			}
		}

		CacheManger.loopTimeLimit=2;
		CacheManger._cacheList=[];
		CacheManger._index=0;
		return CacheManger;
	})()


	/**
	*<code>ClassUtils</code> 是一个类工具类。
	*/
	//class laya.utils.ClassUtils
	var ClassUtils=(function(){
		function ClassUtils(){};
		__class(ClassUtils,'laya.utils.ClassUtils');
		ClassUtils.regClass=function(className,classDef){
			ClassUtils._classMap[className]=classDef;
		}

		ClassUtils.getRegClass=function(className){
			return ClassUtils._classMap[className];
		}

		ClassUtils.getClass=function(className){
			var classObject=ClassUtils._classMap[className] || className;
			if ((typeof classObject=='string'))return Laya["__classmap"][classObject];
			return classObject;
		}

		ClassUtils.getInstance=function(className){
			var compClass=ClassUtils.getClass(className);
			if (compClass)return new compClass();
			else console.warn("[error] Undefined class:",className);
			return null;
		}

		ClassUtils.createByJson=function(json,node,root,customHandler,instanceHandler){
			if ((typeof json=='string'))json=JSON.parse(json);
			var props=json.props;
			if (!node){
				node=instanceHandler ? instanceHandler.runWith(json):ClassUtils.getInstance(props.runtime || json.type);
				if (!node)return null;
			};
			var child=json.child;
			if (child){
				for (var i=0,n=child.length;i < n;i++){
					var data=child[i];
					if ((data.props.name==="render" || data.props.renderType==="render")&& node["_$set_itemRender"])
						node.itemRender=data;
					else {
						if (data.type=="Graphic"){
							ClassUtils._addGraphicsToSprite(data,node);
							}else if (ClassUtils._isDrawType(data.type)){
							ClassUtils._addGraphicToSprite(data,node,true);
							}else {
							var tChild=ClassUtils.createByJson(data,null,root,customHandler,instanceHandler)
							if (data.type==="Script"){
								if (tChild.hasOwnProperty("owner")){
									tChild["owner"]=node;
									}else if (tChild.hasOwnProperty("target")){
									tChild["target"]=node;
								}
								}else if (data.props.renderType=="mask"){
								node.mask=tChild;
								}else {
								node.addChild(tChild);
							}
						}
					}
				}
			}
			if (props){
				for (var prop in props){
					var value=props[prop];
					if (prop==="var" && root){
						root[value]=node;
						}else if ((value instanceof Array)&& (typeof (node[prop])=='function')){
						node[prop].apply(node,value);
						}else {
						node[prop]=value;
					}
				}
			}
			if (customHandler && json.customProps){
				customHandler.runWith([node,json]);
			}
			if (node["created"])node.created();
			return node;
		}

		ClassUtils._addGraphicsToSprite=function(graphicO,sprite){
			var graphics=graphicO.child;
			if (!graphics || graphics.length < 1)return;
			var g=ClassUtils._getGraphicsFromSprite(graphicO,sprite);
			var ox=0;
			var oy=0;
			if (graphicO.props){
				ox=ClassUtils._getObjVar(graphicO.props,"x",0);
				oy=ClassUtils._getObjVar(graphicO.props,"y",0);
			}
			if (ox !=0 && oy !=0){
				g.translate(ox,oy);
			};
			var i=0,len=0;
			len=graphics.length;
			for (i=0;i < len;i++){
				ClassUtils._addGraphicToGraphics(graphics[i],g);
			}
			if (ox !=0 && oy !=0){
				g.translate(-ox,-oy);
			}
		}

		ClassUtils._addGraphicToSprite=function(graphicO,sprite,isChild){
			(isChild===void 0)&& (isChild=false);
			var g=isChild ? ClassUtils._getGraphicsFromSprite(graphicO,sprite):sprite.graphics;
			ClassUtils._addGraphicToGraphics(graphicO,g);
		}

		ClassUtils._getGraphicsFromSprite=function(dataO,sprite){
			if (!dataO || !dataO.props)return sprite.graphics;
			var propsName=dataO.props.renderType;
			if (propsName==="hit" || propsName==="unHit"){
				var hitArea=sprite._style.hitArea || (sprite.hitArea=new HitArea());
				if (!hitArea[propsName]){
					hitArea[propsName]=new Graphics();
				};
				var g=hitArea[propsName];
			}
			if (!g)g=sprite.graphics;
			return g;
		}

		ClassUtils._getTransformData=function(propsO){
			var m;
			if (propsO.hasOwnProperty("pivotX")|| propsO.hasOwnProperty("pivotY")){
				m=m || new Matrix();
				m.translate(-ClassUtils._getObjVar(propsO,"pivotX",0),-ClassUtils._getObjVar(propsO,"pivotY",0));
			};
			var sx=ClassUtils._getObjVar(propsO,"scaleX",1),sy=ClassUtils._getObjVar(propsO,"scaleY",1);
			var rotate=ClassUtils._getObjVar(propsO,"rotation",0);
			var skewX=ClassUtils._getObjVar(propsO,"skewX",0);
			var skewY=ClassUtils._getObjVar(propsO,"skewY",0);
			if (sx !=1 || sy !=1 || rotate !=0){
				m=m || new Matrix();
				m.scale(sx,sy);
				m.rotate(rotate *0.0174532922222222);
			}
			return m;
		}

		ClassUtils._addGraphicToGraphics=function(graphicO,graphic){
			var propsO;
			propsO=graphicO.props;
			if (!propsO)return;
			var drawConfig;
			drawConfig=ClassUtils.DrawTypeDic[graphicO.type];
			if (!drawConfig)return;
			var g=graphic;
			var params=ClassUtils._getParams(propsO,drawConfig[1],drawConfig[2],drawConfig[3]);
			var m=ClassUtils._tM;
			if (m || ClassUtils._alpha !=1){
				g.save();
				if (m)g.transform(m);
				if (ClassUtils._alpha !=1)g.alpha(ClassUtils._alpha);
			}
			g[drawConfig[0]].apply(g,params);
			if (m || ClassUtils._alpha !=1){
				g.restore();
			}
		}

		ClassUtils._adptLineData=function(params){
			params[2]=parseFloat(params[0])+parseFloat(params[2]);
			params[3]=parseFloat(params[1])+parseFloat(params[3]);
			return params;
		}

		ClassUtils._adptTextureData=function(params){
			params[0]=Loader.getRes(params[0]);
			return params;
		}

		ClassUtils._adptLinesData=function(params){
			params[2]=ClassUtils._getPointListByStr(params[2]);
			return params;
		}

		ClassUtils._isDrawType=function(type){
			if (type==="Image")return false;
			return ClassUtils.DrawTypeDic.hasOwnProperty(type);
		}

		ClassUtils._getParams=function(obj,params,xPos,adptFun){
			(xPos===void 0)&& (xPos=0);
			var rst=ClassUtils._temParam;
			rst.length=params.length;
			var i=0,len=0;
			len=params.length;
			for (i=0;i < len;i++){
				rst[i]=ClassUtils._getObjVar(obj,params[i][0],params[i][1]);
			}
			ClassUtils._alpha=ClassUtils._getObjVar(obj,"alpha",1);
			var m;
			m=ClassUtils._getTransformData(obj);
			if (m){
				if (!xPos)xPos=0;
				m.translate(rst[xPos],rst[xPos+1]);
				rst[xPos]=rst[xPos+1]=0;
				ClassUtils._tM=m;
				}else {
				ClassUtils._tM=null;
			}
			if (adptFun && ClassUtils[adptFun]){
				rst=ClassUtils[adptFun](rst);
			}
			return rst;
		}

		ClassUtils._getPointListByStr=function(str){
			var pointArr=str.split(",");
			var i=0,len=0;
			len=pointArr.length;
			for (i=0;i < len;i++){
				pointArr[i]=parseFloat(pointArr[i]);
			}
			return pointArr;
		}

		ClassUtils._getObjVar=function(obj,key,noValue){
			if (obj.hasOwnProperty(key)){
				return obj[key];
			}
			return noValue;
		}

		ClassUtils._temParam=[];
		ClassUtils._classMap={'Sprite':'laya.display.Sprite','Text':'laya.display.Text','Animation':'laya.display.Animation','Skeleton':'laya.ani.bone.Skeleton','Particle2D':'laya.particle.Particle2D','div':'laya.html.dom.HTMLDivParser','p':'laya.html.dom.HTMLElement','img':'laya.html.dom.HTMLImageElement','span':'laya.html.dom.HTMLElement','br':'laya.html.dom.HTMLBrElement','style':'laya.html.dom.HTMLStyleElement','font':'laya.html.dom.HTMLElement','a':'laya.html.dom.HTMLElement','#text':'laya.html.dom.HTMLElement','link':'laya.html.dom.HTMLLinkElement'};
		ClassUtils._tM=null
		ClassUtils._alpha=NaN
		__static(ClassUtils,
		['DrawTypeDic',function(){return this.DrawTypeDic={"Rect":["drawRect",[["x",0],["y",0],["width",0],["height",0],["fillColor",null],["lineColor",null],["lineWidth",1]]],"Circle":["drawCircle",[["x",0],["y",0],["radius",0],["fillColor",null],["lineColor",null],["lineWidth",1]]],"Pie":["drawPie",[["x",0],["y",0],["radius",0],["startAngle",0],["endAngle",0],["fillColor",null],["lineColor",null],["lineWidth",1]]],"Image":["drawTexture",[["x",0],["y",0],["width",0],["height",0]]],"Texture":["drawTexture",[["skin",null],["x",0],["y",0],["width",0],["height",0]],1,"_adptTextureData"],"FillTexture":["fillTexture",[["skin",null],["x",0],["y",0],["width",0],["height",0],["repeat",null]],1,"_adptTextureData"],"FillText":["fillText",[["text",""],["x",0],["y",0],["font",null],["color",null],["textAlign",null]],1],"Line":["drawLine",[["x",0],["y",0],["toX",0],["toY",0],["lineColor",null],["lineWidth",0]],0,"_adptLineData"],"Lines":["drawLines",[["x",0],["y",0],["points",""],["lineColor",null],["lineWidth",0]],0,"_adptLinesData"],"Curves":["drawCurves",[["x",0],["y",0],["points",""],["lineColor",null],["lineWidth",0]],0,"_adptLinesData"],"Poly":["drawPoly",[["x",0],["y",0],["points",""],["fillColor",null],["lineColor",null],["lineWidth",1]],0,"_adptLinesData"]};}
		]);
		return ClassUtils;
	})()


	/**
	*@private
	*<code>Color</code> 是一个颜色值处理类。
	*/
	//class laya.utils.Color
	var Color=(function(){
		function Color(value){
			this.arrColor=[];
			//this.strColor=null;
			//this.numColor=0;
			//this._drawStyle=null;
			if (value==null){
				this.strColor="#00000000";
				this.numColor=0;
				this.arrColor=[0,0,0,0];
				return;
			};
			var i=0,len=0;
			var color=0;
			if ((typeof value=='string')){
				if ((value).indexOf("rgba(")>=0){
					var tStr=value;
					var beginI=0,endI=0;
					beginI=tStr.indexOf("(");
					endI=tStr.indexOf(")");
					tStr=tStr.substring(beginI+1,endI);
					this.arrColor=tStr.split(",");
					len=this.arrColor.length;
					for (i=0;i < len;i++){
						this.arrColor[i]=parseFloat(this.arrColor[i]);
					}
					color=((this.arrColor[0] *256+this.arrColor[1])*256+this.arrColor[2])*256+Math.round(this.arrColor[3] *255);
					this.strColor=value;
					}else{
					this.strColor=value;
					value.charAt(0)==='#' && (value=value.substr(1));
					len=value.length;
					if (len===3 || len===4){
						var temp="";
						for (i=0;i < len;i++){
							temp+=(value[i]+value[i]);
						}
						value=temp;
					}
					color=parseInt(value,16);
				}
				}else {
				color=value;
				this.strColor=Utils.toHexColor(color);
			}
			if (this.strColor.indexOf("rgba")>=0 || this.strColor.length===9){
				this.arrColor=[((0xFF000000 & color)>>>24)/ 255,((0xFF0000 & color)>> 16)/ 255,((0xFF00 & color)>>8)/ 255,(0xFF & color)/ 255];
				this.numColor=(0xff000000&color)>>>24|(color & 0xff0000)>> 8 | (color & 0x00ff00)<<8 | ((color & 0xff)<<24);
				}else {
				this.arrColor=[((0xFF0000 & color)>> 16)/ 255,((0xFF00 & color)>> 8)/ 255,(0xFF & color)/ 255,1];
				this.numColor=0xff000000|(color & 0xff0000)>> 16 | (color & 0x00ff00)| (color & 0xff)<< 16;
			}
			(this.arrColor).__id=++Color._COLODID;
		}

		__class(Color,'laya.utils.Color');
		Color._initDefault=function(){
			Color._DEFAULT={};
			for (var i in Color._COLOR_MAP)Color._SAVE[i]=Color._DEFAULT[i]=new Color(Color._COLOR_MAP[i]);
			return Color._DEFAULT;
		}

		Color._initSaveMap=function(){
			Color._SAVE_SIZE=0;
			Color._SAVE={};
			for (var i in Color._DEFAULT)Color._SAVE[i]=Color._DEFAULT[i];
		}

		Color.create=function(value){
			var key=value+"";
			var color=Color._SAVE[key];
			if (color !=null)return color;
			if (Color._SAVE_SIZE < 1000)Color._initSaveMap();
			return Color._SAVE[key]=new Color(value);
		}

		Color._SAVE={};
		Color._SAVE_SIZE=0;
		Color._COLOR_MAP={"white":'#FFFFFF',"red":'#FF0000',"green":'#00FF00',"blue":'#0000FF',"black":'#000000',"yellow":'#FFFF00','gray':'#808080'};
		Color._DEFAULT=Color._initDefault();
		Color._COLODID=1;
		return Color;
	})()


	/**
	*@private
	*<code>Dragging</code> 类是触摸滑动控件。
	*/
	//class laya.utils.Dragging
	var Dragging=(function(){
		function Dragging(){
			//this.target=null;
			this.ratio=0.92;
			this.maxOffset=60;
			//this.area=null;
			//this.hasInertia=false;
			//this.elasticDistance=NaN;
			//this.elasticBackTime=NaN;
			//this.data=null;
			this._dragging=false;
			this._clickOnly=true;
			//this._elasticRateX=NaN;
			//this._elasticRateY=NaN;
			//this._lastX=NaN;
			//this._lastY=NaN;
			//this._offsetX=NaN;
			//this._offsetY=NaN;
			//this._offsets=null;
			//this._disableMouseEvent=false;
			//this._tween=null;
			//this._parent=null;
		}

		__class(Dragging,'laya.utils.Dragging');
		var __proto=Dragging.prototype;
		/**
		*开始拖拽。
		*@param target 待拖拽的 <code>Sprite</code> 对象。
		*@param area 滑动范围。
		*@param hasInertia 拖动是否有惯性。
		*@param elasticDistance 橡皮筋最大值。
		*@param elasticBackTime 橡皮筋回弹时间，单位为毫秒。
		*@param data 事件携带数据。
		*@param disableMouseEvent 鼠标事件是否有效。
		*@param ratio 惯性阻尼系数
		*/
		__proto.start=function(target,area,hasInertia,elasticDistance,elasticBackTime,data,disableMouseEvent,ratio){
			(ratio===void 0)&& (ratio=0.92);
			this.clearTimer();
			this.target=target;
			this.area=area;
			this.hasInertia=hasInertia;
			this.elasticDistance=area ? elasticDistance :0;
			this.elasticBackTime=elasticBackTime;
			this.data=data;
			this._disableMouseEvent=disableMouseEvent;
			this.ratio=ratio;
			if (target.globalScaleX !=1 || target.globalScaleY !=1){
				this._parent=target.parent;
				}else {
				this._parent=Laya.stage;
			}
			this._clickOnly=true;
			this._dragging=true;
			this._elasticRateX=this._elasticRateY=1;
			this._lastX=this._parent.mouseX;
			this._lastY=this._parent.mouseY;
			Laya.stage.on("mouseup",this,this.onStageMouseUp);
			Laya.stage.on("mouseout",this,this.onStageMouseUp);
			Laya.timer.frameLoop(1,this,this.loop);
		}

		/**
		*清除计时器。
		*/
		__proto.clearTimer=function(){
			Laya.timer.clear(this,this.loop);
			Laya.timer.clear(this,this.tweenMove);
			if (this._tween){
				this._tween.recover();
				this._tween=null;
			}
		}

		/**
		*停止拖拽。
		*/
		__proto.stop=function(){
			if (this._dragging){
				MouseManager.instance.disableMouseEvent=false;
				Laya.stage.off("mouseup",this,this.onStageMouseUp);
				Laya.stage.off("mouseout",this,this.onStageMouseUp);
				this._dragging=false;
				this.target && this.area && this.backToArea();
				this.clear();
			}
		}

		/**
		*拖拽的循环处理函数。
		*/
		__proto.loop=function(){
			var point=this._parent.getMousePoint();
			var mouseX=point.x;
			var mouseY=point.y;
			var offsetX=mouseX-this._lastX;
			var offsetY=mouseY-this._lastY;
			if (this._clickOnly){
				if (Math.abs(offsetX *Laya.stage._canvasTransform.getScaleX())> 1 || Math.abs(offsetY *Laya.stage._canvasTransform.getScaleY())> 1){
					this._clickOnly=false;
					this._offsets || (this._offsets=[]);
					this._offsets.length=0;
					this.target.event("dragstart",this.data);
					MouseManager.instance.disableMouseEvent=this._disableMouseEvent;
				}else return;
				}else {
				this._offsets.push(offsetX,offsetY);
			}
			if (offsetX===0 && offsetY===0)return;
			this._lastX=mouseX;
			this._lastY=mouseY;
			this.target.x+=offsetX *this._elasticRateX;
			this.target.y+=offsetY *this._elasticRateY;
			this.area && this.checkArea();
			this.target.event("dragmove",this.data);
		}

		/**
		*拖拽区域检测。
		*/
		__proto.checkArea=function(){
			if (this.elasticDistance <=0){
				this.backToArea();
				}else {
				if (this.target._x < this.area.x){
					var offsetX=this.area.x-this.target._x;
					}else if (this.target._x > this.area.x+this.area.width){
					offsetX=this.target._x-this.area.x-this.area.width;
					}else {
					offsetX=0;
				}
				this._elasticRateX=Math.max(0,1-(offsetX / this.elasticDistance));
				if (this.target._y < this.area.y){
					var offsetY=this.area.y-this.target.y;
					}else if (this.target._y > this.area.y+this.area.height){
					offsetY=this.target._y-this.area.y-this.area.height;
					}else {
					offsetY=0;
				}
				this._elasticRateY=Math.max(0,1-(offsetY / this.elasticDistance));
			}
		}

		/**
		*移动至设定的拖拽区域。
		*/
		__proto.backToArea=function(){
			this.target.x=Math.min(Math.max(this.target._x,this.area.x),this.area.x+this.area.width);
			this.target.y=Math.min(Math.max(this.target._y,this.area.y),this.area.y+this.area.height);
		}

		/**
		*舞台的抬起事件侦听函数。
		*@param e Event 对象。
		*/
		__proto.onStageMouseUp=function(e){
			MouseManager.instance.disableMouseEvent=false;
			Laya.stage.off("mouseup",this,this.onStageMouseUp);
			Laya.stage.off("mouseout",this,this.onStageMouseUp);
			Laya.timer.clear(this,this.loop);
			if (this._clickOnly || !this.target)return;
			if (this.hasInertia){
				if (this._offsets.length < 1){
					this._offsets.push(this._parent.mouseX-this._lastX,this._parent.mouseY-this._lastY);
				}
				this._offsetX=this._offsetY=0;
				var len=this._offsets.length;
				var n=Math.min(len,6);
				var m=this._offsets.length-n;
				for (var i=len-1;i > m;i--){
					this._offsetY+=this._offsets[i--];
					this._offsetX+=this._offsets[i];
				}
				this._offsetX=this._offsetX / n *2;
				this._offsetY=this._offsetY / n *2;
				if (Math.abs(this._offsetX)> this.maxOffset)this._offsetX=this._offsetX > 0 ? this.maxOffset :-this.maxOffset;
				if (Math.abs(this._offsetY)> this.maxOffset)this._offsetY=this._offsetY > 0 ? this.maxOffset :-this.maxOffset;
				Laya.timer.frameLoop(1,this,this.tweenMove);
				}else if (this.elasticDistance > 0){
				this.checkElastic();
				}else {
				this.clear();
			}
		}

		/**
		*橡皮筋效果检测。
		*/
		__proto.checkElastic=function(){
			var tx=NaN;
			var ty=NaN;
			if (this.target.x < this.area.x)tx=this.area.x;
			else if (this.target._x > this.area.x+this.area.width)tx=this.area.x+this.area.width;
			if (this.target.y < this.area.y)ty=this.area.y;
			else if (this.target._y > this.area.y+this.area.height)ty=this.area.y+this.area.height;
			if (!isNaN(tx)|| !isNaN(ty)){
				var obj={};
				if (!isNaN(tx))obj.x=tx;
				if (!isNaN(ty))obj.y=ty;
				this._tween=Tween.to(this.target,obj,this.elasticBackTime,Ease.sineOut,Handler.create(this,this.clear),0,false,false);
				}else {
				this.clear();
			}
		}

		/**
		*移动。
		*/
		__proto.tweenMove=function(){
			this._offsetX *=this.ratio *this._elasticRateX;
			this._offsetY *=this.ratio *this._elasticRateY;
			this.target.x+=this._offsetX;
			this.target.y+=this._offsetY;
			this.area && this.checkArea();
			this.target.event("dragmove",this.data);
			if ((Math.abs(this._offsetX)< 1 && Math.abs(this._offsetY)< 1)|| this._elasticRateX < 0.5 || this._elasticRateY < 0.5){
				Laya.timer.clear(this,this.tweenMove);
				if (this.elasticDistance > 0)this.checkElastic();
				else this.clear();
			}
		}

		/**
		*结束拖拽。
		*/
		__proto.clear=function(){
			if (this.target){
				this.clearTimer();
				var sp=this.target;
				this.target=null;
				this._parent=null;
				sp.event("dragend",this.data);
			}
		}

		return Dragging;
	})()


	/**
	*<code>Ease</code> 类定义了缓动函数，以便实现 <code>Tween</code> 动画的缓动效果。
	*/
	//class laya.utils.Ease
	var Ease=(function(){
		function Ease(){};
		__class(Ease,'laya.utils.Ease');
		Ease.linearNone=function(t,b,c,d){
			return c *t / d+b;
		}

		Ease.linearIn=function(t,b,c,d){
			return c *t / d+b;
		}

		Ease.linearInOut=function(t,b,c,d){
			return c *t / d+b;
		}

		Ease.linearOut=function(t,b,c,d){
			return c *t / d+b;
		}

		Ease.bounceIn=function(t,b,c,d){
			return c-Ease.bounceOut(d-t,0,c,d)+b;
		}

		Ease.bounceInOut=function(t,b,c,d){
			if (t < d *0.5)return Ease.bounceIn(t *2,0,c,d)*.5+b;
			else return Ease.bounceOut(t *2-d,0,c,d)*.5+c *.5+b;
		}

		Ease.bounceOut=function(t,b,c,d){
			if ((t /=d)< (1 / 2.75))return c *(7.5625 *t *t)+b;
			else if (t < (2 / 2.75))return c *(7.5625 *(t-=(1.5 / 2.75))*t+.75)+b;
			else if (t < (2.5 / 2.75))return c *(7.5625 *(t-=(2.25 / 2.75))*t+.9375)+b;
			else return c *(7.5625 *(t-=(2.625 / 2.75))*t+.984375)+b;
		}

		Ease.backIn=function(t,b,c,d,s){
			(s===void 0)&& (s=1.70158);
			return c *(t /=d)*t *((s+1)*t-s)+b;
		}

		Ease.backInOut=function(t,b,c,d,s){
			(s===void 0)&& (s=1.70158);
			if ((t /=d *0.5)< 1)return c *0.5 *(t *t *(((s *=(1.525))+1)*t-s))+b;
			return c / 2 *((t-=2)*t *(((s *=(1.525))+1)*t+s)+2)+b;
		}

		Ease.backOut=function(t,b,c,d,s){
			(s===void 0)&& (s=1.70158);
			return c *((t=t / d-1)*t *((s+1)*t+s)+1)+b;
		}

		Ease.elasticIn=function(t,b,c,d,a,p){
			(a===void 0)&& (a=0);
			(p===void 0)&& (p=0);
			var s;
			if (t==0)return b;
			if ((t /=d)==1)return b+c;
			if (!p)p=d *.3;
			if (!a || (c > 0 && a < c)|| (c < 0 && a <-c)){
				a=c;
				s=p / 4;
			}else s=p / Ease.PI2 *Math.asin(c / a);
			return-(a *Math.pow(2,10 *(t-=1))*Math.sin((t *d-s)*Ease.PI2 / p))+b;
		}

		Ease.elasticInOut=function(t,b,c,d,a,p){
			(a===void 0)&& (a=0);
			(p===void 0)&& (p=0);
			var s;
			if (t==0)return b;
			if ((t /=d *0.5)==2)return b+c;
			if (!p)p=d *(.3 *1.5);
			if (!a || (c > 0 && a < c)|| (c < 0 && a <-c)){
				a=c;
				s=p / 4;
			}else s=p / Ease.PI2 *Math.asin(c / a);
			if (t < 1)return-.5 *(a *Math.pow(2,10 *(t-=1))*Math.sin((t *d-s)*Ease.PI2 / p))+b;
			return a *Math.pow(2,-10 *(t-=1))*Math.sin((t *d-s)*Ease.PI2 / p)*.5+c+b;
		}

		Ease.elasticOut=function(t,b,c,d,a,p){
			(a===void 0)&& (a=0);
			(p===void 0)&& (p=0);
			var s;
			if (t==0)return b;
			if ((t /=d)==1)return b+c;
			if (!p)p=d *.3;
			if (!a || (c > 0 && a < c)|| (c < 0 && a <-c)){
				a=c;
				s=p / 4;
			}else s=p / Ease.PI2 *Math.asin(c / a);
			return (a *Math.pow(2,-10 *t)*Math.sin((t *d-s)*Ease.PI2 / p)+c+b);
		}

		Ease.strongIn=function(t,b,c,d){
			return c *(t /=d)*t *t *t *t+b;
		}

		Ease.strongInOut=function(t,b,c,d){
			if ((t /=d *0.5)< 1)return c *0.5 *t *t *t *t *t+b;
			return c *0.5 *((t-=2)*t *t *t *t+2)+b;
		}

		Ease.strongOut=function(t,b,c,d){
			return c *((t=t / d-1)*t *t *t *t+1)+b;
		}

		Ease.sineInOut=function(t,b,c,d){
			return-c *0.5 *(Math.cos(Math.PI *t / d)-1)+b;
		}

		Ease.sineIn=function(t,b,c,d){
			return-c *Math.cos(t / d *Ease.HALF_PI)+c+b;
		}

		Ease.sineOut=function(t,b,c,d){
			return c *Math.sin(t / d *Ease.HALF_PI)+b;
		}

		Ease.quintIn=function(t,b,c,d){
			return c *(t /=d)*t *t *t *t+b;
		}

		Ease.quintInOut=function(t,b,c,d){
			if ((t /=d *0.5)< 1)return c *0.5 *t *t *t *t *t+b;
			return c *0.5 *((t-=2)*t *t *t *t+2)+b;
		}

		Ease.quintOut=function(t,b,c,d){
			return c *((t=t / d-1)*t *t *t *t+1)+b;
		}

		Ease.quartIn=function(t,b,c,d){
			return c *(t /=d)*t *t *t+b;
		}

		Ease.quartInOut=function(t,b,c,d){
			if ((t /=d *0.5)< 1)return c *0.5 *t *t *t *t+b;
			return-c *0.5 *((t-=2)*t *t *t-2)+b;
		}

		Ease.quartOut=function(t,b,c,d){
			return-c *((t=t / d-1)*t *t *t-1)+b;
		}

		Ease.cubicIn=function(t,b,c,d){
			return c *(t /=d)*t *t+b;
		}

		Ease.cubicInOut=function(t,b,c,d){
			if ((t /=d *0.5)< 1)return c *0.5 *t *t *t+b;
			return c *0.5 *((t-=2)*t *t+2)+b;
		}

		Ease.cubicOut=function(t,b,c,d){
			return c *((t=t / d-1)*t *t+1)+b;
		}

		Ease.quadIn=function(t,b,c,d){
			return c *(t /=d)*t+b;
		}

		Ease.quadInOut=function(t,b,c,d){
			if ((t /=d *0.5)< 1)return c *0.5 *t *t+b;
			return-c *0.5 *((--t)*(t-2)-1)+b;
		}

		Ease.quadOut=function(t,b,c,d){
			return-c *(t /=d)*(t-2)+b;
		}

		Ease.expoIn=function(t,b,c,d){
			return (t==0)? b :c *Math.pow(2,10 *(t / d-1))+b-c *0.001;
		}

		Ease.expoInOut=function(t,b,c,d){
			if (t==0)return b;
			if (t==d)return b+c;
			if ((t /=d *0.5)< 1)return c *0.5 *Math.pow(2,10 *(t-1))+b;
			return c *0.5 *(-Math.pow(2,-10 *--t)+2)+b;
		}

		Ease.expoOut=function(t,b,c,d){
			return (t==d)? b+c :c *(-Math.pow(2,-10 *t / d)+1)+b;
		}

		Ease.circIn=function(t,b,c,d){
			return-c *(Math.sqrt(1-(t /=d)*t)-1)+b;
		}

		Ease.circInOut=function(t,b,c,d){
			if ((t /=d *0.5)< 1)return-c *0.5 *(Math.sqrt(1-t *t)-1)+b;
			return c *0.5 *(Math.sqrt(1-(t-=2)*t)+1)+b;
		}

		Ease.circOut=function(t,b,c,d){
			return c *Math.sqrt(1-(t=t / d-1)*t)+b;
		}

		Ease.HALF_PI=Math.PI *0.5;
		Ease.PI2=Math.PI *2;
		return Ease;
	})()


	/**
	*鼠标点击区域，可以设置绘制一系列矢量图作为点击区域和非点击区域（目前只支持圆形，矩形，多边形）
	*
	*/
	//class laya.utils.HitArea
	var HitArea=(function(){
		function HitArea(){
			this._hit=null;
			this._unHit=null;
		}

		__class(HitArea,'laya.utils.HitArea');
		var __proto=HitArea.prototype;
		/**
		*检测对象是否包含指定的点。
		*@param x 点的 X 轴坐标值（水平位置）。
		*@param y 点的 Y 轴坐标值（垂直位置）。
		*@return 如果包含指定的点，则值为 true；否则为 false。
		*/
		__proto.contains=function(x,y){
			if (!HitArea._isHitGraphic(x,y,this.hit))return false;
			return !HitArea._isHitGraphic(x,y,this.unHit);
		}

		/**
		*可点击区域，可以设置绘制一系列矢量图作为点击区域（目前只支持圆形，矩形，多边形）
		*/
		__getset(0,__proto,'hit',function(){
			if (!this._hit)this._hit=new Graphics();
			return this._hit;
			},function(value){
			this._hit=value;
		});

		/**
		*不可点击区域，可以设置绘制一系列矢量图作为非点击区域（目前只支持圆形，矩形，多边形）
		*/
		__getset(0,__proto,'unHit',function(){
			if (!this._unHit)this._unHit=new Graphics();
			return this._unHit;
			},function(value){
			this._unHit=value;
		});

		HitArea._isHitGraphic=function(x,y,graphic){
			if (!graphic)return false;
			var cmds=graphic.cmds;
			if (!cmds && graphic._one){
				cmds=HitArea._cmds;
				cmds.length=1;
				cmds[0]=graphic._one;
			}
			if (!cmds)return false;
			var i=0,len=0;
			len=cmds.length;
			var cmd;
			for (i=0;i < len;i++){
				cmd=cmds[i];
				if (!cmd)continue ;
				var context=Render._context;
				switch (cmd.callee){
					case context._translate:
					case 6:
						x-=cmd[0];
						y-=cmd[1];
					}
				if (HitArea._isHitCmd(x,y,cmd))return true;
			}
			return false;
		}

		HitArea._isHitCmd=function(x,y,cmd){
			if (!cmd)return false;
			var context=Render._context;
			var rst=false;
			switch (cmd["callee"]){
				case context._drawRect:
				case 13:
					HitArea._rect.setTo(cmd[0],cmd[1],cmd[2],cmd[3]);
					rst=HitArea._rect.contains(x,y);
					break ;
				case context._drawCircle:
				case context._fillCircle:
				case 14:;
					var d=NaN;
					x-=cmd[0];
					y-=cmd[1];
					d=x *x+y *y;
					rst=d < cmd[2] *cmd[2];
					break ;
				case context._drawPoly:
				case 18:
					x-=cmd[0];
					y-=cmd[1];
					rst=HitArea._ptInPolygon(x,y,cmd[2]);
					break ;
				}
			return rst;
		}

		HitArea._ptInPolygon=function(x,y,areaPoints){
			var p=HitArea._ptPoint;
			p.setTo(x,y);
			var nCross=0;
			var p1x=NaN,p1y=NaN,p2x=NaN,p2y=NaN;
			var len=0;
			len=areaPoints.length;
			for (var i=0;i < len;i+=2){
				p1x=areaPoints[i];
				p1y=areaPoints[i+1];
				p2x=areaPoints[(i+2)% len];
				p2y=areaPoints[(i+3)% len];
				if (p1y==p2y)continue ;
				if (p.y < Math.min(p1y,p2y))continue ;
				if (p.y >=Math.max(p1y,p2y))continue ;
				var tx=(p.y-p1y)*(p2x-p1x)/ (p2y-p1y)+p1x;
				if (tx > p.x)nCross++;
			}
			return (nCross % 2==1);
		}

		HitArea._cmds=[];
		__static(HitArea,
		['_rect',function(){return this._rect=new Rectangle();},'_ptPoint',function(){return this._ptPoint=new Point();}
		]);
		return HitArea;
	})()


	/**
	*@private
	*<code>HTMLChar</code> 是一个 HTML 字符类。
	*/
	//class laya.utils.HTMLChar
	var HTMLChar=(function(){
		function HTMLChar(){
			//this.x=NaN;
			//this.y=NaN;
			//this.width=NaN;
			//this.height=NaN;
			//this.isWord=false;
			//this.char=null;
			//this.charNum=NaN;
			//this.style=null;
			this.reset();
		}

		__class(HTMLChar,'laya.utils.HTMLChar');
		var __proto=HTMLChar.prototype;
		/**
		*根据指定的字符、宽高、样式，创建一个 <code>HTMLChar</code> 类的实例。
		*@param char 字符。
		*@param w 宽度。
		*@param h 高度。
		*@param style CSS 样式。
		*/
		__proto.setData=function(char,w,h,style){
			this.char=char;
			this.charNum=char.charCodeAt(0);
			this.x=this.y=0;
			this.width=w;
			this.height=h;
			this.style=style;
			this.isWord=!HTMLChar._isWordRegExp.test(char);
			return this;
		}

		/**
		*重置
		*/
		__proto.reset=function(){
			this.x=this.y=this.width=this.height=0;
			this.isWord=false;
			this.char=null;
			this.charNum=0;
			this.style=null;
			return this;
		}

		/**
		*回收
		*/
		__proto.recover=function(){
			Pool.recover("HTMLChar",this.reset());
		}

		/**@private */
		__proto._isChar=function(){
			return true;
		}

		/**@private */
		__proto._getCSSStyle=function(){
			return this.style;
		}

		HTMLChar.create=function(){
			return Pool.getItemByClass("HTMLChar",HTMLChar);
		}

		HTMLChar._isWordRegExp=new RegExp("[\\w\.]","");
		return HTMLChar;
	})()


	/**
	*<code>Log</code> 类用于在界面内显示日志记录信息。
	*注意：在加速器内不可使用
	*/
	//class laya.utils.Log
	var Log=(function(){
		function Log(){};
		__class(Log,'laya.utils.Log');
		Log.enable=function(){
			if (!Log._logdiv){
				Log._logdiv=Browser.createElement('div');
				Log._logdiv.style.cssText="border:white;padding:4px;overflow-y:auto;z-index:1000000;background:rgba(100,100,100,0.6);color:white;position: absolute;left:0px;top:0px;width:50%;height:50%;";
				Browser.document.body.appendChild(Log._logdiv);
				Log._btn=Browser.createElement("button");
				Log._btn.innerText="Hide";
				Log._btn.style.cssText="z-index:1000001;position: absolute;left:10px;top:10px;";
				Log._btn.onclick=Log.toggle;
				Browser.document.body.appendChild(Log._btn);
			}
		}

		Log.toggle=function(){
			var style=Log._logdiv.style;
			if (style.display===""){
				Log._btn.innerText="Show";
				style.display="none";
				}else {
				Log._btn.innerText="Hide";
				style.display="";
			}
		}

		Log.print=function(value){
			if (Log._logdiv){
				if (Log._count >=Log.maxCount)Log.clear();
				Log._count++;
				Log._logdiv.innerText+=value+"\n";
				if (Log.autoScrollToBottom){
					if (Log._logdiv.scrollHeight-Log._logdiv.scrollTop-Log._logdiv.clientHeight < 50){
						Log._logdiv.scrollTop=Log._logdiv.scrollHeight;
					}
				}
			}
		}

		Log.clear=function(){
			Log._logdiv.innerText="";
			Log._count=0;
		}

		Log._logdiv=null
		Log._btn=null
		Log._count=0;
		Log.maxCount=50;
		Log.autoScrollToBottom=true;
		return Log;
	})()


	/**
	*<p> <code>Pool</code> 是对象池类，用于对象的存储、重复使用。</p>
	*<p>合理使用对象池，可以有效减少对象创建的开销，避免频繁的垃圾回收，从而优化游戏流畅度。</p>
	*/
	//class laya.utils.Pool
	var Pool=(function(){
		function Pool(){};
		__class(Pool,'laya.utils.Pool');
		Pool.getPoolBySign=function(sign){
			return Pool._poolDic[sign] || (Pool._poolDic[sign]=[]);
		}

		Pool.clearBySign=function(sign){
			if (Pool._poolDic[sign])Pool._poolDic[sign].length=0;
		}

		Pool.recover=function(sign,item){
			if (item["__InPool"])return;
			item["__InPool"]=true;
			Pool.getPoolBySign(sign).push(item);
		}

		Pool.getItemByClass=function(sign,cls){
			var pool=Pool.getPoolBySign(sign);
			if (pool.length){
				var rst=pool.pop();
				rst["__InPool"]=false;
				}else {
				rst=new cls();
			}
			return rst;
		}

		Pool.getItemByCreateFun=function(sign,createFun){
			var pool=Pool.getPoolBySign(sign);
			var rst=pool.length ? pool.pop():createFun();
			rst["__InPool"]=false;
			return rst;
		}

		Pool.getItem=function(sign){
			var pool=Pool.getPoolBySign(sign);
			var rst=pool.length ? pool.pop():null;
			if (rst){
				rst["__InPool"]=false;
			}
			return rst;
		}

		Pool.POOLSIGN="__InPool";
		Pool._poolDic={};
		return Pool;
	})()


	/**
	*@private
	*/
	//class laya.utils.RunDriver
	var RunDriver=(function(){
		function RunDriver(){};
		__class(RunDriver,'laya.utils.RunDriver');
		RunDriver.update3DLoop=function(){}
		RunDriver.enableNative=function(){
			LayaGLRunner.uploadShaderAttributes=LayaGLRunner.uploadShaderAttributesForNative;
			LayaGLRunner.uploadShaderUniforms=LayaGLRunner.uploadShaderUniformsForNative;
			var sprite=Sprite;
			sprite.prototype.render=sprite.prototype.renderToNative;
			var commandEncoder=GLCommandEncoder;
			var layaGL=LayaGL;
			var shaderData=ShaderDatas;
			var shader3D=ShaderInstance;
			var baseTexture=BaseTexture;
			var skinnedMeshRender=SkinnedMeshRender;
			if (window.conch){
				commandEncoder.prototype._init=commandEncoder.prototype._initWithNative;
				commandEncoder.prototype._need=commandEncoder.prototype._needWithNative;
				commandEncoder.prototype.add_String=commandEncoder.prototype.add_StringForNative;
				commandEncoder.prototype.addShaderAttribute=commandEncoder.prototype.addShaderAttributeForNative;
				commandEncoder.prototype.addShaderUniform=commandEncoder.prototype.addShaderUniformForNative;
				commandEncoder.prototype.clearEncoding=commandEncoder.prototype.clearEncodingForNative;
				commandEncoder.prototype.getCount=commandEncoder.prototype.getCountForNative;
				layaGL.prototype.beginCommandEncoding=layaGL.prototype.beginCommandEncodingForNative;
				shaderData.prototype._initData=shaderData.prototype._initDataForNative;
				shaderData.prototype.setBool=shaderData.prototype.setBoolForNative;
				shaderData.prototype.getBool=shaderData.prototype.getBoolForNative;
				shaderData.prototype.setInt=shaderData.prototype.setIntForNative;
				shaderData.prototype.getInt=shaderData.prototype.getIntForNative;
				shaderData.prototype.setNumber=shaderData.prototype.setNumberForNative;
				shaderData.prototype.getNumber=shaderData.prototype.getNumberForNative;
				shaderData.prototype.setVector=shaderData.prototype.setVectorForNative;
				shaderData.prototype.getVector=shaderData.prototype.getVectorForNative;
				shaderData.prototype.setQuaternion=shaderData.prototype.setQuaternionForNative;
				shaderData.prototype.getQuaternion=shaderData.prototype.getQuaternionForNative;
				shaderData.prototype.setMatrix4x4=shaderData.prototype.setMatrix4x4ForNative;
				shaderData.prototype.getMatrix4x4=shaderData.prototype.getMatrix4x4ForNative;
				shaderData.prototype.setBuffer=shaderData.prototype.setBufferForNative;
				shaderData.prototype.getBuffer=shaderData.prototype.getBufferForNative;
				shaderData.prototype.setTexture=shaderData.prototype.setTextureForNative;
				shaderData.prototype.getTexture=shaderData.prototype.getTextureForNative;
				shaderData.prototype.setAttribute=shaderData.prototype.setAttributeForNative;
				shaderData.prototype.getAttribute=shaderData.prototype.getAttributeForNative;
				shader3D.prototype._uniformMatrix2fv=shader3D.prototype._uniformMatrix2fvForNative;
				shader3D.prototype._uniformMatrix3fv=shader3D.prototype._uniformMatrix3fvForNative;
				shader3D.prototype._uniformMatrix4fv=shader3D.prototype._uniformMatrix4fvForNative;
				baseTexture.prototype._getGLFormat=baseTexture.prototype._getGLFormatForNative;
				skinnedMeshRender.prototype._computeSkinnedData=skinnedMeshRender.prototype._computeSkinnedDataForNative;
				Utils3D.matrix4x4MultiplyFFF=Utils3D.matrix4x4MultiplyFFFForNative;
			}
			ConchSpriteAdpt.init();
		}

		RunDriver.FILTER_ACTIONS=[];
		RunDriver.getIncludeStr=function(name){
			return null;
		}

		RunDriver.createShaderCondition=function(conditionScript){
			var fn="(function() {return "+conditionScript+";})";
			return Browser.window.eval(fn);
		}

		RunDriver.fontMap=[];
		RunDriver.measureText=function(txt,font){
			var isChinese=RunDriver.hanzi.test(txt);
			if (isChinese && RunDriver.fontMap[font]){
				return RunDriver.fontMap[font];
			};
			var ctx=Browser.context;
			ctx.font=font;
			var r=ctx.measureText(txt);
			if (isChinese)RunDriver.fontMap[font]=r;
			return r;
		}

		RunDriver.flashFlushImage=function(atlasWebGLCanvas){
		};

		RunDriver.drawToCanvas=function(sprite,_renderType,canvasWidth,canvasHeight,offsetX,offsetY){
			debugger;
			return null;
		}

		RunDriver.createParticleTemplate2D=null
		RunDriver.createGLTextur=null;
		RunDriver.createWebGLContext2D=null;
		RunDriver.changeWebGLSize=function(w,h){
		};

		RunDriver.createRenderSprite=function(type,next){
			return new RenderSprite(type,next);
		}

		RunDriver.createFilterAction=function(type){
			return new ColorFilterAction();
		}

		RunDriver.createGraphics=function(){
			return new Graphics();
		}

		RunDriver.clear=function(value){
			if (!Render.isConchApp){
				Render._context.clear();
			}
		}

		RunDriver.getTexturePixels=function(value,x,y,width,height){
			return null;
		}

		RunDriver.skinAniSprite=function(){
			return null;
		}

		RunDriver.cancelLoadByUrl=function(url){
		};

		__static(RunDriver,
		['hanzi',function(){return this.hanzi=new RegExp("^[\u4E00-\u9FA5]$");}
		]);
		return RunDriver;
	})()


	/**
	*<p> <code>Stat</code> 是一个性能统计面板，可以实时更新相关的性能参数。</p>
	*<p>参与统计的性能参数如下（所有参数都是每大约1秒进行更新）：<br/>
	*FPS(Canvas)/FPS(WebGL)：Canvas 模式或者 WebGL 模式下的帧频，也就是每秒显示的帧数，值越高、越稳定，感觉越流畅；<br/>
	*Sprite：统计所有渲染节点（包括容器）数量，它的大小会影响引擎进行节点遍历、数据组织和渲染的效率。其值越小，游戏运行效率越高；<br/>
	*DrawCall：此值是决定性能的重要指标，其值越小，游戏运行效率越高。Canvas模式下表示每大约1秒的图像绘制次数；WebGL模式下表示每大约1秒的渲染提交批次，每次准备数据并通知GPU渲染绘制的过程称为1次DrawCall，在每次DrawCall中除了在通知GPU的渲染上比较耗时之外，切换材质与shader也是非常耗时的操作；<br/>
	*Memory：Canvas模式下，表示内存占用大小，值越小越好，过高会导致游戏闪退；WebGL模式下，表示内存与显存的占用，值越小越好；<br/>
	*Shader：是 WebGL 模式独有的性能指标，表示每大约1秒 Shader 提交次数，值越小越好；<br/>
	*Canvas：由三个数值组成，只有设置 CacheAs 后才会有值，默认为0/0/0。从左到右数值的意义分别为：每帧重绘的画布数量 / 缓存类型为"normal"类型的画布数量 / 缓存类型为"bitmap"类型的画布数量。</p>
	*/
	//class laya.utils.Stat
	var Stat=(function(){
		function Stat(){};
		__class(Stat,'laya.utils.Stat');
		/**
		*设置点击FPS区域后，触发的函数。里面可以放置一些调试逻辑处理。
		*/
		__getset(1,Stat,'onclick',null,function(fn){
			Stat._canvas.source.onclick=fn;
			Stat._canvas.source.style.pointerEvents='';
		});

		Stat.show=function(x,y){
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			if (Render.isConchApp){
				window.conch && window.conch.showFPS&&window.conch.showFPS(x,y);
				return;
			};
			var pixel=Browser.pixelRatio;
			Stat._width=pixel *130;
			Stat._vx=pixel *75;
			Stat._view[0]={title:"FPS(Canvas)",value:"_fpsStr",color:"yellow",units:"int"};
			Stat._view[1]={title:"Sprite",value:"spriteCount",color:"white",units:"int"};
			Stat._view[2]={title:"DrawCall",value:"drawCall",color:"white",units:"int"};
			Stat._view[3]={title:"Memory",value:"currentMemorySize",color:"yellow",units:"M"};
			if (Render.isWebGL){
				Stat._view[4]={title:"Shader",value:"shaderCall",color:"white",units:"int"};
				if (!Render.is3DMode){
					Stat._view[0].title="FPS(WebGL)";
					Stat._view[5]={title:"Canvas",value:"_canvasStr",color:"white",units:"int" };
					Stat._view[6]={title:"Mesh2D",value:"mesh2DNum",color:"white",uints:"int" };
					}else {
					Stat._view[0].title="FPS(3D)";
					Stat._view[5]={title:"TriFaces",value:"trianglesFaces",color:"white",units:"int"};
					Stat._view[6]={title:"treeNodeColl",value:"treeNodeCollision",color:"white",units:"int"};
					Stat._view[7]={title:"treeSpriteColl",value:"treeSpriteCollision",color:"white",units:"int"};
				}
				}else {
				Stat._view[4]={title:"Canvas",value:"_canvasStr",color:"white",units:"int"};
			}
			Stat._fontSize=12 *pixel;
			for (var i=0;i < Stat._view.length;i++){
				Stat._view[i].x=4;
				Stat._view[i].y=i *Stat._fontSize+2 *pixel;
			}
			Stat._height=pixel *(Stat._view.length *12+3 *pixel)+4;
			if (!Stat._canvas){
				Stat._canvas=new HTMLCanvas('2D');
				Stat._canvas.size(Stat._width,Stat._height);
				Stat._ctx=Stat._canvas.getContext('2d');
				Stat._ctx.textBaseline="top";
				Stat._ctx.font=Stat._fontSize+"px Sans-serif";
				Stat._canvas.source.style.cssText="pointer-events:none;background:rgba(150,150,150,0.8);z-index:100000;position: absolute;left:"+x+"px;top:"+y+"px;width:"+(Stat._width / pixel)+"px;height:"+(Stat._height / pixel)+"px;";
			}
			Stat._first=true;
			Stat._loop();
			Stat._first=false;
			Browser.container.appendChild(Stat._canvas.source);
			Stat.enable();
		}

		Stat.enable=function(){
			Laya.timer.frameLoop(1,Stat,Stat._loop);
		}

		Stat.hide=function(){
			if (Stat._canvas){
				Browser.removeElement(Stat._canvas.source);
				Laya.timer.clear(Stat,Stat._loop);
			}
		}

		Stat.clear=function(){
			Stat.trianglesFaces=Stat.drawCall=Stat.shaderCall=Stat.spriteCount=Stat.treeNodeCollision=Stat.treeSpriteCollision=Stat.canvasNormal=Stat.canvasBitmap=Stat.canvasReCache=0;
		}

		Stat._loop=function(){
			Stat._count++;
			var timer=Browser.now();
			if (timer-Stat._timer < 1000)return;
			var count=Stat._count;
			Stat.FPS=Math.round((count *1000)/ (timer-Stat._timer));
			if (Stat._canvas){
				Stat.trianglesFaces=Math.round(Stat.trianglesFaces / count);
				Stat.drawCall=Math.round(Stat.drawCall / count);
				Stat.shaderCall=Math.round(Stat.shaderCall / count);
				Stat.spriteCount=Math.round(Stat.spriteCount / count)-1;
				Stat.canvasNormal=Math.round(Stat.canvasNormal / count);
				Stat.canvasBitmap=Math.round(Stat.canvasBitmap / count);
				Stat.canvasReCache=Math.ceil(Stat.canvasReCache / count);
				Stat.treeNodeCollision=Math.round(Stat.treeNodeCollision / count);
				Stat.treeSpriteCollision=Math.round(Stat.treeSpriteCollision / count);
				var delay=Stat.FPS > 0 ? Math.floor(1000 / Stat.FPS).toString():" ";
				Stat._fpsStr=Stat.FPS+(Stat.renderSlow ? " slow" :"")+" "+delay;
				Stat._canvasStr=Stat.canvasReCache+"/"+Stat.canvasNormal+"/"+Stat.canvasBitmap;
				Stat.currentMemorySize=ResourceManager.systemResourceManager.memorySize;
				var ctx=Stat._ctx;
				ctx.clearRect(Stat._first ? 0 :Stat._vx,0,Stat._width,Stat._height);
				for (var i=0;i < Stat._view.length;i++){
					var one=Stat._view[i];
					if (Stat._first){
						ctx.fillStyle="white";
						ctx.fillText(one.title,one.x,one.y);
					}
					ctx.fillStyle=one.color;
					var value=Stat[one.value];
					(one.units=="M")&& (value=Math.floor(value / (1024 *1024)*100)/ 100+" M");
					ctx.fillText(value+"",one.x+Stat._vx,one.y);
				}
				Stat.clear();
			}
			Stat._count=0;
			Stat._timer=timer;
		}

		Stat.FPS=0;
		Stat.loopCount=0;
		Stat.shaderCall=0;
		Stat.drawCall=0;
		Stat.trianglesFaces=0;
		Stat.spriteCount=0;
		Stat.treeNodeCollision=0;
		Stat.treeSpriteCollision=0;
		Stat.canvasNormal=0;
		Stat.canvasBitmap=0;
		Stat.canvasReCache=0;
		Stat.renderSlow=false;
		Stat.currentMemorySize=0;
		Stat.mesh2DNum=0;
		Stat._fpsStr=null
		Stat._canvasStr=null
		Stat._canvas=null
		Stat._ctx=null
		Stat._timer=0;
		Stat._count=0;
		Stat._width=0;
		Stat._height=100;
		Stat._view=[];
		Stat._fontSize=12;
		Stat._first=false;
		Stat._vx=NaN
		return Stat;
	})()


	/**
	*@private
	*<code>StringKey</code> 类用于存取字符串对应的数字。
	*/
	//class laya.utils.StringKey
	var StringKey=(function(){
		function StringKey(){
			this._strsToID={};
			this._idToStrs=[];
			this._length=0;
		}

		__class(StringKey,'laya.utils.StringKey');
		var __proto=StringKey.prototype;
		/**
		*添加一个字符。
		*@param str 字符，将作为key 存储相应生成的数字。
		*@return 此字符对应的数字。
		*/
		__proto.add=function(str){
			var index=this._strsToID[str];
			if (index !=null)return index;
			this._idToStrs[this._length]=str;
			return this._strsToID[str]=this._length++;
		}

		/**
		*获取指定字符对应的ID。
		*@param str 字符。
		*@return 此字符对应的ID。
		*/
		__proto.getID=function(str){
			var index=this._strsToID[str];
			return index==null ?-1 :index;
		}

		/**
		*根据指定ID获取对应字符。
		*@param id ID。
		*@return 此id对应的字符。
		*/
		__proto.getName=function(id){
			var str=this._idToStrs[id];
			return str==null ? undefined :str;
		}

		return StringKey;
	})()


	/**
	*<code>Timer</code> 是时钟管理类。它是一个单例，不要手动实例化此类，应该通过 Laya.timer 访问。
	*/
	//class laya.utils.Timer
	var Timer=(function(){
		var TimerHandler;
		function Timer(){
			this._delta=0;
			this.scale=1;
			this.currFrame=0;
			this._mid=1;
			this._map=[];
			this._laters=[];
			this._handlers=[];
			this._temp=[];
			this._count=0;
			this.currTimer=Browser.now();
			this._lastTimer=Browser.now();
			Laya.timer && Laya.timer.frameLoop(1,this,this._update);
		}

		__class(Timer,'laya.utils.Timer');
		var __proto=Timer.prototype;
		/**
		*@private
		*帧循环处理函数。
		*/
		__proto._update=function(){
			if (this.scale <=0){
				this._lastTimer=Browser.now();
				return;
			};
			var frame=this.currFrame=this.currFrame+this.scale;
			var now=Browser.now();
			this._delta=(now-this._lastTimer)*this.scale;
			var timer=this.currTimer=this.currTimer+this._delta;
			this._lastTimer=now;
			var handlers=this._handlers;
			this._count=0;
			for (i=0,n=handlers.length;i < n;i++){
				handler=handlers[i];
				if (handler.method!==null){
					var t=handler.userFrame ? frame :timer;
					if (t >=handler.exeTime){
						if (handler.repeat){
							if (!handler.jumpFrame){
								handler.exeTime+=handler.delay;
								handler.run(false);
								if (t > handler.exeTime){
									handler.exeTime+=Math.ceil((t-handler.exeTime)/ handler.delay)*handler.delay;
								}
								}else {
								while (t >=handler.exeTime){
									handler.exeTime+=handler.delay;
									handler.run(false);
								}
							}
							}else {
							handler.run(true);
						}
					}
					}else {
					this._count++;
				}
			}
			if (this._count > 30 || frame % 200===0)this._clearHandlers();
			var laters=this._laters;
			for (var i=0,n=laters.length-1;i <=n;i++){
				var handler=laters[i];
				if (handler.method!==null){
					this._map[handler.key]=null;
					handler.run(false);
				}
				this._recoverHandler(handler);
				i===n && (n=laters.length-1);
			}
			laters.length=0;
		}

		/**@private */
		__proto._clearHandlers=function(){
			var handlers=this._handlers;
			for (var i=0,n=handlers.length;i < n;i++){
				var handler=handlers[i];
				if (handler.method!==null)this._temp.push(handler);
				else this._recoverHandler(handler);
			}
			this._handlers=this._temp;
			handlers.length=0;
			this._temp=handlers;
		}

		/**@private */
		__proto._recoverHandler=function(handler){
			if(this._map[handler.key]==handler)this._map[handler.key]=null;
			handler.clear();
			Timer._pool.push(handler);
		}

		/**@private */
		__proto._create=function(useFrame,repeat,delay,caller,method,args,coverBefore){
			if (!delay){
				method.apply(caller,args);
				return null;
			}
			if (coverBefore){
				var handler=this._getHandler(caller,method);
				if (handler){
					handler.repeat=repeat;
					handler.userFrame=useFrame;
					handler.delay=delay;
					handler.caller=caller;
					handler.method=method;
					handler.args=args;
					handler.exeTime=delay+(useFrame ? this.currFrame :this.currTimer+Browser.now()-this._lastTimer);
					return handler;
				}
			}
			handler=Timer._pool.length > 0 ? Timer._pool.pop():new TimerHandler();
			handler.repeat=repeat;
			handler.userFrame=useFrame;
			handler.delay=delay;
			handler.caller=caller;
			handler.method=method;
			handler.args=args;
			handler.exeTime=delay+(useFrame ? this.currFrame :this.currTimer+Browser.now()-this._lastTimer);
			this._indexHandler(handler);
			this._handlers.push(handler);
			return handler;
		}

		/**@private */
		__proto._indexHandler=function(handler){
			var caller=handler.caller;
			var method=handler.method;
			var cid=caller ? caller.$_GID || (caller.$_GID=Utils.getGID()):0;
			var mid=method.$_TID || (method.$_TID=(this._mid++)*100000);
			handler.key=cid+mid;
			this._map[handler.key]=handler;
		}

		/**
		*定时执行一次。
		*@param delay 延迟时间(单位为毫秒)。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*@param args 回调参数。
		*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
		*/
		__proto.once=function(delay,caller,method,args,coverBefore){
			(coverBefore===void 0)&& (coverBefore=true);
			this._create(false,false,delay,caller,method,args,coverBefore);
		}

		/**
		*定时重复执行。
		*@param delay 间隔时间(单位毫秒)。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*@param args 回调参数。
		*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
		*@param jumpFrame 时钟是否跳帧。基于时间的循环回调，单位时间间隔内，如能执行多次回调，出于性能考虑，引擎默认只执行一次，设置jumpFrame=true后，则回调会连续执行多次
		*/
		__proto.loop=function(delay,caller,method,args,coverBefore,jumpFrame){
			(coverBefore===void 0)&& (coverBefore=true);
			(jumpFrame===void 0)&& (jumpFrame=false);
			var handler=this._create(false,true,delay,caller,method,args,coverBefore);
			if (handler)handler.jumpFrame=jumpFrame;
		}

		/**
		*定时执行一次(基于帧率)。
		*@param delay 延迟几帧(单位为帧)。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*@param args 回调参数。
		*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
		*/
		__proto.frameOnce=function(delay,caller,method,args,coverBefore){
			(coverBefore===void 0)&& (coverBefore=true);
			this._create(true,false,delay,caller,method,args,coverBefore);
		}

		/**
		*定时重复执行(基于帧率)。
		*@param delay 间隔几帧(单位为帧)。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*@param args 回调参数。
		*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
		*/
		__proto.frameLoop=function(delay,caller,method,args,coverBefore){
			(coverBefore===void 0)&& (coverBefore=true);
			this._create(true,true,delay,caller,method,args,coverBefore);
		}

		/**返回统计信息。*/
		__proto.toString=function(){
			return "callLater:"+this._laters.length+" handlers:"+this._handlers.length+" pool:"+Timer._pool.length;
		}

		/**
		*清理定时器。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*/
		__proto.clear=function(caller,method){
			var handler=this._getHandler(caller,method);
			if (handler){
				this._map[handler.key]=null;handler.key=0;
				handler.clear();
			}
		}

		/**
		*清理对象身上的所有定时器。
		*@param caller 执行域(this)。
		*/
		__proto.clearAll=function(caller){
			if (!caller)return;
			for (var i=0,n=this._handlers.length;i < n;i++){
				var handler=this._handlers[i];
				if (handler.caller===caller){
					this._map[handler.key]=null;handler.key=0;
					handler.clear();
				}
			}
		}

		/**@private */
		__proto._getHandler=function(caller,method){
			var cid=caller ? caller.$_GID || (caller.$_GID=Utils.getGID()):0;
			var mid=method.$_TID || (method.$_TID=(this._mid++)*100000);
			return this._map[cid+mid];
		}

		/**
		*延迟执行。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*@param args 回调参数。
		*/
		__proto.callLater=function(caller,method,args){
			if (this._getHandler(caller,method)==null){
				if (Timer._pool.length)
					var handler=Timer._pool.pop();
				else handler=new TimerHandler();
				handler.caller=caller;
				handler.method=method;
				handler.args=args;
				this._indexHandler(handler);
				this._laters.push(handler);
			}
		}

		/**
		*立即执行 callLater 。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*/
		__proto.runCallLater=function(caller,method){
			var handler=this._getHandler(caller,method);
			if (handler && handler.method !=null){
				this._map[handler.key]=null;
				handler.run(true);
			}
		}

		/**
		*立即提前执行定时器，执行之后从队列中删除
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*/
		__proto.runTimer=function(caller,method){
			this.runCallLater(caller,method);
		}

		/**
		*两帧之间的时间间隔,单位毫秒。
		*/
		__getset(0,__proto,'delta',function(){
			return this._delta;
		});

		Timer._pool=[];
		Timer.__init$=function(){
			/**@private */
			//class TimerHandler
			TimerHandler=(function(){
				function TimerHandler(){
					this.key=0;
					this.repeat=false;
					this.delay=0;
					this.userFrame=false;
					this.exeTime=0;
					this.caller=null;
					this.method=null;
					this.args=null;
					this.jumpFrame=false;
				}
				__class(TimerHandler,'');
				var __proto=TimerHandler.prototype;
				__proto.clear=function(){
					this.caller=null;
					this.method=null;
					this.args=null;
				}
				__proto.run=function(withClear){
					var caller=this.caller;
					if (caller && caller.destroyed)return this.clear();
					var method=this.method;
					var args=this.args;
					withClear && this.clear();
					if (method==null)return;
					args ? method.apply(caller,args):method.call(caller);
				}
				return TimerHandler;
			})()
		}

		return Timer;
	})()


	/**
	*<code>Tween</code> 是一个缓动类。使用此类能够实现对目标对象属性的渐变。
	*/
	//class laya.utils.Tween
	var Tween=(function(){
		function Tween(){
			//this._complete=null;
			//this._target=null;
			//this._ease=null;
			//this._props=null;
			//this._duration=0;
			//this._delay=0;
			//this._startTimer=0;
			//this._usedTimer=0;
			//this._usedPool=false;
			this.gid=0;
			//this.update=null;
		}

		__class(Tween,'laya.utils.Tween');
		var __proto=Tween.prototype;
		/**
		*缓动对象的props属性到目标值。
		*@param target 目标对象(即将更改属性值的对象)。
		*@param props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
		*@param duration 花费的时间，单位毫秒。
		*@param ease 缓动类型，默认为匀速运动。
		*@param complete 结束回调函数。
		*@param delay 延迟执行时间。
		*@param coverBefore 是否覆盖之前的缓动。
		*@return 返回Tween对象。
		*/
		__proto.to=function(target,props,duration,ease,complete,delay,coverBefore){
			(delay===void 0)&& (delay=0);
			(coverBefore===void 0)&& (coverBefore=false);
			return this._create(target,props,duration,ease,complete,delay,coverBefore,true,false,true);
		}

		/**
		*从props属性，缓动到当前状态。
		*@param target 目标对象(即将更改属性值的对象)。
		*@param props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
		*@param duration 花费的时间，单位毫秒。
		*@param ease 缓动类型，默认为匀速运动。
		*@param complete 结束回调函数。
		*@param delay 延迟执行时间。
		*@param coverBefore 是否覆盖之前的缓动。
		*@return 返回Tween对象。
		*/
		__proto.from=function(target,props,duration,ease,complete,delay,coverBefore){
			(delay===void 0)&& (delay=0);
			(coverBefore===void 0)&& (coverBefore=false);
			return this._create(target,props,duration,ease,complete,delay,coverBefore,false,false,true);
		}

		/**@private */
		__proto._create=function(target,props,duration,ease,complete,delay,coverBefore,isTo,usePool,runNow){
			if (!target)throw new Error("Tween:target is null");
			this._target=target;
			this._duration=duration;
			this._ease=ease || props.ease || Tween.easeNone;
			this._complete=complete || props.complete;
			this._delay=delay;
			this._props=[];
			this._usedTimer=0;
			this._startTimer=Browser.now();
			this._usedPool=usePool;
			this.update=props.update;
			var gid=(target.$_GID || (target.$_GID=Utils.getGID()));
			if (!Tween.tweenMap[gid]){
				Tween.tweenMap[gid]=[this];
				}else {
				if (coverBefore)Tween.clearTween(target);
				Tween.tweenMap[gid].push(this);
			}
			if (runNow){
				if (delay <=0)this.firstStart(target,props,isTo);
				else Laya.timer.once(delay,this,this.firstStart,[target,props,isTo]);
				}else {
				this._initProps(target,props,isTo);
			}
			return this;
		}

		__proto.firstStart=function(target,props,isTo){
			if (target.destroyed){
				this.clear();
				return;
			}
			this._initProps(target,props,isTo);
			this._beginLoop();
		}

		__proto._initProps=function(target,props,isTo){
			for (var p in props){
				if ((typeof (target[p])=='number')){
					var start=isTo ? target[p] :props[p];
					var end=isTo ? props[p] :target[p];
					this._props.push([p,start,end-start]);
					if (!isTo)target[p]=start;
				}
			}
		}

		__proto._beginLoop=function(){
			Laya.timer.frameLoop(1,this,this._doEase);
		}

		/**执行缓动**/
		__proto._doEase=function(){
			this._updateEase(Browser.now());
		}

		/**@private */
		__proto._updateEase=function(time){
			var target=this._target;
			if (!target)return;
			if (target.destroyed)return Tween.clearTween(target);
			var usedTimer=this._usedTimer=time-this._startTimer-this._delay;
			if (usedTimer < 0)return;
			if (usedTimer >=this._duration)return this.complete();
			var ratio=usedTimer > 0 ? this._ease(usedTimer,0,1,this._duration):0;
			var props=this._props;
			for (var i=0,n=props.length;i < n;i++){
				var prop=props[i];
				target[prop[0]]=prop[1]+(ratio *prop[2]);
			}
			if (this.update)this.update.run();
		}

		/**
		*立即结束缓动并到终点。
		*/
		__proto.complete=function(){
			if (!this._target)return;
			Laya.timer.runTimer(this,this.firstStart);
			var target=this._target;
			var props=this._props;
			var handler=this._complete;
			for (var i=0,n=props.length;i < n;i++){
				var prop=props[i];
				target[prop[0]]=prop[1]+prop[2];
			}
			if (this.update)this.update.run();
			this.clear();
			handler && handler.run();
		}

		/**
		*暂停缓动，可以通过resume或restart重新开始。
		*/
		__proto.pause=function(){
			Laya.timer.clear(this,this._beginLoop);
			Laya.timer.clear(this,this._doEase);
		}

		/**
		*设置开始时间。
		*@param startTime 开始时间。
		*/
		__proto.setStartTime=function(startTime){
			this._startTimer=startTime;
		}

		/**
		*停止并清理当前缓动。
		*/
		__proto.clear=function(){
			if (this._target){
				this._remove();
				this._clear();
			}
		}

		/**
		*@private
		*/
		__proto._clear=function(){
			this.pause();
			Laya.timer.clear(this,this.firstStart);
			this._complete=null;
			this._target=null;
			this._ease=null;
			this._props=null;
			if (this._usedPool){
				this.update=null;
				Pool.recover("tween",this);
			}
		}

		/**回收到对象池。*/
		__proto.recover=function(){
			this._usedPool=true;
			this._clear();
		}

		__proto._remove=function(){
			var tweens=Tween.tweenMap[this._target.$_GID];
			if (tweens){
				for (var i=0,n=tweens.length;i < n;i++){
					if (tweens[i]===this){
						tweens.splice(i,1);
						break ;
					}
				}
			}
		}

		/**
		*重新开始暂停的缓动。
		*/
		__proto.restart=function(){
			this.pause();
			this._usedTimer=0;
			this._startTimer=Browser.now();
			var props=this._props;
			for (var i=0,n=props.length;i < n;i++){
				var prop=props[i];
				this._target[prop[0]]=prop[1];
			}
			Laya.timer.once(this._delay,this,this._beginLoop);
		}

		/**
		*恢复暂停的缓动。
		*/
		__proto.resume=function(){
			if (this._usedTimer >=this._duration)return;
			this._startTimer=Browser.now()-this._usedTimer-this._delay;
			this._beginLoop();
		}

		/**设置当前执行比例**/
		__getset(0,__proto,'progress',null,function(v){
			var uTime=v *this._duration;
			this._startTimer=Browser.now()-this._delay-uTime;
		});

		Tween.to=function(target,props,duration,ease,complete,delay,coverBefore,autoRecover){
			(delay===void 0)&& (delay=0);
			(coverBefore===void 0)&& (coverBefore=false);
			(autoRecover===void 0)&& (autoRecover=true);
			return Pool.getItemByClass("tween",Tween)._create(target,props,duration,ease,complete,delay,coverBefore,true,autoRecover,true);
		}

		Tween.from=function(target,props,duration,ease,complete,delay,coverBefore,autoRecover){
			(delay===void 0)&& (delay=0);
			(coverBefore===void 0)&& (coverBefore=false);
			(autoRecover===void 0)&& (autoRecover=true);
			return Pool.getItemByClass("tween",Tween)._create(target,props,duration,ease,complete,delay,coverBefore,false,autoRecover,true);
		}

		Tween.clearAll=function(target){
			if (!target || !target.$_GID)return;
			var tweens=Tween.tweenMap[target.$_GID];
			if (tweens){
				for (var i=0,n=tweens.length;i < n;i++){
					tweens[i]._clear();
				}
				tweens.length=0;
			}
		}

		Tween.clear=function(tween){
			tween.clear();
		}

		Tween.clearTween=function(target){
			Tween.clearAll(target);
		}

		Tween.easeNone=function(t,b,c,d){
			return c *t / d+b;
		}

		Tween.tweenMap=[];
		return Tween;
	})()


	/**
	*<code>Utils</code> 是工具类。
	*/
	//class laya.utils.Utils
	var Utils=(function(){
		function Utils(){};
		__class(Utils,'laya.utils.Utils');
		Utils.toRadian=function(angle){
			return angle *Utils._pi2;
		}

		Utils.toAngle=function(radian){
			return radian *Utils._pi;
		}

		Utils.toHexColor=function(color){
			if (color < 0 || isNaN(color))return null;
			var str=color.toString(16);
			while (str.length < 6)str="0"+str;
			return "#"+str;
		}

		Utils.getGID=function(){
			return Utils._gid++;
		}

		Utils.parseXMLFromString=function(value){
			var rst;
			value=value.replace(/>\s+</g,'><');
			rst=(new DOMParser()).parseFromString(value,'text/xml');
			if (rst.firstChild.textContent.indexOf("This page contains the following errors")>-1){
				throw new Error(rst.firstChild.firstChild.textContent);
			}
			return rst;
		}

		Utils.concatArray=function(source,array){
			if (!array)return source;
			if (!source)return array;
			var i=0,len=array.length;
			for (i=0;i < len;i++){
				source.push(array[i]);
			}
			return source;
		}

		Utils.clearArray=function(array){
			if (!array)return array;
			array.length=0;
			return array;
		}

		Utils.copyArray=function(source,array){
			source || (source=[]);
			if (!array)return source;
			source.length=array.length;
			var i=0,len=array.length;
			for (i=0;i < len;i++){
				source[i]=array[i];
			}
			return source;
		}

		Utils.getGlobalRecByPoints=function(sprite,x0,y0,x1,y1){
			var newLTPoint;
			newLTPoint=Point.create().setTo(x0,y0);
			newLTPoint=sprite.localToGlobal(newLTPoint);
			var newRBPoint;
			newRBPoint=Point.create().setTo(x1,y1);
			newRBPoint=sprite.localToGlobal(newRBPoint);
			var rst=Rectangle._getWrapRec([newLTPoint.x,newLTPoint.y,newRBPoint.x,newRBPoint.y]);
			newLTPoint.recover();
			newRBPoint.recover();
			return rst;
		}

		Utils.getGlobalPosAndScale=function(sprite){
			return Utils.getGlobalRecByPoints(sprite,0,0,1,1);
		}

		Utils.bind=function(fun,scope){
			var rst=fun;
			rst=fun.bind(scope);;
			return rst;
		}

		Utils.measureText=function(txt,font){
			return RunDriver.measureText(txt,font);
		}

		Utils.updateOrder=function(array){
			if (!array || array.length < 2)return false;
			var i=1,j=0,len=array.length,key=NaN,c;
			while (i < len){
				j=i;
				c=array[j];
				key=array[j]._zOrder;
				while (--j >-1){
					if (array[j]._zOrder > key)array[j+1]=array[j];
					else break ;
				}
				array[j+1]=c;
				i++;
			}
			return true;
		}

		Utils.transPointList=function(points,x,y){
			var i=0,len=points.length;
			for (i=0;i < len;i+=2){
				points[i]+=x;
				points[i+1]+=y;
			}
		}

		Utils.parseInt=function(str,radix){
			(radix===void 0)&& (radix=0);
			var result=Browser.window.parseInt(str,radix);
			if (isNaN(result))return 0;
			return result;
		}

		Utils.getFileExtension=function(path){
			Utils._extReg.lastIndex=path.lastIndexOf(".");
			var result=Utils._extReg.exec(path);
			if (result && result.length > 1){
				return result[1].toLowerCase();
			}
			return null;
		}

		Utils.getTransformRelativeToWindow=function(coordinateSpace,x,y){
			var stage=Laya.stage;
			var globalTransform=laya.utils.Utils.getGlobalPosAndScale(coordinateSpace);
			var canvasMatrix=stage._canvasTransform.clone();
			var canvasLeft=canvasMatrix.tx;
			var canvasTop=canvasMatrix.ty;
			canvasMatrix.rotate(-Math.PI / 180 *Laya.stage.canvasDegree);
			canvasMatrix.scale(Laya.stage.clientScaleX,Laya.stage.clientScaleY);
			var perpendicular=(Laya.stage.canvasDegree % 180 !=0);
			var tx=NaN,ty=NaN;
			if (perpendicular){
				tx=y+globalTransform.y;
				ty=x+globalTransform.x;
				tx *=canvasMatrix.d;
				ty *=canvasMatrix.a;
				if (Laya.stage.canvasDegree==90){
					tx=canvasLeft-tx;
					ty+=canvasTop;
				}
				else {
					tx+=canvasLeft;
					ty=canvasTop-ty;
				}
			}
			else {
				tx=x+globalTransform.x;
				ty=y+globalTransform.y;
				tx *=canvasMatrix.a;
				ty *=canvasMatrix.d;
				tx+=canvasLeft;
				ty+=canvasTop;
			}
			ty+=Laya.stage['_safariOffsetY'];
			var domScaleX=NaN,domScaleY=NaN;
			if (perpendicular){
				domScaleX=canvasMatrix.d *globalTransform.height;
				domScaleY=canvasMatrix.a *globalTransform.width;
				}else {
				domScaleX=canvasMatrix.a *globalTransform.width;
				domScaleY=canvasMatrix.d *globalTransform.height;
			}
			return {x:tx,y:ty,scaleX:domScaleX,scaleY:domScaleY};
		}

		Utils.fitDOMElementInArea=function(dom,coordinateSpace,x,y,width,height){
			if (!dom._fitLayaAirInitialized){
				dom._fitLayaAirInitialized=true;
				dom.style.transformOrigin=dom.style.webKittransformOrigin="left top";
				dom.style.position="absolute"
			};
			var transform=Utils.getTransformRelativeToWindow(coordinateSpace,x,y);
			dom.style.transform=dom.style.webkitTransform="scale("+transform.scaleX+","+transform.scaleY+") rotate("+(Laya.stage.canvasDegree)+"deg)";
			dom.style.width=width+'px';
			dom.style.height=height+'px';
			dom.style.left=transform.x+'px';
			dom.style.top=transform.y+'px';
		}

		Utils._gid=1;
		Utils._pi=180 / Math.PI;
		Utils._pi2=Math.PI / 180;
		Utils._extReg=/\.(\w+)\??/g;
		return Utils;
	})()


	/**
	*@private
	*TODO:
	*/
	//class laya.utils.VectorGraphManager
	var VectorGraphManager=(function(){
		function VectorGraphManager(){
			this.useDic={};
			this.shapeDic={};
			this.shapeLineDic={};
			this._id=0;
			this._checkKey=false;
			this._freeIdArray=[];
			if (Render.isWebGL){
				CacheManger.regCacheByFunction(Utils.bind(this.startDispose,this),Utils.bind(this.getCacheList,this));
			}
		}

		__class(VectorGraphManager,'laya.utils.VectorGraphManager');
		var __proto=VectorGraphManager.prototype;
		/**
		*得到个空闲的ID
		*@return
		*/
		__proto.getId=function(){
			return this._id++;
		}

		/**
		*添加一个图形到列表中
		*@param id
		*@param shape
		*/
		__proto.addShape=function(id,shape){
			this.shapeDic[id]=shape;
			if (!this.useDic[id]){
				this.useDic[id]=true;
			}
		}

		/**
		*添加一个线图形到列表中
		*@param id
		*@param Line
		*/
		__proto.addLine=function(id,Line){
			this.shapeLineDic[id]=Line;
			if (!this.shapeLineDic[id]){
				this.shapeLineDic[id]=true;
			}
		}

		/**
		*检测一个对象是否在使用中
		*@param id
		*/
		__proto.getShape=function(id){
			if (this._checkKey){
				if (this.useDic[id] !=null){
					this.useDic[id]=true;
				}
			}
		}

		/**
		*删除一个图形对象
		*@param id
		*/
		__proto.deleteShape=function(id){
			if (this.shapeDic[id]){
				this.shapeDic[id]=null;
				delete this.shapeDic[id];
			}
			if (this.shapeLineDic[id]){
				this.shapeLineDic[id]=null;
				delete this.shapeLineDic[id];
			}
			if (this.useDic[id] !=null){
				delete this.useDic[id];
			}
		}

		/**
		*得到缓存列表
		*@return
		*/
		__proto.getCacheList=function(){
			var str;
			var list=[];
			for (str in this.shapeDic){
				list.push(this.shapeDic[str]);
			}
			for (str in this.shapeLineDic){
				list.push(this.shapeLineDic[str]);
			}
			return list;
		}

		/**
		*开始清理状态，准备销毁
		*/
		__proto.startDispose=function(key){
			var str;
			for (str in this.useDic){
				this.useDic[str]=false;
			}
			this._checkKey=true;
		}

		/**
		*确认销毁
		*/
		__proto.endDispose=function(){
			if (this._checkKey){
				var str;
				for (str in this.useDic){
					if (!this.useDic[str]){
						this.deleteShape(str);
					}
				}
				this._checkKey=false;
			}
		}

		VectorGraphManager.getInstance=function(){
			return VectorGraphManager.instance=VectorGraphManager.instance|| new VectorGraphManager();
		}

		VectorGraphManager.instance=null
		return VectorGraphManager;
	})()


	/**
	*封装弱引用WeakMap
	*如果支持WeakMap，则使用WeakMap，如果不支持，则用Object代替
	*注意：如果采用Object，为了防止内存泄漏，则采用定时清理缓存策略
	*/
	//class laya.utils.WeakObject
	var WeakObject=(function(){
		function WeakObject(){
			this._obj=null;
			this._obj=WeakObject.supportWeakMap ? new Browser.window.WeakMap():{};
			if (!WeakObject.supportWeakMap)WeakObject._maps.push(this);
		}

		__class(WeakObject,'laya.utils.WeakObject');
		var __proto=WeakObject.prototype;
		/**
		*设置缓存
		*@param key kye对象，可被回收
		*@param value object对象，可被回收
		*/
		__proto.set=function(key,value){
			if (key==null)return;
			if (WeakObject.supportWeakMap){
				var objKey=key;
				if ((typeof key=='string')|| (typeof key=='number')){
					objKey=WeakObject._keys[key];
					if (!objKey)objKey=WeakObject._keys[key]={k:key};
				}
				this._obj.set(objKey,value);
				}else {
				if ((typeof key=='string')|| (typeof key=='number')){
					this._obj[key]=value;
					}else {
					key.$_GID || (key.$_GID=Utils.getGID());
					this._obj[key.$_GID]=value;
				}
			}
		}

		/**
		*获取缓存
		*@param key kye对象，可被回收
		*/
		__proto.get=function(key){
			if (key==null)return null;
			if (WeakObject.supportWeakMap){
				var objKey=((typeof key=='string')|| (typeof key=='number'))? WeakObject._keys[key] :key;
				return this._obj.get(objKey);
				}else {
				if ((typeof key=='string')|| (typeof key=='number'))return this._obj[key];
				return this._obj[key.$_GID];
			}
		}

		/**
		*删除缓存
		*/
		__proto.del=function(key){
			if (key==null)return;
			if (WeakObject.supportWeakMap){
				var objKey=((typeof key=='string')|| (typeof key=='number'))? WeakObject._keys[key] :key;
				_obj.delete(objKey);
				}else {
				if ((typeof key=='string')|| (typeof key=='number'))delete this._obj[key];
				else delete this._obj[this._obj.$_GID];
			}
		}

		/**
		*是否有缓存
		*/
		__proto.has=function(key){
			if (key==null)return false;
			if (WeakObject.supportWeakMap){
				var objKey=((typeof key=='string')|| (typeof key=='number'))? WeakObject._keys[key] :key;
				return this._obj.has(objKey);
				}else {
				if ((typeof key=='string')|| (typeof key=='number'))return this._obj[key] !=null;
				return this._obj[this._obj.$_GID] !=null;
			}
		}

		WeakObject.__init__=function(){
			WeakObject.supportWeakMap=Browser.window.WeakMap !=null;
			if (!WeakObject.supportWeakMap)Laya.timer.loop(WeakObject.delInterval,null,WeakObject.clearCache);
		}

		WeakObject.clearCache=function(){
			for (var i=0,n=WeakObject._maps.length;i < n;i++){
				var obj=WeakObject._maps[i];
				obj._obj={};
			}
		}

		WeakObject.supportWeakMap=false;
		WeakObject.delInterval=10 *60 *1000;
		WeakObject._keys={};
		WeakObject._maps=[];
		__static(WeakObject,
		['I',function(){return this.I=new WeakObject();}
		]);
		return WeakObject;
	})()


	/**
	*@private
	*/
	//class laya.utils.WordText
	var WordText=(function(){
		function WordText(){
			this.id=NaN;
			this.save=[];
			this.toUpperCase=null;
			this.changed=false;
			this._text=null;
			this.width=-1;
			this.pageChars=[];
		}

		__class(WordText,'laya.utils.WordText');
		var __proto=WordText.prototype;
		//同一个texture的文字。里面又是一个数组。具体含义见使用的地方。
		__proto.setText=function(txt){
			this.changed=true;
			this._text=txt;
			this.width=-1;
			this.pageChars=[];
		}

		//需要重新更新
		__proto.toString=function(){
			return this._text;
		}

		__proto.charCodeAt=function(i){
			return this._text ? this._text.charCodeAt(i):NaN;
		}

		__proto.charAt=function(i){
			return this._text ? this._text.charAt(i):null;
		}

		__getset(0,__proto,'length',function(){
			return this._text ? this._text.length :0;
		});

		return WordText;
	})()


	/**
	*@private
	*@author ...
	*/
	//class laya.ani.AnimationContent
	var AnimationContent=(function(){
		function AnimationContent(){
			this.nodes=null;
			this.name=null;
			this.playTime=NaN;
			this.bone3DMap=null;
			this.totalKeyframeDatasLength=0;
		}

		__class(AnimationContent,'laya.ani.AnimationContent');
		return AnimationContent;
	})()


	/**
	*@private
	*@author ...
	*/
	//class laya.ani.AnimationNodeContent
	var AnimationNodeContent=(function(){
		function AnimationNodeContent(){
			this.name=null;
			this.parentIndex=0;
			this.parent=null;
			this.keyframeWidth=0;
			this.lerpType=0;
			this.interpolationMethod=null;
			this.childs=null;
			this.keyFrame=null;
			this.playTime=NaN;
			this.extenData=null;
			this.dataOffset=0;
		}

		__class(AnimationNodeContent,'laya.ani.AnimationNodeContent');
		return AnimationNodeContent;
	})()


	/**
	*@private
	*/
	//class laya.ani.AnimationParser01
	var AnimationParser01=(function(){
		function AnimationParser01(){};
		__class(AnimationParser01,'laya.ani.AnimationParser01');
		AnimationParser01.parse=function(templet,reader){
			var data=reader.__getBuffer();
			var i=0,j=0,k=0,n=0,l=0,m=0,o=0;
			var aniClassName=reader.readUTFString();
			templet._aniClassName=aniClassName;
			var strList=reader.readUTFString().split("\n");
			var aniCount=reader.getUint8();
			var publicDataPos=reader.getUint32();
			var publicExtDataPos=reader.getUint32();
			var publicData;
			if (publicDataPos > 0)
				publicData=data.slice(publicDataPos,publicExtDataPos);
			var publicRead=new Byte(publicData);
			if (publicExtDataPos > 0)
				templet._publicExtData=data.slice(publicExtDataPos,data.byteLength);
			templet._useParent=!!reader.getUint8();
			templet._anis.length=aniCount;
			for (i=0;i < aniCount;i++){
				var ani=templet._anis[i]=new AnimationContent();
				{};
				ani.nodes=new Array;
				var name=ani.name=strList[reader.getUint16()];
				templet._aniMap[name]=i;
				ani.bone3DMap={};
				ani.playTime=reader.getFloat32();
				var boneCount=ani.nodes.length=reader.getUint8();
				ani.totalKeyframeDatasLength=0;
				for (j=0;j < boneCount;j++){
					var node=ani.nodes[j]=new AnimationNodeContent();
					{};
					node.childs=[];
					var nameIndex=reader.getInt16();
					if (nameIndex >=0){
						node.name=strList[nameIndex];
						ani.bone3DMap[node.name]=j;
					}
					node.keyFrame=new Array;
					node.parentIndex=reader.getInt16();
					node.parentIndex==-1 ? node.parent=null :node.parent=ani.nodes[node.parentIndex]
					node.lerpType=reader.getUint8();
					var keyframeParamsOffset=reader.getUint32();
					publicRead.pos=keyframeParamsOffset;
					var keyframeDataCount=node.keyframeWidth=publicRead.getUint16();
					ani.totalKeyframeDatasLength+=keyframeDataCount;
					if (node.lerpType===0 || node.lerpType===1){
						node.interpolationMethod=[];
						node.interpolationMethod.length=keyframeDataCount;
						for (k=0;k < keyframeDataCount;k++)
						node.interpolationMethod[k]=AnimationTemplet.interpolation[publicRead.getUint8()];
					}
					if (node.parent !=null)
						node.parent.childs.push(node);
					var privateDataLen=reader.getUint16();
					if (privateDataLen > 0){
						node.extenData=data.slice(reader.pos,reader.pos+privateDataLen);
						reader.pos+=privateDataLen;
					};
					var keyframeCount=reader.getUint16();
					node.keyFrame.length=keyframeCount;
					var startTime=0;
					var keyFrame;
					for (k=0,n=keyframeCount;k < n;k++){
						keyFrame=node.keyFrame[k]=new KeyFramesContent();
						{};
						keyFrame.duration=reader.getFloat32();
						keyFrame.startTime=startTime;
						if (node.lerpType===2){
							keyFrame.interpolationData=[];
							var interDataLength=reader.getUint8();
							var lerpType=0;
							lerpType=reader.getFloat32();
							switch (lerpType){
								case 254:
									keyFrame.interpolationData.length=keyframeDataCount;
									for (o=0;o < keyframeDataCount;o++)
									keyFrame.interpolationData[o]=0;
									break ;
								case 255:
									keyFrame.interpolationData.length=keyframeDataCount;
									for (o=0;o < keyframeDataCount;o++)
									keyFrame.interpolationData[o]=5;
									break ;
								default :
									keyFrame.interpolationData.push(lerpType);
									for (m=1;m < interDataLength;m++){
										keyFrame.interpolationData.push(reader.getFloat32());
									}
								}
						}
						keyFrame.data=new Float32Array(keyframeDataCount);
						keyFrame.dData=new Float32Array(keyframeDataCount);
						keyFrame.nextData=new Float32Array(keyframeDataCount);
						for (l=0;l < keyframeDataCount;l++){
							keyFrame.data[l]=reader.getFloat32();
							if (keyFrame.data[l] >-0.00000001 && keyFrame.data[l] < 0.00000001)keyFrame.data[l]=0;
						}
						startTime+=keyFrame.duration;
					}
					keyFrame.startTime=ani.playTime;
					node.playTime=ani.playTime;
					templet._calculateKeyFrame(node,keyframeCount,keyframeDataCount);
				}
			}
		}

		return AnimationParser01;
	})()


	/**
	*@private
	*/
	//class laya.ani.AnimationParser02
	var AnimationParser02=(function(){
		function AnimationParser02(){};
		__class(AnimationParser02,'laya.ani.AnimationParser02');
		AnimationParser02.READ_DATA=function(){
			AnimationParser02._DATA.offset=AnimationParser02._reader.getUint32();
			AnimationParser02._DATA.size=AnimationParser02._reader.getUint32();
		}

		AnimationParser02.READ_BLOCK=function(){
			var count=AnimationParser02._BLOCK.count=AnimationParser02._reader.getUint16();
			var blockStarts=AnimationParser02._BLOCK.blockStarts=[];
			var blockLengths=AnimationParser02._BLOCK.blockLengths=[];
			for (var i=0;i < count;i++){
				blockStarts.push(AnimationParser02._reader.getUint32());
				blockLengths.push(AnimationParser02._reader.getUint32());
			}
		}

		AnimationParser02.READ_STRINGS=function(){
			var offset=AnimationParser02._reader.getUint32();
			var count=AnimationParser02._reader.getUint16();
			var prePos=AnimationParser02._reader.pos;
			AnimationParser02._reader.pos=offset+AnimationParser02._DATA.offset;
			for (var i=0;i < count;i++)
			AnimationParser02._strings[i]=AnimationParser02._reader.readUTFString();
			AnimationParser02._reader.pos=prePos;
		}

		AnimationParser02.parse=function(templet,reader){
			AnimationParser02._templet=templet;
			AnimationParser02._reader=reader;
			var arrayBuffer=reader.__getBuffer();
			AnimationParser02.READ_DATA();
			AnimationParser02.READ_BLOCK();
			AnimationParser02.READ_STRINGS();
			for (var i=0,n=AnimationParser02._BLOCK.count;i < n;i++){
				var index=reader.getUint16();
				var blockName=AnimationParser02._strings[index];
				var fn=AnimationParser02["READ_"+blockName];
				if (fn==null)
					throw new Error("model file err,no this function:"+index+" "+blockName);
				else
				fn.call();
			}
		}

		AnimationParser02.READ_ANIMATIONS=function(){
			var reader=AnimationParser02._reader;
			var arrayBuffer=reader.__getBuffer();
			var i=0,j=0,k=0,n=0,l=0;
			var keyframeWidth=reader.getUint16();
			var interpolationMethod=[];
			interpolationMethod.length=keyframeWidth;
			for (i=0;i < keyframeWidth;i++)
			interpolationMethod[i]=AnimationTemplet.interpolation[reader.getByte()];
			var aniCount=reader.getUint8();
			AnimationParser02._templet._anis.length=aniCount;
			for (i=0;i < aniCount;i++){
				var ani=AnimationParser02._templet._anis[i]=
				{};
				ani.nodes=new Array;
				var aniName=ani.name=AnimationParser02._strings[reader.getUint16()];
				AnimationParser02._templet._aniMap[aniName]=i;
				ani.bone3DMap={};
				ani.playTime=reader.getFloat32();
				var boneCount=ani.nodes.length=reader.getInt16();
				ani.totalKeyframeDatasLength=0;
				for (j=0;j < boneCount;j++){
					var node=ani.nodes[j]=
					{};
					node.keyframeWidth=keyframeWidth;
					node.childs=[];
					var nameIndex=reader.getUint16();
					if (nameIndex >=0){
						node.name=AnimationParser02._strings[nameIndex];
						ani.bone3DMap[node.name]=j;
					}
					node.keyFrame=new Array;
					node.parentIndex=reader.getInt16();
					node.parentIndex==-1 ? node.parent=null :node.parent=ani.nodes[node.parentIndex]
					ani.totalKeyframeDatasLength+=keyframeWidth;
					node.interpolationMethod=interpolationMethod;
					if (node.parent !=null)
						node.parent.childs.push(node);
					var keyframeCount=reader.getUint16();
					node.keyFrame.length=keyframeCount;
					var keyFrame=null,lastKeyFrame=null;
					for (k=0,n=keyframeCount;k < n;k++){
						keyFrame=node.keyFrame[k]=
						{};
						keyFrame.startTime=reader.getFloat32();
						(lastKeyFrame)&& (lastKeyFrame.duration=keyFrame.startTime-lastKeyFrame.startTime);
						keyFrame.dData=new Float32Array(keyframeWidth);
						keyFrame.nextData=new Float32Array(keyframeWidth);
						var offset=AnimationParser02._DATA.offset;
						var keyframeDataOffset=reader.getUint32();
						var keyframeDataLength=keyframeWidth *4;
						var keyframeArrayBuffer=arrayBuffer.slice(offset+keyframeDataOffset,offset+keyframeDataOffset+keyframeDataLength);
						keyFrame.data=new Float32Array(keyframeArrayBuffer);
						lastKeyFrame=keyFrame;
					}
					keyFrame.duration=0;
					node.playTime=ani.playTime;
					AnimationParser02._templet._calculateKeyFrame(node,keyframeCount,keyframeWidth);
				}
			}
		}

		AnimationParser02._templet=null
		AnimationParser02._reader=null
		AnimationParser02._strings=[];
		__static(AnimationParser02,
		['_BLOCK',function(){return this._BLOCK={count:0};},'_DATA',function(){return this._DATA={offset:0,size:0};}
		]);
		return AnimationParser02;
	})()


	/**
	*@private
	*/
	//class laya.ani.AnimationState
	var AnimationState=(function(){
		function AnimationState(){}
		__class(AnimationState,'laya.ani.AnimationState');
		AnimationState.stopped=0;
		AnimationState.paused=1;
		AnimationState.playing=2;
		return AnimationState;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.Bone
	var Bone=(function(){
		function Bone(){
			this.name=null;
			this.root=null;
			this.parentBone=null;
			this.length=10;
			this.transform=null;
			this.inheritScale=true;
			this.inheritRotation=true;
			this.rotation=NaN;
			this.resultRotation=NaN;
			this.d=-1;
			this._tempMatrix=null;
			this._sprite=null;
			this.resultTransform=new Transform();
			this.resultMatrix=new Matrix();
			this._children=[];
		}

		__class(Bone,'laya.ani.bone.Bone');
		var __proto=Bone.prototype;
		__proto.setTempMatrix=function(matrix){
			this._tempMatrix=matrix;
			var i=0,n=0;
			var tBone;
			for (i=0,n=this._children.length;i < n;i++){
				tBone=this._children[i];
				tBone.setTempMatrix(this._tempMatrix);
			}
		}

		__proto.update=function(pMatrix){
			this.rotation=this.transform.skX;
			var tResultMatrix;
			if (pMatrix){
				tResultMatrix=this.resultTransform.getMatrix();
				Matrix.mul(tResultMatrix,pMatrix,this.resultMatrix);
				this.resultRotation=this.rotation;
			}
			else {
				this.resultRotation=this.rotation+this.parentBone.resultRotation;
				if (this.parentBone){
					if (this.inheritRotation && this.inheritScale){
						tResultMatrix=this.resultTransform.getMatrix();
						Matrix.mul(tResultMatrix,this.parentBone.resultMatrix,this.resultMatrix);
					}
					else {
						var temp=0;
						var parent=this.parentBone;
						var tAngle=NaN;
						var cos=NaN;
						var sin=NaN;
						var tParentMatrix=this.parentBone.resultMatrix;
						tResultMatrix=this.resultTransform.getMatrix();
						var worldX=tParentMatrix.a *tResultMatrix.tx+tParentMatrix.c *tResultMatrix.ty+tParentMatrix.tx;
						var worldY=tParentMatrix.b *tResultMatrix.tx+tParentMatrix.d *tResultMatrix.ty+tParentMatrix.ty;
						var tTestMatrix=new Matrix();
						if (this.inheritRotation){
							tAngle=Math.atan2(parent.resultMatrix.b,parent.resultMatrix.a);
							cos=Math.cos(tAngle),sin=Math.sin(tAngle);
							tTestMatrix.setTo(cos,sin,-sin,cos,0,0);
							Matrix.mul(this._tempMatrix,tTestMatrix,Matrix.TEMP);
							Matrix.TEMP.copyTo(tTestMatrix);
							tResultMatrix=this.resultTransform.getMatrix();
							Matrix.mul(tResultMatrix,tTestMatrix,this.resultMatrix);
							if (this.resultTransform.scX *this.resultTransform.scY < 0){
								this.resultMatrix.rotate(Math.PI*0.5);
							}
							this.resultMatrix.tx=worldX;
							this.resultMatrix.ty=worldY;
						}
						else if (this.inheritScale){
							tResultMatrix=this.resultTransform.getMatrix();
							Matrix.TEMP.identity();
							Matrix.TEMP.d=this.d;
							Matrix.mul(tResultMatrix,Matrix.TEMP,this.resultMatrix);
							this.resultMatrix.tx=worldX;
							this.resultMatrix.ty=worldY;
						}
						else {
							tResultMatrix=this.resultTransform.getMatrix();
							Matrix.TEMP.identity();
							Matrix.TEMP.d=this.d;
							Matrix.mul(tResultMatrix,Matrix.TEMP,this.resultMatrix);
							this.resultMatrix.tx=worldX;
							this.resultMatrix.ty=worldY;
						}
					}
				}
				else {
					tResultMatrix=this.resultTransform.getMatrix();
					tResultMatrix.copyTo(this.resultMatrix);
				}
			};
			var i=0,n=0;
			var tBone;
			for (i=0,n=this._children.length;i < n;i++){
				tBone=this._children[i];
				tBone.update();
			}
		}

		__proto.updateChild=function(){
			var i=0,n=0;
			var tBone;
			for (i=0,n=this._children.length;i < n;i++){
				tBone=this._children[i];
				tBone.update();
			}
		}

		__proto.setRotation=function(rd){
			if (this._sprite){
				this._sprite.rotation=rd *180 / Math.PI;
			}
		}

		__proto.updateDraw=function(x,y){
			if (!Bone.ShowBones || Bone.ShowBones[this.name]){
				if (this._sprite){
					this._sprite.x=x+this.resultMatrix.tx;
					this._sprite.y=y+this.resultMatrix.ty;
				}
				else {
					this._sprite=new Sprite();
					this._sprite.graphics.drawCircle(0,0,5,"#ff0000");
					this._sprite.graphics.drawLine(0,0,this.length,0,"#00ff00");
					this._sprite.graphics.fillText(this.name,0,0,"20px Arial","#00ff00","center");
					Laya.stage.addChild(this._sprite);
					this._sprite.x=x+this.resultMatrix.tx;
					this._sprite.y=y+this.resultMatrix.ty;
				}
			};
			var i=0,n=0;
			var tBone;
			for (i=0,n=this._children.length;i < n;i++){
				tBone=this._children[i];
				tBone.updateDraw(x,y);
			}
		}

		__proto.addChild=function(bone){
			this._children.push(bone);
			bone.parentBone=this;
		}

		__proto.findBone=function(boneName){
			if (this.name==boneName){
				return this;
			}
			else {
				var i=0,n=0;
				var tBone;
				var tResult;
				for (i=0,n=this._children.length;i < n;i++){
					tBone=this._children[i];
					tResult=tBone.findBone(boneName);
					if (tResult){
						return tResult;
					}
				}
			}
			return null;
		}

		__proto.localToWorld=function(local){
			var localX=local[0];
			var localY=local[1];
			local[0]=localX *this.resultMatrix.a+localY *this.resultMatrix.c+this.resultMatrix.tx;
			local[1]=localX *this.resultMatrix.b+localY *this.resultMatrix.d+this.resultMatrix.ty;
		}

		Bone.ShowBones={};
		return Bone;
	})()


	/**
	*@private
	*canvas mesh渲染器
	*/
	//class laya.ani.bone.canvasmesh.CanvasMeshRender
	var CanvasMeshRender=(function(){
		function CanvasMeshRender(){
			this.mesh=null;
			this.transform=null;
			this.context=null;
			this.mode=0;
		}

		__class(CanvasMeshRender,'laya.ani.bone.canvasmesh.CanvasMeshRender');
		var __proto=CanvasMeshRender.prototype;
		/**
		*将mesh数据渲染到context上面
		*@param context
		*
		*/
		__proto.renderToContext=function(context){
			this.context=context.ctx||context;
			if (this.mesh){
				if (this.mode==0){
					this._renderWithIndexes(this.mesh);
					}else{
					this._renderNoIndexes(this.mesh);
				}
			}
		}

		/**
		*无顶点索引的模式
		*@param mesh
		*
		*/
		__proto._renderNoIndexes=function(mesh){
			var i=0,len=mesh.vertices.length / 2;
			var index=0;
			for (i=0;i < len-2;i++){
				index=i *2;
				this._renderDrawTriangle(mesh,index,(index+2),(index+4));
			}
		}

		/**
		*使用顶点索引模式绘制
		*@param mesh
		*
		*/
		__proto._renderWithIndexes=function(mesh){
			var indexes=mesh.indexes;
			var i=0,len=indexes.length;
			for (i=0;i < len;i+=3){
				var index0=indexes[i] *2;
				var index1=indexes[i+1] *2;
				var index2=indexes[i+2] *2;
				this._renderDrawTriangle(mesh,index0,index1,index2);
			}
		}

		/**
		*绘制三角形
		*@param mesh mesh
		*@param index0 顶点0
		*@param index1 顶点1
		*@param index2 顶点2
		*
		*/
		__proto._renderDrawTriangle=function(mesh,index0,index1,index2){
			var context=this.context;
			var uvs=mesh.uvs;
			var vertices=mesh.vertices;
			var texture=mesh.texture;
			var source=texture.bitmap;
			var textureSource=source.source;
			var textureWidth=texture.width;
			var textureHeight=texture.height;
			var sourceWidth=source.width;
			var sourceHeight=source.height;
			var u0=NaN;
			var u1=NaN;
			var u2=NaN;
			var v0=NaN;
			var v1=NaN;
			var v2=NaN;
			if (mesh.useUvTransform){
				var ut=mesh.uvTransform;
				u0=((uvs[index0] *ut.a)+(uvs[index0+1] *ut.c)+ut.tx)*sourceWidth;
				u1=((uvs[index1] *ut.a)+(uvs[index1+1] *ut.c)+ut.tx)*sourceWidth;
				u2=((uvs[index2] *ut.a)+(uvs[index2+1] *ut.c)+ut.tx)*sourceWidth;
				v0=((uvs[index0] *ut.b)+(uvs[index0+1] *ut.d)+ut.ty)*sourceHeight;
				v1=((uvs[index1] *ut.b)+(uvs[index1+1] *ut.d)+ut.ty)*sourceHeight;
				v2=((uvs[index2] *ut.b)+(uvs[index2+1] *ut.d)+ut.ty)*sourceHeight;
			}
			else {
				u0=uvs[index0] *sourceWidth;
				u1=uvs[index1] *sourceWidth;
				u2=uvs[index2] *sourceWidth;
				v0=uvs[index0+1] *sourceHeight;
				v1=uvs[index1+1] *sourceHeight;
				v2=uvs[index2+1] *sourceHeight;
			};
			var x0=vertices[index0];
			var x1=vertices[index1];
			var x2=vertices[index2];
			var y0=vertices[index0+1];
			var y1=vertices[index1+1];
			var y2=vertices[index2+1];
			if (mesh.canvasPadding > 0){
				var paddingX=mesh.canvasPadding;
				var paddingY=mesh.canvasPadding;
				var centerX=(x0+x1+x2)/ 3;
				var centerY=(y0+y1+y2)/ 3;
				var normX=x0-centerX;
				var normY=y0-centerY;
				var dist=Math.sqrt((normX *normX)+(normY *normY));
				x0=centerX+((normX / dist)*(dist+paddingX));
				y0=centerY+((normY / dist)*(dist+paddingY));
				normX=x1-centerX;
				normY=y1-centerY;
				dist=Math.sqrt((normX *normX)+(normY *normY));
				x1=centerX+((normX / dist)*(dist+paddingX));
				y1=centerY+((normY / dist)*(dist+paddingY));
				normX=x2-centerX;
				normY=y2-centerY;
				dist=Math.sqrt((normX *normX)+(normY *normY));
				x2=centerX+((normX / dist)*(dist+paddingX));
				y2=centerY+((normY / dist)*(dist+paddingY));
			}
			context.save();
			if (this.transform){
				var mt=this.transform;
				context.transform(mt.a,mt.b,mt.c,mt.d,mt.tx,mt.ty);
			}
			context.beginPath();
			context.moveTo(x0,y0);
			context.lineTo(x1,y1);
			context.lineTo(x2,y2);
			context.closePath();
			context.clip();
			var delta=(u0 *v1)+(v0 *u2)+(u1 *v2)-(v1 *u2)-(v0 *u1)-(u0 *v2);
			var dDelta=1 / delta;
			var deltaA=(x0 *v1)+(v0 *x2)+(x1 *v2)-(v1 *x2)-(v0 *x1)-(x0 *v2);
			var deltaB=(u0 *x1)+(x0 *u2)+(u1 *x2)-(x1 *u2)-(x0 *u1)-(u0 *x2);
			var deltaC=(u0 *v1 *x2)+(v0 *x1 *u2)+(x0 *u1 *v2)-(x0 *v1 *u2)-(v0 *u1 *x2)-(u0 *x1 *v2);
			var deltaD=(y0 *v1)+(v0 *y2)+(y1 *v2)-(v1 *y2)-(v0 *y1)-(y0 *v2);
			var deltaE=(u0 *y1)+(y0 *u2)+(u1 *y2)-(y1 *u2)-(y0 *u1)-(u0 *y2);
			var deltaF=(u0 *v1 *y2)+(v0 *y1 *u2)+(y0 *u1 *v2)-(y0 *v1 *u2)-(v0 *u1 *y2)-(u0 *y1 *v2);
			context.transform(deltaA *dDelta,deltaD *dDelta,deltaB *dDelta,deltaE*dDelta,deltaC *dDelta,deltaF *dDelta);
			context.drawImage(textureSource,texture.uv[0]*sourceWidth,texture.uv[1]*sourceHeight,textureWidth,textureHeight,texture.uv[0]*sourceWidth,texture.uv[1]*sourceHeight,textureWidth,textureHeight);
			context.restore();
		}

		return CanvasMeshRender;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.canvasmesh.MeshData
	var MeshData=(function(){
		function MeshData(){
			this.texture=null;
			this.uvs=[0,0,1,0,1,1,0,1];
			this.vertices=[0,0,100,0,100,100,0,100];
			this.indexes=[0,1,3,3,1,2];
			this.uvTransform=null;
			this.useUvTransform=false;
			this.canvasPadding=1;
		}

		__class(MeshData,'laya.ani.bone.canvasmesh.MeshData');
		var __proto=MeshData.prototype;
		/**
		*计算mesh的Bounds
		*@return
		*
		*/
		__proto.getBounds=function(){
			return Rectangle._getWrapRec(this.vertices);
		}

		return MeshData;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.Transform
	var Transform=(function(){
		function Transform(){
			this.skX=0;
			this.skY=0;
			this.scX=1;
			this.scY=1;
			this.x=0;
			this.y=0;
			this.skewX=0;
			this.skewY=0;
			this.mMatrix=null;
		}

		__class(Transform,'laya.ani.bone.Transform');
		var __proto=Transform.prototype;
		__proto.initData=function(data){
			if (data.x !=undefined){
				this.x=data.x;
			}
			if (data.y !=undefined){
				this.y=data.y;
			}
			if (data.skX !=undefined){
				this.skX=data.skX;
			}
			if (data.skY !=undefined){
				this.skY=data.skY;
			}
			if (data.scX !=undefined){
				this.scX=data.scX;
			}
			if (data.scY !=undefined){
				this.scY=data.scY;
			}
		}

		__proto.getMatrix=function(){
			var tMatrix;
			if (this.mMatrix){
				tMatrix=this.mMatrix;
				}else {
				tMatrix=this.mMatrix=new Matrix();
			}
			tMatrix.identity();
			tMatrix.scale(this.scX,this.scY);
			if (this.skewX || this.skewY){
				this.skew(tMatrix,this.skewX *Math.PI / 180,this.skewY *Math.PI / 180);
			}
			tMatrix.rotate(this.skX *Math.PI / 180);
			tMatrix.translate(this.x,this.y);
			return tMatrix;
		}

		__proto.skew=function(m,x,y){
			var sinX=Math.sin(y);
			var cosX=Math.cos(y);
			var sinY=Math.sin(x);
			var cosY=Math.cos(x);
			m.setTo(m.a *cosY-m.b *sinX,
			m.a *sinY+m.b *cosX,
			m.c *cosY-m.d *sinX,
			m.c *sinY+m.d *cosX,
			m.tx *cosY-m.ty *sinX,
			m.tx *sinY+m.ty *cosX);
			return m;
		}

		return Transform;
	})()


	/**
	*@private
	*@author ...
	*/
	//class laya.ani.KeyFramesContent
	var KeyFramesContent=(function(){
		function KeyFramesContent(){
			this.startTime=NaN;
			this.duration=NaN;
			this.interpolationData=null;
			this.data=null;
			this.dData=null;
			this.nextData=null;
		}

		__class(KeyFramesContent,'laya.ani.KeyFramesContent');
		return KeyFramesContent;
	})()


	/**
	*@private
	*...
	*@author ww
	*/
	//class laya.ani.math.BezierLerp
	var BezierLerp=(function(){
		function BezierLerp(){}
		__class(BezierLerp,'laya.ani.math.BezierLerp');
		BezierLerp.getBezierRate=function(t,px0,py0,px1,py1){
			var key=BezierLerp._getBezierParamKey(px0,py0,px1,py1);
			var vKey=key *100+t;
			if (BezierLerp._bezierResultCache[vKey])return BezierLerp._bezierResultCache[vKey];
			var points=BezierLerp._getBezierPoints(px0,py0,px1,py1,key);
			var i=0,len=0;
			len=points.length;
			for (i=0;i < len;i+=2){
				if (t <=points[i]){
					BezierLerp._bezierResultCache[vKey]=points[i+1];
					return points[i+1];
				}
			}
			BezierLerp._bezierResultCache[vKey]=1;
			return 1;
		}

		BezierLerp._getBezierParamKey=function(px0,py0,px1,py1){
			return (((px0 *100+py0)*100+px1)*100+py1)*100;
		}

		BezierLerp._getBezierPoints=function(px0,py0,px1,py1,key){
			if (BezierLerp._bezierPointsCache[key])return BezierLerp._bezierPointsCache[key];
			var controlPoints;
			controlPoints=[0,0,px0,py0,px1,py1,1,1];
			var bz;
			bz=new Bezier();
			var points;
			points=bz.getBezierPoints(controlPoints,100,3);
			BezierLerp._bezierPointsCache[key]=points;
			return points;
		}

		BezierLerp._bezierResultCache={};
		BezierLerp._bezierPointsCache={};
		return BezierLerp;
	})()


	//class laya.filters.webgl.FilterActionGL
	var FilterActionGL=(function(){
		function FilterActionGL(){}
		__class(FilterActionGL,'laya.filters.webgl.FilterActionGL');
		var __proto=FilterActionGL.prototype;
		Laya.imps(__proto,{"laya.filters.IFilterActionGL":true})
		__proto.setValue=function(shader){}
		__proto.setValueMix=function(shader){}
		__proto.apply3d=function(scope,sprite,context,x,y){return null;}
		__proto.apply=function(srcCanvas){return null;}
		__getset(0,__proto,'typeMix',function(){
			return 0;
		});

		return FilterActionGL;
	})()


	/**
	*@private
	*/
	//class laya.maths.Arith
	var Arith=(function(){
		function Arith(){};
		__class(Arith,'laya.maths.Arith');
		Arith.formatR=function(r){
			if (r > Math.PI)r-=Math.PI *2;
			if (r <-Math.PI)r+=Math.PI *2;
			return r;
		}

		Arith.isPOT=function(w,h){
			return (w > 0 && (w & (w-1))===0 && h > 0 && (h & (h-1))===0);
		}

		Arith.setMatToArray=function(mat,array){
			mat.a,mat.b,0,0,mat.c,mat.d,0,0,0,0,1,0,mat.tx+20,mat.ty+20,0,1
			array[0]=mat.a;
			array[1]=mat.b;
			array[4]=mat.c;
			array[5]=mat.d;
			array[12]=mat.tx;
			array[13]=mat.ty;
		}

		return Arith;
	})()


	//class laya.webgl.canvas.BlendMode
	var BlendMode=(function(){
		function BlendMode(){};
		__class(BlendMode,'laya.webgl.canvas.BlendMode');
		BlendMode._init_=function(gl){
			BlendMode.fns=[BlendMode.BlendNormal,BlendMode.BlendAdd,BlendMode.BlendMultiply,BlendMode.BlendScreen,BlendMode.BlendOverlay,BlendMode.BlendLight,BlendMode.BlendMask,BlendMode.BlendDestinationOut];
			BlendMode.targetFns=[BlendMode.BlendNormalTarget,BlendMode.BlendAddTarget,BlendMode.BlendMultiplyTarget,BlendMode.BlendScreenTarget,BlendMode.BlendOverlayTarget,BlendMode.BlendLightTarget,BlendMode.BlendMask,BlendMode.BlendDestinationOut];
		}

		BlendMode.BlendNormal=function(gl){
			WebGLContext.setBlendFunc(gl,1,0x0303);
		}

		BlendMode.BlendAdd=function(gl){
			WebGLContext.setBlendFunc(gl,1,0x0304);
		}

		BlendMode.BlendMultiply=function(gl){
			WebGLContext.setBlendFunc(gl,0x0306,0x0303);
		}

		BlendMode.BlendScreen=function(gl){
			WebGLContext.setBlendFunc(gl,1,1);
		}

		BlendMode.BlendOverlay=function(gl){
			WebGLContext.setBlendFunc(gl,1,0x0301);
		}

		BlendMode.BlendLight=function(gl){
			WebGLContext.setBlendFunc(gl,1,1);
		}

		BlendMode.BlendNormalTarget=function(gl){
			WebGLContext.setBlendFunc(gl,1,0x0303);
		}

		BlendMode.BlendAddTarget=function(gl){
			WebGLContext.setBlendFunc(gl,1,0x0304);
		}

		BlendMode.BlendMultiplyTarget=function(gl){
			WebGLContext.setBlendFunc(gl,0x0306,0x0303);
		}

		BlendMode.BlendScreenTarget=function(gl){
			WebGLContext.setBlendFunc(gl,1,1);
		}

		BlendMode.BlendOverlayTarget=function(gl){
			WebGLContext.setBlendFunc(gl,1,0x0301);
		}

		BlendMode.BlendLightTarget=function(gl){
			WebGLContext.setBlendFunc(gl,1,1);
		}

		BlendMode.BlendMask=function(gl){
			WebGLContext.setBlendFunc(gl,0,0x0302);
		}

		BlendMode.BlendDestinationOut=function(gl){
			WebGLContext.setBlendFunc(gl,0,0);
		}

		BlendMode.activeBlendFunction=null;
		BlendMode.NAMES=["normal","add","multiply","screen","overlay","light","mask","destination-out"];
		BlendMode.TOINT={"normal":0,"add":1,"multiply":2,"screen":3 ,"lighter":1,"overlay":4,"light":5,"mask":6,"destination-out":7 };
		BlendMode.NORMAL="normal";
		BlendMode.ADD="add";
		BlendMode.MULTIPLY="multiply";
		BlendMode.SCREEN="screen";
		BlendMode.LIGHT="light";
		BlendMode.OVERLAY="overlay";
		BlendMode.DESTINATIONOUT="destination-out";
		BlendMode.fns=[];
		BlendMode.targetFns=[];
		return BlendMode;
	})()


	//class laya.webgl.canvas.DrawStyle
	var DrawStyle=(function(){
		function DrawStyle(value){
			this._color=null;
			this.setValue(value);
		}

		__class(DrawStyle,'laya.webgl.canvas.DrawStyle');
		var __proto=DrawStyle.prototype;
		__proto.setValue=function(value){
			if (value){
				this._color=((value instanceof laya.utils.Color ))?(value):Color.create(value);
			}
			else this._color=Color.create("#000000");
		}

		__proto.reset=function(){
			this._color=Color.create("#000000");
		}

		__proto.toInt=function(){
			return this._color.numColor;
		}

		__proto.equal=function(value){
			if ((typeof value=='string'))return this._color.strColor===value;
			if ((value instanceof laya.utils.Color ))return this._color.numColor===(value).numColor;
			return false;
		}

		__proto.toColorStr=function(){
			return this._color.strColor;
		}

		DrawStyle.create=function(value){
			if (value){
				var color=((value instanceof laya.utils.Color ))?(value):Color.create(value);
				return color._drawStyle || (color._drawStyle=new DrawStyle(value));
			}
			return DrawStyle.DEFAULT;
		}

		DrawStyle.DEFAULT=new DrawStyle("#000000");
		return DrawStyle;
	})()


	//class laya.webgl.canvas.Path
	var Path=(function(){
		var renderPath;
		function Path(){
			this._x=0;
			this._y=0;
			this._lastOriX=0;
			this._lastOriY=0;
			this.paths=[];
			this._curPath=null;
		}

		__class(Path,'laya.webgl.canvas.Path');
		var __proto=Path.prototype;
		//vb=VertexBuffer2D.create(5);
		__proto.beginPath=function(convex){
			this.paths.length=1;
			this._curPath=this.paths[0]=new renderPath();
			this._curPath.convex=convex;
		}

		//_curPath.path=[];
		__proto.closePath=function(){
			this._curPath.loop=true;
		}

		__proto.newPath=function(){
			this._curPath=new renderPath();
			this.paths.push(this._curPath);
		}

		__proto.addPoint=function(pointX,pointY){
			this._curPath.path.push(pointX,pointY);
		}

		__proto.getEndPointX=function(){
			return (this._curPath&&this._curPath.path.length>2)?this._curPath.path[this._curPath.path.length-2]:0;
		}

		__proto.getEndPointY=function(){
			return (this._curPath&&this._curPath.path.length>2)?this._curPath.path[this._curPath.path.length-1]:0;
		}

		__proto.push=function(points,convex){
			var rp=new renderPath();
			rp.path=points.slice();
			rp.convex=convex;
			this.paths.push(rp);
		}

		__proto.polygon=function(x,y,points,color,borderWidth,borderColor){
			var geo;
			debugger;
		}

		/*
		pathes.push(points);
		if (!color)geo.fill=false;
		if (borderColor==undefined)geo.borderWidth=0;
		return geo;
		*/
		__proto.setGeomtry=function(shape){
			debugger;
		}

		//geomatrys.push(_curGeomatry=shape);
		__proto.drawLine=function(x,y,points,width,color){
			debugger;
		}

		/*
		var geo:BasePoly;
		if (closePath){
			geomatrys.push(_curGeomatry=geo=new LoopLine(x,y,points,width,color));
			}else {
			geomatrys.push(_curGeomatry=geo=new Line(x,y,points,width,color));
		}

		geo.fill=false;
		return geo;
		*/
		__proto.update=function(mesh){}
		//this.count=(mesh._ib._byteLength-si)/ CONST3D2D.BYTES_PIDX;
		__proto.reset=function(){
			this.paths.length=0;
		}

		//geomatrys.length=0;TODO
		__proto.recover=function(){}
		Path.__init$=function(){
			//Pool.recover("path",this);
			//class renderPath
			renderPath=(function(){
				function renderPath(){
					this.path=[];
					this.loop=false;
					this.convex=false;
				}
				__class(renderPath,'');
				return renderPath;
			})()
		}

		return Path;
	})()


	//class laya.webgl.canvas.save.SaveClipRect
	var SaveClipRect=(function(){
		function SaveClipRect(){
			//this._clipSaveRect=null;
			//this._submitScissor=null;
			this._clipRect=new Rectangle();
		}

		__class(SaveClipRect,'laya.webgl.canvas.save.SaveClipRect');
		var __proto=SaveClipRect.prototype;
		Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
		__proto.isSaveMark=function(){return false;}
		__proto.restore=function(context){
			context._clipRect=this._clipSaveRect;
			context._clipTransed=false;
			SaveClipRect.POOL[SaveClipRect.POOL._length++]=this;
			this._submitScissor.submitLength=context._submits._length-this._submitScissor.submitIndex;
			context._curSubmit=context._submits[context._submits._length++]=Submit.RENDERBASE;
			context._submitKey.submitType=-1;
		}

		SaveClipRect.save=function(context,submitScissor){
			if ((context._saveMark._saveuse & 0x20000)==0x20000)return;
			context._saveMark._saveuse |=0x20000;
			var cache=SaveClipRect.POOL;
			var o=cache._length > 0 ? cache[--cache._length] :(new SaveClipRect());
			o._clipSaveRect=context._clipRect;
			context._clipRect=o._clipRect.copyFrom(context._clipRect);
			o._submitScissor=submitScissor;
			var _save=context._save;
			_save[_save._length++]=o;
		}

		SaveClipRect.POOL=SaveBase._createArray();
		return SaveClipRect;
	})()


	//class laya.webgl.canvas.save.SaveClipRectStencil
	var SaveClipRectStencil=(function(){
		function SaveClipRectStencil(){
			//this._clipSaveRect=null;
			//this._saveMatrix=null;
			this._contextX=0;
			this._contextY=0;
			//this._submitStencil=null;
			this._clipRect=new Rectangle();
			this._rect=new Rectangle();
			this._matrix=new Matrix();
		}

		__class(SaveClipRectStencil,'laya.webgl.canvas.save.SaveClipRectStencil');
		var __proto=SaveClipRectStencil.prototype;
		Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
		__proto.isSaveMark=function(){return false;}
		__proto.restore=function(context){
			SubmitStencil.restore(context,this._rect,this._saveMatrix,this._contextX,this._contextY);
			context._clipRect=this._clipSaveRect;
			context._curMat=this._saveMatrix;
			context._x=this._contextX;
			context._y=this._contextY;
			SaveClipRectStencil.POOL[SaveClipRectStencil.POOL._length++]=this;
			context._curSubmit=Submit.RENDERBASE;
		}

		SaveClipRectStencil.save=function(context,submitStencil,x,y,width,height){
			if ((context._saveMark._saveuse & 0x40000)==0x40000)return;
			context._saveMark._saveuse |=0x40000;
			var cache=SaveClipRectStencil.POOL;
			var o=cache._length > 0 ? cache[--cache._length] :(new SaveClipRectStencil());
			o._clipSaveRect=context._clipRect;
			context._clipRect=o._clipRect.copyFrom(context._clipRect);
			o._rect.x=x;
			o._rect.y=y;
			o._rect.width=width;
			o._rect.height=height;
			o._contextX=context._x;
			o._contextY=context._y;
			o._saveMatrix=context._curMat;
			context._curMat.copyTo(o._matrix);
			context._curMat=o._matrix;
			o._submitStencil=submitStencil;
			var _save=context._save;
			_save[_save._length++]=o;
		}

		SaveClipRectStencil.POOL=SaveBase._createArray();
		return SaveClipRectStencil;
	})()


	//class laya.webgl.canvas.save.SaveMark
	var SaveMark=(function(){
		function SaveMark(){
			this._saveuse=0;
			//this._preSaveMark=null;
			;
		}

		__class(SaveMark,'laya.webgl.canvas.save.SaveMark');
		var __proto=SaveMark.prototype;
		Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
		__proto.isSaveMark=function(){
			return true;
		}

		__proto.restore=function(context){
			context._saveMark=this._preSaveMark;
			SaveMark.POOL[SaveMark.POOL._length++]=this;
		}

		SaveMark.Create=function(context){
			var no=SaveMark.POOL;
			var o=no._length > 0 ? no[--no._length] :(new SaveMark());
			o._saveuse=0;
			o._preSaveMark=context._saveMark;
			context._saveMark=o;
			return o;
		}

		SaveMark.POOL=SaveBase._createArray();
		return SaveMark;
	})()


	//class laya.webgl.canvas.save.SaveTransform
	var SaveTransform=(function(){
		function SaveTransform(){
			//this._savematrix=null;
			this._matrix=new Matrix();
		}

		__class(SaveTransform,'laya.webgl.canvas.save.SaveTransform');
		var __proto=SaveTransform.prototype;
		Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
		__proto.isSaveMark=function(){return false;}
		__proto.restore=function(context){
			context._curMat=this._savematrix;
			SaveTransform.POOL[SaveTransform.POOL._length++]=this;
		}

		SaveTransform.save=function(context){
			var _saveMark=context._saveMark;
			if ((_saveMark._saveuse & 0x800)===0x800)return;
			_saveMark._saveuse |=0x800;
			var no=SaveTransform.POOL;
			var o=no._length > 0 ? no[--no._length] :(new SaveTransform());
			o._savematrix=context._curMat;
			context._curMat=context._curMat.copyTo(o._matrix);
			var _save=context._save;
			_save[_save._length++]=o;
		}

		SaveTransform.POOL=SaveBase._createArray();
		return SaveTransform;
	})()


	//class laya.webgl.canvas.save.SaveTranslate
	var SaveTranslate=(function(){
		function SaveTranslate(){
			//this._x=NaN;
			//this._y=NaN;
		}

		__class(SaveTranslate,'laya.webgl.canvas.save.SaveTranslate');
		var __proto=SaveTranslate.prototype;
		Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
		__proto.isSaveMark=function(){return false;}
		__proto.restore=function(context){
			var mat=context._curMat;
			context._x=this._x;
			context._y=this._y;
			SaveTranslate.POOL[SaveTranslate.POOL._length++]=this;
		}

		SaveTranslate.save=function(context){
			var no=SaveTranslate.POOL;
			var o=no._length > 0 ? no[--no._length] :(new SaveTranslate());
			o._x=context._x;
			o._y=context._y;
			var _save=context._save;
			_save[_save._length++]=o;
		}

		SaveTranslate.POOL=SaveBase._createArray();
		return SaveTranslate;
	})()


	/**
	*key:font
	*下面是各种大小的page
	*每个大小的page可以有多个
	*/
	//class laya.webgl.resource.CharBook
	var CharBook=(function(){
		function CharBook(){
			this.fontPages=[];
			this.fontPagesName=[];
			this._curFontFamily=null;
			this._curPage=null;
			this.tempUV=[0,0,1,0,1,1,0,1];
			this.fontScale=1.0;
			this._curStrPos=0;
			this._lastFont=null;
			this._emojiReg=/(?:0\u20E3|1\u20E3|2\u20E3|3\u20E3|4\u20E3|5\u20E3|6\u20E3|7\u20E3|8\u20E3|9\u20E3|#\u20E3|\*\u20E3|\uD83C(?:\uDDE6\uD83C(?:\uDDE8|\uDDE9|\uDDEA|\uDDEB|\uDDEC|\uDDEE|\uDDF1|\uDDF2|\uDDF4|\uDDF6|\uDDF7|\uDDF8|\uDDF9|\uDDFA|\uDDFC|\uDDFD|\uDDFF)|\uDDE7\uD83C(?:\uDDE6|\uDDE7|\uDDE9|\uDDEA|\uDDEB|\uDDEC|\uDDED|\uDDEE|\uDDEF|\uDDF1|\uDDF2|\uDDF3|\uDDF4|\uDDF6|\uDDF7|\uDDF8|\uDDF9|\uDDFB|\uDDFC|\uDDFE|\uDDFF)|\uDDE8\uD83C(?:\uDDE6|\uDDE8|\uDDE9|\uDDEB|\uDDEC|\uDDED|\uDDEE|\uDDF0|\uDDF1|\uDDF2|\uDDF3|\uDDF4|\uDDF5|\uDDF7|\uDDFA|\uDDFB|\uDDFC|\uDDFD|\uDDFE|\uDDFF)|\uDDE9\uD83C(?:\uDDEA|\uDDEC|\uDDEF|\uDDF0|\uDDF2|\uDDF4|\uDDFF)|\uDDEA\uD83C(?:\uDDE6|\uDDE8|\uDDEA|\uDDEC|\uDDED|\uDDF7|\uDDF8|\uDDF9|\uDDFA)|\uDDEB\uD83C(?:\uDDEE|\uDDEF|\uDDF0|\uDDF2|\uDDF4|\uDDF7)|\uDDEC\uD83C(?:\uDDE6|\uDDE7|\uDDE9|\uDDEA|\uDDEB|\uDDEC|\uDDED|\uDDEE|\uDDF1|\uDDF2|\uDDF3|\uDDF5|\uDDF6|\uDDF7|\uDDF8|\uDDF9|\uDDFA|\uDDFC|\uDDFE)|\uDDED\uD83C(?:\uDDF0|\uDDF2|\uDDF3|\uDDF7|\uDDF9|\uDDFA)|\uDDEE\uD83C(?:\uDDE8|\uDDE9|\uDDEA|\uDDF1|\uDDF2|\uDDF3|\uDDF4|\uDDF6|\uDDF7|\uDDF8|\uDDF9)|\uDDEF\uD83C(?:\uDDEA|\uDDF2|\uDDF4|\uDDF5)|\uDDF0\uD83C(?:\uDDEA|\uDDEC|\uDDED|\uDDEE|\uDDF2|\uDDF3|\uDDF5|\uDDF7|\uDDFC|\uDDFE|\uDDFF)|\uDDF1\uD83C(?:\uDDE6|\uDDE7|\uDDE8|\uDDEE|\uDDF0|\uDDF7|\uDDF8|\uDDF9|\uDDFA|\uDDFB|\uDDFE)|\uDDF2\uD83C(?:\uDDE6|\uDDE8|\uDDE9|\uDDEA|\uDDEB|\uDDEC|\uDDED|\uDDF0|\uDDF1|\uDDF2|\uDDF3|\uDDF4|\uDDF5|\uDDF6|\uDDF7|\uDDF8|\uDDF9|\uDDFA|\uDDFB|\uDDFC|\uDDFD|\uDDFE|\uDDFF)|\uDDF3\uD83C(?:\uDDE6|\uDDE8|\uDDEA|\uDDEB|\uDDEC|\uDDEE|\uDDF1|\uDDF4|\uDDF5|\uDDF7|\uDDFA|\uDDFF)|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C(?:\uDDE6|\uDDEA|\uDDEB|\uDDEC|\uDDED|\uDDF0|\uDDF1|\uDDF2|\uDDF3|\uDDF7|\uDDF8|\uDDF9|\uDDFC|\uDDFE)|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C(?:\uDDEA|\uDDF4|\uDDF8|\uDDFA|\uDDFC)|\uDDF8\uD83C(?:\uDDE6|\uDDE7|\uDDE8|\uDDE9|\uDDEA|\uDDEC|\uDDED|\uDDEE|\uDDEF|\uDDF0|\uDDF1|\uDDF2|\uDDF3|\uDDF4|\uDDF7|\uDDF8|\uDDF9|\uDDFB|\uDDFD|\uDDFE|\uDDFF)|\uDDF9\uD83C(?:\uDDE6|\uDDE8|\uDDE9|\uDDEB|\uDDEC|\uDDED|\uDDEF|\uDDF0|\uDDF1|\uDDF2|\uDDF3|\uDDF4|\uDDF7|\uDDF9|\uDDFB|\uDDFC|\uDDFF)|\uDDFA\uD83C(?:\uDDE6|\uDDEC|\uDDF2|\uDDF8|\uDDFE|\uDDFF)|\uDDFB\uD83C(?:\uDDE6|\uDDE8|\uDDEA|\uDDEC|\uDDEE|\uDDF3|\uDDFA)|\uDDFC\uD83C(?:\uDDEB|\uDDF8)|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C(?:\uDDEA|\uDDF9)|\uDDFF\uD83C(?:\uDDE6|\uDDF2|\uDDFC)))|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2694\u2696\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD79\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED0\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3]|\uD83E[\uDD10-\uDD18\uDD80-\uDD84\uDDC0]/g;
			this.tempMat=new Matrix();
			CharBook.charbookInst=this;
		}

		__class(CharBook,'laya.webgl.resource.CharBook');
		var __proto=CharBook.prototype;
		/**
		*string 转 id
		*@param str
		*@return
		*/
		__proto.getStringID=function(str){}
		__proto.selectFont=function(fontFamily,fontsize){
			var ret;
			var sz=CharPages.getBmpSize(fontsize);
			var szid=Math.floor(sz / 16);
			var key=fontFamily+szid;
			var fid=this.fontPagesName.indexOf(key);
			if (fid < 0){
				var selFontPages=new CharPages(fontFamily,fontsize,sz);
				this.fontPages.push(selFontPages);
				this.fontPagesName.push(key);
				ret=selFontPages;
				}else {
				ret=this.fontPages[fid];
			}
			ret.onSelect();
			return ret;
		}

		__proto.isEmoji=function(emoji){
			return this._emojiReg.test(emoji);
		}

		/**
		*从string中取出一个完整的char，例如emoji的话要多个
		*会修改 _curStrPos
		*TODO 由于各种文字中的组合写法，这个需要能扩展，以便支持泰文等
		*@param str
		*@param start 开始位置
		*/
		__proto.getNextChar=function(str){
			var len=str.length;
			var start=this._curStrPos;
			if (start >=len)
				return null;
			var link=false;
			var i=start;
			var state=0;
			for (;i < len;i++){
				var c=str.charCodeAt(i);
				if ((c & 0xd800)==0xd800){
					state=1;
					continue ;
				}
				if (c===0xfe0e || c===0xfe0f){
					state=1;
					continue ;
				}
				if (c==0x200d){
					state=1;
					continue ;
				}
				if (state==1)
					break ;
				else {
					i++;
					break ;
				}
			}
			this._curStrPos=i;
			return str.substring(start,i);
		}

		/**
		*
		*TEST
		*emoji:'💗'
		*arabic:'سلام'
		*组合:'ă'
		*泰语:'ฏ๎๎๎๎๎๎๎๎๎๎๎๎๎๎๎'
		*天城文:'कि' *
		*/
		__proto.filltext=function(ctx,data,x,y,fontStr,color,strokeColor,lineWidth,textAlign,underLine){
			(underLine===void 0)&& (underLine=0);
			if (data.length <=0)
				return;
			var c1=Color.create(color);
			var c2=strokeColor?Color.create(strokeColor):null;
			var nColor=c1.numColor;
			var nStrokeColor=c2?c2.numColor:0;
			this.fontScale=1.0;
			if (CharBook.scaleFontWithCtx){
				var sx=ctx._curMat.getScaleX();
				var sy=ctx._curMat.getScaleY();
				if (sx < 1e-4 || sy < 1e-1)
					return;
				if (sx > 1.0 || sy > 1.0){
					ctx._curMat.copyTo(this.tempMat);
					if (sx > sy){
						this.fontScale=sx;
						var s1=sy / sx / sx;
						this.tempMat.a /=sx;this.tempMat.b /=sx;
						this.tempMat.c *=s1;this.tempMat.d *=s1;
						}else {
						this.fontScale=sy;
						var s1=sx / sy / sy;
						this.tempMat.a *=s1;this.tempMat.b *=s1;
						this.tempMat.c /=sy;this.tempMat.d /=sy;
					}
					x *=sx;x=Math.floor(x+0.5);
					y *=sy;y=Math.floor(y+0.5);
				}
			};
			var font=FontInContext.create(fontStr);
			var fontFamily=font.getFamily();
			if (font.getItalic()>=0){
				ctx._italicDeg=12;
			}
			this._curPage=this.selectFont(fontFamily,font.size*this.fontScale);
			var curx=x;
			var wt=data;
			var str=data;
			var strWidth=0;
			var isWT=str instanceof WordText;
			var sameTexData=(CharBook.cacheRenderInfoInWordText && isWT)?wt.pageChars:[];
			if (isWT){
				str=wt.toString();
				strWidth=wt.width;
				if (strWidth < 0){
					strWidth=wt.width=this._curPage.getWidth(str);
				}
				}else {
				strWidth=this._curPage.getWidth(str);
			}
			switch (textAlign){
				case 'center':
					curx=x-strWidth / 2;
					break ;
				case 'right':
					curx=x-strWidth;
					break ;
				default :
					curx=x;
				}
			if (!sameTexData || sameTexData.length <=0){
				this._curStrPos=0;
				var curstr=this.getNextChar(str);
				while (curstr){
					var isEmo=this.isEmoji(curstr);
					var ri=this._curPage.getChar(curstr,false,0,nColor);
					var add=sameTexData[ri.tex.id];
					if (!add){
						add=[];sameTexData[ri.tex.id]=add;
					}
					add.push({ri:ri,isEmoji:isEmo,x:curx,color:color,nColor:nColor});
					if (strokeColor && lineWidth > 0){
						var ris=this._curPage.getChar(curstr,false,lineWidth,nStrokeColor);
						add=sameTexData[ris.tex.id];
						if (!add){
							add=[];sameTexData[ris.tex.id]=add;
						}
						add.push({ri:ris,isEmoji:false,x:curx,color:strokeColor,nColor:nStrokeColor});
					}
					curx+=ri.width;
					curstr=this.getNextChar(str);
				}
			};
			var lastUseColor=ctx._drawTextureUseColor;
			this._drawReSortedWords(ctx,sameTexData,y);
			ctx._drawTextureUseColor=lastUseColor;
			ctx._italicDeg=0;
		}

		/**
		*画出重新按照贴图顺序分组的文字。
		*@param samePagesData
		*@param y {int}因为这个只能画在一行上所以没有必要保存y。所以这里再把y传进来
		*/
		__proto._drawReSortedWords=function(ctx,samePagesData,y){
			var lastcolor=0;
			for (var i=0,sz=samePagesData.length;i < sz;i++){
				var pri=samePagesData[i];
				if (!pri)continue ;
				for (var j=0,pisz=pri.length;j < pisz;j++){
					var riSaved=pri[j];
					ctx._drawTextureUseColor=CharBook.getFontBmpWithColor?false:!riSaved.isEmoji;
					if (lastcolor !=riSaved.nColor){
						ctx.fillStyle=riSaved.color;
						lastcolor=riSaved.nColor;
					}
					this._drawCharRenderInfo(ctx,riSaved.ri,riSaved.x,y);
					riSaved.ri.touch();
				}
			}
		}

		/**
		*画出保存在ri中的文字信息。
		*@param ctx
		*@param ri
		*@param x
		*@param y
		*/
		__proto._drawCharRenderInfo=function(ctx,ri,x,y){
			var fontMat=null;
			if (this.fontScale !=1.0){
				fontMat=this.tempMat;
			}
			ctx._drawTextureM(ri.tex.texture,
			x-this._curPage.margin_left,y-this._curPage.margin_top,ri.width+this._curPage.margin_left+this._curPage.margin_right,ri.height+this._curPage.margin_top+this._curPage.margin_bottom,
			fontMat,1.0,ri.uv);
		}

		/**
		*垃圾回收
		*/
		__proto.GC=function(){
			var i=0,sz=this.fontPages.length;
			if(sz){
				var curCleanID=Stat.loopCount % sz;
				this.fontPages[curCleanID].removeLRU();
			}
		}

		/**
		*把所有的贴图保存成图片
		*/
		__proto.dbg_saveAllPage=function(){}
		CharBook.minTextureWidth=true;
		CharBook.textureWidth=256;
		CharBook.cacheRenderInfoInWordText=true;
		CharBook.scaleFontWithCtx=true;
		CharBook.getFontBmpWithColor=false;
		CharBook.charbookInst=null;
		CharBook._fontMem=0;
		return CharBook;
	})()


	/**
	*由于drawTextureM需要一个Texture对象，又不想真的弄一个，所以，做个假的，只封装必须成员
	*/
	//class laya.webgl.resource.CharInternalTexture
	var CharInternalTexture=(function(){
		function CharInternalTexture(par){
			this._par=null;
			this._loaded=true;
			this.bitmap={};
			this.bitmap.id=par.id;
			this._par=par;
		}

		__class(CharInternalTexture,'laya.webgl.resource.CharInternalTexture');
		var __proto=CharInternalTexture.prototype;
		__proto._getSource=function(){
			return this._par._source;
		}

		return CharInternalTexture;
	})()


	;
	/**
	*管理若干张CharPageTexture
	*里面的字体属于相同字体，相同大小
	*清理方式：
	*每隔一段时间检查一下是否能合并，一旦发现可以省出一整张贴图，就开始清理
	*/
	//class laya.webgl.resource.CharPages
	var CharPages=(function(){
		function CharPages(fontFamily,fontsize,extSize){
			this.pages=[];
			this.font=null;
			this.fontsize=0;
			this._slotW=0;
			this._gridW=0;
			this._gridNum=0;
			this._minScoreID=-1;
			this.margin_left=0;
			this.margin_top=0;
			this.margin_bottom=0;
			this.margin_right=0;
			this._textureWidth=CharBook.textureWidth;
			if (!window.Conch && !CharPages.canvas){
				CharPages.canvas=window.document.createElement('canvas');
				CharPages.canvas.width=512;
				CharPages.canvas.height=512;
				CharPages.canvas.style.left="-1000px";
				CharPages.canvas.style.position="absolute";
				document.body.appendChild(CharPages.canvas);;
				CharPages.ctx=CharPages.canvas.getContext('2d');
			}
			this.font=fontsize+'px '+fontFamily;
			this.fontsize=fontsize;
			this.margin_left=this.margin_right=this.margin_top=this.margin_bottom=Math.ceil((fontsize / 4.0));
			this._slotW=Math.ceil(extSize / CharPages.FONTHGRID)*CharPages.FONTHGRID
			this._gridW=Math.floor(this._textureWidth / this._slotW);
			this._gridNum=this._gridW *this._gridW;
			if(CharBook.minTextureWidth)
				this._textureWidth=this._slotW *this._gridW;
			console.log('gridInfo:slotW='+this._slotW+',gridw='+this._gridW+',gridNum='+this._gridNum+',textureW='+this._textureWidth);
		}

		__class(CharPages,'laya.webgl.resource.CharPages');
		var __proto=CharPages.prototype;
		/**
		*被选中了。由于大家公用一个canvas，所以需要在选中的时候做一些配置。
		*/
		__proto.onSelect=function(){
			if(CharPages.ctx._lastFont!=this.font){
				CharPages.ctx.font=this.font;
				CharPages.ctx._lastFont=this.font;
			}
		}

		__proto.getWidth=function(str){
			if (!CharPages.ctx)return 0;
			return CharPages.ctx.measureText(str).width;
		}

		/**
		*添加一个文字到texture
		*@param str
		*@param forceAdd
		*@return
		*/
		__proto.getChar=function(str,forceAdd,lineWidth,color){
			var colStr='#ffffff';
			if (!CharBook.getFontBmpWithColor){}
				else {
				color=color & 0xffffff;
				var colStr=((color&0xff00)+((color&0xff)<<16)+((color&0xff0000)>>16)).toString(16);
				colStr='#000000'.substr(0,7-colStr.length)+colStr;
			};
			var key=(lineWidth > 0?(str+'_'):str);
			if(CharBook.getFontBmpWithColor)key+=colStr;
			for (var i=0,sz=this.pages.length;i < sz;i++){
				var cp=this.pages[i];
				var cpmap=cp.charMap;
				var ret=cpmap[key];
				if (ret){
					ret.touch();
					return ret;
				}
			};
			var ret=new CharRenderInfo();
			this._getASlot(ret);
			ret.tex.charMap[key]=ret;
			ret.touch();
			var bmp=this.getCharBmp(str,this.font,lineWidth,colStr,ret);
			var cy=Math.floor(ret.pos / this._gridW);
			var cx=ret.pos % this._gridW;
			var _curX=cx *this._slotW;
			var _curY=cy *this._slotW;
			var texW=this._textureWidth;
			var minx=_curX / texW;
			var miny=_curY / texW;
			var maxx=(_curX+bmp.width)/ texW;
			var maxy=(_curY+bmp.height)/ texW;
			var uv=ret.uv;
			uv[0]=minx;uv[1]=miny;
			uv[2]=maxx;uv[3]=miny;
			uv[4]=maxx;uv[5]=maxy;
			uv[6]=minx;uv[7]=maxy;
			ret.tex.addChar(bmp,_curX,_curY);
			return ret;
		}

		__proto.getCharStroke=function(str,forceAdd,width,color){}
		/**
		*从所有的page中找一个空格子
		*如果没有地方了，就创建一个新的charpageTexture
		*/
		__proto._getASlot=function(ret){
			var sz=this.pages.length;
			for (var i=0;i < sz;i++){
				var cp=this.pages[i];
				var pos=cp.findAGrid();
				if (pos!=null){
					ret.tex=cp;
					ret.pos=pos
					return;
				}
			};
			var cp=new CharPageTexture(this);
			this.pages.push(cp);
			var pos=cp.findAGrid();
			if (pos==null)
				throw "_getASlot error!";
			ret.tex=cp;
			ret.pos=pos;
		}

		/**
		*渲染完成后再做
		*同时找到最不常用的
		*@return
		*/
		__proto.getAllPageScore=function(){
			var i=0,sz=this.pages.length;
			var curTick=Stat.loopCount;
			var score=0;
			var minScore=10000;
			for (;i < sz;i++){
				var cp=this.pages[i];
				if (cp._scoreTick==curTick){
					score+=cp._score;
					}else {
					cp._score=0;
				}
				if (cp._score < minScore){
					minScore=cp._score;
					this._minScoreID=i;
				}
			}
			return score;
		}

		__proto.removeLRU=function(){
			var freed=this._gridNum *this.pages.length-this.getAllPageScore();
			if (freed>=this._gridNum){
				if (this._minScoreID >=0){
					console.log('remove font page '+this._minScoreID);
					var cp=this.pages[this._minScoreID];
					var used=cp._score;
					cp.destroy();
					this.pages[this._minScoreID]=this.pages[this.pages.length-1];
					this.pages.pop();
					var curloop=Stat.loopCount;
					var i=0,sz=this.pages.length;
					for(;i < sz && used > 0;i++){
						var cp=this.pages[i];
						var cleaned=cp.removeOld(curloop);
						used-=cleaned;
					}
				}
			}
		}

		/**
		*TODO stroke
		*@param char
		*@param font
		*@param size 返回宽高
		*@return
		*/
		__proto.getCharBmp=function(char,font,lineWidth,colStr,size){
			if (!window.Conch){
				var w=size.width=CharPages.ctx.measureText(char).width;
				var h=size.height=this.fontsize;
				w+=(this.margin_left+this.margin_right);
				h+=(this.margin_top+this.margin_bottom);
				CharPages.ctx.clearRect(0,0,w,h);
				CharPages.ctx.textBaseline="top";
				if (lineWidth > 0){
					CharPages.ctx.strokeStyle=colStr;
					CharPages.ctx.lineWidth=lineWidth;
					CharPages.ctx.strokeText(char,this.margin_left,this.margin_top);
					}else {
					CharPages.ctx.fillStyle=colStr;
					CharPages.ctx.fillText(char,this.margin_left,this.margin_top);
				}
				if (CharPages.debug){
					CharPages.ctx.strokeStyle='#ff0000';
					CharPages.ctx.strokeRect(0,0,w,h);
					CharPages.ctx.strokeStyle='#00ff00';
					CharPages.ctx.strokeRect(this.margin_left,this.margin_top,size.width,size.height);
				}
				return CharPages.ctx.getImageData(0,0,w,h);
			}else {}
		}

		CharPages.getBmpSize=function(fonstsize){
			return fonstsize *1.5;
		}

		CharPages.canvas=null;
		CharPages.ctx=null;
		CharPages.debug=false;
		CharPages.FONTHGRID=16;
		return CharPages;
	})()


	/**
	*TODO如果占用内存较大,这个结构有很多成员可以临时计算
	*/
	//class laya.webgl.resource.CharRenderInfo
	var CharRenderInfo=(function(){
		function CharRenderInfo(){
			this.tex=null;
			this.uv=[0,0,1,1];
			this.pos=0;
			this.width=0;
			this.height=0;
			this.touchTick=0;
		}

		__class(CharRenderInfo,'laya.webgl.resource.CharRenderInfo');
		var __proto=CharRenderInfo.prototype;
		//
		__proto.touch=function(){
			var curLoop=Stat.loopCount;
			if (this.tex._scoreTick !=curLoop){
				this.tex._score=0;
				this.tex._scoreTick=curLoop;
			}
			if (this.touchTick !=curLoop){
				this.tex._score++;
			}
			this.touchTick=curLoop;
		}

		return CharRenderInfo;
	})()


	/**
	*WebGLRTMgr 管理WebGLRenderTarget的创建和回收
	*/
	//class laya.webgl.resource.WebGLRTMgr
	var WebGLRTMgr=(function(){
		function WebGLRTMgr(){};
		__class(WebGLRTMgr,'laya.webgl.resource.WebGLRTMgr');
		WebGLRTMgr.getRT=function(w,h){
			var w=w | 0;
			var h=h | 0;
			if (w >=10000){
				console.error('getRT error! w too big');
			};
			var key=h *10000+w;
			var sw=WebGLRTMgr.dict[key];
			if (sw){
				if (sw.length > 0){
					var ret=sw.pop();
					ret._mgrKey=key;
					return ret;
				}
			};
			var ret=new RenderTexture(w,h,1,-1);
			ret._mgrKey=key;
			return ret;
		}

		WebGLRTMgr.releaseRT=function(rt){
			if (rt._mgrKey <=0)
				return;
			var sw=WebGLRTMgr.dict[rt._mgrKey];
			!sw && (sw=[],WebGLRTMgr.dict[rt._mgrKey]=sw);
			rt._mgrKey=0;
			sw.push(rt);
		}

		WebGLRTMgr.dict={};
		return WebGLRTMgr;
	})()


	//class laya.webgl.shader.d2.Shader2D
	var Shader2D=(function(){
		function Shader2D(){
			this.ALPHA=1;
			//this.shader=null;
			//this.filters=null;
			this.shaderType=0;
			//this.colorAdd=null;
			this.defines=new ShaderDefines2D();
		}

		__class(Shader2D,'laya.webgl.shader.d2.Shader2D');
		var __proto=Shader2D.prototype;
		__proto.destroy=function(){
			this.defines=null;
			this.filters=null;
		}

		__proto.getRenderKey=function(){
			return [this.ALPHA,this.shader?this.shader.id:0,this.filters?this.filters.key:0].join('/');
		}

		Shader2D.__init__=function(){
			Shader.addInclude("parts/ColorFilter.glsl","#begin code ColorFilter_ps_logic\n	mat4 alphaMat =colorMat;\n\n	alphaMat[0][3] *= gl_FragColor.a;\n	alphaMat[1][3] *= gl_FragColor.a;\n	alphaMat[2][3] *= gl_FragColor.a;\n\n	gl_FragColor = gl_FragColor * alphaMat;\n	gl_FragColor += colorAlpha/255.0*gl_FragColor.a;\n#end\n\n#begin code ColorFilter_ps_uniform\n	uniform vec4 colorAlpha;\n	uniform mat4 colorMat;\n#end\n\n#begin function void test(void)\n{\n	\n}\n#end");
			Shader.addInclude("parts/GlowFilter_ps_uniform.glsl","uniform vec4 u_color;\nuniform float u_strength;\nuniform float u_blurX;\nuniform float u_blurY;\nuniform float u_offsetX;\nuniform float u_offsetY;\nuniform float u_textW;\nuniform float u_textH;");
			Shader.addInclude("parts/GlowFilter_ps_logic.glsl","const float c_IterationTime = 10.0;\nfloat floatIterationTotalTime = c_IterationTime * c_IterationTime;\nvec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\nvec2 vec2FilterDir = vec2(-(u_offsetX)/u_textW,-(u_offsetY)/u_textH);\nvec2 vec2FilterOff = vec2(u_blurX/u_textW/c_IterationTime * 2.0,u_blurY/u_textH/c_IterationTime * 2.0);\nfloat maxNum = u_blurX * u_blurY;\nvec2 vec2Off = vec2(0.0,0.0);\nfloat floatOff = c_IterationTime/2.0;\nfor(float i = 0.0;i<=c_IterationTime; ++i){\n	for(float j = 0.0;j<=c_IterationTime; ++j){\n		vec2Off = vec2(vec2FilterOff.x * (i - floatOff),vec2FilterOff.y * (j - floatOff));\n		vec4Color += texture2D(texture, v_texcoordAlpha.xy + vec2FilterDir + vec2Off)/floatIterationTotalTime;\n	}\n}\ngl_FragColor = vec4(u_color.rgb,vec4Color.a * u_strength);\ngl_FragColor.rgb *= gl_FragColor.a;");
			Shader.addInclude("parts/BlurFilter_ps_logic.glsl","gl_FragColor =   blur();\ngl_FragColor.w*=v_color.w;");
			Shader.addInclude("parts/BlurFilter_ps_uniform.glsl","uniform vec4 strength_sig2_2sig2_gauss1;\nuniform vec2 blurInfo;\n\n#define PI 3.141593\n\n//float sigma=strength/3.0;//3σ以外影响很小。即当σ=1的时候，半径为3\n//float sig2 = sigma*sigma;\n//float _2sig2 = 2.0*sig2;\n//return 1.0/(2*PI*sig2)*exp(-(x*x+y*y)/_2sig2)\n//float gauss1 = 1.0/(2.0*PI*sig2);\n\nfloat getGaussian(float x, float y){\n    return strength_sig2_2sig2_gauss1.w*exp(-(x*x+y*y)/strength_sig2_2sig2_gauss1.z);\n}\n\nvec4 blur(){\n    const float blurw = 9.0;\n    vec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\n    vec2 halfsz=vec2(blurw,blurw)/2.0/blurInfo;    \n    vec2 startpos=v_texcoordAlpha.xy-halfsz;\n    vec2 ctexcoord = startpos;\n    vec2 step = 1.0/blurInfo;  //每个像素      \n    \n    for(float y = 0.0;y<=blurw; ++y){\n        ctexcoord.x=startpos.x;\n        for(float x = 0.0;x<=blurw; ++x){\n            //TODO 纹理坐标的固定偏移应该在vs中处理\n            vec4Color += texture2D(texture, ctexcoord)*getGaussian(x-blurw/2.0,y-blurw/2.0);\n            ctexcoord.x+=step.x;\n        }\n        ctexcoord.y+=step.y;\n    }\n    return vec4Color;\n}");
			Shader.addInclude("parts/ColorAdd.glsl","#begin code ColorAdd_ps_logic\n	gl_FragColor = vec4(colorAdd.rgb,colorAdd.a*gl_FragColor.a);\n	gl_FragColor.xyz *= colorAdd.a;\n#end\n\n#begin code ColorAdd_ps_uniform\n	uniform vec4 colorAdd;\n#end\n");
			var vs,ps;
			vs="/*\n	texture��fillrectʹ�õġ�\n*/\nattribute vec4 posuv;\nattribute vec4 attribColor;\nattribute vec4 attribFlags;\n//attribute vec4 clipDir;\n//attribute vec2 clipRect;\nuniform vec4 clipDir;\nuniform vec2 clipRect;\nvarying vec2 cliped;\nuniform vec2 size;\n\n#ifdef WORLDMAT\n	uniform mat4 mmat;\n#endif\n\nvarying vec4 v_texcoordAlpha;\nvarying vec4 v_color;\nvarying float v_useTex;\n\nvoid main() {\n\n#ifdef WORLDMAT\n	vec4 pos=mmat*vec4(posuv.xy,0.,1.);\n	gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,0.,1.0);\n#else\n	gl_Position =vec4((posuv.x/size.x-0.5)*2.0,(0.5-posuv.y/size.y)*2.0,0.,1.0);\n#endif\n  \n	v_texcoordAlpha.xy = posuv.zw;\n	//v_texcoordAlpha.z = attribColor.a/255.0;\n	v_color = attribColor/255.0;\n	v_color.xyz*=v_color.w;//��������ҲҪԤ��\n	\n	v_useTex = attribFlags.r/255.0;\n	float clipw = length(clipDir.xy);\n	float cliph = length(clipDir.zw);\n	vec2 clippos = posuv.xy - clipRect.xy;	//pos�Ѿ�Ӧ�þ����ˣ�Ϊ�˼��������壬clip��λ��ҲҪ����\n	if(clipw>20000. && cliph>20000.)\n		cliped = vec2(0.5,0.5);\n	else {\n		//ת��0��1֮�䡣/clipw/clipw ��ʾclippos��normalize֮���clip������֮���ٳ���clipw\n		cliped=vec2( dot(clippos,clipDir.xy)/clipw/clipw, dot(clippos,clipDir.zw)/cliph/cliph);\n	}\n\n}";
			ps="/*\n	texture和fillrect使用的。\n*/\n\nprecision mediump float;\n//precision highp float;\nvarying vec4 v_texcoordAlpha;\nvarying vec4 v_color;\nvarying float v_useTex;\nuniform sampler2D texture;\nvarying vec2 cliped;\n\n#include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n#include?COLOR_FILTER \"parts/ColorFilter.glsl\" with ColorFilter_ps_uniform;\n#include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n\n#include?COLOR_ADD \"parts/ColorAdd.glsl\" with ColorAdd_ps_uniform;\n\nvoid main() {\n	if(cliped.x<0.) discard;\n	if(cliped.x>1.) discard;\n	if(cliped.y<0.) discard;\n	if(cliped.y>1.) discard;\n	\n   vec4 color= texture2D(texture, v_texcoordAlpha.xy);\n   if(v_useTex<=0.)color = vec4(1.,1.,1.,1.);\n   color.a*=v_color.w;\n   //color.rgb*=v_color.w;\n   color.rgb*=v_color.rgb;\n   gl_FragColor=color;\n   \n   #include?COLOR_ADD \"parts/ColorAdd.glsl\" with ColorAdd_ps_logic;\n   \n   #include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n   \n   #include?COLOR_FILTER \"parts/ColorFilter.glsl\" with ColorFilter_ps_logic;\n   \n   #include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n   \n}";
			Shader.preCompile2D(0,0x01,vs,ps,null);
			vs="attribute vec4 position;\nattribute vec4 attribColor;\n//attribute vec4 clipDir;\n//attribute vec2 clipRect;\nuniform vec4 clipDir;\nuniform vec2 clipRect;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\n//uniform vec2 u_pos;\nuniform vec2 size;\nvarying vec4 color;\n//vec4 dirxy=vec4(0.9,0.1, -0.1,0.9);\n//vec4 clip=vec4(100.,30.,300.,600.);\nvarying vec2 cliped;\nvoid main(){\n	vec4 tPos = vec4(position.x,position.y ,position.z,position.w);\n	vec4 pos=mmat*tPos;\n	gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n	float clipw = length(clipDir.xy);\n	float cliph = length(clipDir.zw);\n	vec2 clippos = tPos.xy - clipRect.xy;	//pos�Ѿ�Ӧ�þ����ˣ�Ϊ�˼��������壬clip��λ��ҲҪ����\n	if(clipw>20000. && cliph>20000.)\n		cliped = vec2(0.5,0.5);\n	else {\n		//clipdir�Ǵ����ŵķ�����������clippos�������ź�Ŀռ����ģ�������Ҫ�ѷ�����normalizeһ��\n		cliped=vec2( dot(clippos,clipDir.xy)/clipw/clipw, dot(clippos,clipDir.zw)/cliph/cliph);\n	}\n  //pos2d.x = dot(clippos,dirx);\n  color=attribColor/255.;\n}";
			ps="precision mediump float;\n//precision mediump float;\nvarying vec4 color;\n//uniform float alpha;\nvarying vec2 cliped;\nvoid main(){\n	//vec4 a=vec4(color.r, color.g, color.b, 1);\n	//a.a*=alpha;\n    gl_FragColor= color;// vec4(color.r, color.g, color.b, alpha);\n	gl_FragColor.rgb*=color.a;\n	if(cliped.x<0.) discard;\n	if(cliped.x>1.) discard;\n	if(cliped.y<0.) discard;\n	if(cliped.y>1.) discard;\n}";
			Shader.preCompile2D(0,0x04,vs,ps,null);
			vs="/*\n	texture��fillrectʹ�õġ�\n*/\nattribute vec4 posuv;\nattribute vec4 attribColor;\nattribute vec4 attribFlags;\n//attribute vec4 clipDir;\n//attribute vec2 clipRect;\nuniform vec4 clipDir;\nuniform vec2 clipRect;\nvarying vec2 cliped;\nuniform vec2 size;\n\n#ifdef WORLDMAT\n	uniform mat4 mmat;\n#endif\n\nvarying vec4 v_texcoordAlpha;\nvarying vec4 v_color;\nvarying float v_useTex;\n\nvoid main() {\n\n#ifdef WORLDMAT\n	vec4 pos=mmat*vec4(posuv.xy,0.,1.);\n	gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,0.,1.0);\n#else\n	gl_Position =vec4((posuv.x/size.x-0.5)*2.0,(0.5-posuv.y/size.y)*2.0,0.,1.0);\n#endif\n  \n	v_texcoordAlpha.xy = posuv.zw;\n	//v_texcoordAlpha.z = attribColor.a/255.0;\n	v_color = attribColor/255.0;\n	v_color.xyz*=v_color.w;//��������ҲҪԤ��\n	\n	v_useTex = attribFlags.r/255.0;\n	float clipw = length(clipDir.xy);\n	float cliph = length(clipDir.zw);\n	vec2 clippos = posuv.xy - clipRect.xy;	//pos�Ѿ�Ӧ�þ����ˣ�Ϊ�˼��������壬clip��λ��ҲҪ����\n	if(clipw>20000. && cliph>20000.)\n		cliped = vec2(0.5,0.5);\n	else {\n		//ת��0��1֮�䡣/clipw/clipw ��ʾclippos��normalize֮���clip������֮���ٳ���clipw\n		cliped=vec2( dot(clippos,clipDir.xy)/clipw/clipw, dot(clippos,clipDir.zw)/cliph/cliph);\n	}\n\n}";
			ps="#ifdef FSHIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\n//precision highp float;\nvarying vec2 v_texcoord;\nuniform sampler2D texture;\nuniform float alpha;\nuniform vec4 u_TexRange;\nuniform vec2 u_offset;\n\n#import?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n\n#import?COLOR_FILTER \"parts/ColorFilter.glsl\" with ColorFilter_ps_uniform;\n\n#import?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n\n#import?COLOR_ADD \"parts/ColorAdd.glsl\" with ColorAdd_ps_uniform;\n\nvoid main() {\n   vec2 newTexCoord;\n   newTexCoord.x = mod(u_offset.x + v_texcoord.x,u_TexRange.y) + u_TexRange.x;\n   newTexCoord.y = mod(u_offset.y + v_texcoord.y,u_TexRange.w) + u_TexRange.z;\n   vec4 color= texture2D(texture, newTexCoord);\n   color.a*=alpha;\n   gl_FragColor=color;\n   \n   #import?COLOR_ADD \"parts/ColorAdd.glsl\" with ColorAdd_ps_logic;\n   \n   #import?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n   \n   #import?COLOR_FILTER \"parts/ColorFilter.glsl\" with ColorFilter_ps_logic;\n   \n   #import?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n}";
			Shader.preCompile2D(0,0x100,vs,ps,null);
			vs="attribute vec2 position;\nattribute vec2 texcoord;\nattribute vec4 color;\nuniform vec2 size;\nuniform float offsetX;\nuniform float offsetY;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nvoid main() {\n  vec4 pos=mmat*u_mmat2*vec4(offsetX+position.x,offsetY+position.y,0,1 );\n  gl_Position = vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  v_color = color;\n  v_color.rgb *= v_color.a;\n  v_texcoord = texcoord;  \n}";
			ps="precision mediump float;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nuniform sampler2D texture;\nuniform float alpha;\nvoid main() {\n	vec4 t_color = texture2D(texture, v_texcoord);\n	gl_FragColor = t_color.rgba * v_color;\n	gl_FragColor *= alpha;\n}";
			Shader.preCompile2D(0,0x200,vs,ps,null);
		}

		return Shader2D;
	})()


	//class laya.webgl.shader.ShaderDefines
	var ShaderDefines=(function(){
		function ShaderDefines(name2int,int2name,int2nameMap){
			this._value=0;
			//this._name2int=null;
			//this._int2name=null;
			//this._int2nameMap=null;
			this._name2int=name2int;
			this._int2name=int2name;
			this._int2nameMap=int2nameMap;
		}

		__class(ShaderDefines,'laya.webgl.shader.ShaderDefines');
		var __proto=ShaderDefines.prototype;
		__proto.add=function(value){
			if ((typeof value=='string'))value=this._name2int[value];
			this._value |=value;
			return this._value;
		}

		__proto.addInt=function(value){
			this._value |=value;
			return this._value;
		}

		__proto.remove=function(value){
			if ((typeof value=='string'))value=this._name2int[value];
			this._value &=(~value);
			return this._value;
		}

		__proto.isDefine=function(def){
			return (this._value & def)===def;
		}

		__proto.getValue=function(){
			return this._value;
		}

		__proto.setValue=function(value){
			this._value=value;
		}

		__proto.toNameDic=function(){
			var r=this._int2nameMap[this._value];
			return r ? r :ShaderDefines._toText(this._value,this._int2name,this._int2nameMap);
		}

		ShaderDefines._reg=function(name,value,_name2int,_int2name){
			_name2int[name]=value;
			_int2name[value]=name;
		}

		ShaderDefines._toText=function(value,_int2name,_int2nameMap){
			var r=_int2nameMap[value];
			if (r)return r;
			var o={};
			var d=1;
			for (var i=0;i < 32;i++){
				d=1 << i;
				if (d > value)break ;
				if (value & d){
					var name=_int2name[d];
					name && (o[name]="");
				}
			}
			_int2nameMap[value]=o;
			return o;
		}

		ShaderDefines._toInt=function(names,_name2int){
			var words=names.split('.');
			var num=0;
			for (var i=0,n=words.length;i < n;i++){
				var value=_name2int[words[i]];
				if (!value)throw new Error("Defines to int err:"+names+"/"+words[i]);
				num |=value;
			}
			return num;
		}

		return ShaderDefines;
	})()


	/**
	*这里销毁的问题，后面待确认
	*/
	//class laya.webgl.shader.d2.skinAnishader.SkinMesh
	var SkinMesh=(function(){
		function SkinMesh(){
			this.mVBBuffer=null;
			this.mIBBuffer=null;
			this.mVBData=null;
			this.mIBData=null;
			this.mEleNum=0;
			this.mTexture=null;
			this.transform=null;
			this._vs=null;
			this._ps=null;
			this._indexStart=-1;
			this._verticles=null;
			this._uvs=null;
			this._tempMatrix=new Matrix();
		}

		__class(SkinMesh,'laya.webgl.shader.d2.skinAnishader.SkinMesh');
		var __proto=SkinMesh.prototype;
		__proto.init=function(texture,vs,ps){
			if (vs){
				this._vs=vs;
				}else {
				this._vs=[];
				var tWidth=texture.width;
				var tHeight=texture.height;
				var tRed=1;
				var tGreed=1;
				var tBlue=1;
				var tAlpha=1;
				this._vs.push(0,0,0,0,tRed,tGreed,tBlue,tAlpha);
				this._vs.push(tWidth,0,1,0,tRed,tGreed,tBlue,tAlpha);
				this._vs.push(tWidth,tHeight,1,1,tRed,tGreed,tBlue,tAlpha);
				this._vs.push(0,tHeight,0,1,tRed,tGreed,tBlue,tAlpha);
			}
			if (ps){
				this._ps=ps;
				}else {
				if (!SkinMesh._defaultPS){
					SkinMesh._defaultPS=[];
					SkinMesh._defaultPS.push(0,1,3,3,1,2);
				}
				this._ps=SkinMesh._defaultPS;
			}
			this.mVBData=new Float32Array(this._vs);
			this.mIBData=new Uint16Array(this._ps.length);
			this.mIBData["start"]=-1;
			this.mEleNum=this._ps.length;
			this.mTexture=texture;
		}

		__proto.init2=function(texture,vs,ps,verticles,uvs){
			if (this.transform)this.transform=null;
			if (ps){
				this._ps=ps;
				}else {
				this._ps=[];
				this._ps.push(0,1,3,3,1,2);
			}
			this._verticles=verticles;
			this._uvs=uvs;
			this.mEleNum=this._ps.length;
			this.mTexture=texture;
		}

		__proto._initMyData=function(){
			var vsI=0;
			var vI=0;
			var vLen=this._verticles.length;
			var tempVLen=vLen *4;
			this._vs=SkinMesh._tempVS;
			var insertNew=false;
			if (this._vs.length < tempVLen){
				this._vs.length=tempVLen;
				insertNew=true;
			}
			SkinMesh._tVSLen=tempVLen;
			if (insertNew){
				while (vsI < tempVLen){
					this._vs[vsI]=this._verticles[vI];
					this._vs[vsI+1]=this._verticles[vI+1];
					this._vs[vsI+2]=this._uvs[vI];
					this._vs[vsI+3]=this._uvs[vI+1];
					this._vs[vsI+4]=1;
					this._vs[vsI+5]=1;
					this._vs[vsI+6]=1;
					this._vs[vsI+7]=1;
					vsI+=8;
					vI+=2;
				}
				}else{
				while (vsI < tempVLen){
					this._vs[vsI]=this._verticles[vI];
					this._vs[vsI+1]=this._verticles[vI+1];
					this._vs[vsI+2]=this._uvs[vI];
					this._vs[vsI+3]=this._uvs[vI+1];
					vsI+=8;
					vI+=2;
				}
			}
		}

		__proto.getData2=function(vb,ib,start){
			this.mVBBuffer=vb;
			this.mIBBuffer=ib;
			this._initMyData();
			vb.appendEx2(this._vs,Float32Array,SkinMesh._tVSLen,4);
			this._indexStart=ib._byteLength;
			var tIB;
			tIB=SkinMesh._tempIB;
			if (tIB.length < this._ps.length){
				tIB.length=this._ps.length;
			}
			for (var i=0,n=this._ps.length;i < n;i++){
				tIB[i]=this._ps[i]+start;
			}
			ib.appendEx2(tIB,Uint16Array,this._ps.length,2);
		}

		__proto.getData=function(vb,ib,start){
			this.mVBBuffer=vb;
			this.mIBBuffer=ib;
			vb.append(this.mVBData);
			this._indexStart=ib._byteLength;
			if (this.mIBData["start"] !=start){
				for (var i=0,n=this._ps.length;i < n;i++){
					this.mIBData[i]=this._ps[i]+start;
				}
				this.mIBData["start"]=start;
			}
			ib.append(this.mIBData);
		}

		__proto.render=function(context,x,y){
			if (Render.isWebGL && this.mTexture){
				SkinMeshBuffer.getInstance().addSkinMesh(this);
				var tempSubmit=Submit.createShape(context,this.mIBBuffer,this.mVBBuffer,this.mEleNum,this._indexStart,Value2D.create(0x200,0));
				this.transform || (this.transform=Matrix.EMPTY);
				this.transform.translate(x,y);
				Matrix.mul(this.transform,context._curMat,this._tempMatrix);
				this.transform.translate(-x,-y);
				var tShaderValue=tempSubmit.shaderValue;
				var tArray=tShaderValue.u_mmat2;
				RenderState2D.mat2MatArray(this._tempMatrix,tArray);
				tShaderValue.textureHost=this.mTexture;
				tShaderValue.offsetX=0;
				tShaderValue.offsetY=0;
				tShaderValue.u_mmat2=tArray;
				tShaderValue.ALPHA=context._shader2D.ALPHA;
				context._submits[context._submits._length++]=tempSubmit;
			}
			else if (Render.isConchApp&&this.mTexture){
				this.transform || (this.transform=Matrix.EMPTY);
				context.setSkinMesh&&context.setSkinMesh(x,y,this._ps,this.mVBData,this.mEleNum,0,this.mTexture,this.transform);
			}
		}

		SkinMesh._tempVS=[];
		SkinMesh._tempIB=[];
		SkinMesh._defaultPS=null
		SkinMesh._tVSLen=0;
		return SkinMesh;
	})()


	//class laya.webgl.shader.d2.skinAnishader.SkinMeshBuffer
	var SkinMeshBuffer=(function(){
		function SkinMeshBuffer(){
			this.ib=null;
			this.vb=null;
			var gl=WebGL.mainContext;
			this.ib=IndexBuffer2D.create(0x88E8);
			this.vb=VertexBuffer2D.create(8);
		}

		__class(SkinMeshBuffer,'laya.webgl.shader.d2.skinAnishader.SkinMeshBuffer');
		var __proto=SkinMeshBuffer.prototype;
		__proto.addSkinMesh=function(skinMesh){
			skinMesh.getData2(this.vb,this.ib,this.vb._byteLength / 32);
		}

		__proto.reset=function(){
			this.vb.clear();
			this.ib.clear();
		}

		SkinMeshBuffer.getInstance=function(){
			return SkinMeshBuffer.instance=SkinMeshBuffer.instance|| new SkinMeshBuffer();
		}

		SkinMeshBuffer.instance=null
		return SkinMeshBuffer;
	})()


	//class laya.webgl.shader.d2.value.Value2D
	var Value2D=(function(){
		function Value2D(mainID,subID){
			this.size=[0,0];
			this.alpha=1.0;
			//this.mmat=null;
			//this.texture=null;
			this.ALPHA=1.0;
			//this.shader=null;
			//this.mainID=0;
			this.subID=0;
			//this.filters=null;
			//this.textureHost=null;
			//this.color=null;
			//this.colorAdd=null;
			//this.u_mmat2=null;
			this.ref=1;
			//this._attribLocation=null;
			//this._inClassCache=null;
			this._cacheID=0;
			this.clipDir=[99999999,0,0,99999999];
			this.clipRect=[0,0];
			this.defines=new ShaderDefines2D();
			this.mainID=mainID;
			this.subID=subID;
			this.textureHost=null;
			this.texture=null;
			this.fillStyle=null;
			this.color=null;
			this.strokeStyle=null;
			this.colorAdd=null;
			this.u_mmat2=null;
			this._cacheID=mainID|subID;
			this._inClassCache=Value2D._cache[this._cacheID];
			if (mainID>0 && !this._inClassCache){
				this._inClassCache=Value2D._cache[this._cacheID]=[];
				this._inClassCache._length=0;
			}
			this.clear();
		}

		__class(Value2D,'laya.webgl.shader.d2.value.Value2D');
		var __proto=Value2D.prototype;
		__proto.setValue=function(value){}
		//public function refresh():ShaderValue
		__proto._ShaderWithCompile=function(){
			var ret=Shader.withCompile2D(0,this.mainID,this.defines.toNameDic(),this.mainID | this.defines._value,Shader2X.create);
			ret.setAttributesLocation(this._attribLocation);
			return ret;
		}

		__proto.upload=function(){
			var renderstate2d=RenderState2D;
			RenderState2D.worldMatrix4===RenderState2D.TEMPMAT4_ARRAY || this.defines.addInt(0x80);
			this.mmat=renderstate2d.worldMatrix4;
			var sd=Shader.sharders[this.mainID | this.defines._value] || this._ShaderWithCompile();
			if (sd._shaderValueWidth!==renderstate2d.width || sd._shaderValueHeight!==renderstate2d.height){
				this.size[0]=renderstate2d.width;
				this.size[1]=renderstate2d.height;
				sd._shaderValueWidth=renderstate2d.width;
				sd._shaderValueHeight=renderstate2d.height;
				sd.upload(this,null);
			}
			else{
				sd.upload(this,sd._params2dQuick2 || sd._make2dQuick2());
			}
		}

		__proto.getRenderKey=function(){
			return [this.ALPHA,this.shader?this.shader.id:0,this.filters?this.filters.key:0].join('/');
		}

		__proto.setFilters=function(value){
			this.filters=value;
			if (!value)
				return;
			var n=value.length,f;
			for (var i=0;i < n;i++){
				f=value[i];
				if (f){
					this.defines.add(f.type);
					f.action.setValue(this);
				}
			}
		}

		__proto.clear=function(){
			this.defines._value=this.subID+(WebGL.shaderHighPrecision?0x400:0);
		}

		__proto.release=function(){
			if ((--this.ref)< 1){
				this._inClassCache && (this._inClassCache[this._inClassCache._length++]=this);
				this.fillStyle=null;
				this.strokeStyle=null;
				this.clear();
				this.filters=null;
				this.ref=1;
			}
		}

		Value2D._initone=function(type,classT){
			Value2D._typeClass[type]=classT;
			Value2D._cache[type]=[];
			Value2D._cache[type]._length=0;
		}

		Value2D.__init__=function(){
			Value2D._initone(0x04,PrimitiveSV);
			Value2D._initone(0x100,FillTextureSV);
			Value2D._initone(0x200,SkinSV);
			Value2D._initone(0x01,TextureSV);
			Value2D._initone(0x01 | 0x40,TextSV);
			Value2D._initone(0x01 | 0x08,TextureSV);
		}

		Value2D.create=function(mainType,subType){
			var types=Value2D._cache[mainType|subType];
			if (types._length)
				return types[--types._length];
			else
			return new Value2D._typeClass[mainType|subType](subType);
		}

		Value2D._cache=[];
		Value2D._typeClass=[];
		Value2D.TEMPMAT4_ARRAY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
		return Value2D;
	})()


	//class laya.webgl.shader.ShaderValue
	var ShaderValue=(function(){
		function ShaderValue(){}
		__class(ShaderValue,'laya.webgl.shader.ShaderValue');
		return ShaderValue;
	})()


	//此类可以减少代码
	//class laya.webgl.shapes.BasePoly
	var BasePoly=(function(){
		function BasePoly(x,y,width,height,edges,color,borderWidth,borderColor,round){
			//this.x=NaN;
			//this.y=NaN;
			//this.r=NaN;
			//this.width=NaN;
			//this.height=NaN;
			//this.edges=NaN;
			this.r0=0
			//this.color=0;
			//this.borderColor=NaN;
			//this.borderWidth=NaN;
			//this.round=0;
			this.fill=true;
			//this.mUint16Array=null;
			//this.mFloat32Array=null;
			this.r1=Math.PI / 2;
			(round===void 0)&& (round=0);
			this.x=x;
			this.y=y;
			this.width=width;
			this.height=height;
			this.edges=edges;
			this.color=color;
			this.borderWidth=borderWidth;
			this.borderColor=borderColor;
		}

		__class(BasePoly,'laya.webgl.shapes.BasePoly');
		var __proto=BasePoly.prototype;
		Laya.imps(__proto,{"laya.webgl.shapes.IShape":true})
		__proto.getData=function(ib,vb,start){}
		__proto.rebuild=function(points){}
		__proto.setMatrix=function(mat){}
		__proto.needUpdate=function(mat){
			return true;
		}

		__proto.sector=function(outVert,outIndex,start){
			var x=this.x,y=this.y,edges=this.edges,seg=(this.r1-this.r0)/ edges;
			var w=this.width,h=this.height,color=this.color;
			var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
			outVert.push(x,y,r,g,b);
			for (var i=0;i < edges+1;i++){
				outVert.push(x+Math.sin(seg *i+this.r0)*w,y+Math.cos(seg *i+this.r0)*h);
				outVert.push(r,g,b);
			}
			for (i=0;i < edges;i++){
				outIndex.push(start,start+i+1,start+i+2);
			}
		}

		//闭合路径
		__proto.createLoopLine=function(p,indices,lineWidth,len,outVertex,outIndex){
			var points=p.concat();
			var result=outVertex ? outVertex :p;
			var color=this.borderColor;
			var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
			points.splice(0,5);
			var firstPoint=[points[0],points[1]];
			var lastPoint=[points[points.length-5],points[points.length-4]];
			var midPointX=lastPoint[0]+(firstPoint[0]-lastPoint[0])*0.5;
			var midPointY=lastPoint[1]+(firstPoint[1]-lastPoint[1])*0.5;
			points.unshift(midPointX,midPointY,0,0,0);
			points.push(midPointX,midPointY,0,0,0);
			var length=points.length / 5;
			var iStart=len,w=lineWidth / 2;
			var px,py,p1x,p1y,p2x,p2y,p3x,p3y;
			var perpx,perpy,perp2x,perp2y,perp3x,perp3y;
			var a1,b1,c1,a2,b2,c2;
			var denom,pdist,dist;
			p1x=points[0];
			p1y=points[1];
			p2x=points[5];
			p2y=points[6];
			perpx=-(p1y-p2y);
			perpy=p1x-p2x;
			dist=Math.sqrt(perpx *perpx+perpy *perpy);
			perpx=perpx / dist *w;
			perpy=perpy / dist *w;
			result.push(p1x-perpx,p1y-perpy,r,g,b,p1x+perpx,p1y+perpy,r,g,b);
			for (var i=1;i < length-1;i++){
				p1x=points[(i-1)*5];
				p1y=points[(i-1)*5+1];
				p2x=points[(i)*5];
				p2y=points[(i)*5+1];
				p3x=points[(i+1)*5];
				p3y=points[(i+1)*5+1];
				perpx=-(p1y-p2y);
				perpy=p1x-p2x;
				dist=Math.sqrt(perpx *perpx+perpy *perpy);
				perpx=perpx / dist *w;
				perpy=perpy / dist *w;
				perp2x=-(p2y-p3y);
				perp2y=p2x-p3x;
				dist=Math.sqrt(perp2x *perp2x+perp2y *perp2y);
				perp2x=perp2x / dist *w;
				perp2y=perp2y / dist *w;
				a1=(-perpy+p1y)-(-perpy+p2y);
				b1=(-perpx+p2x)-(-perpx+p1x);
				c1=(-perpx+p1x)*(-perpy+p2y)-(-perpx+p2x)*(-perpy+p1y);
				a2=(-perp2y+p3y)-(-perp2y+p2y);
				b2=(-perp2x+p2x)-(-perp2x+p3x);
				c2=(-perp2x+p3x)*(-perp2y+p2y)-(-perp2x+p2x)*(-perp2y+p3y);
				denom=a1 *b2-a2 *b1;
				if (Math.abs(denom)< 0.1){
					denom+=10.1;
					result.push(p2x-perpx,p2y-perpy,r,g,b,p2x+perpx,p2y+perpy,r,g,b);
					continue ;
				}
				px=(b1 *c2-b2 *c1)/ denom;
				py=(a2 *c1-a1 *c2)/ denom;
				pdist=(px-p2x)*(px-p2x)+(py-p2y)+(py-p2y);
				result.push(px,py,r,g,b,p2x-(px-p2x),p2y-(py-p2y),r,g,b);
			}
			if (outIndex){
				indices=outIndex;
			};
			var groupLen=this.edges+1;
			for (i=1;i < groupLen;i++){
				indices.push(iStart+(i-1)*2,iStart+(i-1)*2+1,iStart+i *2+1,iStart+i *2+1,iStart+i *2,iStart+(i-1)*2);
			}
			indices.push(iStart+(i-1)*2,iStart+(i-1)*2+1,iStart+1,iStart+1,iStart,iStart+(i-1)*2);
			return result;
		}

		BasePoly.createLine2=function(p,indices,lineWidth,len,outVertex,indexCount){
			var points=p.concat();
			var result=outVertex;
			var color=this.borderColor;
			var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
			var length=points.length / 2;
			var iStart=len,w=lineWidth / 2;
			var px,py,p1x,p1y,p2x,p2y,p3x,p3y;
			var perpx,perpy,perp2x,perp2y,perp3x,perp3y;
			var a1,b1,c1,a2,b2,c2;
			var denom,pdist,dist;
			p1x=points[0];
			p1y=points[1];
			p2x=points[2];
			p2y=points[3];
			perpx=-(p1y-p2y);
			perpy=p1x-p2x;
			dist=Math.sqrt(perpx *perpx+perpy *perpy);
			perpx=perpx / dist *w;
			perpy=perpy / dist *w;
			result.push(p1x-perpx ,p1y-perpy ,p1x+perpx ,p1y+perpy);
			for (var i=1;i < length-1;i++){
				p1x=points[(i-1)*2];
				p1y=points[(i-1)*2+1];
				p2x=points[(i)*2];
				p2y=points[(i)*2+1];
				p3x=points[(i+1)*2];
				p3y=points[(i+1)*2+1];
				perpx=-(p1y-p2y);
				perpy=p1x-p2x;
				dist=Math.sqrt(perpx *perpx+perpy *perpy);
				perpx=perpx / dist *w;
				perpy=perpy / dist *w;
				perp2x=-(p2y-p3y);
				perp2y=p2x-p3x;
				dist=Math.sqrt(perp2x *perp2x+perp2y *perp2y);
				perp2x=perp2x / dist *w;
				perp2y=perp2y / dist *w;
				a1=(-perpy+p1y)-(-perpy+p2y);
				b1=(-perpx+p2x)-(-perpx+p1x);
				c1=(-perpx+p1x)*(-perpy+p2y)-(-perpx+p2x)*(-perpy+p1y);
				a2=(-perp2y+p3y)-(-perp2y+p2y);
				b2=(-perp2x+p2x)-(-perp2x+p3x);
				c2=(-perp2x+p3x)*(-perp2y+p2y)-(-perp2x+p2x)*(-perp2y+p3y);
				denom=a1 *b2-a2 *b1;
				if (Math.abs(denom)< 0.1){
					denom+=10.1;
					result.push(p2x-perpx ,p2y-perpy ,p2x+perpx ,p2y+perpy);
					continue ;
				}
				px=(b1 *c2-b2 *c1)/ denom;
				py=(a2 *c1-a1 *c2)/ denom;
				pdist=(px-p2x)*(px-p2x)+(py-p2y)+(py-p2y);
				result.push(px,py ,p2x-(px-p2x),p2y-(py-p2y));
			}
			p1x=points[points.length-4];
			p1y=points[points.length-3];
			p2x=points[points.length-2];
			p2y=points[points.length-1];
			perpx=-(p1y-p2y);
			perpy=p1x-p2x;
			dist=Math.sqrt(perpx *perpx+perpy *perpy);
			perpx=perpx / dist *w;
			perpy=perpy / dist *w;
			result.push(p2x-perpx ,p2y-perpy ,p2x+perpx ,p2y+perpy);
			var groupLen=indexCount;
			for (i=1;i < groupLen;i++){
				indices.push(iStart+(i-1)*2,iStart+(i-1)*2+1,iStart+i *2+1,iStart+i *2+1,iStart+i *2,iStart+(i-1)*2);
			}
			return result;
		}

		BasePoly.createLineTriangle=function(path,color,width,loop,outvb,vbstride,outib){
			var points=path.slice();
			var ptlen=points.length;
			var p1x=points[0],p1y=points[1];
			var p2x=points[2],p2y=points[2];
			var pointnum=ptlen / 2;
			if (pointnum <=1)return;
			if (pointnum==2){
				return;
			};
			var tmpData=new Array(pointnum *4);
			var realPtNum=0;
			var ci=0;
			for (var i=0;i < pointnum-1;i++){
				var p1x=points[ci++],p1y=points[ci++];
				var p2x=points[ci++],p2y=points[ci++];
				var dx=p2x-p1x,dy=p2y-p1y;
				if(dx!=0 && dy!=0){
					var len=Math.sqrt(dx *dx+dy *dy);
					if (len > 1e-3){
						var rp=realPtNum *4;
						tmpData[rp]=p1x;
						tmpData[rp+1]=p1y;
						tmpData[rp+2]=dx / len;
						tmpData[rp+3]=dy / len;
						realPtNum++;
					}
				}
			}
			if (loop){
				var p1x=points[ptlen-2],p1y=points[ptlen-1];
				var p2x=points[0],p2y=points[1];
				var dx=p2x-p1x,dy=p2y-p1y;
				if(dx!=0 && dy!=0){
					var len=Math.sqrt(dx *dx+dy *dy);
					if (len > 1e-3){
						var rp=realPtNum *4;
						tmpData[rp]=p1x;
						tmpData[rp+1]=p1y;
						tmpData[rp+2]=dx / len;
						tmpData[rp+3]=dy / len;
						realPtNum++;
					}
				}
				}else {
				var rp=realPtNum *4;
				tmpData[rp]=p1x;
				tmpData[rp+1]=p1y;
				tmpData[rp+2]=dx / len;
				tmpData[rp+3]=dy / len;
				realPtNum++;
			}
			ci=0;
			for (var i=0;i < pointnum;i++){
				var p1x=points[ci],p1y=points[ci+1];
				var p2x=points[ci+2],p2y=points[ci+3];
				var p3x=points[ci+4],p3y=points[ci+5];
			}
			if (loop){}
				}
		return BasePoly;
	})()


	//class laya.webgl.shapes.Earcut
	var Earcut=(function(){
		function Earcut(){};
		__class(Earcut,'laya.webgl.shapes.Earcut');
		Earcut.earcut=function(data,holeIndices,dim){
			dim=dim || 2;
			var hasHoles=holeIndices && holeIndices.length,
			outerLen=hasHoles ? holeIndices[0] *dim :data.length,
			outerNode=Earcut.linkedList(data,0,outerLen,dim,true),
			triangles=[];
			if (!outerNode)return triangles;
			var minX,minY,maxX,maxY,x,y,invSize;
			if (hasHoles)outerNode=Earcut.eliminateHoles(data,holeIndices,outerNode,dim);
			if (data.length > 80 *dim){
				minX=maxX=data[0];
				minY=maxY=data[1];
				for (var i=dim;i < outerLen;i+=dim){
					x=data[i];
					y=data[i+1];
					if (x < minX)minX=x;
					if (y < minY)minY=y;
					if (x > maxX)maxX=x;
					if (y > maxY)maxY=y;
				}
				invSize=Math.max(maxX-minX,maxY-minY);
				invSize=invSize!==0 ? 1 / invSize :0;
			}
			Earcut.earcutLinked(outerNode,triangles,dim,minX,minY,invSize);
			return triangles;
		}

		Earcut.linkedList=function(data,start,end,dim,clockwise){
			var i,last;
			if (clockwise===(Earcut.signedArea(data,start,end,dim)> 0)){
				for (i=start;i < end;i+=dim)last=Earcut.insertNode(i,data[i],data[i+1],last);
				}else {
				for (i=end-dim;i >=start;i-=dim)last=Earcut.insertNode(i,data[i],data[i+1],last);
			}
			if (last && Earcut.equals(last,last.next)){
				Earcut.removeNode(last);
				last=last.next;
			}
			return last;
		}

		Earcut.filterPoints=function(start,end){
			if (!start)return start;
			if (!end)end=start;
			var p=start,
			again;
			do {
				again=false;
				if (!p.steiner && (Earcut.equals(p,p.next)|| Earcut.area(p.prev,p,p.next)===0)){
					Earcut.removeNode(p);
					p=end=p.prev;
					if (p===p.next)break ;
					again=true;
					}else {
					p=p.next;
				}
			}while (again || p!==end);
			return end;
		}

		Earcut.earcutLinked=function(ear,triangles,dim,minX,minY,invSize,pass){
			if (!ear)return;
			if (!pass && invSize)Earcut.indexCurve(ear,minX,minY,invSize);
			var stop=ear,
			prev,next;
			while (ear.prev!==ear.next){
				prev=ear.prev;
				next=ear.next;
				if (invSize ? Earcut.isEarHashed(ear,minX,minY,invSize):Earcut.isEar(ear)){
					triangles.push(prev.i / dim,ear.i / dim,next.i / dim);
					Earcut.removeNode(ear);
					ear=next.next;
					stop=next.next;
					continue ;
				}
				ear=next;
				if (ear===stop){
					if (!pass){
						Earcut.earcutLinked(Earcut.filterPoints(ear),triangles,dim,minX,minY,invSize,1);
						}else if (pass===1){
						ear=Earcut.cureLocalIntersections(ear,triangles,dim);
						Earcut.earcutLinked(ear,triangles,dim,minX,minY,invSize,2);
						}else if (pass===2){
						Earcut.splitEarcut(ear,triangles,dim,minX,minY,invSize);
					}
					break ;
				}
			}
		}

		Earcut.isEar=function(ear){
			var a=ear.prev,
			b=ear,
			c=ear.next;
			if (Earcut.area(a,b,c)>=0)return false;
			var p=ear.next.next;
			while (p!==ear.prev){
				if (Earcut.pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&
					Earcut.area(p.prev,p,p.next)>=0)return false;
				p=p.next;
			}
			return true;
		}

		Earcut.isEarHashed=function(ear,minX,minY,invSize){
			var a=ear.prev,
			b=ear,
			c=ear.next;
			if (Earcut.area(a,b,c)>=0)return false;
			var minTX=a.x < b.x ? (a.x < c.x ? a.x :c.x):(b.x < c.x ? b.x :c.x),
			minTY=a.y < b.y ? (a.y < c.y ? a.y :c.y):(b.y < c.y ? b.y :c.y),
			maxTX=a.x > b.x ? (a.x > c.x ? a.x :c.x):(b.x > c.x ? b.x :c.x),
			maxTY=a.y > b.y ? (a.y > c.y ? a.y :c.y):(b.y > c.y ? b.y :c.y);
			var minZ=Earcut.zOrder(minTX,minTY,minX,minY,invSize),
			maxZ=Earcut.zOrder(maxTX,maxTY,minX,minY,invSize);
			var p=ear.nextZ;
			while (p && p.z <=maxZ){
				if (p!==ear.prev && p!==ear.next &&
					Earcut.pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&
				Earcut.area(p.prev,p,p.next)>=0)return false;
				p=p.nextZ;
			}
			p=ear.prevZ;
			while (p && p.z >=minZ){
				if (p!==ear.prev && p!==ear.next &&
					Earcut.pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&
				Earcut.area(p.prev,p,p.next)>=0)return false;
				p=p.prevZ;
			}
			return true;
		}

		Earcut.cureLocalIntersections=function(start,triangles,dim){
			var p=start;
			do {
				var a=p.prev,
				b=p.next.next;
				if (!Earcut.equals(a,b)&& Earcut.intersects(a,p,p.next,b)&& Earcut.locallyInside(a,b)&& Earcut.locallyInside(b,a)){
					triangles.push(a.i / dim);
					triangles.push(p.i / dim);
					triangles.push(b.i / dim);
					Earcut.removeNode(p);
					Earcut.removeNode(p.next);
					p=start=b;
				}
				p=p.next;
			}while (p!==start);
			return p;
		}

		Earcut.splitEarcut=function(start,triangles,dim,minX,minY,invSize){
			var a=start;
			do {
				var b=a.next.next;
				while (b!==a.prev){
					if (a.i!==b.i && Earcut.isValidDiagonal(a,b)){
						var c=Earcut.splitPolygon(a,b);
						a=Earcut.filterPoints(a,a.next);
						c=Earcut.filterPoints(c,c.next);
						Earcut.earcutLinked(a,triangles,dim,minX,minY,invSize);
						Earcut.earcutLinked(c,triangles,dim,minX,minY,invSize);
						return;
					}
					b=b.next;
				}
				a=a.next;
			}while (a!==start);
		}

		Earcut.eliminateHoles=function(data,holeIndices,outerNode,dim){
			var queue=[],
			i,len,start,end,list;
			for (i=0,len=holeIndices.length;i < len;i++){
				start=holeIndices[i] *dim;
				end=i < len-1 ? holeIndices[i+1] *dim :data.length;
				list=Earcut.linkedList(data,start,end,dim,false);
				if (list===list.next)list.steiner=true;
				queue.push(Earcut.getLeftmost(list));
			}
			queue.sort(Earcut.compareX);
			for (i=0;i < queue.length;i++){
				Earcut.eliminateHole(queue[i],outerNode);
				outerNode=Earcut.filterPoints(outerNode,outerNode.next);
			}
			return outerNode;
		}

		Earcut.compareX=function(a,b){
			return a.x-b.x;
		}

		Earcut.eliminateHole=function(hole,outerNode){
			outerNode=Earcut.findHoleBridge(hole,outerNode);
			if (outerNode){
				var b=Earcut.splitPolygon(outerNode,hole);
				Earcut.filterPoints(b,b.next);
			}
		}

		Earcut.findHoleBridge=function(hole,outerNode){
			var p=outerNode,
			hx=hole.x,
			hy=hole.y,
			qx=-Infinity,
			m;
			do {
				if (hy <=p.y && hy >=p.next.y && p.next.y!==p.y){
					var x=p.x+(hy-p.y)*(p.next.x-p.x)/ (p.next.y-p.y);
					if (x <=hx && x > qx){
						qx=x;
						if (x===hx){
							if (hy===p.y)return p;
							if (hy===p.next.y)return p.next;
						}
						m=p.x < p.next.x ? p :p.next;
					}
				}
				p=p.next;
			}while (p!==outerNode);
			if (!m)return null;
			if (hx===qx)return m.prev;
			var stop=m,
			mx=m.x,
			my=m.y,
			tanMin=Infinity,
			tan;
			p=m.next;
			while (p!==stop){
				if (hx >=p.x && p.x >=mx && hx!==p.x &&
					Earcut.pointInTriangle(hy < my ? hx :qx,hy,mx,my,hy < my ? qx :hx,hy,p.x,p.y)){
					tan=Math.abs(hy-p.y)/ (hx-p.x);
					if ((tan < tanMin || (tan===tanMin && p.x > m.x))&& Earcut.locallyInside(p,hole)){
						m=p;
						tanMin=tan;
					}
				}
				p=p.next;
			}
			return m;
		}

		Earcut.indexCurve=function(start,minX,minY,invSize){
			var p=start;
			do {
				if (p.z===null)p.z=Earcut.zOrder(p.x,p.y,minX,minY,invSize);
				p.prevZ=p.prev;
				p.nextZ=p.next;
				p=p.next;
			}while (p!==start);
			p.prevZ.nextZ=null;
			p.prevZ=null;
			Earcut.sortLinked(p);
		}

		Earcut.sortLinked=function(list){
			var i,p,q,e,tail,numMerges,pSize,qSize,
			inSize=1;
			do {
				p=list;
				list=null;
				tail=null;
				numMerges=0;
				while (p){
					numMerges++;
					q=p;
					pSize=0;
					for (i=0;i < inSize;i++){
						pSize++;
						q=q.nextZ;
						if (!q)break ;
					}
					qSize=inSize;
					while (pSize > 0 || (qSize > 0 && q)){
						if (pSize!==0 && (qSize===0 || !q || p.z <=q.z)){
							e=p;
							p=p.nextZ;
							pSize--;
							}else {
							e=q;
							q=q.nextZ;
							qSize--;
						}
						if (tail)tail.nextZ=e;
						else list=e;
						e.prevZ=tail;
						tail=e;
					}
					p=q;
				}
				tail.nextZ=null;
				inSize *=2;
			}while (numMerges > 1);
			return list;
		}

		Earcut.zOrder=function(x,y,minX,minY,invSize){
			x=32767 *(x-minX)*invSize;
			y=32767 *(y-minY)*invSize;
			x=(x | (x << 8))& 0x00FF00FF;
			x=(x | (x << 4))& 0x0F0F0F0F;
			x=(x | (x << 2))& 0x33333333;
			x=(x | (x << 1))& 0x55555555;
			y=(y | (y << 8))& 0x00FF00FF;
			y=(y | (y << 4))& 0x0F0F0F0F;
			y=(y | (y << 2))& 0x33333333;
			y=(y | (y << 1))& 0x55555555;
			return x | (y << 1);
		}

		Earcut.getLeftmost=function(start){
			var p=start,
			leftmost=start;
			do {
				if (p.x < leftmost.x)leftmost=p;
				p=p.next;
			}while (p!==start);
			return leftmost;
		}

		Earcut.pointInTriangle=function(ax,ay,bx,by,cx,cy,px,py){
			return (cx-px)*(ay-py)-(ax-px)*(cy-py)>=0 &&
			(ax-px)*(by-py)-(bx-px)*(ay-py)>=0 &&
			(bx-px)*(cy-py)-(cx-px)*(by-py)>=0;
		}

		Earcut.isValidDiagonal=function(a,b){
			return a.next.i!==b.i && a.prev.i!==b.i && !Earcut.intersectsPolygon(a,b)&&
			Earcut.locallyInside(a,b)&& Earcut.locallyInside(b,a)&& Earcut.middleInside(a,b);
		}

		Earcut.area=function(p,q,r){
			return (q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);
		}

		Earcut.equals=function(p1,p2){
			return p1.x===p2.x && p1.y===p2.y;
		}

		Earcut.intersects=function(p1,q1,p2,q2){
			if ((Earcut.equals(p1,q1)&& Earcut.equals(p2,q2))||
				(Earcut.equals(p1,q2)&& Earcut.equals(p2,q1)))return true;
			return Earcut.area(p1,q1,p2)> 0!==Earcut.area(p1,q1,q2)> 0 &&
			Earcut.area(p2,q2,p1)> 0!==Earcut.area(p2,q2,q1)> 0;
		}

		Earcut.intersectsPolygon=function(a,b){
			var p=a;
			do {
				if (p.i!==a.i && p.next.i!==a.i && p.i!==b.i && p.next.i!==b.i &&
					Earcut.intersects(p,p.next,a,b))return true;
				p=p.next;
			}while (p!==a);
			return false;
		}

		Earcut.locallyInside=function(a,b){
			return Earcut.area(a.prev,a,a.next)< 0 ?
			Earcut.area(a,b,a.next)>=0 && Earcut.area(a,a.prev,b)>=0 :
			Earcut.area(a,b,a.prev)< 0 || Earcut.area(a,a.next,b)< 0;
		}

		Earcut.middleInside=function(a,b){
			var p=a,
			inside=false,
			px=(a.x+b.x)/ 2,
			py=(a.y+b.y)/ 2;
			do {
				if (((p.y > py)!==(p.next.y > py))&& p.next.y!==p.y &&
					(px < (p.next.x-p.x)*(py-p.y)/ (p.next.y-p.y)+p.x))
				inside=!inside;
				p=p.next;
			}while (p!==a);
			return inside;
		}

		Earcut.splitPolygon=function(a,b){
			var a2=new Earcut.Node(a.i,a.x,a.y),
			b2=new Earcut.Node(b.i,b.x,b.y),
			an=a.next,
			bp=b.prev;
			a.next=b;
			b.prev=a;
			a2.next=an;
			an.prev=a2;
			b2.next=a2;
			a2.prev=b2;
			bp.next=b2;
			b2.prev=bp;
			return b2;
		}

		Earcut.insertNode=function(i,x,y,last){
			var p=new Earcut.Node(i,x,y);
			if (!last){
				p.prev=p;
				p.next=p;
				}else {
				p.next=last.next;
				p.prev=last;
				last.next.prev=p;
				last.next=p;
			}
			return p;
		}

		Earcut.removeNode=function(p){
			p.next.prev=p.prev;
			p.prev.next=p.next;
			if (p.prevZ)p.prevZ.nextZ=p.nextZ;
			if (p.nextZ)p.nextZ.prevZ=p.prevZ;
		}

		Earcut.Node=function(i,x,y){
			this.i=i;
			this.x=x;
			this.y=y;
			this.prev=null;
			this.next=null;
			this.z=null;
			this.prevZ=null;
			this.nextZ=null;
			this.steiner=false;
		}

		Earcut.signedArea=function(data,start,end,dim){
			var sum=0;
			for (var i=start,j=end-dim;i < end;i+=dim){
				sum+=(data[j]-data[i])*(data[i+1]+data[j+1]);
				j=i;
			}
			return sum;
		}

		return Earcut;
	})()


	//class laya.webgl.submit.Submit
	var Submit=(function(){
		function Submit(renderType){
			this.clipInfoID=-1;
			//this._mesh=null;
			//this._blendFn=null;
			//this._id=0;
			//this._renderType=0;
			//this._parent=null;
			//this._startIdx=0;
			this._numEle=0;
			this._ref=1;
			//this.shaderValue=null;
			this._key=new SubmitKey();
			(renderType===void 0)&& (renderType=10000);
			this._renderType=renderType;
			this._id=++Submit.ID;
		}

		__class(Submit,'laya.webgl.submit.Submit');
		var __proto=Submit.prototype;
		Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
		__proto.getID=function(){
			return this._id;
		}

		__proto.releaseRender=function(){
			if (Submit.RENDERBASE==this)
				return;
			if((--this._ref)<1){
				Submit.POOL[Submit._poolSize++]=this;
				this.shaderValue.release();
				this.shaderValue=null;
				this._mesh=null;
				this._parent && (this._parent.releaseRender(),this._parent=null);
			}
		}

		__proto.getRenderType=function(){
			return this._renderType;
		}

		__proto.renderSubmit=function(){
			if (this._numEle===0 || !this._mesh || this._numEle==0)return 1;
			var _tex=this.shaderValue.textureHost;
			if (_tex){
				var source=_tex._getSource();
				if (!source)
					return 1;
				this.shaderValue.texture=source;
			};
			var gl=WebGL.mainContext;
			this._mesh.useMesh(gl);
			this.shaderValue.upload();
			if (BlendMode.activeBlendFunction!==this._blendFn){
				WebGLContext.setBlend(gl,true);
				this._blendFn(gl);
				BlendMode.activeBlendFunction=this._blendFn;
			}
			gl.drawElements(0x0004,this._numEle,0x1403,this._startIdx);
			Stat.drawCall++;
			Stat.trianglesFaces+=this._numEle / 3;
			return 1;
		}

		/**
		*基于o和传入的其他参数来初始化submit对象
		*@param o
		*@param context
		*@param mesh
		*@param pos
		*/
		__proto._cloneInit=function(o,context,mesh,pos){
			debugger;
			o._ref=1;
			o._mesh=mesh;
			o._id=this._id;
			o._key.copyFrom(this._key);
			o._parent=this;
			o._blendFn=this._blendFn;
			o._renderType=this._renderType;
			o._startIdx=pos *CONST3D2D.BYTES_PIDX;
			o._numEle=this._numEle;
			o.shaderValue=this.shaderValue;
			this.shaderValue.ref++;
			this._ref++;
		}

		__proto.clone=function(context,ib,vb,pos){
			debugger;
		}

		/*
		if (_key.submitType===-1 || _isSelfVb)return null;
		var o:Submit=_poolSize ? POOL[--_poolSize] :new Submit();
		_cloneInit(o,context,ib,vb,pos);
		return o;
		*/
		__proto.reUse=function(context,pos){
			debugger;
		}

		/*
		_ref++;
		if (_isSelfVb){
			return pos;
		}

		_ib=context._ib;
		_vb=context._vb;
		_startIdx=pos / 8 *6;
		return pos+_numEle / 6 *16;
		*/
		__proto.toString=function(){
			return "ibindex:"+this._startIdx+" num:"+this._numEle+" key="+this._key;
		}

		Submit.__init__=function(){
			var s=Submit.RENDERBASE=new Submit(-1);
			s.shaderValue=new Value2D(0,0);
			s.shaderValue.ALPHA=1;
			s._ref=0xFFFFFFFF;
		}

		Submit.create=function(context,mesh,sv){
			debugger;
			var o=Submit._poolSize ? Submit.POOL[--Submit._poolSize] :new Submit();
			o._ref=1;
			o._mesh=mesh;
			o._key.clear();
			o._startIdx=mesh.indexNum *CONST3D2D.BYTES_PIDX;
			o._numEle=0;
			var blendType=context._nBlendType;
			o._blendFn=context._targets ? BlendMode.targetFns[blendType] :BlendMode.fns[blendType];
			o.shaderValue=sv;
			o.shaderValue.setValue(context._shader2D);
			var filters=context._shader2D.filters;
			filters && o.shaderValue.setFilters(filters);
			return o;
		}

		Submit.createShape=function(ctx,mesh,numEle,sv){
			var o=Submit._poolSize ? Submit.POOL[--Submit._poolSize]:(new Submit());
			o._mesh=mesh;
			o._numEle=numEle;
			o._startIdx=mesh.indexNum *2;
			o._ref=1;
			o.shaderValue=sv;
			o.shaderValue.setValue(ctx._shader2D);
			var blendType=ctx._nBlendType;
			o._blendFn=ctx._targets ? BlendMode.targetFns[blendType] :BlendMode.fns[blendType];
			return o;
		}

		Submit.TYPE_2D=10000;
		Submit.TYPE_CANVAS=10003;
		Submit.TYPE_CMDSETRT=10004;
		Submit.TYPE_CUSTOM=10005;
		Submit.TYPE_BLURRT=10006;
		Submit.TYPE_CMDDESTORYPRERT=10007;
		Submit.TYPE_DISABLESTENCIL=10008;
		Submit.TYPE_OTHERIBVB=10009;
		Submit.TYPE_PRIMITIVE=10010;
		Submit.TYPE_RT=10011;
		Submit.TYPE_BLUR_RT=10012;
		Submit.TYPE_TARGET=10013;
		Submit.TYPE_CHANGE_VALUE=10014;
		Submit.TYPE_SHAPE=10015;
		Submit.TYPE_TEXTURE=10016;
		Submit.TYPE_FILLTEXTURE=10017;
		Submit.KEY_ONCE=-1;
		Submit.KEY_FILLRECT=1;
		Submit.KEY_DRAWTEXTURE=2;
		Submit.KEY_VG=3;
		Submit.KEY_TRIANGLES=4;
		Submit.RENDERBASE=null
		Submit.ID=1;
		Submit.preRender=null
		Submit._poolSize=0;
		Submit.POOL=[];
		return Submit;
	})()


	//class laya.webgl.submit.SubmitCMD
	var SubmitCMD=(function(){
		function SubmitCMD(){
			this.fun=null;
			this._this=null;
			this.args=null;
			this._ref=1;
			this._key=new SubmitKey();
		}

		__class(SubmitCMD,'laya.webgl.submit.SubmitCMD');
		var __proto=SubmitCMD.prototype;
		Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
		__proto.renderSubmit=function(){
			this.fun.apply(this._this,this.args);
			return 1;
		}

		__proto.getRenderType=function(){
			return 0;
		}

		__proto.reUse=function(context,pos){
			this._ref++;
			return pos;
		}

		__proto.releaseRender=function(){
			if((--this._ref)<1){
				var pool=SubmitCMD.POOL;
				pool[pool._length++]=this;
			}
		}

		__proto.clone=function(context,ib,vb,pos){
			return null;
		}

		SubmitCMD.create=function(args,fun,thisobj){
			var o=SubmitCMD.POOL._length?SubmitCMD.POOL[--SubmitCMD.POOL._length]:new SubmitCMD();
			o.fun=fun;
			o.args=args;
			o._this=thisobj;
			o._ref=1;
			o._key.clear();
			return o;
		}

		SubmitCMD.POOL=(SubmitCMD.POOL=[],SubmitCMD.POOL._length=0,SubmitCMD.POOL);
		return SubmitCMD;
	})()


	//class laya.webgl.submit.SubmitCMDScope
	var SubmitCMDScope=(function(){
		function SubmitCMDScope(){
			this.variables={};
		}

		__class(SubmitCMDScope,'laya.webgl.submit.SubmitCMDScope');
		var __proto=SubmitCMDScope.prototype;
		__proto.getValue=function(name){
			return this.variables[name];
		}

		__proto.addValue=function(name,value){
			return this.variables[name]=value;
		}

		__proto.setValue=function(name,value){
			if(this.variables.hasOwnProperty(name)){
				return this.variables[name]=value;
			}
			return null;
		}

		__proto.clear=function(){
			for(var key in this.variables){
				delete this.variables[key];
			}
		}

		__proto.recycle=function(){
			this.clear();
			SubmitCMDScope.POOL.push(this);
		}

		SubmitCMDScope.create=function(){
			return new SubmitCMDScope();
			var scope=SubmitCMDScope.POOL.pop();
			scope||(scope=new SubmitCMDScope());
			return scope;
		}

		SubmitCMDScope.POOL=[];
		return SubmitCMDScope;
	})()


	/**
	*...
	*@author xie
	*/
	//class laya.webgl.submit.SubmitKey
	var SubmitKey=(function(){
		function SubmitKey(){
			this.blendShader=0;
			this.submitType=0;
			this.other=0;
			this.clear();
		}

		__class(SubmitKey,'laya.webgl.submit.SubmitKey');
		var __proto=SubmitKey.prototype;
		__proto.clear=function(){
			this.submitType=-1;
			this.blendShader=this.other=0;
		}

		//alpha=1;
		__proto.copyFrom=function(src){
			this.other=src.other;
			this.blendShader=src.blendShader;
			this.submitType=src.submitType;
		}

		//alpha=src.alpha;
		__proto.copyFrom2=function(src,submitType,other){
			this.blendShader=src.blendShader;
			this.other=other;
			this.submitType=submitType;
		}

		//�Ƚ�3�����ⲿ�ṩ2��
		__proto.equal3_2=function(next,submitType,other){
			return this.submitType===submitType && this.other===other && this.blendShader===next.blendShader;
		}

		//ȫ�Ƚϡ��ⲿ�ṩ2��
		__proto.equal4_2=function(next,submitType,other){
			return this.submitType===submitType && this.other===other && this.blendShader===next.blendShader;
		}

		//�Ƚ�3��
		__proto.equal_3=function(next){
			return this.submitType===next.submitType && this.blendShader===next.blendShader;
		}

		//ȫ�Ƚϡ�4��
		__proto.equal=function(next){
			return this.other===next.other && this.submitType===next.submitType && this.blendShader===next.blendShader;
		}

		return SubmitKey;
	})()


	//class laya.webgl.submit.SubmitOtherIBVB
	var SubmitOtherIBVB=(function(){
		function SubmitOtherIBVB(){
			this.offset=0;
			//this._vb=null;
			//this._ib=null;
			//this._blendFn=null;
			//this._mat=null;
			//this._shader=null;
			//this._numEle=0;
			this._ref=1;
			this.startIndex=0;
			//this.shaderValue=null;
			this._key=new SubmitKey();
			;
			this._mat=Matrix.create();
		}

		__class(SubmitOtherIBVB,'laya.webgl.submit.SubmitOtherIBVB');
		var __proto=SubmitOtherIBVB.prototype;
		Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
		__proto.releaseRender=function(){
			if ((--this._ref)< 1){
				var pool=SubmitOtherIBVB.POOL;
				pool[pool._length++]=this;
			}
		}

		__proto.getRenderType=function(){
			return 10009;
		}

		__proto.reUse=function(context,pos){
			this._ref++;
			return pos;
		}

		__proto.clone=function(context,ib,vb,pos){
			return null;
		}

		__proto.renderSubmit=function(){
			var _tex=this.shaderValue.textureHost;
			if (_tex){
				var source=_tex.source;
				if (!_tex.bitmap || !source)
					return 1;
				this.shaderValue.texture=source;
			}
			this._ib._bind_upload()|| this._ib.bind();
			this._vb._bind_upload()|| this._vb.bind();
			var w=RenderState2D.worldMatrix4;
			var wmat=Matrix.TEMP;
			Matrix.mulPre(this._mat,w[0],w[1],w[4],w[5],w[12],w[13],wmat);
			var tmp=RenderState2D.worldMatrix4=SubmitOtherIBVB.tempMatrix4;
			tmp[0]=wmat.a;
			tmp[1]=wmat.b;
			tmp[4]=wmat.c;
			tmp[5]=wmat.d;
			tmp[12]=wmat.tx;
			tmp[13]=wmat.ty;
			this.shaderValue.size[0]=RenderState2D.width;
			this.shaderValue.size[1]=RenderState2D.height;
			this.shaderValue.alpha=this.shaderValue.ALPHA *RenderState2D.worldAlpha;
			this.shaderValue.mmat=RenderState2D.worldMatrix4;
			this._shader.upload(this.shaderValue);
			var gl=WebGL.mainContext;
			if (BlendMode.activeBlendFunction!==this._blendFn){
				WebGLContext.setBlend(gl,true);
				this._blendFn(gl);
				BlendMode.activeBlendFunction=this._blendFn;
			}
			Stat.drawCall++;
			Stat.trianglesFaces+=this._numEle / 3;
			gl.drawElements(0x0004,this._numEle,0x1403,this.startIndex);
			RenderState2D.worldMatrix4=w;
			BaseShader.activeShader=null;
			return 1;
		}

		SubmitOtherIBVB.create=function(context,vb,ib,numElement,shader,shaderValue,startIndex){
			var o=(!SubmitOtherIBVB.POOL._length)? (new SubmitOtherIBVB()):SubmitOtherIBVB.POOL[--SubmitOtherIBVB.POOL._length];
			o._ib=ib;
			o._vb=vb;
			o._numEle=numElement;
			o._shader=shader;
			o._key.clear();
			o._ref=1;
			o.shaderValue=shaderValue;
			var blendType=context._nBlendType;
			o._blendFn=context._targets ? BlendMode.targetFns[blendType] :BlendMode.fns[blendType];
			o.startIndex=startIndex;
			return o;
		}

		SubmitOtherIBVB.POOL=[];
		SubmitOtherIBVB.tempMatrix4=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,];
		return SubmitOtherIBVB;
	})()


	//class laya.webgl.submit.SubmitScissor
	var SubmitScissor=(function(){
		function SubmitScissor(){
			this.submitIndex=0;
			this.submitLength=0;
			this.context=null;
			this._numEle=0;
			this._ref=1;
			this.clipRect=new Rectangle();
			this.screenRect=new Rectangle();
			this._key=new SubmitKey();
		}

		__class(SubmitScissor,'laya.webgl.submit.SubmitScissor');
		var __proto=SubmitScissor.prototype;
		Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
		__proto._scissor=function(x,y,w,h){
			var m=RenderState2D.worldMatrix4;
			var a=m[0],d=m[5],tx=m[12],ty=m[13];
			x=x *a+tx;
			y=y *d+ty;
			w *=a;
			h *=d;
			if (w < 1 || h < 1){
				return false;
			};
			var r=x+w;
			var b=y+h;
			x < 0 && (x=0,w=r-x);
			y < 0 && (y=0,h=b-y);
			var screen=RenderState2D.worldClipRect;
			x=Math.max(x,screen.x);
			y=Math.max(y,screen.y);
			w=Math.min(r,screen.right)-x;
			h=Math.min(b,screen.bottom)-y;
			if (w < 1 || h < 1){
				return false;
			};
			var worldScissorTest=RenderState2D.worldScissorTest;
			this.screenRect.copyFrom(screen);
			screen.x=x;
			screen.y=y;
			screen.width=w;
			screen.height=h;
			RenderState2D.worldScissorTest=true;
			y=RenderState2D.height-y-h;
			WebGL.mainContext.scissor(x,y,w,h);
			WebGL.mainContext.enable(0x0C11);
			this.context.submitNextElement(this.submitLength);
			if (worldScissorTest){
				y=RenderState2D.height-this.screenRect.y-this.screenRect.height;
				WebGL.mainContext.scissor(this.screenRect.x,y,this.screenRect.width,this.screenRect.height);
				WebGL.mainContext.enable(0x0C11);
			}
			else{
				WebGL.mainContext.disable(0x0C11);
				RenderState2D.worldScissorTest=false;
			}
			screen.copyFrom(this.screenRect);
			return true;
		}

		__proto._scissorWithTagart=function(x,y,w,h){
			if (w < 1 || h < 1){
				return false;
			};
			var r=x+w;
			var b=y+h;
			x < 0 && (x=0,w=r-x);
			y < 0 && (y=0,h=b-y);
			var screen=RenderState2D.worldClipRect;
			x=Math.max(x,screen.x);
			y=Math.max(y,screen.y);
			w=Math.min(r,screen.right)-x;
			h=Math.min(b,screen.bottom)-y;
			if (w < 1 || h < 1){
				return false;
			};
			var worldScissorTest=RenderState2D.worldScissorTest;
			this.screenRect.copyFrom(screen);
			RenderState2D.worldScissorTest=true;
			screen.x=x;
			screen.y=y;
			screen.width=w;
			screen.height=h;
			y=RenderState2D.height-y-h;
			WebGL.mainContext.scissor(x,y,w,h);
			WebGL.mainContext.enable(0x0C11);
			this.context.submitNextElement(this.submitLength);
			if (worldScissorTest){
				y=RenderState2D.height-this.screenRect.y-this.screenRect.height;
				WebGL.mainContext.scissor(this.screenRect.x,y,this.screenRect.width,this.screenRect.height);
				WebGL.mainContext.enable(0x0C11);
			}
			else{
				WebGL.mainContext.disable(0x0C11);
				RenderState2D.worldScissorTest=false;
			}
			screen.copyFrom(this.screenRect);
			return true;
		}

		__proto.renderSubmit=function(){
			if (this.clipRect.width < 1 || this.clipRect.height < 1){
				return this.submitLength+1;
			}
			if (this.context._targets)
				this._scissorWithTagart(this.clipRect.x,this.clipRect.y,this.clipRect.width,this.clipRect.height);
			else this._scissor(this.clipRect.x,this.clipRect.y,this.clipRect.width,this.clipRect.height);
			return this.submitLength+1;
		}

		__proto.getRenderType=function(){
			return 0;
		}

		__proto.releaseRender=function(){
			if((--this._ref)<1){
				var pool=SubmitScissor.POOL;
				pool[pool._length++]=this;
				this.context=null;
			}
		}

		__proto.clone=function(context,ib,vb,pos){
			return null;
		}

		__proto.reUse=function(ctx,pos){
			this._key.clear();
			this._ref++;
			this._numEle=0;
			this.context=ctx;
			return pos;
		}

		SubmitScissor.create=function(ctx){
			var o=SubmitScissor.POOL._length?SubmitScissor.POOL[--SubmitScissor.POOL._length]:new SubmitScissor();
			o.context=ctx;
			o._key.clear();
			o._ref=1;
			return o;
		}

		SubmitScissor.POOL=(SubmitScissor.POOL=[],SubmitScissor.POOL._length=0,SubmitScissor.POOL);
		return SubmitScissor;
	})()


	//class laya.webgl.submit.SubmitStencil
	var SubmitStencil=(function(){
		function SubmitStencil(){
			this.step=0;
			this.blendMode=null;
			this._ref=1;
			this.level=0;
			this._key=new SubmitKey();
		}

		__class(SubmitStencil,'laya.webgl.submit.SubmitStencil');
		var __proto=SubmitStencil.prototype;
		Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
		__proto.renderSubmit=function(){
			switch(this.step){
				case 1:
					this.do1();
					break ;
				case 2:
					this.do2();
					break ;
				case 3:
					this.do3();
					break ;
				case 4:
					this.do4();
					break ;
				case 5:
					this.do5();
					break ;
				case 6:
					this.do6();
					break ;
				case 7:
					this.do7();
					break ;
				case 8:
					this.do8();
					break ;
				}
			return 1;
		}

		__proto.getRenderType=function(){
			return 0;
		}

		__proto.releaseRender=function(){
			if((--this._ref)<1){
				var pool=SubmitStencil.POOL;
				pool[pool._length++]=this;
			}
		}

		__proto.clone=function(context,ib,vb,pos){
			return null;
		}

		__proto.reUse=function(context,pos){
			this._ref++;
			return pos;
		}

		__proto.do1=function(){
			var gl=WebGL.mainContext;
			gl.enable(0x0B90);
			gl.clear(0x00000400);
			gl.colorMask(false,false,false,false);
			gl.stencilFunc(0x0202,this.level,0xFF);
			gl.stencilOp(0x1E00,0x1E00,0x1E02);
		}

		//gl.stencilOp(WebGLContext.KEEP,WebGLContext.KEEP,WebGLContext.INVERT);//测试通过给模版缓冲 写入值 一开始是0 现在是 0xFF (模版缓冲中不知道是多少位的数据)
		__proto.do2=function(){
			var gl=WebGL.mainContext;
			gl.stencilFunc(0x0202,this.level+1,0xFF);
			gl.colorMask(true,true,true,true);
			gl.stencilOp(0x1E00,0x1E00,0x1E00);
		}

		__proto.do3=function(){
			var gl=WebGL.mainContext;
			gl.colorMask(true,true,true,true);
			gl.stencilOp(0x1E00,0x1E00,0x1E00);
			gl.clear(0x00000400);
			gl.disable(0x0B90);
		}

		__proto.do4=function(){
			var gl=WebGL.mainContext;
			if (this.level==0){
				gl.enable(0x0B90);
				gl.clear(0x00000400);
			}
			gl.colorMask(false,false,false,false);
			gl.stencilFunc(0x0207,0,0xFF);
			gl.stencilOp(0x1E00,0x1E00,0x1E02);
		}

		__proto.do5=function(){
			var gl=WebGL.mainContext;
			gl.stencilFunc(0x0202,this.level,0xFF);
			gl.colorMask(true,true,true,true);
			gl.stencilOp(0x1E00,0x1E00,0x1E00);
		}

		__proto.do6=function(){
			var gl=WebGL.mainContext;
			BlendMode.targetFns[BlendMode.TOINT[this.blendMode]](gl);
		}

		__proto.do7=function(){
			var gl=WebGL.mainContext;
			gl.colorMask(false,false,false,false);
			gl.stencilOp(0x1E00,0x1E00,0x1E03);
		}

		__proto.do8=function(){
			var gl=WebGL.mainContext;
			gl.colorMask(true,true,true,true);
			gl.stencilFunc(0x0202,this.level,0xFF);
			gl.stencilOp(0x1E00,0x1E00,0x1E00);
		}

		SubmitStencil.restore=function(context,clip,m,_x,_y){
			var submitStencil;
			if (SubmitStencil._mask > 0){
				SubmitStencil._mask--;
			}
			if (SubmitStencil._mask==0){
				submitStencil=laya.webgl.submit.SubmitStencil.create(3);
				context.addRenderObject(submitStencil);
				context._curSubmit=Submit.RENDERBASE;
			}
			else{
				submitStencil=laya.webgl.submit.SubmitStencil.create(7);
				context.addRenderObject(submitStencil);
				var vb=context._vb;
				var nPos=(vb._byteLength >> 2);
				if (GlUtils.fillRectImgVb(vb,null,clip.x,clip.y,clip.width,clip.height,Texture.DEF_UV,m)){
					var shader=context._shader2D;
					var submit=context._curSubmit=Submit.create(context,context._ib,vb,((vb._byteLength-WebGLContext2D._RECTVBSIZE *4)/ 32)*3,Value2D.create(ShaderDefines2D.COLOR2D,0));
					submit.shaderValue.ALPHA=1.0;
					submit._key.clear();
					context._submits[context._submits._length++]=submit;
					context._curSubmit._numEle+=6;
					context._curSubmit=Submit.RENDERBASE;
					}else {
					alert("clipRect calc stencil rect error");
				}
				submitStencil=laya.webgl.submit.SubmitStencil.create(8);
				context.addRenderObject(submitStencil);
			}
		}

		SubmitStencil.restore2=function(context,submit){
			var submitStencil;
			submit._key.clear();
			if (SubmitStencil._mask > 0){
				SubmitStencil._mask--;
			}
			if (SubmitStencil._mask==0){
				submitStencil=laya.webgl.submit.SubmitStencil.create(3);
				context.addRenderObject(submitStencil);
				context._curSubmit=Submit.RENDERBASE;
			}
			else{
				submitStencil=laya.webgl.submit.SubmitStencil.create(7);
				context.addRenderObject(submitStencil);
				context._submits[context._submits._length++]=submit;
				submitStencil=laya.webgl.submit.SubmitStencil.create(8);
				context.addRenderObject(submitStencil);
			}
		}

		SubmitStencil.create=function(step){
			var o=SubmitStencil.POOL._length?SubmitStencil.POOL[--SubmitStencil.POOL._length]:new SubmitStencil();
			o.step=step;
			o._ref=1;
			if (step==5)
				++SubmitStencil._mask;
			o.level=SubmitStencil._mask;
			return o;
		}

		SubmitStencil._mask=0;
		SubmitStencil.POOL=(SubmitStencil.POOL=[],SubmitStencil.POOL._length=0,SubmitStencil.POOL);
		return SubmitStencil;
	})()


	//class laya.webgl.submit.SubmitTarget
	var SubmitTarget=(function(){
		function SubmitTarget(){
			this._renderType=0;
			this._mesh=null;
			this._startIdx=0;
			this._numEle=0;
			this.shaderValue=null;
			this.blendType=0;
			this.proName=null;
			this._ref=1;
			this.scope=null;
			this._key=new SubmitKey();
		}

		__class(SubmitTarget,'laya.webgl.submit.SubmitTarget');
		var __proto=SubmitTarget.prototype;
		Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
		__proto.renderSubmit=function(){
			var gl=WebGL.mainContext;
			this._mesh.useMesh(gl);
			var target=this.scope.getValue(this.proName);
			if (target){
				this.shaderValue.texture=target._getSource();
				if (this.shaderValue["strength"] && !this.shaderValue["blurInfo"]){
					this.shaderValue["blurInfo"]=[target.width,target.height];
				}
				this.shaderValue.upload();
				this.blend();
				Stat.drawCall++;
				Stat.trianglesFaces+=this._numEle/3;
				WebGL.mainContext.drawElements(0x0004,this._numEle,0x1403,this._startIdx);
			}
			return 1;
		}

		__proto.blend=function(){
			if (BlendMode.activeBlendFunction!==BlendMode.fns[this.blendType]){
				var gl=WebGL.mainContext;
				gl.enable(0x0BE2);
				BlendMode.fns[this.blendType](gl);
				BlendMode.activeBlendFunction=BlendMode.fns[this.blendType];
			}
		}

		__proto.getRenderType=function(){
			return 0;
		}

		__proto.releaseRender=function(){
			if ((--this._ref)< 1){
				var pool=SubmitTarget.POOL;
				pool[pool._length++]=this;
			}
		}

		__proto.clone=function(context,ib,vb,pos){
			return null;
		}

		__proto.reUse=function(context,pos){
			this._startIdx=pos;
			this._ref++;
			return pos;
		}

		SubmitTarget.create=function(context,mesh,sv,proName){
			var o=SubmitTarget.POOL._length?SubmitTarget.POOL[--SubmitTarget.POOL._length]:new SubmitTarget();
			o._mesh=mesh;
			o.proName=proName;
			o._startIdx=mesh.indexNum *CONST3D2D.BYTES_PIDX;
			o._ref=1;
			o._key.clear();
			o._numEle=0;
			o.blendType=context._nBlendType;
			o.shaderValue=sv;
			o.shaderValue.setValue(context._shader2D);
			return o;
		}

		SubmitTarget.POOL=(SubmitTarget.POOL=[],SubmitTarget.POOL._length=0,SubmitTarget.POOL);
		return SubmitTarget;
	})()


	/**
	*Javascript Arabic Reshaper by Louy Alakkad
	*https://github.com/louy/Javascript-Arabic-Reshaper
	*Based on (http://git.io/vsnAd)
	*/
	//class laya.webgl.text.ArabicReshaper
	var ArabicReshaper=(function(){
		function ArabicReshaper(){};
		__class(ArabicReshaper,'laya.webgl.text.ArabicReshaper');
		var __proto=ArabicReshaper.prototype;
		/*ARABIC SMALL LOW MEEM */
		__proto.characterMapContains=function(c){
			for (var i=0;i < ArabicReshaper.charsMap.length;++i){
				if (ArabicReshaper.charsMap[ i][0]===c){
					return true;
				}
			}
			return false;
		}

		__proto.getCharRep=function(c){
			for (var i=0;i < ArabicReshaper.charsMap.length;++i){
				if (ArabicReshaper.charsMap[ i][0]===c){
					return ArabicReshaper.charsMap[i];
				}
			}
			return false;
		}

		__proto.getCombCharRep=function(c1,c2){
			for (var i=0;i < ArabicReshaper.combCharsMap.length;++i){
				if (ArabicReshaper.combCharsMap[i][0][0]===c1 && ArabicReshaper.combCharsMap[i][0][1]===c2){
					return ArabicReshaper.combCharsMap[i];
				}
			}
			return false;
		}

		__proto.isTransparent=function(c){
			for (var i=0;i < ArabicReshaper.transChars.length;++i){
				if (ArabicReshaper.transChars[i]===c){
					return true;
				}
			}
			return false;
		}

		__proto.getOriginalCharsFromCode=function(code){
			var j;
			for (j=0;j < ArabicReshaper.charsMap.length;++j){
				if (ArabicReshaper.charsMap[j].indexOf(code)>-1){
					return String.fromCharCode(ArabicReshaper.charsMap[j][0]);
				}
			}
			for (j=0;j < ArabicReshaper.combCharsMap.length;++j){
				if (ArabicReshaper.combCharsMap[j].indexOf(code)>-1){
					return String.fromCharCode(ArabicReshaper.combCharsMap[j][0][0])+
					String.fromCharCode(ArabicReshaper.combCharsMap[j][0][1]);
				}
			}
			return String.fromCharCode(code);
		}

		/**
		*转换函数。从normal转到presentB
		*这个返回的字符串可以直接按照从左到右的顺序渲染。
		*例如
		*graphics.fillText(convertArabic('سلام'),....)
		*
		*/
		__proto.convertArabic=function(normal){
			var crep,
			combcrep,
			shaped='';
			for (var i=0;i < normal.length;++i){
				var current=normal.charCodeAt(i);
				if (this.characterMapContains(current)){
					var prev=null,
					next=null,
					prevID=i-1,
					nextID=i+1;
					for (;prevID >=0;--prevID){
						if (!this.isTransparent(normal.charCodeAt(prevID))){
							break ;
						}
					}
					prev=(prevID >=0)? normal.charCodeAt(prevID):null;
					crep=prev ? this.getCharRep(prev):false;
					if (!crep || crep[2]==null && crep[3]==null){
						prev=null;
					}
					for (;nextID < normal.length;++nextID){
						if (!this.isTransparent(normal.charCodeAt(nextID))){
							break ;
						}
					}
					next=(nextID < normal.length)? normal.charCodeAt(nextID):null;
					crep=next ? this.getCharRep(next):false;
					if (!crep || crep[3]==null && crep[4]==null){
						next=null;
					}
					if (current===0x0644 && next !=null &&
						(next===0x0622 || next===0x0623 || next===0x0625 || next===0x0627)){
						combcrep=this.getCombCharRep(current,next);
						if (prev !=null){
							shaped+=String.fromCharCode(combcrep[4]);
							}else {
							shaped+=String.fromCharCode(combcrep[1]);
						}
						++i;
						continue ;
					}
					crep=this.getCharRep(current);
					if (prev !=null && next !=null && crep[3] !=null){
						shaped+=String.fromCharCode(crep[3]);
						continue ;
					}else
					if (prev !=null && crep[4] !=null){
						shaped+=String.fromCharCode(crep[4]);
						continue ;
					}else
					if (next !=null && crep[2] !=null){
						shaped+=String.fromCharCode(crep[2]);
						continue ;
						}else {
						shaped+=String.fromCharCode(crep[1]);
					}
					}else {
					shaped+=String.fromCharCode(current);
				}
			}
			return shaped;
		}

		// convert from Arabic Presentation Forms B
		__proto.convertArabicBack=function(apfb){
			var toReturn='',
			selectedChar;
			var i;
			theLoop:
			for (i=0;i < apfb.length;++i){
				selectedChar=apfb.charCodeAt(i);
				toReturn+=this.getOriginalCharsFromCode(selectedChar);
			}
			return toReturn;
		}

		__static(ArabicReshaper,
		['charsMap',function(){return this.charsMap=[
			[0x0621,0xFE80,null,null,null],
			[0x0622,0xFE81,null,null,0xFE82],
			[0x0623,0xFE83,null,null,0xFE84],
			[0x0624,0xFE85,null,null,0xFE86],
			[0x0625,0xFE87,null,null,0xFE88],
			[0x0626,0xFE89,0xFE8B,0xFE8C,0xFE8A],
			[0x0627,0xFE8D,null,null,0xFE8E],
			[0x0628,0xFE8F,0xFE91,0xFE92,0xFE90],
			[0x0629,0xFE93,null,null,0xFE94],
			[0x062A,0xFE95,0xFE97,0xFE98,0xFE96],
			[0x062B,0xFE99,0xFE9B,0xFE9C,0xFE9A],
			[0x062C,0xFE9D,0xFE9F,0xFEA0,0xFE9E],
			[0x062D,0xFEA1,0xFEA3,0xFEA4,0xFEA2],
			[0x062E,0xFEA5,0xFEA7,0xFEA8,0xFEA6],
			[0x062F,0xFEA9,null,null,0xFEAA],
			[0x0630,0xFEAB,null,null,0xFEAC],
			[0x0631,0xFEAD,null,null,0xFEAE],
			[0x0632,0xFEAF,null,null,0xFEB0],
			[0x0633,0xFEB1,0xFEB3,0xFEB4,0xFEB2],
			[0x0634,0xFEB5,0xFEB7,0xFEB8,0xFEB6],
			[0x0635,0xFEB9,0xFEBB,0xFEBC,0xFEBA],
			[0x0636,0xFEBD,0xFEBF,0xFEC0,0xFEBE],
			[0x0637,0xFEC1,0xFEC3,0xFEC4,0xFEC2],
			[0x0638,0xFEC5,0xFEC7,0xFEC8,0xFEC6],
			[0x0639,0xFEC9,0xFECB,0xFECC,0xFECA],
			[0x063A,0xFECD,0xFECF,0xFED0,0xFECE],
			[0x0640,0x0640,0x0640,0x0640,0x0640],
			[0x0641,0xFED1,0xFED3,0xFED4,0xFED2],
			[0x0642,0xFED5,0xFED7,0xFED8,0xFED6],
			[0x0643,0xFED9,0xFEDB,0xFEDC,0xFEDA],
			[0x0644,0xFEDD,0xFEDF,0xFEE0,0xFEDE],
			[0x0645,0xFEE1,0xFEE3,0xFEE4,0xFEE2],
			[0x0646,0xFEE5,0xFEE7,0xFEE8,0xFEE6],
			[0x0647,0xFEE9,0xFEEB,0xFEEC,0xFEEA],
			[0x0648,0xFEED,null,null,0xFEEE],
			[0x0649,0xFEEF,null,null,0xFEF0],
			[0x064A,0xFEF1,0xFEF3,0xFEF4,0xFEF2],
			[0x067E,0xFB56,0xFB58,0xFB59,0xFB57],
			[0x06CC,0xFBFC,0xFBFE,0xFBFF,0xFBFD],
			[0x0686,0xFB7A,0xFB7C,0xFB7D,0xFB7B],
			[0x06A9,0xFB8E,0xFB90,0xFB91,0xFB8F],
			[0x06AF,0xFB92,0xFB94,0xFB95,0xFB93],
			[0x0698,0xFB8A,null,null,0xFB8B],];},'combCharsMap',function(){return this.combCharsMap=[
			[[0x0644,0x0622],0xFEF5,null,null,0xFEF6],
			[[0x0644,0x0623],0xFEF7,null,null,0xFEF8],
			[[0x0644,0x0625],0xFEF9,null,null,0xFEFA],
			[[0x0644,0x0627],0xFEFB,null,null,0xFEFC],];},'transChars',function(){return this.transChars=[
			0x0610,
			0x0612,
			0x0613,
			0x0614,
			0x0615,
			0x064B,
			0x064C,
			0x064D,
			0x064E,
			0x064F,
			0x0650,
			0x0651,
			0x0652,
			0x0653,
			0x0654,
			0x0655,
			0x0656,
			0x0657,
			0x0658,
			0x0670,
			0x06D6,
			0x06D7,
			0x06D8,
			0x06D9,
			0x06DA,
			0x06DB,
			0x06DC,
			0x06DF,
			0x06E0,
			0x06E1,
			0x06E2,
			0x06E3,
			0x06E4,
			0x06E7,
			0x06E8,
			0x06EA,
			0x06EB,
			0x06EC,
			0x06ED,];}
		]);
		return ArabicReshaper;
	})()


	/**
	*...特殊的字符，如泰文，必须重新实现这个类
	*/
	//class laya.webgl.text.CharSegment
	var CharSegment=(function(){
		function CharSegment(){
			this._sourceStr=null;
		}

		__class(CharSegment,'laya.webgl.text.CharSegment');
		var __proto=CharSegment.prototype;
		Laya.imps(__proto,{"laya.webgl.text.ICharSegment":true})
		__proto.textToSpit=function(str){
			this._sourceStr=str;
		}

		__proto.getChar=function(i){
			return this._sourceStr.charAt(i);
		}

		__proto.getCharCode=function(i){
			return this._sourceStr.charCodeAt(i);
		}

		__proto.length=function(){
			return this._sourceStr.length;
		}

		return CharSegment;
	})()


	//class laya.webgl.text.DrawText
	var DrawText=(function(){
		var CharValue;
		function DrawText(){};
		__class(DrawText,'laya.webgl.text.DrawText');
		DrawText.__init__=function(){
			DrawText._charsTemp=new Array;
			DrawText._drawValue=new CharValue();
			DrawText._charSeg=new CharSegment();
		}

		DrawText.customCharSeg=function(charseg){
			DrawText._charSeg=charseg;
		}

		DrawText.getChar=function(char,id,drawValue){
			var result=WebGLCharImage.createOneChar(char,drawValue);
			if(id!=-1)
				DrawText._charsCache[id]=result;
			return result;
		}

		DrawText._drawSlow=function(save,ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,sx,sy,underLine){
			var drawValue=DrawText._drawValue.value(font,fillColor,borderColor,lineWidth,sx,sy,underLine);
			var i=0,n=0;
			var chars=DrawText._charsTemp;
			var width=0,oneChar,htmlWord,id=NaN;
			if (words){
				chars.length=words.length;
				for (i=0,n=words.length;i < n;i++){
					htmlWord=words[i];
					id=htmlWord.charNum+drawValue.txtID;
					chars[i]=oneChar=DrawText._charsCache[id] || DrawText.getChar(htmlWord.char,id,drawValue);
					oneChar.active();
				}
				}else {
				var text=((txt instanceof laya.utils.WordText ))? txt.toString():txt;
				if (Text.CharacterCache){
					DrawText._charSeg.textToSpit(text);
					var len=/*if err,please use iflash.method.xmlLength()*/DrawText._charSeg.length();
					chars.length=len;
					for (i=0,n=len;i < n;i++){
						id=DrawText._charSeg.getCharCode(i)+drawValue.txtID;
						chars[i]=oneChar=DrawText._charsCache[id] || DrawText.getChar(DrawText._charSeg.getChar(i),id,drawValue);
						oneChar.active();
						width+=oneChar.cw;
					}
				}
				else {
					chars.length=0;
					oneChar=DrawText.getChar(text,-1,drawValue);
					oneChar.active();
					width+=oneChar.cw;
					chars[0]=oneChar;
				}
			};
			var dx=0;
			if (textAlign!==null && textAlign!=="left")
				dx=-(textAlign=="center" ? (width / 2):width);
			var uv,bdSz=NaN,texture,value,saveLength=0;
			if (words){
				for (i=0,n=chars.length;i < n;i++){
					oneChar=chars[i];
					if (!oneChar.isSpace){
						htmlWord=words[i];
						bdSz=oneChar.borderSize;
						texture=oneChar.texture;
						ctx._drawTextureM(texture,x+dx+htmlWord.x *sx-bdSz,y+htmlWord.y *sy-bdSz,texture.width,texture.height,curMat);
					}
				}
				}else {
				for (i=0,n=chars.length;i < n;i++){
					oneChar=chars[i];
					if (!oneChar.isSpace){
						bdSz=oneChar.borderSize;
						texture=oneChar.texture;
						ctx._drawTextureM(texture,x+dx-bdSz,y-bdSz,texture.width,texture.height,curMat);
						save && (value=save[saveLength++],value || (value=save[saveLength-1]=[]),value[0]=texture,value[1]=dx-bdSz,value[2]=-bdSz);
					}
					dx+=oneChar.cw;
				}
				save && (save.length=saveLength);
			}
		}

		DrawText._drawFast=function(save,ctx,curMat,x,y){
			var texture,value;
			for (var i=0,n=save.length;i < n;i++){
				value=save[i];
				texture=value[0];
				texture.active();
				ctx._drawText(texture,x+value[1],y+value[2],texture.width,texture.height,curMat,0,0,0,0);
			}
		}

		DrawText._drawText_slow=function(ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,underLine){
			var sx=curMat.a,sy=curMat.d;
			(curMat.b!==0 || curMat.c!==0)&& (sx=sy=1);
			var scale=sx!==1 || sy!==1;
			if (scale && Laya.stage.transform){
				var t=Laya.stage.transform;
				scale=t.a===sx && t.d===sy;
			}else scale=false;
			if (scale){
				curMat=curMat.copyTo(WebGLContext2D._tmpMatrix);
				var tempTx=curMat.tx;
				var tempTy=curMat.ty;
				curMat.scale(1 / sx,1 / sy);
				curMat._checkTransform();
				x *=sx;
				y *=sy;
				x+=tempTx-curMat.tx;
				y+=tempTy-curMat.ty;
			}else sx=sy=1;
			if (words){
				DrawText._drawSlow(null,ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,sx,sy,underLine);
				}else {
				var id=txt+font.toString()+fillColor+borderColor+lineWidth+sx+sy+textAlign;
				var cache=DrawText._textsCache[id];
				if (Text.CharacterCache){
					if (cache){
						DrawText._drawFast(cache,ctx,curMat,x,y);
						}else {
						DrawText._textsCache.__length || (DrawText._textsCache.__length=0);
						if (DrawText._textsCache.__length > Config.WebGLTextCacheCount){
							DrawText._textsCache={};
							DrawText._textsCache.__length=0;
							DrawText._curPoolIndex=0;
						}
						DrawText._textCachesPool[DrawText._curPoolIndex] ? (cache=DrawText._textsCache[id]=DrawText._textCachesPool[DrawText._curPoolIndex],cache.length=0):(DrawText._textCachesPool[DrawText._curPoolIndex]=cache=DrawText._textsCache[id]=[]);
						DrawText._textsCache.__length++
						DrawText._curPoolIndex++;
						DrawText._drawSlow(cache,ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,sx,sy,underLine);
					}
				}
				else{
					DrawText._drawSlow(cache,ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,sx,sy,underLine);
				}
			}
		}

		DrawText.drawText=function(ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,underLine){
			(underLine===void 0)&& (underLine=0);
			if ((txt && txt.length===0)|| (words && words.length===0))
				return;
			if (words || txt.toUpperCase){
				DrawText._drawText_slow(ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,underLine);
				return;
			};
			var sx=curMat.a,sy=curMat.d;
			(curMat.b!==0 || curMat.c!==0)&& (sx=sy=1);
			var scale=sx!==1 || sy!==1;
			if (scale && Laya.stage.transform){
				var t=Laya.stage.transform;
				scale=t.a===sx && t.d===sy;
			}else scale=false;
			if (scale){
				curMat=curMat.copyTo(WebGLContext2D._tmpMatrix);
				var tempTx=curMat.tx;
				var tempTy=curMat.ty;
				curMat.scale(1 / sx,1 / sy);
				curMat._checkTransform();
				x *=sx;
				y *=sy;
				x+=tempTx-curMat.tx;
				y+=tempTy-curMat.ty;
			}
			else
			sx=sy=1;
			var idNum=sx+sy *100000;
			var myCache=txt;
			if (!myCache.changed && myCache.id===idNum){
				DrawText._drawFast(myCache.save,ctx,curMat,x,y);
			}
			else {
				myCache.id=idNum;
				myCache.changed=false;
				DrawText._drawSlow(myCache.save,ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,sx,sy,underLine);
			}
		}

		DrawText._charsTemp=null
		DrawText._textCachesPool=[];
		DrawText._curPoolIndex=0;
		DrawText._charsCache={};
		DrawText._textsCache={};
		DrawText._drawValue=null
		DrawText.d=[];
		DrawText._charSeg=null;
		DrawText.__init$=function(){
			//class CharValue
			CharValue=(function(){
				function CharValue(){
					//this.txtID=NaN;
					//this.font=null;
					//this.fillColor=null;
					//this.borderColor=null;
					//this.lineWidth=0;
					//this.scaleX=NaN;
					//this.scaleY=NaN;
					//this.underLine=0;
				}
				__class(CharValue,'');
				var __proto=CharValue.prototype;
				__proto.value=function(font,fillColor,borderColor,lineWidth,scaleX,scaleY,underLine){
					this.font=font;
					this.fillColor=fillColor;
					this.borderColor=borderColor;
					this.lineWidth=lineWidth;
					this.scaleX=scaleX;
					this.scaleY=scaleY;
					this.underLine=underLine;
					var key=font.toString()+scaleX+scaleY+lineWidth+fillColor+borderColor+underLine;
					this.txtID=CharValue._keymap[key];
					if (!this.txtID){
						this.txtID=(++CharValue._keymapCount)*0.0000001;
						CharValue._keymap[key]=this.txtID;
					}
					return this;
				}
				CharValue.clear=function(){
					CharValue._keymap={};
					CharValue._keymapCount=1;
				}
				CharValue._keymap={};
				CharValue._keymapCount=1;
				return CharValue;
			})()
		}

		return DrawText;
	})()


	//class laya.webgl.text.FontInContext
	var FontInContext=(function(){
		function FontInContext(font){
			//this._text=null;
			//this._words=null;
			this._index=0;
			this._size=14;
			this._italic=-2;
			FontInContext._cache2=FontInContext._cache2|| [];
			this.setFont(font || "14px Arial");
		}

		__class(FontInContext,'laya.webgl.text.FontInContext');
		var __proto=FontInContext.prototype;
		__proto.setFont=function(value){
			var arr=FontInContext._cache2[value];
			if (!arr){
				this._words=value.split(' ');
				for (var i=0,n=this._words.length;i < n;i++){
					if (this._words[i].indexOf('px')> 0 || this._words[i].indexOf('pt')> 0){
						this._index=i;
						break ;
					}
				}
				this._size=parseInt(this._words[this._index]);
				FontInContext._cache2[value]=[this._words,this._size];
				}else {
				this._words=arr[0];
				this._size=arr[1];
			}
			this._text=null;
			this._italic=-2;
		}

		__proto.getItalic=function(){
			this._italic===-2 && (this._italic=this.hasType("italic"));
			return this._italic;
		}

		__proto.getFamily=function(){
			return this._words[this._index+1];
		}

		__proto.hasType=function(name){
			for (var i=0,n=this._words.length;i < n;i++)
			if (this._words[i]===name)return i;
			return-1;
		}

		__proto.removeType=function(name){
			for (var i=0,n=this._words.length;i < n;i++)
			if (this._words[i]===name){
				this._words.splice(i,1);
				if (this._index > i)this._index--;
				break ;
			}
			this._text=null;
			this._italic=-2;
		}

		__proto.copyTo=function(dec){
			dec._text=this._text;
			dec._size=this._size;
			dec._index=this._index;
			dec._words=this._words.slice();
			dec._italic=-2;
			return dec;
		}

		__proto.toString=function(){
			return this._text ? this._text :(this._text=this._words.join(' '));
		}

		__getset(0,__proto,'size',function(){
			return this._size;
			},function(value){
			this._size=value;
			this._words[this._index]=value+"px";
			this._text=null;
		});

		FontInContext.create=function(font){
			var r=FontInContext._cache[font];
			if (r)return r;
			r=FontInContext._cache[font]=new FontInContext(font);
			return r;
		}

		FontInContext.EMPTY=new FontInContext();
		FontInContext._cache={};
		FontInContext._cache2=null
		return FontInContext;
	})()


	//class laya.webgl.utils.CONST3D2D
	var CONST3D2D=(function(){
		function CONST3D2D(){};
		__class(CONST3D2D,'laya.webgl.utils.CONST3D2D');
		CONST3D2D.BYTES_PE=4;
		CONST3D2D.BYTES_PIDX=2;
		CONST3D2D.defaultMatrix4=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
		CONST3D2D.defaultMinusYMatrix4=[1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1];
		CONST3D2D.uniformMatrix3=[1,0,0,0,0,1,0,0,0,0,1,0];
		CONST3D2D._TMPARRAY=[];
		CONST3D2D._OFFSETX=0;
		CONST3D2D._OFFSETY=0;
		return CONST3D2D;
	})()


	//class laya.webgl.utils.GlUtils
	var GlUtils=(function(){
		function GlUtils(){};
		__class(GlUtils,'laya.webgl.utils.GlUtils');
		GlUtils.make2DProjection=function(width,height,depth){
			return [2.0 / width,0,0,0,0,-2.0 / height,0,0,0,0,2.0 / depth,0,-1,1,0,1,];
		}

		GlUtils.fillIBQuadrangle=function(buffer,count){
			if (count > 65535 / 4){
				throw Error("IBQuadrangle count:"+count+" must<:"+Math.floor(65535 / 4));
				return false;
			}
			count=Math.floor(count);
			buffer._resizeBuffer((count+1)*6 *2,false);
			buffer.byteLength=buffer.bufferLength;
			var bufferData=buffer.getUint16Array();
			var idx=0;
			for (var i=0;i < count;i++){
				bufferData[idx++]=i *4;
				bufferData[idx++]=i *4+2;
				bufferData[idx++]=i *4+1;
				bufferData[idx++]=i *4;
				bufferData[idx++]=i *4+3;
				bufferData[idx++]=i *4+2;
			}
			buffer.setNeedUpload();
			return true;
		}

		GlUtils.expandIBQuadrangle=function(buffer,count){
			buffer.bufferLength >=(count *6 *2)|| GlUtils.fillIBQuadrangle(buffer,count);
		}

		GlUtils.mathCeilPowerOfTwo=function(value){
			value--;
			value |=value >> 1;
			value |=value >> 2;
			value |=value >> 4;
			value |=value >> 8;
			value |=value >> 16;
			value++;
			return value;
		}

		GlUtils.fillTranglesVB=function(vb,x,y,points,m,_x,_y){
			var vpos=(vb._byteLength >> 2)+points.length;
			vb.byteLength=(vpos << 2);
			var vbdata=vb.getFloat32Array();
			vpos-=points.length;
			var len=points.length;
			var a=m.a,b=m.b,c=m.c,d=m.d;
			for (var i=0;i < len;i+=4){
				vbdata[vpos+i+2]=points[i+2];
				vbdata[vpos+i+3]=points[i+3];
				if (a!==1 || b!==0 || c!==0 || d!==1){
					m._bTransform=true;
					var tx=m.tx+_x,ty=m.ty+_y;
					vbdata[vpos+i]=(points[i]+x)*a+(points[i+1]+y)*c+tx;
					vbdata[vpos+i+1]=(points[i]+x)*b+(points[i+1]+y)*d+ty;
				}
				else{
					m._bTransform=false;
					x+=m.tx+_x;
					y+=m.ty+_y;
					vbdata[vpos+i]=x+points[i];
					vbdata[vpos+i+1]=y+points[i+1];
				}
			}
			vb._upload=true;
			return true;
		}

		GlUtils._fillLineArray=new Array(20);
		return GlUtils;
	})()


	//class laya.webgl.utils.MatirxArray
	var MatirxArray=(function(){
		function MatirxArray(){};
		__class(MatirxArray,'laya.webgl.utils.MatirxArray');
		MatirxArray.ArrayMul=function(a,b,o){
			if (!a){
				MatirxArray.copyArray(b,o);
				return;
			}
			if (!b){
				MatirxArray.copyArray(a,o);
				return;
			};
			var ai0=NaN,ai1=NaN,ai2=NaN,ai3=NaN;
			for (var i=0;i < 4;i++){
				ai0=a[i];
				ai1=a[i+4];
				ai2=a[i+8];
				ai3=a[i+12];
				o[i]=ai0 *b[0]+ai1 *b[1]+ai2 *b[2]+ai3 *b[3];
				o[i+4]=ai0 *b[4]+ai1 *b[5]+ai2 *b[6]+ai3 *b[7];
				o[i+8]=ai0 *b[8]+ai1 *b[9]+ai2 *b[10]+ai3 *b[11];
				o[i+12]=ai0 *b[12]+ai1 *b[13]+ai2 *b[14]+ai3 *b[15];
			}
		}

		MatirxArray.copyArray=function(f,t){
			if (!f)return;
			if (!t)return;
			for (var i=0;i < f.length;i++){
				t[i]=f[i];
			}
		}

		return MatirxArray;
	})()


	/**
	*Mesh2d只是保存数据。描述attribute用的。本身不具有渲染功能。
	*/
	//class laya.webgl.utils.Mesh2D
	var Mesh2D=(function(){
		function Mesh2D(stride,vballoc,iballoc){
			this._stride=0;
			this.vertNum=0;
			this.indexNum=0;
			this._applied=false;
			this._vb=null;
			this._ib=null;
			this._vao=null;
			this._attribInfo=null;
			this._quadNum=0;
			this._fixedib=false;
			this.canReuse=false;
			this._stride=stride;
			this._vb=new VertexBuffer2D(stride,0x88E8);
			if (vballoc){
				this._vb._resizeBuffer(vballoc,false);
				}else{
				Config.webGL2D_MeshAllocMaxMem && this._vb._resizeBuffer(64 *1024 *stride,false);
			}
			this._ib=new IndexBuffer2D();
			if (iballoc){
				this._ib._resizeBuffer(iballoc,false);
			}
		}

		__class(Mesh2D,'laya.webgl.utils.Mesh2D');
		var __proto=Mesh2D.prototype;
		/**
		*重新创建一个mesh。复用这个对象的vertex结构，ib对象和attribinfo对象
		*/
		__proto.cloneWithNewVB=function(){
			var mesh=new Mesh2D(this._stride,0,0);
			mesh._ib=this._ib;
			mesh._quadNum=this._quadNum;
			mesh._attribInfo=this._attribInfo;
			return mesh;
		}

		/**
		*创建一个mesh，使用当前对象的vertex结构。vb和ib自己提供。
		*@return
		*/
		__proto.cloneWithNewVBIB=function(){
			var mesh=new Mesh2D(this._stride,0,0);
			mesh._attribInfo=this._attribInfo;
			return mesh;
		}

		/**
		*获得一个可以写的vb对象
		*/
		__proto.getVBW=function(){
			this._vb.setNeedUpload();
			return this._vb;
		}

		/**
		*获得一个只读vb
		*/
		__proto.getVBR=function(){
			return this._vb;
		}

		__proto.getIBR=function(){
			return this._ib;
		}

		/**
		*获得一个可写的ib
		*/
		__proto.getIBW=function(){
			this._ib.setNeedUpload();
			return this._ib;
		}

		/**
		*直接创建一个固定的ib。按照固定四边形的索引。
		*@param var QuadNum
		*/
		__proto.createQuadIB=function(QuadNum){
			this._quadNum=QuadNum;
			this._ib._resizeBuffer(QuadNum *6 *2,false);
			this._ib.byteLength=this._ib.bufferLength;
			var bd=this._ib.getUint16Array();
			var idx=0;
			var curvert=0;
			for (var i=0;i < QuadNum;i++){
				bd[idx++]=curvert;
				bd[idx++]=curvert+2;
				bd[idx++]=curvert+1;
				bd[idx++]=curvert;
				bd[idx++]=curvert+3;
				bd[idx++]=curvert+2;
				curvert+=4;
			}
			this._ib.setNeedUpload();
		}

		/**
		*设置mesh的属性。每3个一组，对应的location分别是0,1,2...
		*含义是：type,size,offset
		*不允许多流。因此stride是固定的，offset只是在一个vertex之内。
		*@param attribs
		*/
		__proto.setAttributes=function(attribs){
			this._attribInfo=attribs;
			if (this._attribInfo.length % 3 !=0){
				throw 'Mesh2D setAttributes error!';
			}
		}

		/**
		*初始化VAO的配置，只需要执行一次。以后使用的时候直接bind就行
		*@param gl
		*/
		__proto.configVAO=function(gl){
			if (this._applied)
				return;
			this._applied=true;
			if (!this._vao){
				this._vao=gl.createVertexArray();;
			}
			gl.bindVertexArray(this._vao);;
			this._vb._bindForVAO();
			this._ib.setNeedUpload();
			this._ib._bind_uploadForVAO();
			var attribNum=this._attribInfo.length / 3;
			var idx=0;
			for (var i=0;i < attribNum;i++){
				var _size=this._attribInfo[idx+1];
				var _type=this._attribInfo[idx];
				var _off=this._attribInfo[idx+2];
				gl.enableVertexAttribArray(i);
				gl.vertexAttribPointer(i,_size,_type,false,this._stride,_off);
				idx+=3;
			}
			gl.bindVertexArray(null);;
		}

		/**
		*应用这个mesh
		*@param gl
		*/
		__proto.useMesh=function(gl){
			this._applied || this.configVAO(gl);
			if (Mesh2D._bindedVAO!==this._vao){
				gl.bindVertexArray(this._vao);;
				Mesh2D._bindedVAO=this._vao;
			}
			this._vb.bind();
			if(!this._fixedib){
				this._ib._bind_upload()|| this._ib.bind();
			}
			this._vb._bind_upload()|| this._vb.bind();
		}

		__proto.getEleNum=function(){
			return this._ib.getBuffer().byteLength / 2;
		}

		/**
		*子类实现。用来把自己放到对应的回收池中，以便复用。
		*/
		__proto.releaseMesh=function(){}
		/**
		*释放资源。
		*/
		__proto.destroy=function(){}
		/**
		*清理vb数据
		*/
		__proto.clearVB=function(){
			this._vb.clear();
		}

		Mesh2D._gvaoid=0;
		Mesh2D._bindedVAO=null
		return Mesh2D;
	})()


	//class laya.webgl.utils.RenderState2D
	var RenderState2D=(function(){
		function RenderState2D(){};
		__class(RenderState2D,'laya.webgl.utils.RenderState2D');
		RenderState2D.mat2MatArray=function(mat,matArray){
			var m=mat;
			var m4=matArray;
			m4[0]=m.a;
			m4[1]=m.b;
			m4[2]=RenderState2D.EMPTYMAT4_ARRAY[2];
			m4[3]=RenderState2D.EMPTYMAT4_ARRAY[3];
			m4[4]=m.c;
			m4[5]=m.d;
			m4[6]=RenderState2D.EMPTYMAT4_ARRAY[6];
			m4[7]=RenderState2D.EMPTYMAT4_ARRAY[7];
			m4[8]=RenderState2D.EMPTYMAT4_ARRAY[8];
			m4[9]=RenderState2D.EMPTYMAT4_ARRAY[9];
			m4[10]=RenderState2D.EMPTYMAT4_ARRAY[10];
			m4[11]=RenderState2D.EMPTYMAT4_ARRAY[11];
			m4[12]=m.tx;
			m4[13]=m.ty;
			m4[14]=RenderState2D.EMPTYMAT4_ARRAY[14];
			m4[15]=RenderState2D.EMPTYMAT4_ARRAY[15];
			return matArray;
		}

		RenderState2D.restoreTempArray=function(){
			RenderState2D.TEMPMAT4_ARRAY[0]=1;
			RenderState2D.TEMPMAT4_ARRAY[1]=0;
			RenderState2D.TEMPMAT4_ARRAY[4]=0;
			RenderState2D.TEMPMAT4_ARRAY[5]=1;
			RenderState2D.TEMPMAT4_ARRAY[12]=0;
			RenderState2D.TEMPMAT4_ARRAY[13]=0;
		}

		RenderState2D.clear=function(){
			RenderState2D.worldScissorTest=false;
			RenderState2D.worldAlpha=1;
			RenderState2D.curRenderTarget=null;
		}

		RenderState2D._MAXSIZE=99999999;
		RenderState2D.EMPTYMAT4_ARRAY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
		RenderState2D.TEMPMAT4_ARRAY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
		RenderState2D.worldMatrix4=RenderState2D.TEMPMAT4_ARRAY;
		RenderState2D.worldAlpha=1.0;
		RenderState2D.worldScissorTest=false;
		RenderState2D.curRenderTarget=null
		RenderState2D.width=0;
		RenderState2D.height=0;
		__static(RenderState2D,
		['worldMatrix',function(){return this.worldMatrix=new Matrix();}
		]);
		return RenderState2D;
	})()


	/**
	*@private
	*<code>ShaderCompile</code> 类用于实现Shader编译。
	*/
	//class laya.webgl.utils.ShaderCompile
	var ShaderCompile=(function(){
		var ShaderNode,InlcudeFile;
		function ShaderCompile(vs,ps,nameMap,defs){
			//this._nameMap=null;
			//this._VS=null;
			//this._PS=null;
			var _$this=this;
			function _compile (script){
				var includefiles=[];
				var top=new ShaderNode(includefiles);
				_$this._compileToTree(top,script.split('\n'),0,includefiles,defs);
				return top;
			};
			var startTime=Browser.now();
			this._VS=_compile(vs);
			this._PS=_compile(ps);
			this._nameMap=nameMap;
			if ((Browser.now()-startTime)> 2)
				console.log("ShaderCompile use time:"+(Browser.now()-startTime)+"  size:"+vs.length+"/"+ps.length);
		}

		__class(ShaderCompile,'laya.webgl.utils.ShaderCompile');
		var __proto=ShaderCompile.prototype;
		__proto._compileToTree=function(parent,lines,start,includefiles,defs){
			var node,preNode;
			var text,name,fname;
			var ofs=0,words,noUseNode;
			var i=0,n=0,j=0;
			for (i=start;i < lines.length;i++){
				text=lines[i];
				if (text.length < 1)continue ;
				ofs=text.indexOf("//");
				if (ofs===0)continue ;
				if (ofs >=0)text=text.substr(0,ofs);
				node=noUseNode || new ShaderNode(includefiles);
				noUseNode=null;
				node.text=text;
				node.noCompile=true;
				if ((ofs=text.indexOf("#"))>=0){
					name="#";
					for (j=ofs+1,n=text.length;j < n;j++){
						var c=text.charAt(j);
						if (c===' ' || c==='\t' || c==='?')break ;
						name+=c;
					}
					node.name=name;
					switch (name){
						case "#ifdef":
						case "#ifndef":
							node.src=text;
							node.noCompile=text.match(/[!&|()=<>]/)!=null;
							if (!node.noCompile){
								words=text.replace(/^\s*/,'').split(/\s+/);
								node.setCondition(words[1],name==="#ifdef" ? 1 :2);
								node.text="//"+node.text;
								}else {
								console.log("function():Boolean{return "+text.substr(ofs+node.name.length)+"}");
							}
							node.setParent(parent);
							parent=node;
							if (defs){
								words=text.substr(j).split(ShaderCompile._splitToWordExps3);
								for (j=0;j < words.length;j++){
									text=words[j];
									text.length && (defs[text]=true);
								}
							}
							continue ;
						case "#if":
							node.src=text;
							if (ShaderCompile.customCompile){
								node.noCompile=false;
								if (!node.noCompile){
									words=text.replace(/^\s*/,'').split(/\s+/);
									node.setCondition(words[1],4);
									node.text="//"+node.text;
								}
								}else {
								node.noCompile=true;
							}
							node.setParent(parent);
							parent=node;
							if (defs){
								words=text.substr(j).split(ShaderCompile._splitToWordExps3);
								for (j=0;j < words.length;j++){
									text=words[j];
									text.length && text !="defined" && (defs[text]=true);
								}
							}
							continue ;
						case "#else":
							node.src=text;
							parent=parent.parent;
							preNode=parent.childs[parent.childs.length-1];
							if (!(node.noCompile=preNode.noCompile)){
								node.condition=preNode.condition;
								node.conditionType=preNode.conditionType==1 ? 2 :1;
								node.text="//"+node.text+" "+preNode.text+" "+node.conditionType;
							}
							node.setParent(parent);
							parent=node;
							continue ;
						case "#endif":
							parent=parent.parent;
							preNode=parent.childs[parent.childs.length-1];
							if (!(node.noCompile=preNode.noCompile)){
								node.text="//"+node.text;
							}
							node.setParent(parent);
							continue ;
						case "#include":
							words=ShaderCompile.splitToWords(text,null);
							var inlcudeFile=ShaderCompile.includes[words[1]];
							if (!inlcudeFile){
								throw "ShaderCompile error no this include file:"+words[1];
								return;
							}
							if ((ofs=words[0].indexOf("?"))< 0){
								node.setParent(parent);
								text=inlcudeFile.getWith(words[2]=='with' ? words[3] :null);
								this._compileToTree(node,text.split('\n'),0,includefiles,defs);
								node.text="";
								continue ;
							}
							node.setCondition(words[0].substr(ofs+1),1);
							node.text=inlcudeFile.getWith(words[2]=='with' ? words[3] :null);
							break ;
						case "#import":
							words=ShaderCompile.splitToWords(text,null);
							fname=words[1];
							includefiles.push({node:node,file:ShaderCompile.includes[fname],ofs:node.text.length});
							continue ;
						}
					}else {
					preNode=parent.childs[parent.childs.length-1];
					if (preNode && !preNode.name){
						includefiles.length > 0 && ShaderCompile.splitToWords(text,preNode);
						noUseNode=node;
						preNode.text+="\n"+text;
						continue ;
					}
					includefiles.length > 0 && ShaderCompile.splitToWords(text,node);
				}
				node.setParent(parent);
			}
		}

		__proto.createShader=function(define,shaderName,createShader){
			var defMap={};
			var defineStr="";
			if (define){
				for (var i in define){
					defineStr+="#define "+i+"\n";
					defMap[i]=true;
				}
			};
			var vs=this._VS.toscript(defMap,[]);
			var ps=this._PS.toscript(defMap,[]);
			return (createShader || Shader.create)(defineStr+vs.join('\n'),defineStr+ps.join('\n'),shaderName,this._nameMap);
		}

		ShaderCompile._parseOne=function(attributes,uniforms,words,i,word,b){
			var one={type:ShaderCompile.shaderParamsMap[words[i+1]],name:words[i+2],size:isNaN(parseInt(words[i+3]))? 1 :parseInt(words[i+3])};
			if (ShaderCompile.customCompile){
				if (one.size > 1){
					one.name+="[0]";
				}
			}
			if (b){
				if (word=="attribute"){
					attributes.push(one);
					}else {
					uniforms.push(one);
				}
			}
			if (words[i+3]==':'){
				one.type=words[i+4];
				i+=2;
			}
			i+=2;
			return i;
		}

		ShaderCompile.addInclude=function(fileName,txt){
			if (!txt || txt.length===0)
				throw new Error("add shader include file err:"+fileName);
			if (ShaderCompile.includes[fileName])
				throw new Error("add shader include file err, has add:"+fileName);
			ShaderCompile.includes[fileName]=new InlcudeFile(txt);
		}

		ShaderCompile.preGetParams=function(vs,ps){
			var text=[vs,ps];
			var result={};
			var attributes=[];
			var uniforms=[];
			var definesInfo={};
			var definesName=[];
			result.attributes=attributes;
			result.uniforms=uniforms;
			result.defines=definesInfo;
			var i=0,n=0,one;
			for (var s=0;s < 2;s++){
				text[s]=text[s].replace(ShaderCompile._removeAnnotation,"");
				var words=text[s].match(ShaderCompile._reg);
				var tempelse;
				for (i=0,n=words.length;i < n;i++){
					var word=words[i];
					if (word !="attribute" && word !="uniform"){
						if (word=="#define"){
							word=words[++i];
							definesName[word]=1;
							continue ;
							}else if (word=="#ifdef"){
							tempelse=words[++i];
							var def=definesInfo[tempelse]=definesInfo[tempelse] || [];
							for (i++;i < n;i++){
								word=words[i];
								if (word !="attribute" && word !="uniform"){
									if (word=="#else"){
										for (i++;i < n;i++){
											word=words[i];
											if (word !="attribute" && word !="uniform"){
												if (word=="#endif"){
													break ;
												}
												continue ;
											}
											i=ShaderCompile._parseOne(attributes,uniforms,words,i,word,!definesName[tempelse]);
										}
									}
									continue ;
								}
								i=ShaderCompile._parseOne(attributes,uniforms,words,i,word,definesName[tempelse]);
							}
						}
						continue ;
					}
					i=ShaderCompile._parseOne(attributes,uniforms,words,i,word,true);
				}
			}
			return result;
		}

		ShaderCompile.splitToWords=function(str,block){
			var out=[];
			var c;
			var ofs=-1;
			var word;
			for (var i=0,n=str.length;i < n;i++){
				c=str.charAt(i);
				if (" \t=+-*/&%!<>()'\",;".indexOf(c)>=0){
					if (ofs >=0 && (i-ofs)> 1){
						word=str.substr(ofs,i-ofs);
						out.push(word);
					}
					if (c=='"' || c=="'"){
						var ofs2=str.indexOf(c,i+1);
						if (ofs2 < 0){
							throw "Sharder err:"+str;
							return;
						}
						out.push(str.substr(i+1,ofs2-i-1));
						i=ofs2;
						ofs=-1;
						continue ;
					}
					if (c=='(' && block && out.length > 0){
						word=out[out.length-1]+";";
						if ("vec4;main;".indexOf(word)< 0)
							block.useFuns+=word;
					}
					ofs=-1;
					continue ;
				}
				if (ofs < 0)ofs=i;
			}
			if (ofs < n && (n-ofs)> 1){
				word=str.substr(ofs,n-ofs);
				out.push(word);
			}
			return out;
		}

		ShaderCompile.customCompile=false;
		ShaderCompile.IFDEF_NO=0;
		ShaderCompile.IFDEF_YES=1;
		ShaderCompile.IFDEF_ELSE=2;
		ShaderCompile.IFDEF_PARENT=3;
		ShaderCompile.IFDEF_NORMALYES=4;
		ShaderCompile._removeAnnotation=new RegExp("(/\\*([^*]|[\\r\\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+/)|(//.*)","g");
		ShaderCompile._reg=new RegExp("(\".*\")|('.*')|([#\\w\\*-\\.+/()=<>{}\\\\]+)|([,;:\\\\])","g");
		ShaderCompile._splitToWordExps=new RegExp("[(\".*\")]+|[('.*')]+|([ \\t=\\+\\-*/&%!<>!%\(\),;])","g");
		ShaderCompile.includes={};
		__static(ShaderCompile,
		['shaderParamsMap',function(){return this.shaderParamsMap={"float":0x1406,"int":0x1404,"bool":0x8B56,"vec2":0x8B50,"vec3":0x8B51,"vec4":0x8B52,"ivec2":0x8B53,"ivec3":0x8B54,"ivec4":0x8B55,"bvec2":0x8B57,"bvec3":0x8B58,"bvec4":0x8B59,"mat2":0x8B5A,"mat3":0x8B5B,"mat4":0x8B5C,"sampler2D":0x8B5E,"samplerCube":0x8B60};},'_splitToWordExps3',function(){return this._splitToWordExps3=new RegExp("[ \\t=\\+\\-*/&%!<>!%\(\),;\\|]","g");}
		]);
		ShaderCompile.__init$=function(){
			//class ShaderNode
			ShaderNode=(function(){
				function ShaderNode(includefiles){
					this.childs=[];
					this.text="";
					this.parent=null;
					this.name=null;
					this.noCompile=false;
					this.includefiles=null;
					this.condition=null;
					this.conditionType=0;
					this.useFuns="";
					this.z=0;
					this.src=null;
					this.includefiles=includefiles;
				}
				__class(ShaderNode,'');
				var __proto=ShaderNode.prototype;
				__proto.setParent=function(parent){
					parent.childs.push(this);
					this.z=parent.z+1;
					this.parent=parent;
				}
				//customCompile
				__proto.setCondition=function(condition,type){
					if (condition){
						this.conditionType=type;
						if (ShaderCompile.customCompile){
							if (type==4){
								if (!Browser.window.conditionSlef){
									Browser.window.conditionSlef=function (a){
										return a;
									}
								}
								condition=condition.replace(/(defined\()/g,"conditionSlef(this.");
								this.condition=function (){
									return eval(condition);
								}
								this.condition.__condition=condition;
								return;
							}
						}
						condition=condition.replace(/(\s*$)/g,"");
						this.condition=function (){
							return this[condition];
						}
						this.condition.__condition=condition;
					}
				}
				__proto.toscript=function(def,out){
					return this._toscript(def,out,++ShaderNode.__id);
				}
				__proto._toscript=function(def,out,id){
					if (this.childs.length < 1 && !this.text)return out;
					var outIndex=out.length;
					if (this.condition){
						var ifdef=!!this.condition.call(def);
						this.conditionType===2 && (ifdef=!ifdef);
						if (!ifdef)return out;
					}
					this.text && out.push(this.text);
					this.childs.length > 0 && this.childs.forEach(function(o,index,arr){
						o._toscript(def,out,id);
					});
					if (this.includefiles.length > 0 && this.useFuns.length > 0){
						var funsCode;
						for (var i=0,n=this.includefiles.length;i < n;i++){
							if (this.includefiles[i].curUseID==id){
								continue ;
							}
							funsCode=this.includefiles[i].file.getFunsScript(this.useFuns);
							if (funsCode.length > 0){
								this.includefiles[i].curUseID=id;
								out[0]=funsCode+out[0];
							}
						}
					}
					return out;
				}
				ShaderNode.__id=1;
				__static(ShaderNode,
				['wordReg',function(){return this.wordReg=new RegExp("","g");}
				]);
				return ShaderNode;
			})()
			//class InlcudeFile
			InlcudeFile=(function(){
				function InlcudeFile(txt){
					this.script=null;
					this.codes={};
					this.funs={};
					this.curUseID=-1;
					this.funnames="";
					this.script=txt;
					var begin=0,ofs=0,end=0;
					while (true){
						begin=txt.indexOf("#begin",begin);
						if (begin < 0)break ;
						end=begin+5;
						while (true){
							end=txt.indexOf("#end",end);
							if (end < 0)break ;
							if (txt.charAt(end+4)==='i')
								end+=5;
							else break ;
						}
						if (end < 0){
							throw "add include err,no #end:"+txt;
							return;
						}
						ofs=txt.indexOf('\n',begin);
						var words=ShaderCompile.splitToWords(txt.substr(begin,ofs-begin),null);
						if (words[1]=='code'){
							this.codes[words[2]]=txt.substr(ofs+1,end-ofs-1);
							}else if (words[1]=='function'){
							ofs=txt.indexOf("function",begin);
							ofs+="function".length;
							this.funs[words[3]]=txt.substr(ofs+1,end-ofs-1);
							this.funnames+=words[3]+";";
						}
						begin=end+1;
					}
				}
				__class(InlcudeFile,'');
				var __proto=InlcudeFile.prototype;
				__proto.getWith=function(name){
					var r=name ? this.codes[name] :this.script;
					if (!r){
						throw "get with error:"+name;
					}
					return r;
				}
				__proto.getFunsScript=function(funsdef){
					var r="";
					for (var i in this.funs){
						if (funsdef.indexOf(i+";")>=0){
							r+=this.funs[i];
						}
					}
					return r;
				}
				return InlcudeFile;
			})()
		}

		return ShaderCompile;
	})()


	/**
	*@private
	*/
	//class laya.webgl.WebGL
	var WebGL=(function(){
		function WebGL(){};
		__class(WebGL,'laya.webgl.WebGL');
		WebGL._uint8ArraySlice=function(){
			var _this=this;
			var sz=_this.length;
			var dec=new Uint8Array(_this.length);
			for (var i=0;i < sz;i++)dec[i]=_this[i];
			return dec;
		}

		WebGL._float32ArraySlice=function(){
			var _this=this;
			var sz=_this.length;
			var dec=new Float32Array(_this.length);
			for (var i=0;i < sz;i++)dec[i]=_this[i];
			return dec;
		}

		WebGL._uint16ArraySlice=function(__arg){
			var arg=arguments;
			var _this=this;
			var sz=0;
			var dec;
			var i=0;
			if (arg.length===0){
				sz=_this.length;
				dec=new Uint16Array(sz);
				for (i=0;i < sz;i++)
				dec[i]=_this[i];
				}else if (arg.length===2){
				var start=arg[0];
				var end=arg[1];
				if (end > start){
					sz=end-start;
					dec=new Uint16Array(sz);
					for (i=start;i < end;i++)
					dec[i-start]=_this[i];
					}else {
					dec=new Uint16Array(0);
				}
			}
			return dec;
		}

		WebGL.expandContext=function(){
			var from=Context.prototype;
			var to=CanvasRenderingContext2D.prototype;
			to.fillTrangles=from.fillTrangles;
			Buffer2D.__int__(null);
			to.setIBVB=function (x,y,ib,vb,numElement,mat,shader,shaderValues,startIndex,offset){
				(startIndex===void 0)&& (startIndex=0);
				(offset===void 0)&& (offset=0);
				if (ib===null){
					this._ib=this._ib || IndexBuffer2D.QuadrangleIB;
					ib=this._ib;
					GlUtils.expandIBQuadrangle(ib,(vb.byteLength / (4 *16)+8));
				}
				this._setIBVB(x,y,ib,vb,numElement,mat,shader,shaderValues,startIndex,offset);
			};
			to.fillTrangles=function (tex,x,y,points,m){
				this._curMat=this._curMat || Matrix.create();
				this._vb=this._vb || VertexBuffer2D.create();
				if (!this._ib){
					this._ib=IndexBuffer2D.create();
					GlUtils.fillIBQuadrangle(this._ib,length / 4);
				};
				var vb=this._vb;
				var length=points.length >> 4;
				GlUtils.fillTranglesVB(vb,x,y,points,m || this._curMat,0,0);
				GlUtils.expandIBQuadrangle(this._ib,(vb.byteLength / (4 *16)+8));
				var shaderValues=new Value2D(0x01,0);
				shaderValues.textureHost=tex;
				var sd=new Shader2X("attribute vec2 position; attribute vec2 texcoord; uniform vec2 size; uniform mat4 mmat; varying vec2 v_texcoord; void main() { vec4 p=vec4(position.xy,0.0,1.0);vec4 pos=mmat*p; gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0); v_texcoord = texcoord; }","precision mediump float; varying vec2 v_texcoord; uniform sampler2D texture; void main() {vec4 color= texture2D(texture, v_texcoord); color.a*=1.0; gl_FragColor= color;}");
				vb._vertType=3;
				this._setIBVB(x,y,this._ib,vb,length *6,m,sd,shaderValues,0,0);
			}
		}

		WebGL.enable=function(){
			Browser.__init__();
			if (Render.isConchApp){
				HTMLImage.create=function (src,def){
					return new Texture2D(1,true,false);
				}
				return true;
			}
			function getWebGLContext (canvas){
				var gl;
				var names=["webgl","experimental-webgl","webkit-3d","moz-webgl"];
				for (var i=0;i < names.length;i++){
					try {
						gl=canvas.getContext(names[i],{stencil:Config.isStencil,alpha:Config.isAlpha,antialias:Config.isAntialias,premultipliedAlpha:Config.premultipliedAlpha,preserveDrawingBuffer:Config.preserveDrawingBuffer});
					}catch (e){}
					if (gl){
						(i!==0)&& (WebGL._isExperimentalWebgl=true);
						new LayaGL(gl);
						return gl;
					}
				}
				return null;
			}
			WebGL.mainContext=getWebGLContext(Render._mainCanvas);
			if (WebGL.mainContext==null)
				return false;
			if (Render.isWebGL)return true;
			var gl=WebGL.mainContext;
			WebGLContext.__init__(gl);
			if (!(gl instanceof WebGLRenderingContext)){
				ext=gl.rawgl.getExtension("OES_vertex_array_object");
				}else{
				var ext=gl.getExtension("OES_vertex_array_object");
			}
			if (ext){
				console.log("EXT:webgl support OES_vertex_array_object！");
				gl.createVertexArray=function(){return ext.createVertexArrayOES();};
				gl.bindVertexArray=function(vao){ext.bindVertexArrayOES(vao);};
				}else {
				gl.createVertexArray=function(){throw "not implemented";};;
				gl.bindVertexArray=function(){throw "not implemented";};;
			}
			HTMLImage.create=function (src,def){
				return new Texture2D(1,true,false);
			}
			Render.WebGL=WebGL;
			Render.isWebGL=true;
			DrawText.__init__();
			RunDriver.createRenderSprite=function (type,next){
				return new RenderSprite3D(type,next);
			}
			RunDriver.createWebGLContext2D=function (c){
				return new WebGLContext2D(c);
			}
			RunDriver.changeWebGLSize=function (width,height){
				laya.webgl.WebGL.onStageResize(width,height);
			}
			RunDriver.createGraphics=function (){
				return new GraphicsGL();
			};
			var action=RunDriver.createFilterAction;
			RunDriver.createFilterAction=action ? action :function (type){
				return new ColorFilterActionGL()
			}
			RunDriver.clear=function (color){
				RenderState2D.worldScissorTest && laya.webgl.WebGL.mainContext.disable(0x0C11);
				var ctx=Render.context;
				var c=(ctx._submits._length==0 || Config.preserveDrawingBuffer)? Color.create(color).arrColor :Laya.stage._wgColor;
				if (c)ctx.clearBG(c[0],c[1],c[2],c[3]);
				RenderState2D.clear();
			}
			RunDriver.drawToCanvas=function (sprite,_renderType,canvasWidth,canvasHeight,offsetX,offsetY){
				debugger;
			}
			RunDriver.createFilterAction=function (type){
				var action;
				switch (type){
					case 0x20:
						action=new ColorFilterActionGL();
						break ;
					}
				return action;
			}
			RunDriver.getTexturePixels=function (value,x,y,width,height){
				(Render.context).clear();
				var tSprite=new Sprite();
				tSprite.graphics.drawImage(value,-x,-y);
				var tRenderTarget=laya.webgl.resource.RenderTarget2D.create(width,height);
				tRenderTarget.start();
				tRenderTarget.clear(0,0,0,0);
				tSprite.render(Render.context,0,0);
				(Render.context).flush();
				tRenderTarget.end();
				var tUint8Array=tRenderTarget.getData(0,0,width,height);
				var tArray=[];
				var tIndex=0;
				for (var i=height-1;i >=0;i--){
					for (var j=0;j < width;j++){
						tIndex=(i *width+j)*4;
						tArray.push(tUint8Array[tIndex]);
						tArray.push(tUint8Array[tIndex+1]);
						tArray.push(tUint8Array[tIndex+2]);
						tArray.push(tUint8Array[tIndex+3]);
					}
				}
				return tArray;
			}
			RunDriver.skinAniSprite=function (){
				var tSkinSprite=new SkinMesh()
				return tSkinSprite;
			}
			Filter._recycleScope=function (scope){
				scope.recycle();
			}
			Filter._filter2=function (sprite,context,x,y){
				var next=this._next;
				if (next){
					var filters=sprite.filters,len=filters.length;
					if (len==1 && (filters[0].type==0x20)){
						context.save();
						context.setFilters([filters[0]]);
						next._fun.call(next,sprite,context,x,y);
						context.restore();
						return;
					};
					var mainCtx=context;
					var mainSubmits=mainCtx._submits;
					var sp=sprite;
					var spctx=sp._cacheStyle.canvas.context;
					var tMatrix=context._getTransformMatrix();
					var out=sprite._$P._filterCache ? sprite._$P._filterCache :null;
					if (!out || sprite._repaint){
						var bbx=sprite.getSelfBounds();
						var rtw=bbx.width,rth=bbx.height;
						var temp=WebGLRTMgr.getRT(rtw,rth);
						var tHalfPadding=0;
						var tX=sprite.x-x+tHalfPadding;
						var tY=sprite.y-y+tHalfPadding;
						next._fun.call(next,sprite,context,tX,tY);
						sprite._set$P('_filterCache',out);
					}else {}
				}
			}
			Filter._filter=function (sprite,context,x,y){
				var next=this._next;
				if (next){
					var filters=sprite.filters,len=filters.length;
					if (len==1 && (filters[0].type==0x20)){
						context.save();
						context.setFilters([filters[0]]);
						next._fun.call(next,sprite,context,x,y);
						context.restore();
						return;
					};
					var shaderValue;
					var b;
					var scope=SubmitCMDScope.create();
					var p=Point.TEMP;
					var tMatrix=context._getTransformMatrix();
					var mat=Matrix.create();
					tMatrix.copyTo(mat);
					var tPadding=0;
					var tHalfPadding=0;
					var tIsHaveGlowFilter=false;
					var out=sprite._$P._filterCache ? sprite._$P._filterCache :null;
					if (!out || sprite._repaint){
						tIsHaveGlowFilter=sprite._isHaveGlowFilter();
						scope.addValue("_isHaveGlowFilter",tIsHaveGlowFilter);
						if (tIsHaveGlowFilter){
							tPadding=50;
							tHalfPadding=25;
						}
						b=new Rectangle();
						b.copyFrom((sprite).getSelfBounds());
						b.x+=(sprite).x;
						b.y+=(sprite).y;
						b.x-=(sprite).pivotX+4;
						b.y-=(sprite).pivotY+4;
						var tSX=b.x;
						var tSY=b.y;
						b.width+=(tPadding+8);
						b.height+=(tPadding+8);
						p.x=b.x *mat.a+b.y *mat.c;
						p.y=b.y *mat.d+b.x *mat.b;
						b.x=p.x;
						b.y=p.y;
						p.x=b.width *mat.a+b.height *mat.c;
						p.y=b.height *mat.d+b.width *mat.b;
						b.width=p.x;
						b.height=p.y;
						if (b.width <=0 || b.height <=0){
							return;
						}
						out && WebGLRTMgr.releaseRT(out);
						scope.addValue("bounds",b);
						var source=WebGLRTMgr.getRT(b.width,b.height);
						scope.addValue("src",source);
						var outRT=WebGLRTMgr.getRT(b.width,b.height);
						scope.addValue("out",outRT);
						sprite._set$P('_filterCache',out);
						var webglctx=context;
						webglctx.pushRT();
						webglctx.useRT(source);
						var tX=sprite.x-tSX+tHalfPadding;
						var tY=sprite.y-tSY+tHalfPadding;
						next._fun.call(next,sprite,context,tX,tY);
						webglctx.useRT(outRT);
						for (var i=0;i < len;i++){
							if (i !=0){
								webglctx.useRT(source);
								shaderValue=Value2D.create(0x01,0);
								Matrix.TEMP.identity();
								webglctx.drawTarget(scope,0,0,b.width,b.height,Matrix.TEMP,"out",shaderValue,null,BlendMode.TOINT.overlay);
								webglctx.useRT(outRT);
							};
							var fil=filters[i];
							fil.action.apply3d(scope,sprite,context,0,0);
						}
						webglctx.popRT();
						}else {
						tIsHaveGlowFilter=sprite._$P._isHaveGlowFilter ? sprite._$P._isHaveGlowFilter :false;
						if (tIsHaveGlowFilter){
							tPadding=50;
							tHalfPadding=25;
						}
						b=sprite.getBounds();
						if (b.width <=0 || b.height <=0){
							return;
						}
						b.width+=tPadding;
						b.height+=tPadding;
						p.x=b.x *mat.a+b.y *mat.c;
						p.y=b.y *mat.d+b.x *mat.b;
						b.x=p.x;
						b.y=p.y;
						p.x=b.width *mat.a+b.height *mat.c;
						p.y=b.height *mat.d+b.width *mat.b;
						b.width=p.x;
						b.height=p.y;
						scope.addValue("out",out);
					}
					x=x-tHalfPadding-sprite.x;
					y=y-tHalfPadding-sprite.y;
					p.setTo(x,y);
					mat.transformPoint(p);
					x=p.x+b.x;
					y=p.y+b.y;
					shaderValue=Value2D.create(0x01,0);
					Matrix.TEMP.identity();
					webglctx._drawRenderTexture(outRT,x,y,b.width,b.height,Matrix.TEMP,1.0,RenderTexture.defuv);
					var submit=SubmitCMD.create([scope],Filter._recycleScope);
					context.addRenderObject(submit);
					mat.destroy();
				}
			}
			Float32Array.prototype.slice || (Float32Array.prototype.slice=WebGL._float32ArraySlice);
			Uint16Array.prototype.slice || (Uint16Array.prototype.slice=WebGL._uint16ArraySlice);
			Uint8Array.prototype.slice || (Uint8Array.prototype.slice=WebGL._uint8ArraySlice);
			return true;
		}

		WebGL.onStageResize=function(width,height){
			if (WebGL.mainContext==null)return;
			WebGL.mainContext.viewport(0,0,width,height);
			RenderState2D.width=width;
			RenderState2D.height=height;
		}

		WebGL.isExperimentalWebgl=function(){
			return WebGL._isExperimentalWebgl;
		}

		WebGL.onInvalidGLRes=function(){
			ResourceManager.releaseContentManagers(true);
			WebGL.doNodeRepaint(Laya.stage);
			WebGL.mainContext.viewport(0,0,RenderState2D.width,RenderState2D.height);
			Laya.stage.event("devicelost");
		}

		WebGL.doNodeRepaint=function(sprite){
			(sprite.numChildren==0)&& (sprite.repaint());
			for (var i=0;i < sprite.numChildren;i++)
			WebGL.doNodeRepaint(sprite.getChildAt(i));
		}

		WebGL.init=function(canvas,width,height){
			WebGL.mainCanvas=canvas;
			HTMLCanvas._createContext=function (canvas){
				return new WebGLContext2D(canvas);
			}
			WebGL._isExperimentalWebgl=(WebGL._isExperimentalWebgl && (Browser.onWeiXin || Browser.onMQQBrowser));
			WebGL.shaderHighPrecision=false;
			var gl=laya.webgl.WebGL.mainContext;
			try {
				var precisionFormat=gl.getShaderPrecisionFormat(0x8B30,0x8DF2);
				precisionFormat.precision ? WebGL.shaderHighPrecision=true :WebGL.shaderHighPrecision=false;
			}catch (e){}
			gl.deleteTexture1=gl.deleteTexture;
			gl.deleteTexture=function (t){
				if (t==WebGLContext.curBindTexValue){
					WebGLContext.curBindTexValue=null;
				}
				gl.deleteTexture1(t);
			}
			WebGL.onStageResize(width,height);
			if (WebGL.mainContext==null)
				throw new Error("webGL getContext err!");
			System.__init__();
			ShaderDefines2D.__init__();
			Submit.__init__();
			WebGLContext2D.__init__();
			Value2D.__init__();
			Shader2D.__init__();
			Buffer2D.__int__(gl);
			BlendMode._init_(gl);
		}

		WebGL.mainCanvas=null
		WebGL.mainContext=null
		WebGL.antialias=true;
		WebGL.shaderHighPrecision=false;
		WebGL._bg_null=[0,0,0,0];
		WebGL._isExperimentalWebgl=false;
		return WebGL;
	})()


	//class laya.webgl.WebGLContext
	var WebGLContext=(function(){
		function WebGLContext(){};
		__class(WebGLContext,'laya.webgl.WebGLContext');
		var __proto=WebGLContext.prototype;
		__proto.getContextAttributes=function(){return null;}
		__proto.isContextLost=function(){}
		__proto.getSupportedExtensions=function(){return null;}
		__proto.getExtension=function(name){return null;}
		__proto.activeTexture=function(texture){}
		__proto.attachShader=function(program,shader){}
		__proto.bindAttribLocation=function(program,index,name){}
		__proto.bindBuffer=function(target,buffer){}
		__proto.bindFramebuffer=function(target,framebuffer){}
		__proto.bindRenderbuffer=function(target,renderbuffer){}
		__proto.bindTexture=function(target,texture){}
		__proto.useTexture=function(value){}
		__proto.blendColor=function(red,green,blue,alpha){}
		__proto.blendEquation=function(mode){}
		__proto.blendEquationSeparate=function(modeRGB,modeAlpha){}
		__proto.blendFunc=function(sfactor,dfactor){}
		__proto.blendFuncSeparate=function(srcRGB,dstRGB,srcAlpha,dstAlpha){}
		__proto.bufferData=function(target,size,usage){}
		__proto.bufferSubData=function(target,offset,data){}
		__proto.checkFramebufferStatus=function(target){return null;}
		__proto.clear=function(mask){}
		__proto.clearColor=function(red,green,blue,alpha){}
		__proto.clearDepth=function(depth){}
		__proto.clearStencil=function(s){}
		__proto.colorMask=function(red,green,blue,alpha){}
		__proto.compileShader=function(shader){}
		__proto.copyTexImage2D=function(target,level,internalformat,x,y,width,height,border){}
		__proto.copyTexSubImage2D=function(target,level,xoffset,yoffset,x,y,width,height){}
		__proto.createBuffer=function(){}
		__proto.createFramebuffer=function(){}
		__proto.createProgram=function(){}
		__proto.createRenderbuffer=function(){}
		__proto.createShader=function(type){}
		__proto.createTexture=function(){return null}
		__proto.cullFace=function(mode){}
		__proto.deleteBuffer=function(buffer){}
		__proto.deleteFramebuffer=function(framebuffer){}
		__proto.deleteProgram=function(program){}
		__proto.deleteRenderbuffer=function(renderbuffer){}
		__proto.deleteShader=function(shader){}
		__proto.deleteTexture=function(texture){}
		__proto.depthFunc=function(func){}
		__proto.depthMask=function(flag){}
		__proto.depthRange=function(zNear,zFar){}
		__proto.detachShader=function(program,shader){}
		__proto.disable=function(cap){}
		__proto.disableVertexAttribArray=function(index){}
		__proto.drawArrays=function(mode,first,count){}
		__proto.drawElements=function(mode,count,type,offset){}
		__proto.enable=function(cap){}
		__proto.enableVertexAttribArray=function(index){}
		__proto.finish=function(){}
		__proto.flush=function(){}
		__proto.framebufferRenderbuffer=function(target,attachment,renderbuffertarget,renderbuffer){}
		__proto.framebufferTexture2D=function(target,attachment,textarget,texture,level){}
		__proto.frontFace=function(mode){return null;}
		__proto.generateMipmap=function(target){return null;}
		__proto.getActiveAttrib=function(program,index){return null;}
		__proto.getActiveUniform=function(program,index){return null;}
		__proto.getAttribLocation=function(program,name){return 0;}
		__proto.getParameter=function(pname){return null;}
		__proto.getBufferParameter=function(target,pname){return null;}
		__proto.getError=function(){return null;}
		__proto.getFramebufferAttachmentParameter=function(target,attachment,pname){}
		__proto.getProgramParameter=function(program,pname){return 0;}
		__proto.getProgramInfoLog=function(program){return null;}
		__proto.getRenderbufferParameter=function(target,pname){return null;}
		__proto.getShaderPrecisionFormat=function(__arg){
			var arg=arguments;return null;}
		__proto.getShaderParameter=function(shader,pname){}
		__proto.getShaderInfoLog=function(shader){return null;}
		__proto.getShaderSource=function(shader){return null;}
		__proto.getTexParameter=function(target,pname){}
		__proto.getUniform=function(program,location){}
		__proto.getUniformLocation=function(program,name){return null;}
		__proto.getVertexAttrib=function(index,pname){return null;}
		__proto.getVertexAttribOffset=function(index,pname){return null;}
		__proto.hint=function(target,mode){}
		__proto.isBuffer=function(buffer){}
		__proto.isEnabled=function(cap){}
		__proto.isFramebuffer=function(framebuffer){}
		__proto.isProgram=function(program){}
		__proto.isRenderbuffer=function(renderbuffer){}
		__proto.isShader=function(shader){}
		__proto.isTexture=function(texture){}
		__proto.lineWidth=function(width){}
		__proto.linkProgram=function(program){}
		__proto.pixelStorei=function(pname,param){}
		__proto.polygonOffset=function(factor,units){}
		__proto.readPixels=function(x,y,width,height,format,type,pixels){}
		__proto.renderbufferStorage=function(target,internalformat,width,height){}
		__proto.sampleCoverage=function(value,invert){}
		__proto.scissor=function(x,y,width,height){}
		__proto.shaderSource=function(shader,source){}
		__proto.stencilFunc=function(func,ref,mask){}
		__proto.stencilFuncSeparate=function(face,func,ref,mask){}
		__proto.stencilMask=function(mask){}
		__proto.stencilMaskSeparate=function(face,mask){}
		__proto.stencilOp=function(fail,zfail,zpass){}
		__proto.stencilOpSeparate=function(face,fail,zfail,zpass){}
		__proto.texImage2D=function(__args){}
		__proto.texParameterf=function(target,pname,param){}
		__proto.texParameteri=function(target,pname,param){}
		__proto.texSubImage2D=function(__args){}
		__proto.uniform1f=function(location,x){}
		__proto.uniform1fv=function(location,v){}
		__proto.uniform1i=function(location,x){}
		__proto.uniform1iv=function(location,v){}
		__proto.uniform2f=function(location,x,y){}
		__proto.uniform2fv=function(location,v){}
		__proto.uniform2i=function(location,x,y){}
		__proto.uniform2iv=function(location,v){}
		__proto.uniform3f=function(location,x,y,z){}
		__proto.uniform3fv=function(location,v){}
		__proto.uniform3i=function(location,x,y,z){}
		__proto.uniform3iv=function(location,v){}
		__proto.uniform4f=function(location,x,y,z,w){}
		__proto.uniform4fv=function(location,v){}
		__proto.uniform4i=function(location,x,y,z,w){}
		__proto.uniform4iv=function(location,v){}
		__proto.uniformMatrix2fv=function(location,transpose,value){}
		__proto.uniformMatrix3fv=function(location,transpose,value){}
		__proto.uniformMatrix4fv=function(location,transpose,value){}
		__proto.useProgram=function(program){}
		__proto.validateProgram=function(program){}
		__proto.vertexAttrib1f=function(indx,x){}
		__proto.vertexAttrib1fv=function(indx,values){}
		__proto.vertexAttrib2f=function(indx,x,y){}
		__proto.vertexAttrib2fv=function(indx,values){}
		__proto.vertexAttrib3f=function(indx,x,y,z){}
		__proto.vertexAttrib3fv=function(indx,values){}
		__proto.vertexAttrib4f=function(indx,x,y,z,w){}
		__proto.vertexAttrib4fv=function(indx,values){}
		__proto.vertexAttribPointer=function(indx,size,type,normalized,stride,offset){}
		__proto.viewport=function(x,y,width,height){}
		__proto.configureBackBuffer=function(width,height,antiAlias,enableDepthAndStencil,wantsBestResolution){
			(enableDepthAndStencil===void 0)&& (enableDepthAndStencil=true);
			(wantsBestResolution===void 0)&& (wantsBestResolution=false);
		}

		__proto.compressedTexImage2D=function(__args){}
		WebGLContext.__init__=function(gl){
			WebGLContext.extTextureFilterAnisotropic=(gl.getExtension('EXT_texture_filter_anisotropic')|| gl.getExtension('MOZ_EXT_texture_filter_anisotropic')|| gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic'));
		}

		WebGLContext.useProgram=function(gl,program){
			if (WebGLContext._useProgram===program)
				return false;
			gl.useProgram(program);
			WebGLContext._useProgram=program;
			return true;
		}

		WebGLContext.setDepthTest=function(gl,value){
			value!==WebGLContext._depthTest && (WebGLContext._depthTest=value,value?gl.enable(0x0B71):gl.disable(0x0B71));
		}

		WebGLContext.setDepthMask=function(gl,value){
			value!==WebGLContext._depthMask && (WebGLContext._depthMask=value,gl.depthMask(value));
		}

		WebGLContext.setDepthFunc=function(gl,value){
			value!==WebGLContext._depthFunc && (WebGLContext._depthFunc=value,gl.depthFunc(value));
		}

		WebGLContext.setBlend=function(gl,value){
			value!==WebGLContext._blend && (WebGLContext._blend=value,value?gl.enable(0x0BE2):gl.disable(0x0BE2));
		}

		WebGLContext.setBlendFunc=function(gl,sFactor,dFactor){
			(sFactor!==WebGLContext._sFactor||dFactor!==WebGLContext._dFactor)&& (WebGLContext._sFactor=sFactor,WebGLContext._dFactor=dFactor,gl.blendFunc(sFactor,dFactor));
		}

		WebGLContext.setCullFace=function(gl,value){
			value!==WebGLContext._cullFace && (WebGLContext._cullFace=value,value?gl.enable(0x0B44):gl.disable(0x0B44));
		}

		WebGLContext.setFrontFace=function(gl,value){
			value!==WebGLContext._frontFace && (WebGLContext._frontFace=value,gl.frontFace(value));
		}

		WebGLContext.activeTexture=function(gl,textureID){
			if (WebGLContext._activedTextureID!==textureID){
				gl.activeTexture(textureID);
				WebGLContext._activedTextureID=textureID;
			}
		}

		WebGLContext.bindTexture=function(gl,target,texture){
			if (WebGLContext._activeTextures[WebGLContext._activedTextureID-0x84C0]!==texture){
				gl.bindTexture(target,texture);
				WebGLContext._activeTextures[WebGLContext._activedTextureID-0x84C0]=texture;
			}
		}

		WebGLContext.DEPTH_BUFFER_BIT=0x00000100;
		WebGLContext.STENCIL_BUFFER_BIT=0x00000400;
		WebGLContext.COLOR_BUFFER_BIT=0x00004000;
		WebGLContext.POINTS=0x0000;
		WebGLContext.LINES=0x0001;
		WebGLContext.LINE_LOOP=0x0002;
		WebGLContext.LINE_STRIP=0x0003;
		WebGLContext.TRIANGLES=0x0004;
		WebGLContext.TRIANGLE_STRIP=0x0005;
		WebGLContext.TRIANGLE_FAN=0x0006;
		WebGLContext.ZERO=0;
		WebGLContext.ONE=1;
		WebGLContext.SRC_COLOR=0x0300;
		WebGLContext.ONE_MINUS_SRC_COLOR=0x0301;
		WebGLContext.SRC_ALPHA=0x0302;
		WebGLContext.ONE_MINUS_SRC_ALPHA=0x0303;
		WebGLContext.DST_ALPHA=0x0304;
		WebGLContext.ONE_MINUS_DST_ALPHA=0x0305;
		WebGLContext.DST_COLOR=0x0306;
		WebGLContext.ONE_MINUS_DST_COLOR=0x0307;
		WebGLContext.SRC_ALPHA_SATURATE=0x0308;
		WebGLContext.FUNC_ADD=0x8006;
		WebGLContext.BLEND_EQUATION=0x8009;
		WebGLContext.BLEND_EQUATION_RGB=0x8009;
		WebGLContext.BLEND_EQUATION_ALPHA=0x883D;
		WebGLContext.FUNC_SUBTRACT=0x800A;
		WebGLContext.FUNC_REVERSE_SUBTRACT=0x800B;
		WebGLContext.BLEND_DST_RGB=0x80C8;
		WebGLContext.BLEND_SRC_RGB=0x80C9;
		WebGLContext.BLEND_DST_ALPHA=0x80CA;
		WebGLContext.BLEND_SRC_ALPHA=0x80CB;
		WebGLContext.CONSTANT_COLOR=0x8001;
		WebGLContext.ONE_MINUS_CONSTANT_COLOR=0x8002;
		WebGLContext.CONSTANT_ALPHA=0x8003;
		WebGLContext.ONE_MINUS_CONSTANT_ALPHA=0x8004;
		WebGLContext.BLEND_COLOR=0x8005;
		WebGLContext.ARRAY_BUFFER=0x8892;
		WebGLContext.ELEMENT_ARRAY_BUFFER=0x8893;
		WebGLContext.ARRAY_BUFFER_BINDING=0x8894;
		WebGLContext.ELEMENT_ARRAY_BUFFER_BINDING=0x8895;
		WebGLContext.STREAM_DRAW=0x88E0;
		WebGLContext.STATIC_DRAW=0x88E4;
		WebGLContext.DYNAMIC_DRAW=0x88E8;
		WebGLContext.BUFFER_SIZE=0x8764;
		WebGLContext.BUFFER_USAGE=0x8765;
		WebGLContext.CURRENT_VERTEX_ATTRIB=0x8626;
		WebGLContext.FRONT=0x0404;
		WebGLContext.BACK=0x0405;
		WebGLContext.CULL_FACE=0x0B44;
		WebGLContext.FRONT_AND_BACK=0x0408;
		WebGLContext.BLEND=0x0BE2;
		WebGLContext.DITHER=0x0BD0;
		WebGLContext.STENCIL_TEST=0x0B90;
		WebGLContext.DEPTH_TEST=0x0B71;
		WebGLContext.SCISSOR_TEST=0x0C11;
		WebGLContext.POLYGON_OFFSET_FILL=0x8037;
		WebGLContext.SAMPLE_ALPHA_TO_COVERAGE=0x809E;
		WebGLContext.SAMPLE_COVERAGE=0x80A0;
		WebGLContext.NO_ERROR=0;
		WebGLContext.INVALID_ENUM=0x0500;
		WebGLContext.INVALID_VALUE=0x0501;
		WebGLContext.INVALID_OPERATION=0x0502;
		WebGLContext.OUT_OF_MEMORY=0x0505;
		WebGLContext.CW=0x0900;
		WebGLContext.CCW=0x0901;
		WebGLContext.LINE_WIDTH=0x0B21;
		WebGLContext.ALIASED_POINT_SIZE_RANGE=0x846D;
		WebGLContext.ALIASED_LINE_WIDTH_RANGE=0x846E;
		WebGLContext.CULL_FACE_MODE=0x0B45;
		WebGLContext.FRONT_FACE=0x0B46;
		WebGLContext.DEPTH_RANGE=0x0B70;
		WebGLContext.DEPTH_WRITEMASK=0x0B72;
		WebGLContext.DEPTH_CLEAR_VALUE=0x0B73;
		WebGLContext.DEPTH_FUNC=0x0B74;
		WebGLContext.STENCIL_CLEAR_VALUE=0x0B91;
		WebGLContext.STENCIL_FUNC=0x0B92;
		WebGLContext.STENCIL_FAIL=0x0B94;
		WebGLContext.STENCIL_PASS_DEPTH_FAIL=0x0B95;
		WebGLContext.STENCIL_PASS_DEPTH_PASS=0x0B96;
		WebGLContext.STENCIL_REF=0x0B97;
		WebGLContext.STENCIL_VALUE_MASK=0x0B93;
		WebGLContext.STENCIL_WRITEMASK=0x0B98;
		WebGLContext.STENCIL_BACK_FUNC=0x8800;
		WebGLContext.STENCIL_BACK_FAIL=0x8801;
		WebGLContext.STENCIL_BACK_PASS_DEPTH_FAIL=0x8802;
		WebGLContext.STENCIL_BACK_PASS_DEPTH_PASS=0x8803;
		WebGLContext.STENCIL_BACK_REF=0x8CA3;
		WebGLContext.STENCIL_BACK_VALUE_MASK=0x8CA4;
		WebGLContext.STENCIL_BACK_WRITEMASK=0x8CA5;
		WebGLContext.VIEWPORT=0x0BA2;
		WebGLContext.SCISSOR_BOX=0x0C10;
		WebGLContext.COLOR_CLEAR_VALUE=0x0C22;
		WebGLContext.COLOR_WRITEMASK=0x0C23;
		WebGLContext.UNPACK_ALIGNMENT=0x0CF5;
		WebGLContext.PACK_ALIGNMENT=0x0D05;
		WebGLContext.MAX_TEXTURE_SIZE=0x0D33;
		WebGLContext.MAX_VIEWPORT_DIMS=0x0D3A;
		WebGLContext.SUBPIXEL_BITS=0x0D50;
		WebGLContext.RED_BITS=0x0D52;
		WebGLContext.GREEN_BITS=0x0D53;
		WebGLContext.BLUE_BITS=0x0D54;
		WebGLContext.ALPHA_BITS=0x0D55;
		WebGLContext.DEPTH_BITS=0x0D56;
		WebGLContext.STENCIL_BITS=0x0D57;
		WebGLContext.POLYGON_OFFSET_UNITS=0x2A00;
		WebGLContext.POLYGON_OFFSET_FACTOR=0x8038;
		WebGLContext.TEXTURE_BINDING_2D=0x8069;
		WebGLContext.SAMPLE_BUFFERS=0x80A8;
		WebGLContext.SAMPLES=0x80A9;
		WebGLContext.SAMPLE_COVERAGE_VALUE=0x80AA;
		WebGLContext.SAMPLE_COVERAGE_INVERT=0x80AB;
		WebGLContext.NUM_COMPRESSED_TEXTURE_FORMATS=0x86A2;
		WebGLContext.COMPRESSED_TEXTURE_FORMATS=0x86A3;
		WebGLContext.DONT_CARE=0x1100;
		WebGLContext.FASTEST=0x1101;
		WebGLContext.NICEST=0x1102;
		WebGLContext.GENERATE_MIPMAP_HINT=0x8192;
		WebGLContext.BYTE=0x1400;
		WebGLContext.UNSIGNED_BYTE=0x1401;
		WebGLContext.SHORT=0x1402;
		WebGLContext.UNSIGNED_SHORT=0x1403;
		WebGLContext.INT=0x1404;
		WebGLContext.UNSIGNED_INT=0x1405;
		WebGLContext.FLOAT=0x1406;
		WebGLContext.DEPTH_COMPONENT=0x1902;
		WebGLContext.ALPHA=0x1906;
		WebGLContext.RGB=0x1907;
		WebGLContext.RGBA=0x1908;
		WebGLContext.LUMINANCE=0x1909;
		WebGLContext.LUMINANCE_ALPHA=0x190A;
		WebGLContext.UNSIGNED_SHORT_4_4_4_4=0x8033;
		WebGLContext.UNSIGNED_SHORT_5_5_5_1=0x8034;
		WebGLContext.UNSIGNED_SHORT_5_6_5=0x8363;
		WebGLContext.FRAGMENT_SHADER=0x8B30;
		WebGLContext.VERTEX_SHADER=0x8B31;
		WebGLContext.MAX_VERTEX_ATTRIBS=0x8869;
		WebGLContext.MAX_VERTEX_UNIFORM_VECTORS=0x8DFB;
		WebGLContext.MAX_VARYING_VECTORS=0x8DFC;
		WebGLContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS=0x8B4D;
		WebGLContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS=0x8B4C;
		WebGLContext.MAX_TEXTURE_IMAGE_UNITS=0x8872;
		WebGLContext.MAX_FRAGMENT_UNIFORM_VECTORS=0x8DFD;
		WebGLContext.SHADER_TYPE=0x8B4F;
		WebGLContext.DELETE_STATUS=0x8B80;
		WebGLContext.LINK_STATUS=0x8B82;
		WebGLContext.VALIDATE_STATUS=0x8B83;
		WebGLContext.ATTACHED_SHADERS=0x8B85;
		WebGLContext.ACTIVE_UNIFORMS=0x8B86;
		WebGLContext.ACTIVE_ATTRIBUTES=0x8B89;
		WebGLContext.SHADING_LANGUAGE_VERSION=0x8B8C;
		WebGLContext.CURRENT_PROGRAM=0x8B8D;
		WebGLContext.NEVER=0x0200;
		WebGLContext.LESS=0x0201;
		WebGLContext.EQUAL=0x0202;
		WebGLContext.LEQUAL=0x0203;
		WebGLContext.GREATER=0x0204;
		WebGLContext.NOTEQUAL=0x0205;
		WebGLContext.GEQUAL=0x0206;
		WebGLContext.ALWAYS=0x0207;
		WebGLContext.KEEP=0x1E00;
		WebGLContext.REPLACE=0x1E01;
		WebGLContext.INCR=0x1E02;
		WebGLContext.DECR=0x1E03;
		WebGLContext.INVERT=0x150A;
		WebGLContext.INCR_WRAP=0x8507;
		WebGLContext.DECR_WRAP=0x8508;
		WebGLContext.VENDOR=0x1F00;
		WebGLContext.RENDERER=0x1F01;
		WebGLContext.VERSION=0x1F02;
		WebGLContext.NEAREST=0x2600;
		WebGLContext.LINEAR=0x2601;
		WebGLContext.NEAREST_MIPMAP_NEAREST=0x2700;
		WebGLContext.LINEAR_MIPMAP_NEAREST=0x2701;
		WebGLContext.NEAREST_MIPMAP_LINEAR=0x2702;
		WebGLContext.LINEAR_MIPMAP_LINEAR=0x2703;
		WebGLContext.TEXTURE_MAG_FILTER=0x2800;
		WebGLContext.TEXTURE_MIN_FILTER=0x2801;
		WebGLContext.TEXTURE_WRAP_S=0x2802;
		WebGLContext.TEXTURE_WRAP_T=0x2803;
		WebGLContext.TEXTURE_2D=0x0DE1;
		WebGLContext.TEXTURE=0x1702;
		WebGLContext.TEXTURE_CUBE_MAP=0x8513;
		WebGLContext.TEXTURE_BINDING_CUBE_MAP=0x8514;
		WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X=0x8515;
		WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X=0x8516;
		WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y=0x8517;
		WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y=0x8518;
		WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z=0x8519;
		WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z=0x851A;
		WebGLContext.MAX_CUBE_MAP_TEXTURE_SIZE=0x851C;
		WebGLContext.TEXTURE0=0x84C0;
		WebGLContext.TEXTURE1=0x84C1;
		WebGLContext.TEXTURE2=0x84C2;
		WebGLContext.TEXTURE3=0x84C3;
		WebGLContext.TEXTURE4=0x84C4;
		WebGLContext.TEXTURE5=0x84C5;
		WebGLContext.TEXTURE6=0x84C6;
		WebGLContext.TEXTURE7=0x84C7;
		WebGLContext.TEXTURE8=0x84C8;
		WebGLContext.TEXTURE9=0x84C9;
		WebGLContext.TEXTURE10=0x84CA;
		WebGLContext.TEXTURE11=0x84CB;
		WebGLContext.TEXTURE12=0x84CC;
		WebGLContext.TEXTURE13=0x84CD;
		WebGLContext.TEXTURE14=0x84CE;
		WebGLContext.TEXTURE15=0x84CF;
		WebGLContext.TEXTURE16=0x84D0;
		WebGLContext.TEXTURE17=0x84D1;
		WebGLContext.TEXTURE18=0x84D2;
		WebGLContext.TEXTURE19=0x84D3;
		WebGLContext.TEXTURE20=0x84D4;
		WebGLContext.TEXTURE21=0x84D5;
		WebGLContext.TEXTURE22=0x84D6;
		WebGLContext.TEXTURE23=0x84D7;
		WebGLContext.TEXTURE24=0x84D8;
		WebGLContext.TEXTURE25=0x84D9;
		WebGLContext.TEXTURE26=0x84DA;
		WebGLContext.TEXTURE27=0x84DB;
		WebGLContext.TEXTURE28=0x84DC;
		WebGLContext.TEXTURE29=0x84DD;
		WebGLContext.TEXTURE30=0x84DE;
		WebGLContext.TEXTURE31=0x84DF;
		WebGLContext.ACTIVE_TEXTURE=0x84E0;
		WebGLContext.REPEAT=0x2901;
		WebGLContext.CLAMP_TO_EDGE=0x812F;
		WebGLContext.MIRRORED_REPEAT=0x8370;
		WebGLContext.FLOAT_VEC2=0x8B50;
		WebGLContext.FLOAT_VEC3=0x8B51;
		WebGLContext.FLOAT_VEC4=0x8B52;
		WebGLContext.INT_VEC2=0x8B53;
		WebGLContext.INT_VEC3=0x8B54;
		WebGLContext.INT_VEC4=0x8B55;
		WebGLContext.BOOL=0x8B56;
		WebGLContext.BOOL_VEC2=0x8B57;
		WebGLContext.BOOL_VEC3=0x8B58;
		WebGLContext.BOOL_VEC4=0x8B59;
		WebGLContext.FLOAT_MAT2=0x8B5A;
		WebGLContext.FLOAT_MAT3=0x8B5B;
		WebGLContext.FLOAT_MAT4=0x8B5C;
		WebGLContext.SAMPLER_2D=0x8B5E;
		WebGLContext.SAMPLER_CUBE=0x8B60;
		WebGLContext.VERTEX_ATTRIB_ARRAY_ENABLED=0x8622;
		WebGLContext.VERTEX_ATTRIB_ARRAY_SIZE=0x8623;
		WebGLContext.VERTEX_ATTRIB_ARRAY_STRIDE=0x8624;
		WebGLContext.VERTEX_ATTRIB_ARRAY_TYPE=0x8625;
		WebGLContext.VERTEX_ATTRIB_ARRAY_NORMALIZED=0x886A;
		WebGLContext.VERTEX_ATTRIB_ARRAY_POINTER=0x8645;
		WebGLContext.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING=0x889F;
		WebGLContext.COMPILE_STATUS=0x8B81;
		WebGLContext.LOW_FLOAT=0x8DF0;
		WebGLContext.MEDIUM_FLOAT=0x8DF1;
		WebGLContext.HIGH_FLOAT=0x8DF2;
		WebGLContext.LOW_INT=0x8DF3;
		WebGLContext.MEDIUM_INT=0x8DF4;
		WebGLContext.HIGH_INT=0x8DF5;
		WebGLContext.FRAMEBUFFER=0x8D40;
		WebGLContext.RENDERBUFFER=0x8D41;
		WebGLContext.RGBA4=0x8056;
		WebGLContext.RGB5_A1=0x8057;
		WebGLContext.RGB565=0x8D62;
		WebGLContext.DEPTH_COMPONENT16=0x81A5;
		WebGLContext.STENCIL_INDEX=0x1901;
		WebGLContext.STENCIL_INDEX8=0x8D48;
		WebGLContext.DEPTH_STENCIL=0x84F9;
		WebGLContext.RENDERBUFFER_WIDTH=0x8D42;
		WebGLContext.RENDERBUFFER_HEIGHT=0x8D43;
		WebGLContext.RENDERBUFFER_INTERNAL_FORMAT=0x8D44;
		WebGLContext.RENDERBUFFER_RED_SIZE=0x8D50;
		WebGLContext.RENDERBUFFER_GREEN_SIZE=0x8D51;
		WebGLContext.RENDERBUFFER_BLUE_SIZE=0x8D52;
		WebGLContext.RENDERBUFFER_ALPHA_SIZE=0x8D53;
		WebGLContext.RENDERBUFFER_DEPTH_SIZE=0x8D54;
		WebGLContext.RENDERBUFFER_STENCIL_SIZE=0x8D55;
		WebGLContext.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE=0x8CD0;
		WebGLContext.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME=0x8CD1;
		WebGLContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL=0x8CD2;
		WebGLContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE=0x8CD3;
		WebGLContext.COLOR_ATTACHMENT0=0x8CE0;
		WebGLContext.DEPTH_ATTACHMENT=0x8D00;
		WebGLContext.STENCIL_ATTACHMENT=0x8D20;
		WebGLContext.DEPTH_STENCIL_ATTACHMENT=0x821A;
		WebGLContext.NONE=0;
		WebGLContext.FRAMEBUFFER_COMPLETE=0x8CD5;
		WebGLContext.FRAMEBUFFER_INCOMPLETE_ATTACHMENT=0x8CD6;
		WebGLContext.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT=0x8CD7;
		WebGLContext.FRAMEBUFFER_INCOMPLETE_DIMENSIONS=0x8CD9;
		WebGLContext.FRAMEBUFFER_UNSUPPORTED=0x8CDD;
		WebGLContext.FRAMEBUFFER_BINDING=0x8CA6;
		WebGLContext.RENDERBUFFER_BINDING=0x8CA7;
		WebGLContext.MAX_RENDERBUFFER_SIZE=0x84E8;
		WebGLContext.INVALID_FRAMEBUFFER_OPERATION=0x0506;
		WebGLContext.UNPACK_FLIP_Y_WEBGL=0x9240;
		WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL=0x9241;
		WebGLContext.CONTEXT_LOST_WEBGL=0x9242;
		WebGLContext.UNPACK_COLORSPACE_CONVERSION_WEBGL=0x9243;
		WebGLContext.BROWSER_DEFAULT_WEBGL=0x9244;
		WebGLContext.extTextureFilterAnisotropic=null
		WebGLContext._glTextureIDs=[ 0x84C0,0x84C1,0x84C2,0x84C3,0x84C4,0x84C5,0x84C6,0x84C7];
		WebGLContext._useProgram=null;
		WebGLContext._depthTest=true;
		WebGLContext._depthMask=true;
		WebGLContext._depthFunc=0x0201;
		WebGLContext._blend=false;
		WebGLContext._sFactor=1;
		WebGLContext._dFactor=0;
		WebGLContext._cullFace=false;
		WebGLContext._frontFace=0x0901;
		WebGLContext._activedTextureID=0x84C0;
		__static(WebGLContext,
		['_activeTextures',function(){return this._activeTextures=new Array(8);}
		]);
		return WebGLContext;
	})()


	/**
	*@private
	*/
	//class laya.d3.animation.AnimationClipParser01
	var AnimationClipParser01=(function(){
		function AnimationClipParser01(){};
		__class(AnimationClipParser01,'laya.d3.animation.AnimationClipParser01');
		AnimationClipParser01.READ_DATA=function(){
			AnimationClipParser01._DATA.offset=AnimationClipParser01._reader.getUint32();
			AnimationClipParser01._DATA.size=AnimationClipParser01._reader.getUint32();
		}

		AnimationClipParser01.READ_BLOCK=function(){
			var count=AnimationClipParser01._BLOCK.count=AnimationClipParser01._reader.getUint16();
			var blockStarts=AnimationClipParser01._BLOCK.blockStarts=[];
			var blockLengths=AnimationClipParser01._BLOCK.blockLengths=[];
			for (var i=0;i < count;i++){
				blockStarts.push(AnimationClipParser01._reader.getUint32());
				blockLengths.push(AnimationClipParser01._reader.getUint32());
			}
		}

		AnimationClipParser01.READ_STRINGS=function(){
			var offset=AnimationClipParser01._reader.getUint32();
			var count=AnimationClipParser01._reader.getUint16();
			var prePos=AnimationClipParser01._reader.pos;
			AnimationClipParser01._reader.pos=offset+AnimationClipParser01._DATA.offset;
			for (var i=0;i < count;i++)
			AnimationClipParser01._strings[i]=AnimationClipParser01._reader.readUTFString();
			AnimationClipParser01._reader.pos=prePos;
		}

		AnimationClipParser01.parse=function(clip,reader){
			AnimationClipParser01._animationClip=clip;
			AnimationClipParser01._reader=reader;
			var arrayBuffer=reader.__getBuffer();
			AnimationClipParser01.READ_DATA();
			AnimationClipParser01.READ_BLOCK();
			AnimationClipParser01.READ_STRINGS();
			for (var i=0,n=AnimationClipParser01._BLOCK.count;i < n;i++){
				var index=reader.getUint16();
				var blockName=AnimationClipParser01._strings[index];
				var fn=AnimationClipParser01["READ_"+blockName];
				if (fn==null)
					throw new Error("model file err,no this function:"+index+" "+blockName);
				else
				fn.call();
			}
		}

		AnimationClipParser01.READ_ANIMATIONS=function(){
			var i=0,j=0;
			var node;
			var reader=AnimationClipParser01._reader;
			var buffer=reader.__getBuffer();
			var lengthTypes=[];
			var lenghthTypeCount=reader.getUint8();
			lengthTypes.length=lenghthTypeCount;
			for (i=0;i < lenghthTypeCount;i++)
			lengthTypes[i]=reader.getUint16();
			var startTimeTypes=[];
			var startTimeTypeCount=reader.getUint16();
			startTimeTypes.length=startTimeTypeCount;
			for (i=0;i < startTimeTypeCount;i++)
			startTimeTypes[i]=reader.getFloat32();
			var clip=AnimationClipParser01._animationClip;
			clip.name=AnimationClipParser01._strings[reader.getUint16()];
			var clipDur=clip._duration=reader.getFloat32();
			clip.islooping=!!reader.getByte();
			clip._frameRate=reader.getInt16();
			var nodeCount=reader.getInt16();
			var nodes=clip._nodes=new Array;
			nodes.length=nodeCount;
			var publicDatas=clip._publicClipDatas=[];
			publicDatas.length=nodeCount;
			var nodesMap=clip._nodesMap={};
			var cachePropertyToNodeIndex=0,unCachePropertyToNodeIndex=0;
			for (i=0;i < nodeCount;i++){
				node=nodes[i]=new KeyframeNode();
				var pathLength=reader.getUint16();
				var path=node.path=[];
				path.length=pathLength;
				for (j=0;j < pathLength;j++)
				path[j]=AnimationClipParser01._strings[reader.getUint16()];
				var nodePath=path.join("/");
				var mapArray=nodesMap[nodePath];
				(mapArray)|| (nodesMap[nodePath]=mapArray=[]);
				mapArray.push(node);
				var componentTypeStrIndex=reader.getInt16();
				(componentTypeStrIndex!==-1)&& (node.componentType=AnimationClipParser01._strings[componentTypeStrIndex]);
				var propertyNameID=AnimationNode._propertyIndexDic[AnimationClipParser01._strings[reader.getUint16()]];
				if (propertyNameID !=null){
					var isTransformProperty=propertyNameID < 4;
					var cacheProperty=!isTransformProperty || (isTransformProperty && path[0]==="");
					node._cacheProperty=cacheProperty;
					if (cacheProperty)
						cachePropertyToNodeIndex++;
					else
					unCachePropertyToNodeIndex++;
					node.propertyNameID=propertyNameID;
					}else {
					throw new Error("AnimationClipParser01:unknown property name.");
				};
				var dataLength=lengthTypes[reader.getUint8()];
				node.keyFrameWidth=dataLength / 4;
				var keyFrames=node.keyFrames=[];
				var keyframeCount=keyFrames.length=reader.getUint16();
				var lastKeyFrame=null;
				var startTime=NaN;
				for (j=0;j < keyframeCount;j++){
					var keyFrame=keyFrames[j]=new Keyframe();
					startTime=keyFrame.startTime=startTimeTypes[reader.getUint16()];
					var offset=reader.pos;
					keyFrame.inTangent=new Float32Array(buffer.slice(offset,offset+dataLength));
					reader.pos+=dataLength;
					offset=reader.pos;
					keyFrame.outTangent=new Float32Array(buffer.slice(offset,offset+dataLength));
					reader.pos+=dataLength;
					offset=reader.pos;
					keyFrame.data=new Float32Array(buffer.slice(offset,offset+dataLength));
					reader.pos+=dataLength;
					if (lastKeyFrame){
						lastKeyFrame.next=keyFrame;
						lastKeyFrame.duration=startTime-lastKeyFrame.startTime;
					}
					lastKeyFrame=keyFrame;
				}
				keyFrame.next=null;
				keyFrame.duration=clipDur-startTime;
			};
			var nodeToCachePropertyMap=clip._nodeToCachePropertyMap=new Int32Array(nodeCount);
			var cachePropertyToNodeMap=clip._cachePropertyMap=new Int32Array(cachePropertyToNodeIndex);
			var unCachePropertyToNodeMap=clip._unCachePropertyMap=new Int32Array(unCachePropertyToNodeIndex);
			cachePropertyToNodeIndex=unCachePropertyToNodeIndex=0;
			for (i=0;i < nodeCount;i++){
				node=nodes[i];
				if (node._cacheProperty){
					nodeToCachePropertyMap[i]=cachePropertyToNodeIndex;
					cachePropertyToNodeMap[cachePropertyToNodeIndex++]=i;
					}else {
					unCachePropertyToNodeMap[unCachePropertyToNodeIndex++]=i;
				}
			}
		}

		AnimationClipParser01._animationClip=null
		AnimationClipParser01._reader=null
		AnimationClipParser01._strings=[];
		__static(AnimationClipParser01,
		['_BLOCK',function(){return this._BLOCK={count:0};},'_DATA',function(){return this._DATA={offset:0,size:0};}
		]);
		return AnimationClipParser01;
	})()


	/**
	*@private
	*/
	//class laya.d3.animation.AnimationClipParser02
	var AnimationClipParser02=(function(){
		function AnimationClipParser02(){};
		__class(AnimationClipParser02,'laya.d3.animation.AnimationClipParser02');
		AnimationClipParser02.READ_DATA=function(){
			AnimationClipParser02._DATA.offset=AnimationClipParser02._reader.getUint32();
			AnimationClipParser02._DATA.size=AnimationClipParser02._reader.getUint32();
		}

		AnimationClipParser02.READ_BLOCK=function(){
			var count=AnimationClipParser02._BLOCK.count=AnimationClipParser02._reader.getUint16();
			var blockStarts=AnimationClipParser02._BLOCK.blockStarts=[];
			var blockLengths=AnimationClipParser02._BLOCK.blockLengths=[];
			for (var i=0;i < count;i++){
				blockStarts.push(AnimationClipParser02._reader.getUint32());
				blockLengths.push(AnimationClipParser02._reader.getUint32());
			}
		}

		AnimationClipParser02.READ_STRINGS=function(){
			var offset=AnimationClipParser02._reader.getUint32();
			var count=AnimationClipParser02._reader.getUint16();
			var prePos=AnimationClipParser02._reader.pos;
			AnimationClipParser02._reader.pos=offset+AnimationClipParser02._DATA.offset;
			for (var i=0;i < count;i++)
			AnimationClipParser02._strings[i]=AnimationClipParser02._reader.readUTFString();
			AnimationClipParser02._reader.pos=prePos;
		}

		AnimationClipParser02.parse=function(clip,reader){
			AnimationClipParser02._animationClip=clip;
			AnimationClipParser02._reader=reader;
			var arrayBuffer=reader.__getBuffer();
			AnimationClipParser02.READ_DATA();
			AnimationClipParser02.READ_BLOCK();
			AnimationClipParser02.READ_STRINGS();
			for (var i=0,n=AnimationClipParser02._BLOCK.count;i < n;i++){
				var index=reader.getUint16();
				var blockName=AnimationClipParser02._strings[index];
				var fn=AnimationClipParser02["READ_"+blockName];
				if (fn==null)
					throw new Error("model file err,no this function:"+index+" "+blockName);
				else
				fn.call();
			}
		}

		AnimationClipParser02.READ_ANIMATIONS=function(){
			var i=0,j=0;
			var node;
			var reader=AnimationClipParser02._reader;
			var buffer=reader.__getBuffer();
			var lengthTypes=[];
			var lenghthTypeCount=reader.getUint8();
			lengthTypes.length=lenghthTypeCount;
			for (i=0;i < lenghthTypeCount;i++)
			lengthTypes[i]=reader.getUint16();
			var startTimeTypes=[];
			var startTimeTypeCount=reader.getUint16();
			startTimeTypes.length=startTimeTypeCount;
			for (i=0;i < startTimeTypeCount;i++)
			startTimeTypes[i]=reader.getFloat32();
			var clip=AnimationClipParser02._animationClip;
			clip.name=AnimationClipParser02._strings[reader.getUint16()];
			var clipDur=clip._duration=reader.getFloat32();
			clip.islooping=!!reader.getByte();
			clip._frameRate=reader.getInt16();
			var nodeCount=reader.getInt16();
			var nodes=clip._nodes=new Array;
			nodes.length=nodeCount;
			var publicDatas=clip._publicClipDatas=[];
			publicDatas.length=nodeCount;
			var nodesMap=clip._nodesMap={};
			var cachePropertyToNodeIndex=0,unCachePropertyToNodeIndex=0;
			for (i=0;i < nodeCount;i++){
				node=nodes[i]=new KeyframeNode();
				var pathLength=reader.getUint16();
				var path=node.path=[];
				path.length=pathLength;
				for (j=0;j < pathLength;j++)
				path[j]=AnimationClipParser02._strings[reader.getUint16()];
				var nodePath=path.join("/");
				var mapArray=nodesMap[nodePath];
				(mapArray)|| (nodesMap[nodePath]=mapArray=[]);
				mapArray.push(node);
				var componentTypeStrIndex=reader.getInt16();
				(componentTypeStrIndex!==-1)&& (node.componentType=AnimationClipParser02._strings[componentTypeStrIndex]);
				var propertyNameID=AnimationNode._propertyIndexDic[AnimationClipParser02._strings[reader.getUint16()]];
				if (propertyNameID !=null){
					var isTransformProperty=propertyNameID < 4;
					var cacheProperty=!isTransformProperty || (isTransformProperty && path[0]==="");
					node._cacheProperty=cacheProperty;
					if (cacheProperty)
						cachePropertyToNodeIndex++;
					else
					unCachePropertyToNodeIndex++;
					node.propertyNameID=propertyNameID;
					}else {
					throw new Error("AnimationClipParser02:unknown property name.");
				};
				var dataLength=lengthTypes[reader.getUint8()];
				node.keyFrameWidth=dataLength / 4;
				var keyFrames=node.keyFrames=[];
				var keyframeCount=keyFrames.length=reader.getUint16();
				var lastKeyFrame=null;
				var startTime=NaN;
				for (j=0;j < keyframeCount;j++){
					var keyFrame=keyFrames[j]=new Keyframe();
					startTime=keyFrame.startTime=startTimeTypes[reader.getUint16()];
					var offset=reader.pos;
					keyFrame.inTangent=new Float32Array(buffer.slice(offset,offset+dataLength));
					reader.pos+=dataLength;
					offset=reader.pos;
					keyFrame.outTangent=new Float32Array(buffer.slice(offset,offset+dataLength));
					reader.pos+=dataLength;
					offset=reader.pos;
					keyFrame.data=new Float32Array(buffer.slice(offset,offset+dataLength));
					reader.pos+=dataLength;
					if (lastKeyFrame){
						lastKeyFrame.next=keyFrame;
						lastKeyFrame.duration=startTime-lastKeyFrame.startTime;
					}
					lastKeyFrame=keyFrame;
				}
				keyFrame.next=null;
				keyFrame.duration=clipDur-startTime;
			};
			var eventCount=reader.getUint16();
			for (i=0;i < eventCount;i++){
				var event=new AnimationEvent();
				event.time=reader.getFloat32();
				event.eventName=AnimationClipParser02._strings[reader.getUint16()];
				var params;
				var paramCount=reader.getUint16();
				(paramCount > 0)&& (event.params=params=[]);
				for (j=0;j < paramCount;j++){
					var type=reader.getByte();
					switch (type){
						case 0:
							params.push(!!reader.getByte());
							break ;
						case 1:
							params.push(reader.getInt32());
							break ;
						case 2:
							params.push(reader.getFloat32());
							break ;
						case 3:
							params.push(AnimationClipParser02._strings[reader.getUint16()]);
							break ;
						default :
							throw new Error("unknown type.");
						}
				}
				clip.addEvent(event);
			};
			var nodeToCachePropertyMap=clip._nodeToCachePropertyMap=new Int32Array(nodeCount);
			var cachePropertyToNodeMap=clip._cachePropertyMap=new Int32Array(cachePropertyToNodeIndex);
			var unCachePropertyToNodeMap=clip._unCachePropertyMap=new Int32Array(unCachePropertyToNodeIndex);
			cachePropertyToNodeIndex=unCachePropertyToNodeIndex=0;
			for (i=0;i < nodeCount;i++){
				node=nodes[i];
				if (node._cacheProperty){
					nodeToCachePropertyMap[i]=cachePropertyToNodeIndex;
					cachePropertyToNodeMap[cachePropertyToNodeIndex++]=i;
					}else {
					unCachePropertyToNodeMap[unCachePropertyToNodeIndex++]=i;
				}
			}
		}

		AnimationClipParser02._animationClip=null
		AnimationClipParser02._reader=null
		AnimationClipParser02._strings=[];
		__static(AnimationClipParser02,
		['_BLOCK',function(){return this._BLOCK={count:0};},'_DATA',function(){return this._DATA={offset:0,size:0};}
		]);
		return AnimationClipParser02;
	})()


	/**
	*<code>AnimationEvent</code> 类用于实现动画事件。
	*/
	//class laya.d3.animation.AnimationEvent
	var AnimationEvent=(function(){
		function AnimationEvent(){
			this.time=NaN;
			this.eventName=null;
			this.params=null;
		}

		__class(AnimationEvent,'laya.d3.animation.AnimationEvent');
		return AnimationEvent;
	})()


	/**
	*<code>BoneNode</code> 类用于实现骨骼节点。
	*/
	//class laya.d3.animation.AnimationNode
	var AnimationNode=(function(){
		function AnimationNode(){
			//this._children=null;
			//this._parent=null;
			//this.transform=null;
			//this.name=null;
			this._children=[];
			this.transform=new AnimationTransform3D(this);
		}

		__class(AnimationNode,'laya.d3.animation.AnimationNode');
		var __proto=AnimationNode.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*添加子节点。
		*@param child 子节点。
		*/
		__proto.addChild=function(child){
			child._parent=this;
			child.transform.setParent(this.transform);
			this._children.push(child);
		}

		/**
		*移除子节点。
		*@param child 子节点。
		*/
		__proto.removeChild=function(child){
			var index=this._children.indexOf(child);
			(index!==-1)&& (this._children.splice(index,1));
		}

		/**
		*根据名字获取子节点。
		*@param name 名字。
		*/
		__proto.getChildByName=function(name){
			for (var i=0,n=this._children.length;i < n;i++){
				var child=this._children[i];
				if (child.name===name)
					return child;
			}
			return null;
		}

		/**
		*根据索引获取子节点。
		*@param index 索引。
		*/
		__proto.getChildByIndex=function(index){
			return this._children[index];
		}

		/**
		*获取子节点的个数。
		*/
		__proto.getChildCount=function(){
			return this._children.length;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destNode=destObject;
			destNode.name=this.name;
			for (var i=0,n=this._children.length;i < n;i++){
				var child=this._children[i];
				var destChild=child.clone();
				destNode.addChild(destChild);
				var transform=child.transform;
				var destTransform=destChild.transform;
				destTransform.setLocalPosition(transform.getLocalPosition());
				destTransform.setLocalRotation(transform.getLocalRotation());
				destTransform.setLocalScale(transform.getLocalScale());
				destTransform._localRotationEuler=transform._localRotationEuler;
				destTransform._setWorldMatrixIgnoreUpdate(transform.getWorldMatrix());
			}
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		AnimationNode.__init__=function(){
			AnimationNode.registerAnimationNodeProperty("localPosition",AnimationNode._getLocalPosition,AnimationNode._setLocalPosition);
			AnimationNode.registerAnimationNodeProperty("localRotation",AnimationNode._getLocalRotation,AnimationNode._setLocalRotation);
			AnimationNode.registerAnimationNodeProperty("localScale",AnimationNode._getLocalScale,AnimationNode._setLocalScale);
			AnimationNode.registerAnimationNodeProperty("localRotationEuler",AnimationNode._getLocalRotationEuler,AnimationNode._setLocalRotationEuler);
			AnimationNode.registerAnimationNodeProperty("particleRender.sharedMaterial.tintColor",AnimationNode._getParticleRenderSharedMaterialTintColor,AnimationNode._setParticleRenderSharedMaterialTintColor);
			AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.tilingOffset",AnimationNode._getMeshRenderSharedMaterialTilingOffset,AnimationNode._setMeshRenderSharedMaterialTilingOffset);
			AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.albedoColor",AnimationNode._getMeshRenderSharedMaterialAlbedo,AnimationNode._setMeshRenderSharedMaterialAlbedo);
			AnimationNode.registerAnimationNodeProperty("skinnedMeshRender.sharedMaterial.tilingOffset",AnimationNode._getSkinnedMeshRenderSharedMaterialTilingOffset,AnimationNode._setSkinnedMeshRenderSharedMaterialTilingOffset);
			AnimationNode.registerAnimationNodeProperty("skinnedMeshRender.sharedMaterial.albedoColor",AnimationNode._getSkinnedMeshRenderSharedMaterialAlbedo,AnimationNode._setSkinnedMeshRenderSharedMaterialAlbedo);
			AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.albedo",AnimationNode._getMeshRenderSharedMaterialAlbedo,AnimationNode._setMeshRenderSharedMaterialAlbedo);
			AnimationNode.registerAnimationNodeProperty("skinnedMeshRender.sharedMaterial.albedo",AnimationNode._getSkinnedMeshRenderSharedMaterialAlbedo,AnimationNode._setSkinnedMeshRenderSharedMaterialAlbedo);
		}

		AnimationNode.registerAnimationNodeProperty=function(propertyName,getFunc,setFunc){
			if (AnimationNode._propertyIndexDic[propertyName]){
				throw new Error("AnimationNode: this propertyName has registered.");
				}else {
				AnimationNode._propertyIndexDic[propertyName]=AnimationNode._propertyIDCounter;
				AnimationNode._propertyGetFuncs[AnimationNode._propertyIDCounter]=getFunc;
				AnimationNode._propertySetFuncs[AnimationNode._propertyIDCounter]=setFunc;
				AnimationNode._propertyIDCounter++;
			}
		}

		AnimationNode._getLocalPosition=function(animationNode,sprite3D){
			if (animationNode)
				return animationNode.transform.getLocalPosition();
			else
			return sprite3D._transform.localPosition.elements;
		}

		AnimationNode._setLocalPosition=function(animationNode,sprite3D,value){
			if (animationNode){
				animationNode.transform.setLocalPosition(value);
				}else {
				var spriteTransform=sprite3D._transform;
				var localPosition=spriteTransform.localPosition;
				localPosition.elements=value;
				spriteTransform.localPosition=localPosition;
			}
		}

		AnimationNode._getLocalRotation=function(animationNode,sprite3D){
			if (animationNode)
				return animationNode.transform.getLocalRotation();
			else
			return sprite3D._transform.localRotation.elements;
		}

		AnimationNode._setLocalRotation=function(animationNode,sprite3D,value){
			if (animationNode){
				animationNode.transform.setLocalRotation(value);
				}else {
				var spriteTransform=sprite3D._transform;
				var localRotation=spriteTransform.localRotation;
				localRotation.elements=value;
				spriteTransform.localRotation=localRotation;
			}
		}

		AnimationNode._getLocalScale=function(animationNode,sprite3D){
			if (animationNode)
				return animationNode.transform.getLocalScale();
			else
			return sprite3D._transform.localScale.elements;
		}

		AnimationNode._setLocalScale=function(animationNode,sprite3D,value){
			if (animationNode){
				animationNode.transform.setLocalScale(value);
				}else {
				var spriteTransform=sprite3D._transform;
				var localScale=spriteTransform.localScale;
				localScale.elements=value;
				spriteTransform.localScale=localScale;
			}
		}

		AnimationNode._getLocalRotationEuler=function(animationNode,sprite3D){
			if (animationNode)
				return animationNode.transform.getLocalRotationEuler();
			else
			return sprite3D._transform.localRotationEuler.elements;
		}

		AnimationNode._setLocalRotationEuler=function(animationNode,sprite3D,value){
			if (animationNode){
				animationNode.transform.setLocalRotationEuler(value);
				}else {
				var spriteTransform=sprite3D._transform;
				var localRotationEuler=spriteTransform.localRotationEuler;
				localRotationEuler.elements=value;
				spriteTransform.localRotationEuler=localRotationEuler;
			}
		}

		AnimationNode._getMeshRenderSharedMaterialTilingOffset=function(animationNode,sprite3D){
			var material;
			if (animationNode){
				var entity=animationNode.transform._entity;
				if (entity){
					material=(entity.owner).meshRender.sharedMaterial;
					return material.tilingOffset.elements;
				}else
				return null;
				}else {
				material=(sprite3D).meshRender.sharedMaterial;
				return material.tilingOffset.elements;
			}
		}

		AnimationNode._setMeshRenderSharedMaterialTilingOffset=function(animationNode,sprite3D,value){
			var material,tilingOffset;
			if (animationNode){
				var entity=animationNode.transform._entity;
				if (entity){
					material=(entity.owner).meshRender.material;
					tilingOffset=material.tilingOffset;
					tilingOffset.elements=value;
					material.tilingOffset=tilingOffset;
				}
				}else {
				material=(sprite3D).meshRender.material;
				tilingOffset=material.tilingOffset;
				tilingOffset.elements=value;
				material.tilingOffset=tilingOffset;
			}
		}

		AnimationNode._getMeshRenderSharedMaterialAlbedo=function(animationNode,sprite3D){
			var material;
			if (animationNode){
				var entity=animationNode.transform._entity;
				if (entity){
					material=(entity.owner).meshRender.sharedMaterial;
					return material.albedoColor.elements;
				}else
				return null;
				}else {
				material=(sprite3D).meshRender.sharedMaterial;
				return material.albedoColor.elements;
			}
		}

		AnimationNode._setMeshRenderSharedMaterialAlbedo=function(animationNode,sprite3D,value){
			var material,albedo;
			if (animationNode){
				var entity=animationNode.transform._entity;
				if (entity){
					material=(entity.owner).meshRender.material;
					albedo=material.albedoColor;
					albedo.elements=value;
					material.albedoColor=albedo;
				}
				}else {
				material=(sprite3D).meshRender.material;
				albedo=material.albedoColor;
				albedo.elements=value;
				material.albedoColor=albedo;
			}
		}

		AnimationNode._getSkinnedMeshRenderSharedMaterialTilingOffset=function(animationNode,sprite3D){
			var material;
			if (animationNode){
				var entity=animationNode.transform._entity;
				if (entity){
					material=(entity.owner).skinnedMeshRender.sharedMaterial;
					return material.tilingOffset.elements;
				}else
				return null;
				}else {
				material=(sprite3D).skinnedMeshRender.sharedMaterial;
				return material.tilingOffset.elements;
			}
		}

		AnimationNode._setSkinnedMeshRenderSharedMaterialTilingOffset=function(animationNode,sprite3D,value){
			var material,tilingOffset;
			if (animationNode){
				var entity=animationNode.transform._entity;
				if (entity){
					material=(entity.owner).skinnedMeshRender.material;
					tilingOffset=material.tilingOffset;
					tilingOffset.elements=value;
					material.tilingOffset=tilingOffset;
				}
				}else {
				material=(sprite3D).skinnedMeshRender.material;
				tilingOffset=material.tilingOffset;
				tilingOffset.elements=value;
				material.tilingOffset=tilingOffset;
			}
		}

		AnimationNode._getSkinnedMeshRenderSharedMaterialAlbedo=function(animationNode,sprite3D){
			var material;
			if (animationNode){
				var entity=animationNode.transform._entity;
				if (entity){
					material=(entity.owner).skinnedMeshRender.sharedMaterial;
					return material.albedoColor.elements;
					}else {
					return null;
				}
				}else {
				material=(sprite3D).skinnedMeshRender.sharedMaterial;
				return material.albedoColor.elements;
			}
		}

		AnimationNode._setSkinnedMeshRenderSharedMaterialAlbedo=function(animationNode,sprite3D,value){
			var material,albedo;
			if (animationNode){
				var entity=animationNode.transform._entity;
				if (entity){
					material=(entity.owner).skinnedMeshRender.material;
					albedo=material.albedoColor;
					albedo.elements=value;
					material.albedoColor=albedo;
				}
				}else {
				material=(sprite3D).skinnedMeshRender.material;
				albedo=material.albedoColor;
				albedo.elements=value;
				material.albedoColor=albedo;
			}
		}

		AnimationNode._getParticleRenderSharedMaterialTintColor=function(animationNode,sprite3D){
			var material;
			if (animationNode){
				var entity=animationNode.transform._entity;
				if (entity){
					material=(entity.owner).particleRender.sharedMaterial;
					return material.tintColor.elements;
				}else
				return null;
				}else {
				material=(sprite3D).particleRender.sharedMaterial;
				return material.tintColor.elements;
			}
		}

		AnimationNode._setParticleRenderSharedMaterialTintColor=function(animationNode,sprite3D,value){
			var material,tintColor;
			if (animationNode){
				var entity=animationNode.transform._entity;
				if (entity){
					material=(entity.owner).particleRender.material;
					tintColor=material.tintColor;
					tintColor.elements=value;
					material.tintColor=tintColor;
				}
				}else {
				material=(sprite3D).particleRender.material;
				tintColor=material.tintColor;
				tintColor.elements=value;
				material.tintColor=tintColor;
			}
		}

		AnimationNode._propertyIDCounter=0;
		AnimationNode._propertyIndexDic={};
		AnimationNode._propertySetFuncs=[];
		AnimationNode._propertyGetFuncs=[];
		return AnimationNode;
	})()


	/**
	*@private
	*/
	//class laya.d3.animation.Keyframe
	var Keyframe=(function(){
		function Keyframe(){
			this.startTime=NaN;
			this.inTangent=null;
			this.outTangent=null;
			this.data=null;
			this.duration=NaN;
			this.next=null;
		}

		__class(Keyframe,'laya.d3.animation.Keyframe');
		return Keyframe;
	})()


	/**
	*@private
	*/
	//class laya.d3.animation.KeyframeNode
	var KeyframeNode=(function(){
		function KeyframeNode(){
			this._cacheProperty=false;
			this.path=null;
			this.componentType=null;
			this.propertyNameID=0;
			this.keyFrameWidth=0;
			this.defaultData=null;
			this.keyFrames=null;
		}

		__class(KeyframeNode,'laya.d3.animation.KeyframeNode');
		return KeyframeNode;
	})()


	/**
	*<code>componentPool</code> 类用于实现组件对象池。
	*/
	//class laya.d3.component.ComponentPool
	var ComponentPool=(function(){
		function ComponentPool(){
			//this._rebuild=false;
			//this._cleanElementCount=0;
			//this._cleanElements=null;
			//this.elements=null;
			this.elements=[];
			this._rebuild=false;
			this._cleanElementCount=0;
			this._cleanElements=[];
		}

		__class(ComponentPool,'laya.d3.component.ComponentPool');
		var __proto=ComponentPool.prototype;
		/**
		*@private
		*/
		__proto.clear=function(){
			if (this._rebuild){
				this._cleanElements.length=this._cleanElementCount;
				var j=0;
				for (var i=0;i < this._cleanElementCount;i++){
					var element=this.elements[i];
					(element)&& (this._cleanElements[j++]=element);
				};
				var temp=this.elements;
				this.elements=this._cleanElements;
				this._cleanElements=temp;
				this._rebuild=false;
			}
		}

		/**
		*@private
		*/
		__proto.add=function(element){
			this.elements[this._cleanElementCount]=element;
			this._cleanElementCount++;
		}

		/**
		*@private
		*/
		__proto.remove=function(element){
			var index=this.elements.indexOf(element);
			this.elements[index]=null;
			this._cleanElementCount--;
			this._rebuild=true;
		}

		return ComponentPool;
	})()


	/**
	*@private
	*<code>GeometryElement</code> 类用于实现几何体元素。
	*/
	//class laya.d3.core.GeometryElement
	var GeometryElement=(function(){
		function GeometryElement(){
			//this._destroyed=false;
			//this._singletonVertexBuffer=false;
			//this._vertexDeclarationDefine=0;
			//this._vertexBuffer=null;
			//this._vertexBuffers=null;
			this._destroyed=false;
			this._vertexDeclarationDefine=0;
		}

		__class(GeometryElement,'laya.d3.core.GeometryElement');
		var __proto=GeometryElement.prototype;
		Laya.imps(__proto,{"laya.resource.IDestroy":true})
		/**
		*@private
		*vertexBuffer的vertexDeclaration不能为空。
		*/
		__proto._setVertexBuffer=function(vertexBuffer){
			this._vertexBuffer=vertexBuffer;
			this._vertexDeclarationDefine=vertexBuffer.vertexDeclaration._defineDatas.value;
			this._singletonVertexBuffer=true;
			this._vertexBuffers=null;
		}

		/**
		*@private
		*/
		__proto._setVertexBuffers=function(vertexBuffers){
			this._vertexBuffers=vertexBuffers;
			for (var i=0,n=vertexBuffers.length;i < n;i++)
			this._vertexDeclarationDefine |=vertexBuffers[i].vertexDeclaration._defineDatas.value;
			this._singletonVertexBuffer=false;
			this._vertexBuffer=null;
		}

		/**
		*@private
		*@return 是否需要渲染。
		*/
		__proto._prepareRender=function(state){
			return true;
		}

		/**
		*@private
		*/
		__proto._render=function(state){
			throw new Error("GeometryElement:must override it.");
		}

		/**
		*销毁。
		*/
		__proto.destroy=function(){
			this._destroyed=true;
			for (var i=0,n=this._vertexBuffers.length;i < n;i++)
			this._vertexBuffers[i].destroy();
			this._vertexBuffers=null;
		}

		/**
		*@private
		*/
		__getset(0,__proto,'_vertexBufferCount',function(){
			throw new Error("GeometryElement:must override it.");
		});

		/**
		*获取是否销毁。
		*@return 是否销毁。
		*/
		__getset(0,__proto,'destroyed',function(){
			return this._destroyed;
		});

		/**
		*@private
		*/
		__getset(0,__proto,'triangleCount',function(){
			throw new Error("GeometryElement:must override it.");
		});

		return GeometryElement;
	})()


	/**
	*<code>Layer</code> 类用于实现层。
	*/
	//class laya.d3.core.Layer
	var Layer=(function(){
		function Layer(){
			//this._number=0;
			//this._mask=0;
			//this._visible=false;
			//this._nonRigidbodyOffset=0;
			//this._colliders=null;
			//this.name=null;
			this._visible=true;
			this._nonRigidbodyOffset=0;
			this._colliders=[];
		}

		__class(Layer,'laya.d3.core.Layer');
		var __proto=Layer.prototype;
		/**
		*@private
		*/
		__proto._binarySearchIndex=function(){
			var start=0;
			var end=Layer._collsionTestList.length-1;
			var mid=0;
			while (start <=end){
				mid=Math.floor((start+end)/ 2);
				var midValue=Layer._collsionTestList[mid];
				if (midValue==this._number)
					return mid;
				else if (midValue > this._number)
				end=mid-1;
				else
				start=mid+1;
			}
			return start;
		}

		/**
		*@private
		*/
		__proto._addCollider=function(collider){
			(this._colliders.length===0)&& (Layer._collsionTestList.splice(this._binarySearchIndex(),0,this._number));
			if (collider._isRigidbody){
				this._colliders.unshift(collider);
				this._nonRigidbodyOffset++;
				}else {
				this._colliders.push(collider);
			}
		}

		/**
		*@private
		*/
		__proto._removeCollider=function(collider){
			var index=this._colliders.indexOf(collider);
			if (index < this._nonRigidbodyOffset)
				this._nonRigidbodyOffset--;
			this._colliders.splice(index,1);
			(this._colliders.length===0)&& (Layer._collsionTestList.splice(Layer._collsionTestList.indexOf(this._number),1));
		}

		/**
		*获取编号。
		*@return 编号。
		*/
		__getset(0,__proto,'number',function(){
			return this._number;
		});

		/**
		*设置是否显示。
		*@param value 是否显示。
		*/
		/**
		*获取是否显示。
		*@return 是否显示。
		*/
		__getset(0,__proto,'visible',function(){
			return this._visible;
			},function(value){
			this._visible=value;
			if (value)
				Layer._visibleLayers=Layer._visibleLayers | this.mask;
			else
			Layer._visibleLayers=Layer._visibleLayers & ~this.mask;
		});

		/**
		*获取蒙版值。
		*@return 蒙版值。
		*/
		__getset(0,__proto,'mask',function(){
			return this._mask;
		});

		/**
		*设置Layer显示层。
		*@param value 显示层。
		*/
		/**
		*获取Layer显示层。
		*@return 显示层。
		*/
		__getset(1,Layer,'visibleLayers',function(){
			return Layer._visibleLayers;
			},function(value){
			Layer._visibleLayers=value;
			for (var i=0,n=Layer._layerList.length;i < n;i++){
				var layer=Layer._layerList[i];
				layer._visible=(layer._mask & Layer._visibleLayers)!==0;
			}
		});

		Layer.__init__=function(){
			Layer._layerList.length=31;
			for (var i=0;i < 31;i++){
				var layer=new Layer();
				Layer._layerList[i]=layer;
				if (i===0){
					layer.name="Default Layer";
					layer.visible=true;
					}else {
					layer.name="Layer-"+i;
					layer.visible=false;
				}
				layer._number=i;
				layer._mask=Math.pow(2,i);
			}
			Layer.currentCreationLayer=Layer._layerList[0];
		}

		Layer.getLayerByNumber=function(number){
			if (number < 0 || number > 30)
				throw new Error("无法返回指定Layer，该number超出范围！");
			return Layer._layerList[number];
		}

		Layer.getLayerByName=function(name){
			for (var i=0;i < 31;i++){
				if (Layer._layerList[i].name===name)
					return Layer._layerList[i];
			}
			throw new Error("无法返回指定Layer,该name不存在");
		}

		Layer.isVisible=function(mask){
			return (mask & Layer._currentCameraCullingMask & Layer._visibleLayers)!=0;
		}

		Layer._layerList=[];
		Layer._visibleLayers=2147483647;
		Layer._collsionTestList=[];
		Layer._currentCameraCullingMask=2147483647;
		Layer.maxCount=31;
		Layer.currentCreationLayer=null
		return Layer;
	})()


	/**
	*<code>RenderState</code> 类用于控制渲染状态。
	*/
	//class laya.d3.core.material.RenderState
	var RenderState=(function(){
		function RenderState(){
			this.cull=0;
			this.blend=0;
			this.srcBlend=0;
			this.dstBlend=0;
			this.srcBlendRGB=0;
			this.dstBlendRGB=0;
			this.srcBlendAlpha=0;
			this.dstBlendAlpha=0;
			this.blendConstColor=null;
			this.blendEquation=0;
			this.blendEquationRGB=0;
			this.blendEquationAlpha=0;
			this.depthTest=0;
			this.depthWrite=false;
			this.cull=2;
			this.blend=0;
			this.srcBlend=1;
			this.dstBlend=0;
			this.srcBlendRGB=1;
			this.dstBlendRGB=0;
			this.srcBlendAlpha=1;
			this.dstBlendAlpha=0;
			this.blendConstColor=new Vector4(1,1,1,1);
			this.blendEquation=0;
			this.blendEquationRGB=0;
			this.blendEquationAlpha=0;
			this.depthTest=0x0201;
			this.depthWrite=true;
		}

		__class(RenderState,'laya.d3.core.material.RenderState');
		var __proto=RenderState.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*设置渲染相关状态。
		*/
		__proto._setRenderStateBlendDepth=function(){
			var gl=LayaGL.instance;
			WebGLContext.setDepthMask(gl,this.depthWrite);
			if (this.depthTest===0)
				WebGLContext.setDepthTest(gl,false);
			else {
				WebGLContext.setDepthTest(gl,true);
				WebGLContext.setDepthFunc(gl,this.depthTest);
			}
			switch (this.blend){
				case 0:
					WebGLContext.setBlend(gl,false);
					break ;
				case 1:
					WebGLContext.setBlend(gl,true);
					WebGLContext.setBlendFunc(gl,this.srcBlend,this.dstBlend);
					break ;
				case 2:
					WebGLContext.setBlend(gl,true);
					break ;
				}
		}

		/**
		*设置渲染相关状态。
		*/
		__proto._setRenderStateFrontFace=function(isTarget,transform){
			var gl=LayaGL.instance;
			var forntFace=0;
			switch (this.cull){
				case 0:
					WebGLContext.setCullFace(gl,false);
					break ;
				case 1:
					WebGLContext.setCullFace(gl,true);
					if (isTarget){
						if (transform && transform._isFrontFaceInvert)
							forntFace=0x0901;
						else
						forntFace=0x0900;
						}else {
						if (transform && transform._isFrontFaceInvert)
							forntFace=0x0900;
						else
						forntFace=0x0901;
					}
					WebGLContext.setFrontFace(gl,forntFace);
					break ;
				case 2:
					WebGLContext.setCullFace(gl,true);
					if (isTarget){
						if (transform && transform._isFrontFaceInvert)
							forntFace=0x0900;
						else
						forntFace=0x0901;
						}else {
						if (transform && transform._isFrontFaceInvert)
							forntFace=0x0901;
						else
						forntFace=0x0900;
					}
					WebGLContext.setFrontFace(gl,forntFace);
					break ;
				}
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(dest){
			var destState=dest;
			destState.cull=this.cull;
			destState.blend=this.blend;
			destState.srcBlend=this.srcBlend;
			destState.dstBlend=this.dstBlend;
			destState.srcBlendRGB=this.srcBlendRGB;
			destState.dstBlendRGB=this.dstBlendRGB;
			destState.srcBlendAlpha=this.srcBlendAlpha;
			destState.dstBlendAlpha=this.dstBlendAlpha;
			this.blendConstColor.cloneTo(destState.blendConstColor);
			destState.blendEquation=this.blendEquation;
			destState.blendEquationRGB=this.blendEquationRGB;
			destState.blendEquationAlpha=this.blendEquationAlpha;
			destState.depthTest=this.depthTest;
			destState.depthWrite=this.depthWrite;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		RenderState.CULL_NONE=0;
		RenderState.CULL_FRONT=1;
		RenderState.CULL_BACK=2;
		RenderState.BLEND_DISABLE=0;
		RenderState.BLEND_ENABLE_ALL=1;
		RenderState.BLEND_ENABLE_SEPERATE=2;
		RenderState.BLENDPARAM_ZERO=0;
		RenderState.BLENDPARAM_ONE=1;
		RenderState.BLENDPARAM_SRC_COLOR=0x0300;
		RenderState.BLENDPARAM_ONE_MINUS_SRC_COLOR=0x0301;
		RenderState.BLENDPARAM_DST_COLOR=0x0306;
		RenderState.BLENDPARAM_ONE_MINUS_DST_COLOR=0x0307;
		RenderState.BLENDPARAM_SRC_ALPHA=0x0302;
		RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA=0x0303;
		RenderState.BLENDPARAM_DST_ALPHA=0x0304;
		RenderState.BLENDPARAM_ONE_MINUS_DST_ALPHA=0x0305;
		RenderState.BLENDPARAM_SRC_ALPHA_SATURATE=0x0308;
		RenderState.BLENDEQUATION_ADD=0;
		RenderState.BLENDEQUATION_SUBTRACT=1;
		RenderState.BLENDEQUATION_REVERSE_SUBTRACT=2;
		RenderState.DEPTHTEST_OFF=0;
		RenderState.DEPTHTEST_NEVER=0x0200;
		RenderState.DEPTHTEST_LESS=0x0201;
		RenderState.DEPTHTEST_EQUAL=0x0202;
		RenderState.DEPTHTEST_LEQUAL=0x0203;
		RenderState.DEPTHTEST_GREATER=0x0204;
		RenderState.DEPTHTEST_NOTEQUAL=0x0205;
		RenderState.DEPTHTEST_GEQUAL=0x0206;
		RenderState.DEPTHTEST_ALWAYS=0x0207;
		return RenderState;
	})()


	/**
	*<code>Burst</code> 类用于粒子的爆裂描述。
	*/
	//class laya.d3.core.particleShuriKen.module.Burst
	var Burst=(function(){
		function Burst(time,minCount,maxCount){
			this._time=NaN;
			this._minCount=0;
			this._maxCount=0;
			this._time=time;
			this._minCount=minCount;
			this._maxCount=maxCount;
		}

		__class(Burst,'laya.d3.core.particleShuriKen.module.Burst');
		var __proto=Burst.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destBurst=destObject;
			destBurst._time=this._time
			destBurst._minCount=this._minCount;
			destBurst._maxCount=this._maxCount;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destBurst=new this.constructor();
			this.cloneTo(destBurst);
			return destBurst;
		}

		/**
		*获取爆裂时间,单位为秒。
		*@return 爆裂时间,单位为秒。
		*/
		__getset(0,__proto,'time',function(){
			return this._time;
		});

		/**
		*获取爆裂的最小数量。
		*@return 爆裂的最小数量。
		*/
		__getset(0,__proto,'minCount',function(){
			return this._minCount;
		});

		/**
		*获取爆裂的最大数量。
		*@return 爆裂的最大数量。
		*/
		__getset(0,__proto,'maxCount',function(){
			return this._maxCount;
		});

		return Burst;
	})()


	/**
	*<code>ColorOverLifetime</code> 类用于粒子的生命周期颜色。
	*/
	//class laya.d3.core.particleShuriKen.module.ColorOverLifetime
	var ColorOverLifetime=(function(){
		function ColorOverLifetime(color){
			this._color=null;
			this.enbale=false;
			this._color=color;
		}

		__class(ColorOverLifetime,'laya.d3.core.particleShuriKen.module.ColorOverLifetime');
		var __proto=ColorOverLifetime.prototype;
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destColorOverLifetime=destObject;
			this._color.cloneTo(destColorOverLifetime._color);
			destColorOverLifetime.enbale=this.enbale;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destColor;
			switch (this._color.type){
				case 0:
					destColor=GradientColor.createByConstant(this._color.constant.clone());
					break ;
				case 1:
					destColor=GradientColor.createByGradient(this._color.gradient.clone());
					break ;
				case 2:
					destColor=GradientColor.createByRandomTwoConstant(this._color.constantMin.clone(),this._color.constantMax.clone());
					break ;
				case 3:
					destColor=GradientColor.createByRandomTwoGradient(this._color.gradientMin.clone(),this._color.gradientMax.clone());
					break ;
				};
			var destColorOverLifetime=new this.constructor(destColor);
			destColorOverLifetime.enbale=this.enbale;
			return destColorOverLifetime;
		}

		/**
		*获取颜色。
		*/
		__getset(0,__proto,'color',function(){
			return this._color;
		});

		return ColorOverLifetime;
	})()


	/**
	*<code>Emission</code> 类用于粒子发射器。
	*/
	//class laya.d3.core.particleShuriKen.module.Emission
	var Emission=(function(){
		function Emission(){
			this._destroyed=false;
			this._emissionRate=0;
			this._bursts=null;
			this.enbale=false;
			this._destroyed=false;
			this.emissionRate=10;
			this._bursts=[];
		}

		__class(Emission,'laya.d3.core.particleShuriKen.module.Emission');
		var __proto=Emission.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true,"laya.resource.IDestroy":true})
		/**
		*@private
		*/
		__proto.destroy=function(){
			this._bursts=null;
			this._destroyed=true;
		}

		/**
		*获取粒子爆裂个数。
		*@return 粒子爆裂个数。
		*/
		__proto.getBurstsCount=function(){
			return this._bursts.length;
		}

		/**
		*通过索引获取粒子爆裂。
		*@param index 爆裂索引。
		*@return 粒子爆裂。
		*/
		__proto.getBurstByIndex=function(index){
			return this._bursts[index];
		}

		/**
		*增加粒子爆裂。
		*@param burst 爆裂。
		*/
		__proto.addBurst=function(burst){
			var burstsCount=this._bursts.length;
			if (burstsCount > 0)
				for (var i=0;i < burstsCount;i++){
				if (this._bursts[i].time > burst.time)
					this._bursts.splice(i,0,burst);
			}
			this._bursts.push(burst);
		}

		/**
		*移除粒子爆裂。
		*@param burst 爆裂。
		*/
		__proto.removeBurst=function(burst){
			var index=this._bursts.indexOf(burst);
			if (index!==-1){
				this._bursts.splice(index,1);
			}
		}

		/**
		*通过索引移除粒子爆裂。
		*@param index 爆裂索引。
		*/
		__proto.removeBurstByIndex=function(index){
			this._bursts.splice(index,1);
		}

		/**
		*清空粒子爆裂。
		*/
		__proto.clearBurst=function(){
			this._bursts.length=0;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destEmission=destObject;
			var destBursts=destEmission._bursts;
			destBursts.length=this._bursts.length;
			for (var i=0,n=this._bursts.length;i < n;i++){
				var destBurst=destBursts[i];
				if (destBurst)
					this._bursts[i].cloneTo(destBurst);
				else
				destBursts[i]=this._bursts[i].clone();
			}
			destEmission._emissionRate=this._emissionRate;
			destEmission.enbale=this.enbale;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destEmission=new this.constructor();
			this.cloneTo(destEmission);
			return destEmission;
		}

		/**
		*获取是否已销毁。
		*@return 是否已销毁。
		*/
		__getset(0,__proto,'destroyed',function(){
			return this._destroyed;
		});

		/**
		*设置粒子发射速率。
		*@param emissionRate 粒子发射速率 (个/秒)。
		*/
		/**
		*获取粒子发射速率。
		*@return 粒子发射速率 (个/秒)。
		*/
		__getset(0,__proto,'emissionRate',function(){
			return this._emissionRate;
			},function(value){
			if (value < 0)
				throw new Error("ParticleBaseShape:emissionRate value must large or equal than 0.");
			this._emissionRate=value;
		});

		return Emission;
	})()


	/**
	*<code>FrameOverTime</code> 类用于创建时间帧。
	*/
	//class laya.d3.core.particleShuriKen.module.FrameOverTime
	var FrameOverTime=(function(){
		function FrameOverTime(){
			this._type=0;
			this._constant=0;
			this._overTime=null;
			this._constantMin=0;
			this._constantMax=0;
			this._overTimeMin=null;
			this._overTimeMax=null;
		}

		__class(FrameOverTime,'laya.d3.core.particleShuriKen.module.FrameOverTime');
		var __proto=FrameOverTime.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destFrameOverTime=destObject;
			destFrameOverTime._type=this._type;
			destFrameOverTime._constant=this._constant;
			this._overTime.cloneTo(destFrameOverTime._overTime);
			destFrameOverTime._constantMin=this._constantMin;
			destFrameOverTime._constantMax=this._constantMax;
			this._overTimeMin.cloneTo(destFrameOverTime._overTimeMin);
			this._overTimeMax.cloneTo(destFrameOverTime._overTimeMax);
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destFrameOverTime=new this.constructor();
			this.cloneTo(destFrameOverTime);
			return destFrameOverTime;
		}

		/**
		*时间帧。
		*/
		__getset(0,__proto,'frameOverTimeData',function(){
			return this._overTime;
		});

		/**
		*固定帧。
		*/
		__getset(0,__proto,'constant',function(){
			return this._constant;
		});

		/**
		*生命周期旋转类型,0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
		*/
		__getset(0,__proto,'type',function(){
			return this._type;
		});

		/**
		*最小时间帧。
		*/
		__getset(0,__proto,'frameOverTimeDataMin',function(){
			return this._overTimeMin;
		});

		/**
		*最小固定帧。
		*/
		__getset(0,__proto,'constantMin',function(){
			return this._constantMin;
		});

		/**
		*最大时间帧。
		*/
		__getset(0,__proto,'frameOverTimeDataMax',function(){
			return this._overTimeMax;
		});

		/**
		*最大固定帧。
		*/
		__getset(0,__proto,'constantMax',function(){
			return this._constantMax;
		});

		FrameOverTime.createByConstant=function(constant){
			var rotationOverLifetime=new FrameOverTime();
			rotationOverLifetime._type=0;
			rotationOverLifetime._constant=constant;
			return rotationOverLifetime;
		}

		FrameOverTime.createByOverTime=function(overTime){
			var rotationOverLifetime=new FrameOverTime();
			rotationOverLifetime._type=1;
			rotationOverLifetime._overTime=overTime;
			return rotationOverLifetime;
		}

		FrameOverTime.createByRandomTwoConstant=function(constantMin,constantMax){
			var rotationOverLifetime=new FrameOverTime();
			rotationOverLifetime._type=2;
			rotationOverLifetime._constantMin=constantMin;
			rotationOverLifetime._constantMax=constantMax;
			return rotationOverLifetime;
		}

		FrameOverTime.createByRandomTwoOverTime=function(gradientFrameMin,gradientFrameMax){
			var rotationOverLifetime=new FrameOverTime();
			rotationOverLifetime._type=3;
			rotationOverLifetime._overTimeMin=gradientFrameMin;
			rotationOverLifetime._overTimeMax=gradientFrameMax;
			return rotationOverLifetime;
		}

		return FrameOverTime;
	})()


	/**
	*<code>GradientRotation</code> 类用于创建渐变角速度。
	*/
	//class laya.d3.core.particleShuriKen.module.GradientAngularVelocity
	var GradientAngularVelocity=(function(){
		function GradientAngularVelocity(){
			this._type=0;
			this._separateAxes=false;
			this._constant=NaN;
			this._constantSeparate=null;
			this._gradient=null;
			this._gradientX=null;
			this._gradientY=null;
			this._gradientZ=null;
			this._gradientW=null;
			this._constantMin=NaN;
			this._constantMax=NaN;
			this._constantMinSeparate=null;
			this._constantMaxSeparate=null;
			this._gradientMin=null;
			this._gradientMax=null;
			this._gradientXMin=null;
			this._gradientXMax=null;
			this._gradientYMin=null;
			this._gradientYMax=null;
			this._gradientZMin=null;
			this._gradientZMax=null;
			this._gradientWMin=null;
			this._gradientWMax=null;
		}

		__class(GradientAngularVelocity,'laya.d3.core.particleShuriKen.module.GradientAngularVelocity');
		var __proto=GradientAngularVelocity.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destGradientAngularVelocity=destObject;
			destGradientAngularVelocity._type=this._type;
			destGradientAngularVelocity._separateAxes=this._separateAxes;
			destGradientAngularVelocity._constant=this._constant;
			this._constantSeparate.cloneTo(destGradientAngularVelocity._constantSeparate);
			this._gradient.cloneTo(destGradientAngularVelocity._gradient);
			this._gradientX.cloneTo(destGradientAngularVelocity._gradientX);
			this._gradientY.cloneTo(destGradientAngularVelocity._gradientY);
			this._gradientZ.cloneTo(destGradientAngularVelocity._gradientZ);
			destGradientAngularVelocity._constantMin=this._constantMin;
			destGradientAngularVelocity._constantMax=this._constantMax;
			this._constantMinSeparate.cloneTo(destGradientAngularVelocity._constantMinSeparate);
			this._constantMaxSeparate.cloneTo(destGradientAngularVelocity._constantMaxSeparate);
			this._gradientMin.cloneTo(destGradientAngularVelocity._gradientMin);
			this._gradientMax.cloneTo(destGradientAngularVelocity._gradientMax);
			this._gradientXMin.cloneTo(destGradientAngularVelocity._gradientXMin);
			this._gradientXMax.cloneTo(destGradientAngularVelocity._gradientXMax);
			this._gradientYMin.cloneTo(destGradientAngularVelocity._gradientYMin);
			this._gradientYMax.cloneTo(destGradientAngularVelocity._gradientYMax);
			this._gradientZMin.cloneTo(destGradientAngularVelocity._gradientZMin);
			this._gradientZMax.cloneTo(destGradientAngularVelocity._gradientZMax);
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destGradientAngularVelocity=new this.constructor();
			this.cloneTo(destGradientAngularVelocity);
			return destGradientAngularVelocity;
		}

		/**
		*渐变角速度Z。
		*/
		__getset(0,__proto,'gradientZ',function(){
			return this._gradientZ;
		});

		/**
		*固定角速度。
		*/
		__getset(0,__proto,'constant',function(){
			return this._constant;
		});

		/**
		*渐变角速度。
		*/
		__getset(0,__proto,'gradient',function(){
			return this._gradient;
		});

		/**
		*是否分轴。
		*/
		__getset(0,__proto,'separateAxes',function(){
			return this._separateAxes;
		});

		/**
		*生命周期角速度类型,0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
		*/
		__getset(0,__proto,'type',function(){
			return this._type;
		});

		/**
		*分轴固定角速度。
		*/
		__getset(0,__proto,'constantSeparate',function(){
			return this._constantSeparate;
		});

		/**
		*渐变角角速度X。
		*/
		__getset(0,__proto,'gradientX',function(){
			return this._gradientX;
		});

		/**
		*渐变角速度Y。
		*/
		__getset(0,__proto,'gradientY',function(){
			return this._gradientY;
		});

		/**
		*渐变角速度Z。
		*/
		__getset(0,__proto,'gradientW',function(){
			return this._gradientW;
		});

		/**
		*最小渐变角速度。
		*/
		__getset(0,__proto,'gradientMin',function(){
			return this._gradientMin;
		});

		/**
		*最小随机双固定角速度。
		*/
		__getset(0,__proto,'constantMin',function(){
			return this._constantMin;
		});

		/**
		*最大渐变角速度。
		*/
		__getset(0,__proto,'gradientMax',function(){
			return this._gradientMax;
		});

		/**
		*最大随机双固定角速度。
		*/
		__getset(0,__proto,'constantMax',function(){
			return this._constantMax;
		});

		/**
		*最小渐变角速度Z。
		*/
		__getset(0,__proto,'gradientWMin',function(){
			return this._gradientWMin;
		});

		/**
		*最小分轴随机双固定角速度。
		*/
		__getset(0,__proto,'constantMinSeparate',function(){
			return this._constantMinSeparate;
		});

		/**
		*最大分轴随机双固定角速度。
		*/
		__getset(0,__proto,'constantMaxSeparate',function(){
			return this._constantMaxSeparate;
		});

		/**
		*最小渐变角速度X。
		*/
		__getset(0,__proto,'gradientXMin',function(){
			return this._gradientXMin;
		});

		/**
		*最大渐变角速度X。
		*/
		__getset(0,__proto,'gradientXMax',function(){
			return this._gradientXMax;
		});

		/**
		*最大渐变角速度Z。
		*/
		__getset(0,__proto,'gradientWMax',function(){
			return this._gradientWMax;
		});

		/**
		*最小渐变角速度Y。
		*/
		__getset(0,__proto,'gradientYMin',function(){
			return this._gradientYMin;
		});

		/**
		*最大渐变角速度Y。
		*/
		__getset(0,__proto,'gradientYMax',function(){
			return this._gradientYMax;
		});

		/**
		*最小渐变角速度Z。
		*/
		__getset(0,__proto,'gradientZMin',function(){
			return this._gradientZMin;
		});

		/**
		*最大渐变角速度Z。
		*/
		__getset(0,__proto,'gradientZMax',function(){
			return this._gradientZMax;
		});

		GradientAngularVelocity.createByConstant=function(constant){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=0;
			gradientAngularVelocity._separateAxes=false;
			gradientAngularVelocity._constant=constant;
			return gradientAngularVelocity;
		}

		GradientAngularVelocity.createByConstantSeparate=function(separateConstant){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=0;
			gradientAngularVelocity._separateAxes=true;
			gradientAngularVelocity._constantSeparate=separateConstant;
			return gradientAngularVelocity;
		}

		GradientAngularVelocity.createByGradient=function(gradient){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=1;
			gradientAngularVelocity._separateAxes=false;
			gradientAngularVelocity._gradient=gradient;
			return gradientAngularVelocity;
		}

		GradientAngularVelocity.createByGradientSeparate=function(gradientX,gradientY,gradientZ,gradientW){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=1;
			gradientAngularVelocity._separateAxes=true;
			gradientAngularVelocity._gradientX=gradientX;
			gradientAngularVelocity._gradientY=gradientY;
			gradientAngularVelocity._gradientZ=gradientZ;
			gradientAngularVelocity._gradientW=gradientW;
			return gradientAngularVelocity;
		}

		GradientAngularVelocity.createByRandomTwoConstant=function(constantMin,constantMax){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=2;
			gradientAngularVelocity._separateAxes=false;
			gradientAngularVelocity._constantMin=constantMin;
			gradientAngularVelocity._constantMax=constantMax;
			return gradientAngularVelocity;
		}

		GradientAngularVelocity.createByRandomTwoConstantSeparate=function(separateConstantMin,separateConstantMax){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=2;
			gradientAngularVelocity._separateAxes=true;
			gradientAngularVelocity._constantMinSeparate=separateConstantMin;
			gradientAngularVelocity._constantMaxSeparate=separateConstantMax;
			return gradientAngularVelocity;
		}

		GradientAngularVelocity.createByRandomTwoGradient=function(gradientMin,gradientMax){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=3;
			gradientAngularVelocity._separateAxes=false;
			gradientAngularVelocity._gradientMin=gradientMin;
			gradientAngularVelocity._gradientMax=gradientMax;
			return gradientAngularVelocity;
		}

		GradientAngularVelocity.createByRandomTwoGradientSeparate=function(gradientXMin,gradientXMax,gradientYMin,gradientYMax,gradientZMin,gradientZMax,gradientWMin,gradientWMax){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=3;
			gradientAngularVelocity._separateAxes=true;
			gradientAngularVelocity._gradientXMin=gradientXMin;
			gradientAngularVelocity._gradientXMax=gradientXMax;
			gradientAngularVelocity._gradientYMin=gradientYMin;
			gradientAngularVelocity._gradientYMax=gradientYMax;
			gradientAngularVelocity._gradientZMin=gradientZMin;
			gradientAngularVelocity._gradientZMax=gradientZMax;
			gradientAngularVelocity._gradientWMin=gradientWMin;
			gradientAngularVelocity._gradientWMax=gradientWMax;
			return gradientAngularVelocity;
		}

		return GradientAngularVelocity;
	})()


	/**
	*<code>GradientColor</code> 类用于创建渐变颜色。
	*/
	//class laya.d3.core.particleShuriKen.module.GradientColor
	var GradientColor=(function(){
		function GradientColor(){
			this._type=0;
			this._constant=null;
			this._constantMin=null;
			this._constantMax=null;
			this._gradient=null;
			this._gradientMin=null;
			this._gradientMax=null;
		}

		__class(GradientColor,'laya.d3.core.particleShuriKen.module.GradientColor');
		var __proto=GradientColor.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destGradientColor=destObject;
			destGradientColor._type=this._type;
			this._constant.cloneTo(destGradientColor._constant);
			this._constantMin.cloneTo(destGradientColor._constantMin);
			this._constantMax.cloneTo(destGradientColor._constantMax);
			this._gradient.cloneTo(destGradientColor._gradient);
			this._gradientMin.cloneTo(destGradientColor._gradientMin);
			this._gradientMax.cloneTo(destGradientColor._gradientMax);
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destGradientColor=new this.constructor();
			this.cloneTo(destGradientColor);
			return destGradientColor;
		}

		/**
		*渐变颜色。
		*/
		__getset(0,__proto,'gradient',function(){
			return this._gradient;
		});

		/**
		*固定颜色。
		*/
		__getset(0,__proto,'constant',function(){
			return this._constant;
		});

		/**
		*生命周期颜色类型,0为固定颜色模式,1渐变模式,2为随机双固定颜色模式,3随机双渐变模式。
		*/
		__getset(0,__proto,'type',function(){
			return this._type;
		});

		/**
		*最小渐变颜色。
		*/
		__getset(0,__proto,'gradientMin',function(){
			return this._gradientMin;
		});

		/**
		*最小固定颜色。
		*/
		__getset(0,__proto,'constantMin',function(){
			return this._constantMin;
		});

		/**
		*最大渐变颜色。
		*/
		__getset(0,__proto,'gradientMax',function(){
			return this._gradientMax;
		});

		/**
		*最大固定颜色。
		*/
		__getset(0,__proto,'constantMax',function(){
			return this._constantMax;
		});

		GradientColor.createByConstant=function(constant){
			var gradientColor=new GradientColor();
			gradientColor._type=0;
			gradientColor._constant=constant;
			return gradientColor;
		}

		GradientColor.createByGradient=function(gradient){
			var gradientColor=new GradientColor();
			gradientColor._type=1;
			gradientColor._gradient=gradient;
			return gradientColor;
		}

		GradientColor.createByRandomTwoConstant=function(minConstant,maxConstant){
			var gradientColor=new GradientColor();
			gradientColor._type=2;
			gradientColor._constantMin=minConstant;
			gradientColor._constantMax=maxConstant;
			return gradientColor;
		}

		GradientColor.createByRandomTwoGradient=function(minGradient,maxGradient){
			var gradientColor=new GradientColor();
			gradientColor._type=3;
			gradientColor._gradientMin=minGradient;
			gradientColor._gradientMax=maxGradient;
			return gradientColor;
		}

		return GradientColor;
	})()


	/**
	*<code>GradientDataColor</code> 类用于创建颜色渐变。
	*/
	//class laya.d3.core.particleShuriKen.module.GradientDataColor
	var GradientDataColor=(function(){
		function GradientDataColor(){
			this._alphaCurrentLength=0;
			this._rgbCurrentLength=0;
			this._alphaElements=null;
			this._rgbElements=null;
			this._alphaElements=new Float32Array(8);
			this._rgbElements=new Float32Array(16);
		}

		__class(GradientDataColor,'laya.d3.core.particleShuriKen.module.GradientDataColor');
		var __proto=GradientDataColor.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*增加Alpha渐变。
		*@param key 生命周期，范围为0到1。
		*@param value rgb值。
		*/
		__proto.addAlpha=function(key,value){
			if (this._alphaCurrentLength < 8){
				if ((this._alphaCurrentLength===6)&& ((key!==1))){
					key=1;
					console.log("GradientDataColor warning:the forth key is  be force set to 1.");
				}
				this._alphaElements[this._alphaCurrentLength++]=key;
				this._alphaElements[this._alphaCurrentLength++]=value;
				}else {
				console.log("GradientDataColor warning:data count must lessEqual than 4");
			}
		}

		/**
		*增加RGB渐变。
		*@param key 生命周期，范围为0到1。
		*@param value RGB值。
		*/
		__proto.addRGB=function(key,value){
			if (this._rgbCurrentLength < 16){
				if ((this._rgbCurrentLength===12)&& ((key!==1))){
					key=1;
					console.log("GradientDataColor warning:the forth key is  be force set to 1.");
				}
				this._rgbElements[this._rgbCurrentLength++]=key;
				this._rgbElements[this._rgbCurrentLength++]=value.x;
				this._rgbElements[this._rgbCurrentLength++]=value.y;
				this._rgbElements[this._rgbCurrentLength++]=value.z;
				}else {
				console.log("GradientDataColor warning:data count must lessEqual than 4");
			}
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destGradientDataColor=destObject;
			var i=0,n=0;
			destGradientDataColor._alphaCurrentLength=this._alphaCurrentLength;
			var destAlphaElements=destGradientDataColor._alphaElements;
			destAlphaElements.length=this._alphaElements.length;
			for (i=0,n=this._alphaElements.length;i < n;i++)
			destAlphaElements[i]=this._alphaElements[i];
			destGradientDataColor._rgbCurrentLength=this._rgbCurrentLength;
			var destRGBElements=destGradientDataColor._rgbElements;
			destRGBElements.length=this._rgbElements.length;
			for (i=0,n=this._rgbElements.length;i < n;i++)
			destRGBElements[i]=this._rgbElements[i];
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destGradientDataColor=new this.constructor();
			this.cloneTo(destGradientDataColor);
			return destGradientDataColor;
		}

		/**渐变Alpha数量。*/
		__getset(0,__proto,'alphaGradientCount',function(){
			return this._alphaCurrentLength / 2;
		});

		/**渐变RGB数量。*/
		__getset(0,__proto,'rgbGradientCount',function(){
			return this._rgbCurrentLength / 4;
		});

		return GradientDataColor;
	})()


	/**
	*<code>GradientDataInt</code> 类用于创建整形渐变。
	*/
	//class laya.d3.core.particleShuriKen.module.GradientDataInt
	var GradientDataInt=(function(){
		function GradientDataInt(){
			this._currentLength=0;
			this._elements=null;
			this._elements=new Float32Array(8);
		}

		__class(GradientDataInt,'laya.d3.core.particleShuriKen.module.GradientDataInt');
		var __proto=GradientDataInt.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*增加整形渐变。
		*@param key 生命周期，范围为0到1。
		*@param value 整形值。
		*/
		__proto.add=function(key,value){
			if (this._currentLength < 8){
				if ((this._currentLength===6)&& ((key!==1))){
					key=1;
					console.log("Warning:the forth key is  be force set to 1.");
				}
				this._elements[this._currentLength++]=key;
				this._elements[this._currentLength++]=value;
				}else {
				console.log("Warning:data count must lessEqual than 4");
			}
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destGradientDataInt=destObject;
			destGradientDataInt._currentLength=this._currentLength;
			var destElements=destGradientDataInt._elements;
			destElements.length=this._elements.length;
			for (var i=0,n=this._elements.length;i < n;i++){
				destElements[i]=this._elements[i];
			}
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destGradientDataInt=new this.constructor();
			this.cloneTo(destGradientDataInt);
			return destGradientDataInt;
		}

		/**整形渐变数量。*/
		__getset(0,__proto,'gradientCount',function(){
			return this._currentLength / 2;
		});

		return GradientDataInt;
	})()


	/**
	*<code>GradientDataNumber</code> 类用于创建浮点渐变。
	*/
	//class laya.d3.core.particleShuriKen.module.GradientDataNumber
	var GradientDataNumber=(function(){
		function GradientDataNumber(){
			this._currentLength=0;
			this._elements=null;
			this._elements=new Float32Array(8);
		}

		__class(GradientDataNumber,'laya.d3.core.particleShuriKen.module.GradientDataNumber');
		var __proto=GradientDataNumber.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*增加浮点渐变。
		*@param key 生命周期，范围为0到1。
		*@param value 浮点值。
		*/
		__proto.add=function(key,value){
			if (this._currentLength < 8){
				if ((this._currentLength===6)&& ((key!==1))){
					key=1;
					console.log("GradientDataNumber warning:the forth key is  be force set to 1.");
				}
				this._elements[this._currentLength++]=key;
				this._elements[this._currentLength++]=value;
				}else {
				console.log("GradientDataNumber warning:data count must lessEqual than 4");
			}
		}

		/**
		*通过索引获取键。
		*@param index 索引。
		*@return value 键。
		*/
		__proto.getKeyByIndex=function(index){
			return this._elements[index *2];
		}

		/**
		*通过索引获取值。
		*@param index 索引。
		*@return value 值。
		*/
		__proto.getValueByIndex=function(index){
			return this._elements[index *2+1];
		}

		/**
		*获取平均值。
		*/
		__proto.getAverageValue=function(){
			var total=0;
			for (var i=0,n=this._currentLength-2;i < n;i+=2){
				var subValue=this._elements[i+1];
				subValue+=this._elements[i+3];
				subValue=subValue *(this._elements[i+2]-this._elements[i]);
			}
			return total / 2;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destGradientDataNumber=destObject;
			destGradientDataNumber._currentLength=this._currentLength;
			var destElements=destGradientDataNumber._elements;
			destElements.length=this._elements.length;
			for (var i=0,n=this._elements.length;i < n;i++)
			destElements[i]=this._elements[i];
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destGradientDataNumber=new this.constructor();
			this.cloneTo(destGradientDataNumber);
			return destGradientDataNumber;
		}

		/**渐变浮点数量。*/
		__getset(0,__proto,'gradientCount',function(){
			return this._currentLength / 2;
		});

		return GradientDataNumber;
	})()


	/**
	*<code>GradientSize</code> 类用于创建渐变尺寸。
	*/
	//class laya.d3.core.particleShuriKen.module.GradientSize
	var GradientSize=(function(){
		function GradientSize(){
			this._type=0;
			this._separateAxes=false;
			this._gradient=null;
			this._gradientX=null;
			this._gradientY=null;
			this._gradientZ=null;
			this._constantMin=NaN;
			this._constantMax=NaN;
			this._constantMinSeparate=null;
			this._constantMaxSeparate=null;
			this._gradientMin=null;
			this._gradientMax=null;
			this._gradientXMin=null;
			this._gradientXMax=null;
			this._gradientYMin=null;
			this._gradientYMax=null;
			this._gradientZMin=null;
			this._gradientZMax=null;
		}

		__class(GradientSize,'laya.d3.core.particleShuriKen.module.GradientSize');
		var __proto=GradientSize.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*获取最大尺寸。
		*/
		__proto.getMaxSizeInGradient=function(){
			var i=0,n=0;
			var maxSize=-Number.MAX_VALUE;
			switch (this._type){
				case 0:
					if (this._separateAxes){
						for (i=0,n=this._gradientX.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientX.getValueByIndex(i));
						for (i=0,n=this._gradientY.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientY.getValueByIndex(i));
						}else {
						for (i=0,n=this._gradient.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradient.getValueByIndex(i));
					}
					break ;
				case 1:
					if (this._separateAxes){
						maxSize=Math.max(this._constantMinSeparate.x,this._constantMaxSeparate.x);
						maxSize=Math.max(maxSize,this._constantMinSeparate.y);
						maxSize=Math.max(maxSize,this._constantMaxSeparate.y);
						}else {
						maxSize=Math.max(this._constantMin,this._constantMax);
					}
					break ;
				case 2:
					if (this._separateAxes){
						for (i=0,n=this._gradientXMin.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientXMin.getValueByIndex(i));
						for (i=0,n=this._gradientXMax.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientXMax.getValueByIndex(i));
						for (i=0,n=this._gradientYMin.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientYMin.getValueByIndex(i));
						for (i=0,n=this._gradientZMax.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientZMax.getValueByIndex(i));
						}else {
						for (i=0,n=this._gradientMin.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientMin.getValueByIndex(i));
						for (i=0,n=this._gradientMax.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientMax.getValueByIndex(i));
					}
					break ;
				}
			return maxSize;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destGradientSize=destObject;
			destGradientSize._type=this._type;
			destGradientSize._separateAxes=this._separateAxes;
			this._gradient.cloneTo(destGradientSize._gradient);
			this._gradientX.cloneTo(destGradientSize._gradientX);
			this._gradientY.cloneTo(destGradientSize._gradientY);
			this._gradientZ.cloneTo(destGradientSize._gradientZ);
			destGradientSize._constantMin=this._constantMin;
			destGradientSize._constantMax=this._constantMax;
			this._constantMinSeparate.cloneTo(destGradientSize._constantMinSeparate);
			this._constantMaxSeparate.cloneTo(destGradientSize._constantMaxSeparate);
			this._gradientMin.cloneTo(destGradientSize._gradientMin);
			this._gradientMax.cloneTo(destGradientSize._gradientMax);
			this._gradientXMin.cloneTo(destGradientSize._gradientXMin);
			this._gradientXMax.cloneTo(destGradientSize._gradientXMax);
			this._gradientYMin.cloneTo(destGradientSize._gradientYMin);
			this._gradientYMax.cloneTo(destGradientSize._gradientYMax);
			this._gradientZMin.cloneTo(destGradientSize._gradientZMin);
			this._gradientZMax.cloneTo(destGradientSize._gradientZMax);
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destGradientSize=new this.constructor();
			this.cloneTo(destGradientSize);
			return destGradientSize;
		}

		/**
		*渐变尺寸Z。
		*/
		__getset(0,__proto,'gradientZ',function(){
			return this._gradientZ;
		});

		/**
		*渐变尺寸。
		*/
		__getset(0,__proto,'gradient',function(){
			return this._gradient;
		});

		/**
		*是否分轴。
		*/
		__getset(0,__proto,'separateAxes',function(){
			return this._separateAxes;
		});

		/**
		*生命周期尺寸类型，0曲线模式，1随机双常量模式，2随机双曲线模式。
		*/
		__getset(0,__proto,'type',function(){
			return this._type;
		});

		/**
		*渐变最小尺寸。
		*/
		__getset(0,__proto,'gradientMin',function(){
			return this._gradientMin;
		});

		/**
		*最小随机双固定尺寸。
		*/
		__getset(0,__proto,'constantMin',function(){
			return this._constantMin;
		});

		/**
		*渐变尺寸X。
		*/
		__getset(0,__proto,'gradientX',function(){
			return this._gradientX;
		});

		/**
		*渐变尺寸Y。
		*/
		__getset(0,__proto,'gradientY',function(){
			return this._gradientY;
		});

		/**
		*渐变最大尺寸。
		*/
		__getset(0,__proto,'gradientMax',function(){
			return this._gradientMax;
		});

		/**
		*最大随机双固定尺寸。
		*/
		__getset(0,__proto,'constantMax',function(){
			return this._constantMax;
		});

		/**
		*最小分轴随机双固定尺寸。
		*/
		__getset(0,__proto,'constantMinSeparate',function(){
			return this._constantMinSeparate;
		});

		/**
		*最小分轴随机双固定尺寸。
		*/
		__getset(0,__proto,'constantMaxSeparate',function(){
			return this._constantMaxSeparate;
		});

		/**
		*渐变最小尺寸X。
		*/
		__getset(0,__proto,'gradientXMin',function(){
			return this._gradientXMin;
		});

		/**
		*渐变最大尺寸X。
		*/
		__getset(0,__proto,'gradientXMax',function(){
			return this._gradientXMax;
		});

		/**
		*渐变最小尺寸Y。
		*/
		__getset(0,__proto,'gradientYMin',function(){
			return this._gradientYMin;
		});

		/**
		*渐变最大尺寸Y。
		*/
		__getset(0,__proto,'gradientYMax',function(){
			return this._gradientYMax;
		});

		/**
		*渐变最小尺寸Z。
		*/
		__getset(0,__proto,'gradientZMin',function(){
			return this._gradientZMin;
		});

		/**
		*渐变最大尺寸Z。
		*/
		__getset(0,__proto,'gradientZMax',function(){
			return this._gradientZMax;
		});

		GradientSize.createByGradient=function(gradient){
			var gradientSize=new GradientSize();
			gradientSize._type=0;
			gradientSize._separateAxes=false;
			gradientSize._gradient=gradient;
			return gradientSize;
		}

		GradientSize.createByGradientSeparate=function(gradientX,gradientY,gradientZ){
			var gradientSize=new GradientSize();
			gradientSize._type=0;
			gradientSize._separateAxes=true;
			gradientSize._gradientX=gradientX;
			gradientSize._gradientY=gradientY;
			gradientSize._gradientZ=gradientZ;
			return gradientSize;
		}

		GradientSize.createByRandomTwoConstant=function(constantMin,constantMax){
			var gradientSize=new GradientSize();
			gradientSize._type=1;
			gradientSize._separateAxes=false;
			gradientSize._constantMin=constantMin;
			gradientSize._constantMax=constantMax;
			return gradientSize;
		}

		GradientSize.createByRandomTwoConstantSeparate=function(constantMinSeparate,constantMaxSeparate){
			var gradientSize=new GradientSize();
			gradientSize._type=1;
			gradientSize._separateAxes=true;
			gradientSize._constantMinSeparate=constantMinSeparate;
			gradientSize._constantMaxSeparate=constantMaxSeparate;
			return gradientSize;
		}

		GradientSize.createByRandomTwoGradient=function(gradientMin,gradientMax){
			var gradientSize=new GradientSize();
			gradientSize._type=2;
			gradientSize._separateAxes=false;
			gradientSize._gradientMin=gradientMin;
			gradientSize._gradientMax=gradientMax;
			return gradientSize;
		}

		GradientSize.createByRandomTwoGradientSeparate=function(gradientXMin,gradientXMax,gradientYMin,gradientYMax,gradientZMin,gradientZMax){
			var gradientSize=new GradientSize();
			gradientSize._type=2;
			gradientSize._separateAxes=true;
			gradientSize._gradientXMin=gradientXMin;
			gradientSize._gradientXMax=gradientXMax;
			gradientSize._gradientYMin=gradientYMin;
			gradientSize._gradientYMax=gradientYMax;
			gradientSize._gradientZMin=gradientZMin;
			gradientSize._gradientZMax=gradientZMax;
			return gradientSize;
		}

		return GradientSize;
	})()


	/**
	*<code>GradientVelocity</code> 类用于创建渐变速度。
	*/
	//class laya.d3.core.particleShuriKen.module.GradientVelocity
	var GradientVelocity=(function(){
		function GradientVelocity(){
			this._type=0;
			this._constant=null;
			this._gradientX=null;
			this._gradientY=null;
			this._gradientZ=null;
			this._constantMin=null;
			this._constantMax=null;
			this._gradientXMin=null;
			this._gradientXMax=null;
			this._gradientYMin=null;
			this._gradientYMax=null;
			this._gradientZMin=null;
			this._gradientZMax=null;
		}

		__class(GradientVelocity,'laya.d3.core.particleShuriKen.module.GradientVelocity');
		var __proto=GradientVelocity.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destGradientVelocity=destObject;
			destGradientVelocity._type=this._type;
			this._constant.cloneTo(destGradientVelocity._constant);
			this._gradientX.cloneTo(destGradientVelocity._gradientX);
			this._gradientY.cloneTo(destGradientVelocity._gradientY);
			this._gradientZ.cloneTo(destGradientVelocity._gradientZ);
			this._constantMin.cloneTo(destGradientVelocity._constantMin);
			this._constantMax.cloneTo(destGradientVelocity._constantMax);
			this._gradientXMin.cloneTo(destGradientVelocity._gradientXMin);
			this._gradientXMax.cloneTo(destGradientVelocity._gradientXMax);
			this._gradientYMin.cloneTo(destGradientVelocity._gradientYMin);
			this._gradientYMax.cloneTo(destGradientVelocity._gradientYMax);
			this._gradientZMin.cloneTo(destGradientVelocity._gradientZMin);
			this._gradientZMax.cloneTo(destGradientVelocity._gradientZMax);
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destGradientVelocity=new this.constructor();
			this.cloneTo(destGradientVelocity);
			return destGradientVelocity;
		}

		/**
		*渐变速度Z。
		*/
		__getset(0,__proto,'gradientZ',function(){
			return this._gradientZ;
		});

		/**固定速度。*/
		__getset(0,__proto,'constant',function(){
			return this._constant;
		});

		/**
		*生命周期速度类型，0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
		*/
		__getset(0,__proto,'type',function(){
			return this._type;
		});

		/**
		*渐变最大速度X。
		*/
		__getset(0,__proto,'gradientXMax',function(){
			return this._gradientXMax;
		});

		/**最小固定速度。*/
		__getset(0,__proto,'constantMin',function(){
			return this._constantMin;
		});

		/**
		*渐变速度X。
		*/
		__getset(0,__proto,'gradientX',function(){
			return this._gradientX;
		});

		/**
		*渐变速度Y。
		*/
		__getset(0,__proto,'gradientY',function(){
			return this._gradientY;
		});

		/**
		*渐变最小速度X。
		*/
		__getset(0,__proto,'gradientXMin',function(){
			return this._gradientXMin;
		});

		/**最大固定速度。*/
		__getset(0,__proto,'constantMax',function(){
			return this._constantMax;
		});

		/**
		*渐变最小速度Y。
		*/
		__getset(0,__proto,'gradientYMin',function(){
			return this._gradientYMin;
		});

		/**
		*渐变最大速度Y。
		*/
		__getset(0,__proto,'gradientYMax',function(){
			return this._gradientYMax;
		});

		/**
		*渐变最小速度Z。
		*/
		__getset(0,__proto,'gradientZMin',function(){
			return this._gradientZMin;
		});

		/**
		*渐变最大速度Z。
		*/
		__getset(0,__proto,'gradientZMax',function(){
			return this._gradientZMax;
		});

		GradientVelocity.createByConstant=function(constant){
			var gradientVelocity=new GradientVelocity();
			gradientVelocity._type=0;
			gradientVelocity._constant=constant;
			return gradientVelocity;
		}

		GradientVelocity.createByGradient=function(gradientX,gradientY,gradientZ){
			var gradientVelocity=new GradientVelocity();
			gradientVelocity._type=1;
			gradientVelocity._gradientX=gradientX;
			gradientVelocity._gradientY=gradientY;
			gradientVelocity._gradientZ=gradientZ;
			return gradientVelocity;
		}

		GradientVelocity.createByRandomTwoConstant=function(constantMin,constantMax){
			var gradientVelocity=new GradientVelocity();
			gradientVelocity._type=2;
			gradientVelocity._constantMin=constantMin;
			gradientVelocity._constantMax=constantMax;
			return gradientVelocity;
		}

		GradientVelocity.createByRandomTwoGradient=function(gradientXMin,gradientXMax,gradientYMin,gradientYMax,gradientZMin,gradientZMax){
			var gradientVelocity=new GradientVelocity();
			gradientVelocity._type=3;
			gradientVelocity._gradientXMin=gradientXMin;
			gradientVelocity._gradientXMax=gradientXMax;
			gradientVelocity._gradientYMin=gradientYMin;
			gradientVelocity._gradientYMax=gradientYMax;
			gradientVelocity._gradientZMin=gradientZMin;
			gradientVelocity._gradientZMax=gradientZMax;
			return gradientVelocity;
		}

		return GradientVelocity;
	})()


	/**
	*<code>RotationOverLifetime</code> 类用于粒子的生命周期旋转。
	*/
	//class laya.d3.core.particleShuriKen.module.RotationOverLifetime
	var RotationOverLifetime=(function(){
		function RotationOverLifetime(angularVelocity){
			this._angularVelocity=null;
			this.enbale=false;
			this._angularVelocity=angularVelocity;
		}

		__class(RotationOverLifetime,'laya.d3.core.particleShuriKen.module.RotationOverLifetime');
		var __proto=RotationOverLifetime.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destRotationOverLifetime=destObject;
			this._angularVelocity.cloneTo(destRotationOverLifetime._angularVelocity);
			destRotationOverLifetime.enbale=this.enbale;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destAngularVelocity;
			switch (this._angularVelocity.type){
				case 0:
					if (this._angularVelocity.separateAxes)
						destAngularVelocity=GradientAngularVelocity.createByConstantSeparate(this._angularVelocity.constantSeparate.clone());
					else
					destAngularVelocity=GradientAngularVelocity.createByConstant(this._angularVelocity.constant);
					break ;
				case 1:
					if (this._angularVelocity.separateAxes)
						destAngularVelocity=GradientAngularVelocity.createByGradientSeparate(this._angularVelocity.gradientX.clone(),this._angularVelocity.gradientY.clone(),this._angularVelocity.gradientZ.clone(),this._angularVelocity.gradientW.clone());
					else
					destAngularVelocity=GradientAngularVelocity.createByGradient(this._angularVelocity.gradient.clone());
					break ;
				case 2:
					if (this._angularVelocity.separateAxes)
						destAngularVelocity=GradientAngularVelocity.createByRandomTwoConstantSeparate(this._angularVelocity.constantMinSeparate.clone(),this._angularVelocity.constantMaxSeparate.clone());
					else
					destAngularVelocity=GradientAngularVelocity.createByRandomTwoConstant(this._angularVelocity.constantMin,this._angularVelocity.constantMax);
					break ;
				case 3:
					if (this._angularVelocity.separateAxes)
						destAngularVelocity=GradientAngularVelocity.createByRandomTwoGradientSeparate(this._angularVelocity.gradientXMin.clone(),this._angularVelocity.gradientYMin.clone(),this._angularVelocity.gradientZMin.clone(),this._angularVelocity.gradientWMin.clone(),this._angularVelocity.gradientXMax.clone(),this._angularVelocity.gradientYMax.clone(),this._angularVelocity.gradientZMax.clone(),this._angularVelocity.gradientWMax.clone());
					else
					destAngularVelocity=GradientAngularVelocity.createByRandomTwoGradient(this._angularVelocity.gradientMin.clone(),this._angularVelocity.gradientMax.clone());
					break ;
				};
			var destRotationOverLifetime=new this.constructor(destAngularVelocity);
			destRotationOverLifetime.enbale=this.enbale;
			return destRotationOverLifetime;
		}

		/**
		*获取角速度。
		*/
		__getset(0,__proto,'angularVelocity',function(){
			return this._angularVelocity;
		});

		return RotationOverLifetime;
	})()


	/**
	*<code>BaseShape</code> 类用于粒子形状。
	*/
	//class laya.d3.core.particleShuriKen.module.shape.BaseShape
	var BaseShape=(function(){
		function BaseShape(){
			this.enable=false;
			this.randomDirection=false;
		}

		__class(BaseShape,'laya.d3.core.particleShuriKen.module.shape.BaseShape');
		var __proto=BaseShape.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**@private */
		__proto._getShapeBoundBox=function(boundBox){
			throw new Error("BaseShape: must override it.");
		}

		/**@private */
		__proto._getSpeedBoundBox=function(boundBox){
			throw new Error("BaseShape: must override it.");
		}

		/**
		*用于生成粒子初始位置和方向。
		*@param position 粒子位置。
		*@param direction 粒子方向。
		*/
		__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
			throw new Error("BaseShape: must override it.");
		}

		/**
		*@private
		*/
		__proto._calculateProceduralBounds=function(boundBox,emitterPosScale,minMaxBounds){
			this._getShapeBoundBox(boundBox);
			var min=boundBox.min;
			var max=boundBox.max;
			Vector3.multiply(min,emitterPosScale,min);
			Vector3.multiply(max,emitterPosScale,max);
			var speedBounds=new BoundBox(new Vector3(),new Vector3());
			if (this.randomDirection){
				speedBounds.min=new Vector3(-1,-1,-1);
				speedBounds.max=new Vector3(1,1,1);
			}
			else{
				this._getSpeedBoundBox(speedBounds);
			};
			var maxSpeedBound=new BoundBox(new Vector3(),new Vector3());
			var maxSpeedMin=maxSpeedBound.min;
			var maxSpeedMax=maxSpeedBound.max;
			Vector3.scale(speedBounds.min,minMaxBounds.y,maxSpeedMin);
			Vector3.scale(speedBounds.max,minMaxBounds.y,maxSpeedMax);
			Vector3.add(boundBox.min,maxSpeedMin,maxSpeedMin);
			Vector3.add(boundBox.max,maxSpeedMax,maxSpeedMax);
			Vector3.min(boundBox.min,maxSpeedMin,boundBox.min);
			Vector3.max(boundBox.max,maxSpeedMin,boundBox.max);
			var minSpeedBound=new BoundBox(new Vector3(),new Vector3());
			var minSpeedMin=minSpeedBound.min;
			var minSpeedMax=minSpeedBound.max;
			Vector3.scale(speedBounds.min,minMaxBounds.x,minSpeedMin);
			Vector3.scale(speedBounds.max,minMaxBounds.x,minSpeedMax);
			Vector3.min(minSpeedBound.min,minSpeedMax,maxSpeedMin);
			Vector3.max(minSpeedBound.min,minSpeedMax,maxSpeedMax);
			Vector3.min(boundBox.min,maxSpeedMin,boundBox.min);
			Vector3.max(boundBox.max,maxSpeedMin,boundBox.max);
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destShape=destObject;
			destShape.enable=this.enable;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destShape=new this.constructor();
			this.cloneTo(destShape);
			return destShape;
		}

		return BaseShape;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.core.particleShuriKen.module.shape.ShapeUtils
	var ShapeUtils=(function(){
		function ShapeUtils(){}
		__class(ShapeUtils,'laya.d3.core.particleShuriKen.module.shape.ShapeUtils');
		ShapeUtils._randomPointUnitArcCircle=function(arc,out,rand){
			var outE=out.elements;
			var angle=NaN;
			if (rand)
				angle=rand.getFloat()*arc;
			else
			angle=Math.random()*arc;
			outE[0]=Math.cos(angle);
			outE[1]=Math.sin(angle);
		}

		ShapeUtils._randomPointInsideUnitArcCircle=function(arc,out,rand){
			var outE=out.elements;
			ShapeUtils._randomPointUnitArcCircle(arc,out,rand);
			var range=NaN;
			if (rand)
				range=Math.pow(rand.getFloat(),1.0 / 2.0);
			else
			range=Math.pow(Math.random(),1.0 / 2.0);
			outE[0]=outE[0] *range;
			outE[1]=outE[1] *range;
		}

		ShapeUtils._randomPointUnitCircle=function(out,rand){
			var outE=out.elements;
			var angle=NaN;
			if (rand)
				angle=rand.getFloat()*Math.PI *2;
			else
			angle=Math.random()*Math.PI *2;
			outE[0]=Math.cos(angle);
			outE[1]=Math.sin(angle);
		}

		ShapeUtils._randomPointInsideUnitCircle=function(out,rand){
			var outE=out.elements;
			ShapeUtils._randomPointUnitCircle(out);
			var range=NaN;
			if (rand)
				range=Math.pow(rand.getFloat(),1.0 / 2.0);
			else
			range=Math.pow(Math.random(),1.0 / 2.0);
			outE[0]=outE[0] *range;
			outE[1]=outE[1] *range;
		}

		ShapeUtils._randomPointUnitSphere=function(out,rand){
			var outE=out.elements;
			var z=NaN;
			var a=NaN;
			if (rand){
				z=outE[2]=rand.getFloat()*2-1.0;
				a=rand.getFloat()*Math.PI *2;
				}else {
				z=outE[2]=Math.random()*2-1.0;
				a=Math.random()*Math.PI *2;
			};
			var r=Math.sqrt(1.0-z *z);
			outE[0]=r *Math.cos(a);
			outE[1]=r *Math.sin(a);
		}

		ShapeUtils._randomPointInsideUnitSphere=function(out,rand){
			var outE=out.elements;
			ShapeUtils._randomPointUnitSphere(out);
			var range=NaN;
			if (rand)
				range=Math.pow(rand.getFloat(),1.0 / 3.0);
			else
			range=Math.pow(Math.random(),1.0 / 3.0);
			outE[0]=outE[0] *range;
			outE[1]=outE[1] *range;
			outE[2]=outE[2] *range;
		}

		ShapeUtils._randomPointInsideHalfUnitBox=function(out,rand){
			var outE=out.elements;
			if (rand){
				outE[0]=(rand.getFloat()-0.5);
				outE[1]=(rand.getFloat()-0.5);
				outE[2]=(rand.getFloat()-0.5);
				}else {
				outE[0]=(Math.random()-0.5);
				outE[1]=(Math.random()-0.5);
				outE[2]=(Math.random()-0.5);
			}
		}

		return ShapeUtils;
	})()


	/**
	*<code>SizeOverLifetime</code> 类用于粒子的生命周期尺寸。
	*/
	//class laya.d3.core.particleShuriKen.module.SizeOverLifetime
	var SizeOverLifetime=(function(){
		function SizeOverLifetime(size){
			this._size=null;
			this.enbale=false;
			this._size=size;
		}

		__class(SizeOverLifetime,'laya.d3.core.particleShuriKen.module.SizeOverLifetime');
		var __proto=SizeOverLifetime.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destSizeOverLifetime=destObject;
			this._size.cloneTo(destSizeOverLifetime._size);
			destSizeOverLifetime.enbale=this.enbale;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destSize;
			switch (this._size.type){
				case 0:
					if (this._size.separateAxes)
						destSize=GradientSize.createByGradientSeparate(this._size.gradientX.clone(),this._size.gradientY.clone(),this._size.gradientZ.clone());
					else
					destSize=GradientSize.createByGradient(this._size.gradient.clone());
					break ;
				case 1:
					if (this._size.separateAxes)
						destSize=GradientSize.createByRandomTwoConstantSeparate(this._size.constantMinSeparate.clone(),this._size.constantMaxSeparate.clone());
					else
					destSize=GradientSize.createByRandomTwoConstant(this._size.constantMin,this._size.constantMax);
					break ;
				case 2:
					if (this._size.separateAxes)
						destSize=GradientSize.createByRandomTwoGradientSeparate(this._size.gradientXMin.clone(),this._size.gradientYMin.clone(),this._size.gradientZMin.clone(),this._size.gradientXMax.clone(),this._size.gradientYMax.clone(),this._size.gradientZMax.clone());
					else
					destSize=GradientSize.createByRandomTwoGradient(this._size.gradientMin.clone(),this._size.gradientMax.clone());
					break ;
				};
			var destSizeOverLifetime=new this.constructor(destSize);
			destSizeOverLifetime.enbale=this.enbale;
			return destSizeOverLifetime;
		}

		/**
		*获取尺寸。
		*/
		__getset(0,__proto,'size',function(){
			return this._size;
		});

		return SizeOverLifetime;
	})()


	/**
	*<code>StartFrame</code> 类用于创建开始帧。
	*/
	//class laya.d3.core.particleShuriKen.module.StartFrame
	var StartFrame=(function(){
		function StartFrame(){
			this._type=0;
			this._constant=NaN;
			this._constantMin=NaN;
			this._constantMax=NaN;
		}

		__class(StartFrame,'laya.d3.core.particleShuriKen.module.StartFrame');
		var __proto=StartFrame.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destStartFrame=destObject;
			destStartFrame._type=this._type;
			destStartFrame._constant=this._constant;
			destStartFrame._constantMin=this._constantMin;
			destStartFrame._constantMax=this._constantMax;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destStartFrame=new this.constructor();
			this.cloneTo(destStartFrame);
			return destStartFrame;
		}

		/**
		*固定帧。
		*/
		__getset(0,__proto,'constant',function(){
			return this._constant;
		});

		/**
		*开始帧类型,0常量模式，1随机双常量模式。
		*/
		__getset(0,__proto,'type',function(){
			return this._type;
		});

		/**
		*最小固定帧。
		*/
		__getset(0,__proto,'constantMin',function(){
			return this._constantMin;
		});

		/**
		*最大固定帧。
		*/
		__getset(0,__proto,'constantMax',function(){
			return this._constantMax;
		});

		StartFrame.createByConstant=function(constant){
			var rotationOverLifetime=new StartFrame();
			rotationOverLifetime._type=0;
			rotationOverLifetime._constant=constant;
			return rotationOverLifetime;
		}

		StartFrame.createByRandomTwoConstant=function(constantMin,constantMax){
			var rotationOverLifetime=new StartFrame();
			rotationOverLifetime._type=1;
			rotationOverLifetime._constantMin=constantMin;
			rotationOverLifetime._constantMax=constantMax;
			return rotationOverLifetime;
		}

		return StartFrame;
	})()


	/**
	*<code>TextureSheetAnimation</code> 类用于创建粒子帧动画。
	*/
	//class laya.d3.core.particleShuriKen.module.TextureSheetAnimation
	var TextureSheetAnimation=(function(){
		function TextureSheetAnimation(frame,startFrame){
			this._frame=null;
			this._startFrame=null;
			this.tiles=null;
			this.type=0;
			this.randomRow=false;
			this.rowIndex=0;
			this.cycles=0;
			this.enableUVChannels=0;
			this.enable=false;
			this.tiles=new Vector2(1,1);
			this.type=0;
			this.randomRow=true;
			this.rowIndex=0;
			this.cycles=1;
			this.enableUVChannels=1;
			this._frame=frame;
			this._startFrame=startFrame;
		}

		__class(TextureSheetAnimation,'laya.d3.core.particleShuriKen.module.TextureSheetAnimation');
		var __proto=TextureSheetAnimation.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destTextureSheetAnimation=destObject;
			this.tiles.cloneTo(destTextureSheetAnimation.tiles);
			destTextureSheetAnimation.type=this.type;
			destTextureSheetAnimation.randomRow=this.randomRow;
			this._frame.cloneTo(destTextureSheetAnimation._frame);
			this._startFrame.cloneTo(destTextureSheetAnimation._startFrame);
			destTextureSheetAnimation.cycles=this.cycles;
			destTextureSheetAnimation.enableUVChannels=this.enableUVChannels;
			destTextureSheetAnimation.enable=this.enable;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destFrame;
			switch (this._frame.type){
				case 0:
					destFrame=FrameOverTime.createByConstant(this._frame.constant);
					break ;
				case 1:
					destFrame=FrameOverTime.createByOverTime(this._frame.frameOverTimeData.clone());
					break ;
				case 2:
					destFrame=FrameOverTime.createByRandomTwoConstant(this._frame.constantMin,this._frame.constantMax);
					break ;
				case 3:
					destFrame=FrameOverTime.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin.clone(),this._frame.frameOverTimeDataMax.clone());
					break ;
				};
			var destStartFrame;
			switch (this._startFrame.type){
				case 0:
					destStartFrame=StartFrame.createByConstant(this._startFrame.constant);
					break ;
				case 1:
					destStartFrame=StartFrame.createByRandomTwoConstant(this._startFrame.constantMin,this._startFrame.constantMax);
					break ;
				};
			var destTextureSheetAnimation=new this.constructor(destFrame,destStartFrame);
			this.tiles.cloneTo(destTextureSheetAnimation.tiles);
			destTextureSheetAnimation.type=this.type;
			destTextureSheetAnimation.randomRow=this.randomRow;
			destTextureSheetAnimation.cycles=this.cycles;
			destTextureSheetAnimation.enableUVChannels=this.enableUVChannels;
			destTextureSheetAnimation.enable=this.enable;
			return destTextureSheetAnimation;
		}

		/**获取时间帧率。*/
		__getset(0,__proto,'frame',function(){
			return this._frame;
		});

		/**获取开始帧率。*/
		__getset(0,__proto,'startFrame',function(){
			return this._startFrame;
		});

		return TextureSheetAnimation;
	})()


	/**
	*<code>VelocityOverLifetime</code> 类用于粒子的生命周期速度。
	*/
	//class laya.d3.core.particleShuriKen.module.VelocityOverLifetime
	var VelocityOverLifetime=(function(){
		function VelocityOverLifetime(velocity){
			this._velocity=null;
			this.enbale=false;
			this.space=0;
			this._velocity=velocity;
		}

		__class(VelocityOverLifetime,'laya.d3.core.particleShuriKen.module.VelocityOverLifetime');
		var __proto=VelocityOverLifetime.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destVelocityOverLifetime=destObject;
			this._velocity.cloneTo(destVelocityOverLifetime._velocity);
			destVelocityOverLifetime.enbale=this.enbale;
			destVelocityOverLifetime.space=this.space;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destVelocity;
			switch(this._velocity.type){
				case 0:
					destVelocity=GradientVelocity.createByConstant(this._velocity.constant.clone());
					break ;
				case 1:
					destVelocity=GradientVelocity.createByGradient(this._velocity.gradientX.clone(),this._velocity.gradientY.clone(),this._velocity.gradientZ.clone());
					break ;
				case 2:
					destVelocity=GradientVelocity.createByRandomTwoConstant(this._velocity.constantMin.clone(),this._velocity.constantMax.clone());
					break ;
				case 3:
					destVelocity=GradientVelocity.createByRandomTwoGradient(this._velocity.gradientXMin.clone(),this._velocity.gradientYMin.clone(),this._velocity.gradientZMin.clone(),this._velocity.gradientXMax.clone(),this._velocity.gradientYMax.clone(),this._velocity.gradientZMax.clone());
					break ;
				};
			var destVelocityOverLifetime=new this.constructor(destVelocity);
			destVelocityOverLifetime.enbale=this.enbale;
			destVelocityOverLifetime.space=this.space;
			return destVelocityOverLifetime;
		}

		/**
		*获取尺寸。
		*/
		__getset(0,__proto,'velocity',function(){
			return this._velocity;
		});

		return VelocityOverLifetime;
	})()


	/**
	*@private
	*/
	//class laya.d3.core.particleShuriKen.ShurikenParticleData
	var ShurikenParticleData=(function(){
		function ShurikenParticleData(){}
		__class(ShurikenParticleData,'laya.d3.core.particleShuriKen.ShurikenParticleData');
		ShurikenParticleData._getStartLifetimeFromGradient=function(startLifeTimeGradient,emissionTime){
			for (var i=1,n=startLifeTimeGradient.gradientCount;i < n;i++){
				var key=startLifeTimeGradient.getKeyByIndex(i);
				if (key >=emissionTime){
					var lastKey=startLifeTimeGradient.getKeyByIndex(i-1);
					var age=(emissionTime-lastKey)/ (key-lastKey);
					return MathUtil.lerp(startLifeTimeGradient.getValueByIndex(i-1),startLifeTimeGradient.getValueByIndex(i),age)
				}
			}
			throw new Error("ShurikenParticleData: can't get value foam startLifeTimeGradient.");
		}

		ShurikenParticleData._randomInvertRoationArray=function(rotatonE,outE,randomizeRotationDirection,rand,randomSeeds){
			var randDic=NaN;
			if (rand){
				rand.seed=randomSeeds[6];
				randDic=rand.getFloat();
				randomSeeds[6]=rand.seed;
				}else {
				randDic=Math.random();
			}
			if (randDic < randomizeRotationDirection){
				outE[0]=-rotatonE[0];
				outE[1]=-rotatonE[1];
				outE[2]=-rotatonE[2];
				}else {
				outE[0]=rotatonE[0];
				outE[1]=rotatonE[1];
				outE[2]=rotatonE[2];
			}
		}

		ShurikenParticleData._randomInvertRoation=function(rotaton,randomizeRotationDirection,rand,randomSeeds){
			var randDic=NaN;
			if (rand){
				rand.seed=randomSeeds[6];
				randDic=rand.getFloat();
				randomSeeds[6]=rand.seed;
				}else {
				randDic=Math.random();
			}
			if (randDic < randomizeRotationDirection)
				rotaton=-rotaton;
			return rotaton;
		}

		ShurikenParticleData.create=function(particleSystem,particleRender,transform){
			var autoRandomSeed=particleSystem.autoRandomSeed;
			var rand=particleSystem._rand;
			var randomSeeds=particleSystem._randomSeeds;
			switch (particleSystem.startColorType){
				case 0:;
					var constantStartColorE=particleSystem.startColorConstant.elements;
					ShurikenParticleData.startColor[0]=constantStartColorE[0];
					ShurikenParticleData.startColor[1]=constantStartColorE[1];
					ShurikenParticleData.startColor[2]=constantStartColorE[2];
					ShurikenParticleData.startColor[3]=constantStartColorE[3];
					break ;
				case 2:
					if (autoRandomSeed){
						MathUtil.lerpVector4(particleSystem.startColorConstantMin.elements,particleSystem.startColorConstantMax.elements,Math.random(),ShurikenParticleData.startColor);
						}else {
						rand.seed=randomSeeds[3];
						MathUtil.lerpVector4(particleSystem.startColorConstantMin.elements,particleSystem.startColorConstantMax.elements,rand.getFloat(),ShurikenParticleData.startColor);
						randomSeeds[3]=rand.seed;
					}
					break ;
				};
			var colorOverLifetime=particleSystem.colorOverLifetime;
			if (colorOverLifetime && colorOverLifetime.enbale){
				var color=colorOverLifetime.color;
				switch (color.type){
					case 0:
						ShurikenParticleData.startColor[0]=ShurikenParticleData.startColor[0] *color.constant.x;
						ShurikenParticleData.startColor[1]=ShurikenParticleData.startColor[1] *color.constant.y;
						ShurikenParticleData.startColor[2]=ShurikenParticleData.startColor[2] *color.constant.z;
						ShurikenParticleData.startColor[3]=ShurikenParticleData.startColor[3] *color.constant.w;
						break ;
					case 2:;
						var colorRandom=NaN;
						if (autoRandomSeed){
							colorRandom=Math.random();
							}else {
							rand.seed=randomSeeds[10];
							colorRandom=rand.getFloat();
							randomSeeds[10]=rand.seed;
						};
						var minConstantColor=color.constantMin;
						var maxConstantColor=color.constantMax;
						ShurikenParticleData.startColor[0]=ShurikenParticleData.startColor[0] *MathUtil.lerp(minConstantColor.x,maxConstantColor.x,colorRandom);
						ShurikenParticleData.startColor[1]=ShurikenParticleData.startColor[1] *MathUtil.lerp(minConstantColor.y,maxConstantColor.y,colorRandom);
						ShurikenParticleData.startColor[2]=ShurikenParticleData.startColor[2] *MathUtil.lerp(minConstantColor.z,maxConstantColor.z,colorRandom);
						ShurikenParticleData.startColor[3]=ShurikenParticleData.startColor[3] *MathUtil.lerp(minConstantColor.w,maxConstantColor.w,colorRandom);
						break ;
					}
			};
			var particleSize=ShurikenParticleData.startSize;
			switch (particleSystem.startSizeType){
				case 0:
					if (particleSystem.threeDStartSize){
						var startSizeConstantSeparate=particleSystem.startSizeConstantSeparate;
						particleSize[0]=startSizeConstantSeparate.x;
						particleSize[1]=startSizeConstantSeparate.y;
						particleSize[2]=startSizeConstantSeparate.z;
						}else {
						particleSize[0]=particleSize[1]=particleSize[2]=particleSystem.startSizeConstant;
					}
					break ;
				case 2:
					if (particleSystem.threeDStartSize){
						var startSizeConstantMinSeparate=particleSystem.startSizeConstantMinSeparate;
						var startSizeConstantMaxSeparate=particleSystem.startSizeConstantMaxSeparate;
						if (autoRandomSeed){
							particleSize[0]=MathUtil.lerp(startSizeConstantMinSeparate.x,startSizeConstantMaxSeparate.x,Math.random());
							particleSize[1]=MathUtil.lerp(startSizeConstantMinSeparate.y,startSizeConstantMaxSeparate.y,Math.random());
							particleSize[2]=MathUtil.lerp(startSizeConstantMinSeparate.z,startSizeConstantMaxSeparate.z,Math.random());
							}else {
							rand.seed=randomSeeds[4];
							particleSize[0]=MathUtil.lerp(startSizeConstantMinSeparate.x,startSizeConstantMaxSeparate.x,rand.getFloat());
							particleSize[1]=MathUtil.lerp(startSizeConstantMinSeparate.y,startSizeConstantMaxSeparate.y,rand.getFloat());
							particleSize[2]=MathUtil.lerp(startSizeConstantMinSeparate.z,startSizeConstantMaxSeparate.z,rand.getFloat());
							randomSeeds[4]=rand.seed;
						}
						}else {
						if (autoRandomSeed){
							particleSize[0]=particleSize[1]=particleSize[2]=MathUtil.lerp(particleSystem.startSizeConstantMin,particleSystem.startSizeConstantMax,Math.random());
							}else {
							rand.seed=randomSeeds[4];
							particleSize[0]=particleSize[1]=particleSize[2]=MathUtil.lerp(particleSystem.startSizeConstantMin,particleSystem.startSizeConstantMax,rand.getFloat());
							randomSeeds[4]=rand.seed;
						}
					}
					break ;
				};
			var sizeOverLifetime=particleSystem.sizeOverLifetime;
			if (sizeOverLifetime && sizeOverLifetime.enbale && sizeOverLifetime.size.type===1){
				var size=sizeOverLifetime.size;
				if (size.separateAxes){
					if (autoRandomSeed){
						particleSize[0]=particleSize[0] *MathUtil.lerp(size.constantMinSeparate.x,size.constantMaxSeparate.x,Math.random());
						particleSize[1]=particleSize[1] *MathUtil.lerp(size.constantMinSeparate.y,size.constantMaxSeparate.y,Math.random());
						particleSize[2]=particleSize[2] *MathUtil.lerp(size.constantMinSeparate.z,size.constantMaxSeparate.z,Math.random());
						}else {
						rand.seed=randomSeeds[11];
						particleSize[0]=particleSize[0] *MathUtil.lerp(size.constantMinSeparate.x,size.constantMaxSeparate.x,rand.getFloat());
						particleSize[1]=particleSize[1] *MathUtil.lerp(size.constantMinSeparate.y,size.constantMaxSeparate.y,rand.getFloat());
						particleSize[2]=particleSize[2] *MathUtil.lerp(size.constantMinSeparate.z,size.constantMaxSeparate.z,rand.getFloat());
						randomSeeds[11]=rand.seed;
					}
					}else {
					var randomSize=NaN;
					if (autoRandomSeed){
						randomSize=MathUtil.lerp(size.constantMin,size.constantMax,Math.random());
						}else {
						rand.seed=randomSeeds[11];
						randomSize=MathUtil.lerp(size.constantMin,size.constantMax,rand.getFloat());
						randomSeeds[11]=rand.seed;
					}
					particleSize[0]=particleSize[0] *randomSize;
					particleSize[1]=particleSize[1] *randomSize;
					particleSize[2]=particleSize[2] *randomSize;
				}
			};
			var renderMode=particleRender.renderMode;
			if (renderMode!==1){
				switch (particleSystem.startRotationType){
					case 0:
						if (particleSystem.threeDStartRotation){
							var startRotationConstantSeparate=particleSystem.startRotationConstantSeparate;
							var randomRotationE=ShurikenParticleData._tempVector30.elements;
							ShurikenParticleData._randomInvertRoationArray(startRotationConstantSeparate.elements,randomRotationE,particleSystem.randomizeRotationDirection,autoRandomSeed ? null :rand,randomSeeds);
							ShurikenParticleData.startRotation[0]=randomRotationE[0];
							ShurikenParticleData.startRotation[1]=randomRotationE[1];
							if (renderMode!==4)
								ShurikenParticleData.startRotation[2]=-randomRotationE[2];
							else
							ShurikenParticleData.startRotation[2]=randomRotationE[2];
							}else {
							ShurikenParticleData.startRotation[0]=ShurikenParticleData._randomInvertRoation(particleSystem.startRotationConstant,particleSystem.randomizeRotationDirection,autoRandomSeed ? null :rand,randomSeeds);
						}
						break ;
					case 2:
						if (particleSystem.threeDStartRotation){
							var startRotationConstantMinSeparate=particleSystem.startRotationConstantMinSeparate;
							var startRotationConstantMaxSeparate=particleSystem.startRotationConstantMaxSeparate;
							var lerpRoationE=ShurikenParticleData._tempVector30.elements;
							if (autoRandomSeed){
								lerpRoationE[0]=MathUtil.lerp(startRotationConstantMinSeparate.x,startRotationConstantMaxSeparate.x,Math.random());
								lerpRoationE[1]=MathUtil.lerp(startRotationConstantMinSeparate.y,startRotationConstantMaxSeparate.y,Math.random());
								lerpRoationE[2]=MathUtil.lerp(startRotationConstantMinSeparate.z,startRotationConstantMaxSeparate.z,Math.random());
								}else {
								rand.seed=randomSeeds[5];
								lerpRoationE[0]=MathUtil.lerp(startRotationConstantMinSeparate.x,startRotationConstantMaxSeparate.x,rand.getFloat());
								lerpRoationE[1]=MathUtil.lerp(startRotationConstantMinSeparate.y,startRotationConstantMaxSeparate.y,rand.getFloat());
								lerpRoationE[2]=MathUtil.lerp(startRotationConstantMinSeparate.z,startRotationConstantMaxSeparate.z,rand.getFloat());
								randomSeeds[5]=rand.seed;
							}
							ShurikenParticleData._randomInvertRoationArray(lerpRoationE,lerpRoationE,particleSystem.randomizeRotationDirection,autoRandomSeed ? null :rand,randomSeeds);
							ShurikenParticleData.startRotation[0]=lerpRoationE[0];
							ShurikenParticleData.startRotation[1]=lerpRoationE[1];
							if (renderMode!==4)
								ShurikenParticleData.startRotation[2]=-lerpRoationE[2];
							else
							ShurikenParticleData.startRotation[2]=lerpRoationE[2];
							}else {
							if (autoRandomSeed){
								ShurikenParticleData.startRotation[0]=ShurikenParticleData._randomInvertRoation(MathUtil.lerp(particleSystem.startRotationConstantMin,particleSystem.startRotationConstantMax,Math.random()),particleSystem.randomizeRotationDirection,autoRandomSeed ? null :rand,randomSeeds);
								}else {
								rand.seed=randomSeeds[5];
								ShurikenParticleData.startRotation[0]=ShurikenParticleData._randomInvertRoation(MathUtil.lerp(particleSystem.startRotationConstantMin,particleSystem.startRotationConstantMax,rand.getFloat()),particleSystem.randomizeRotationDirection,autoRandomSeed ? null :rand,randomSeeds);
								randomSeeds[5]=rand.seed;
							}
						}
						break ;
					}
			}
			switch (particleSystem.startLifetimeType){
				case 0:
					ShurikenParticleData.startLifeTime=particleSystem.startLifetimeConstant;
					break ;
				case 1:
					ShurikenParticleData.startLifeTime=ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradient,particleSystem.emissionTime);
					break ;
				case 2:
					if (autoRandomSeed){
						ShurikenParticleData.startLifeTime=MathUtil.lerp(particleSystem.startLifetimeConstantMin,particleSystem.startLifetimeConstantMax,Math.random());
						}else {
						rand.seed=randomSeeds[7];
						ShurikenParticleData.startLifeTime=MathUtil.lerp(particleSystem.startLifetimeConstantMin,particleSystem.startLifetimeConstantMax,rand.getFloat());
						randomSeeds[7]=rand.seed;
					}
					break ;
				case 3:;
					var emissionTime=particleSystem.emissionTime;
					if (autoRandomSeed){
						ShurikenParticleData.startLifeTime=MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMin,emissionTime),ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMax,emissionTime),Math.random());
						}else {
						rand.seed=randomSeeds[7];
						ShurikenParticleData.startLifeTime=MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMin,emissionTime),ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMax,emissionTime),rand.getFloat());
						randomSeeds[7]=rand.seed;
					}
					break ;
				}
			switch (particleSystem.startSpeedType){
				case 0:
					ShurikenParticleData.startSpeed=particleSystem.startSpeedConstant;
					break ;
				case 2:
					if (autoRandomSeed){
						ShurikenParticleData.startSpeed=MathUtil.lerp(particleSystem.startSpeedConstantMin,particleSystem.startSpeedConstantMax,Math.random());
						}else {
						rand.seed=randomSeeds[8];
						ShurikenParticleData.startSpeed=MathUtil.lerp(particleSystem.startSpeedConstantMin,particleSystem.startSpeedConstantMax,rand.getFloat());
						randomSeeds[8]=rand.seed;
					}
					break ;
				};
			var textureSheetAnimation=particleSystem.textureSheetAnimation;
			var enableSheetAnimation=textureSheetAnimation && textureSheetAnimation.enable;
			if (enableSheetAnimation){
				var title=textureSheetAnimation.tiles;
				var titleX=title.x,titleY=title.y;
				var subU=1.0 / titleX,subV=1.0 / titleY;
				var startFrameCount=0;
				var startFrame=textureSheetAnimation.startFrame;
				switch (startFrame.type){
					case 0:
						startFrameCount=startFrame.constant;
						break ;
					case 1:
						if (autoRandomSeed){
							startFrameCount=MathUtil.lerp(startFrame.constantMin,startFrame.constantMax,Math.random());
							}else {
							rand.seed=randomSeeds[14];
							startFrameCount=MathUtil.lerp(startFrame.constantMin,startFrame.constantMax,rand.getFloat());
							randomSeeds[14]=rand.seed;
						}
						break ;
					};
				var frame=textureSheetAnimation.frame;
				switch (frame.type){
					case 0:
						startFrameCount+=frame.constant;
						break ;
					case 2:
						if (autoRandomSeed){
							startFrameCount+=MathUtil.lerp(frame.constantMin,frame.constantMax,Math.random());
							}else {
							rand.seed=randomSeeds[15];
							startFrameCount+=MathUtil.lerp(frame.constantMin,frame.constantMax,rand.getFloat());
							randomSeeds[15]=rand.seed;
						}
						break ;
					};
				var startRow=0;
				switch (textureSheetAnimation.type){
					case 0:
						startRow=Math.floor(startFrameCount / titleX);
						break ;
					case 1:
						if (textureSheetAnimation.randomRow){
							if (autoRandomSeed){
								startRow=Math.floor(Math.random()*titleY);
								}else {
								rand.seed=randomSeeds[13];
								startRow=Math.floor(rand.getFloat()*titleY);
								randomSeeds[13]=rand.seed;
							}
							}else {
							startRow=textureSheetAnimation.rowIndex;
						}
						break ;
					};
				var startCol=Math.floor(startFrameCount % titleX);
				ShurikenParticleData.startUVInfo=ShurikenParticleData.startUVInfo;
				ShurikenParticleData.startUVInfo[0]=subU;
				ShurikenParticleData.startUVInfo[1]=subV;
				ShurikenParticleData.startUVInfo[2]=startCol *subU;
				ShurikenParticleData.startUVInfo[3]=startRow *subV;
				}else {
				ShurikenParticleData.startUVInfo=ShurikenParticleData.startUVInfo;
				ShurikenParticleData.startUVInfo[0]=1.0;
				ShurikenParticleData.startUVInfo[1]=1.0;
				ShurikenParticleData.startUVInfo[2]=0.0;
				ShurikenParticleData.startUVInfo[3]=0.0;
			}
			switch (particleSystem.simulationSpace){
				case 0:;
					var positionE=transform.position.elements;
					ShurikenParticleData.simulationWorldPostion[0]=positionE[0];
					ShurikenParticleData.simulationWorldPostion[1]=positionE[1];
					ShurikenParticleData.simulationWorldPostion[2]=positionE[2];
					var rotationE=transform.rotation.elements;
					ShurikenParticleData.simulationWorldRotation[0]=rotationE[0];
					ShurikenParticleData.simulationWorldRotation[1]=rotationE[1];
					ShurikenParticleData.simulationWorldRotation[2]=rotationE[2];
					ShurikenParticleData.simulationWorldRotation[3]=rotationE[3];
					break ;
				case 1:
					break ;
				default :
					throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
					break ;
				}
		}

		ShurikenParticleData.startLifeTime=NaN
		ShurikenParticleData.startSpeed=NaN
		__static(ShurikenParticleData,
		['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempQuaternion',function(){return this._tempQuaternion=new Quaternion();},'startColor',function(){return this.startColor=new Float32Array(4);},'startSize',function(){return this.startSize=new Float32Array(3);},'startRotation',function(){return this.startRotation=new Float32Array(3);},'startUVInfo',function(){return this.startUVInfo=new Float32Array(4);},'simulationWorldPostion',function(){return this.simulationWorldPostion=new Float32Array(3);},'simulationWorldRotation',function(){return this.simulationWorldRotation=new Float32Array(4);}
		]);
		return ShurikenParticleData;
	})()


	/**
	*@private
	*<code>PhasorSpriter3D</code> 类用于创建矢量笔刷。
	*/
	//class laya.d3.core.PhasorSpriter3D
	var PhasorSpriter3D=(function(){
		function PhasorSpriter3D(){
			this._tempInt0=0;
			this._tempInt1=0;
			this._tempUint0=0;
			this._tempUint1=0;
			this._tempUint2=0;
			this._tempUint3=0;
			this._tempUint4=0;
			this._tempUint5=0;
			this._tempUint6=0;
			this._tempUint7=0;
			this._tempNumver0=NaN;
			this._tempNumver1=NaN;
			this._tempNumver2=NaN;
			this._tempNumver3=NaN;
			this._floatSizePerVer=7;
			this._defaultBufferSize=600 *this._floatSizePerVer;
			this._vb=null;
			this._posInVBData=0;
			this._ib=null;
			this._posInIBData=0;
			this._primitiveType=NaN;
			this._hasBegun=false;
			this._numVertsPerPrimitive=0;
			this._camera=null;
			this._sharderNameID=0;
			this._shader=null;
			this._shaderCompile=null;
			this._vbData=new Float32Array(this._defaultBufferSize);
			this._ibData=new Uint16Array(this._defaultBufferSize);
			this._spriteShaderValue=new ShaderDatas(null,0);
			;
			this._vb=new VertexBuffer3D(PhasorSpriter3D._vertexDeclaration.vertexStride*(this._defaultBufferSize / this._floatSizePerVer),0x88E8);
			this._vb.vertexDeclaration=PhasorSpriter3D._vertexDeclaration;
			this._ib=IndexBuffer3D.create("ushort",this._defaultBufferSize,0x88E8);
			this._sharderNameID=ShaderInstance.nameKey.getID("LINE");
			this._shaderCompile=Shader3D._preCompileShader[this._sharderNameID];
		}

		__class(PhasorSpriter3D,'laya.d3.core.PhasorSpriter3D');
		var __proto=PhasorSpriter3D.prototype;
		__proto.line=function(startPosition,startColor,endPosition,endColor){
			if (!this._hasBegun || this._primitiveType!==0x0001)
				this.drawLinesException();
			if (this._posInVBData+2 *this._floatSizePerVer > this._vbData.length || this._posInIBData+2 > this._ibData.length)
				this.flush();
			this._tempUint0=this._posInVBData / this._floatSizePerVer;
			this.addVertex(startPosition.x,startPosition.y,startPosition.z,startColor.x,startColor.y,startColor.z,startColor.w);
			this.addVertex(endPosition.x,endPosition.y,endPosition.z,endColor.x,endColor.y,endColor.z,endColor.w);
			this.addIndexes(this._tempUint0,this._tempUint0+1);
			return this;
		}

		__proto.circle=function(radius,numberOfPoints,r,g,b,a){
			if (!this._hasBegun || (this._primitiveType!==0x0001))
				this.drawLinesException();
			this._tempUint0=numberOfPoints *2;
			if (this._posInVBData+this._tempUint0 *this._floatSizePerVer > this._vbData.length || this._posInIBData+2 *this._tempUint0 > this._ibData.length)
				this.flush();
			this._tempUint1=this._posInVBData / this._floatSizePerVer;
			for (this._tempNumver0=0,this._tempInt0=0;this._tempNumver0 < 3.1416 *2;this._tempNumver0=this._tempNumver0+(3.1416 / numberOfPoints),this._tempInt0++){
				this.addVertex(Math.sin(this._tempNumver0)*radius,Math.cos(this._tempNumver0)*radius,0,r,g,b,a);
				if (this._tempInt0===0){
					this.addIndexes(this._tempUint1);
					}else if (this._tempInt0===this._tempUint0-1){
					this._tempUint2=this._tempUint1+this._tempInt0;
					this.addIndexes(this._tempUint2,this._tempUint2,this._tempUint1);
					}else {
					this._tempUint2=this._tempUint1+this._tempInt0;
					this.addIndexes(this._tempUint2,this._tempUint2);
				}
			}
			return this;
		}

		__proto.plane=function(positionX,positionY,positionZ,width,height,r,g,b,a){
			if (!this._hasBegun || this._primitiveType!==0x0004)
				this.drawTrianglesException();
			if (this._posInVBData+4 *this._floatSizePerVer > this._vbData.length || this._posInIBData+6 > this._ibData.length)
				this.flush();
			this._tempNumver0=width / 2;
			this._tempNumver1=height / 2;
			this._tempUint0=this._posInVBData / this._floatSizePerVer;
			this.addVertex(positionX-this._tempNumver0,positionY+this._tempNumver1,positionZ,r,g,b,a);
			this.addVertex(positionX+this._tempNumver0,positionY+this._tempNumver1,positionZ,r,g,b,a);
			this.addVertex(positionX-this._tempNumver0,positionY-this._tempNumver1,positionZ,r,g,b,a);
			this.addVertex(positionX+this._tempNumver0,positionY-this._tempNumver1,positionZ,r,g,b,a);
			this._tempUint1=this._tempUint0+1;
			this._tempUint2=this._tempUint0+2;
			this.addIndexes(this._tempUint0,this._tempUint1,this._tempUint2,this._tempUint2,this._tempUint1,this._tempUint0+3);
			return this;
		}

		__proto.box=function(positionX,positionY,positionZ,width,height,depth,r,g,b,a){
			if (!this._hasBegun || this._primitiveType!==0x0004)
				this.drawTrianglesException();
			if (this._posInVBData+8 *this._floatSizePerVer > this._vbData.length || this._posInIBData+36 > this._ibData.length)
				this.flush();
			this._tempNumver0=width / 2;
			this._tempNumver1=height / 2;
			this._tempNumver2=depth / 2;
			this._tempUint0=this._posInVBData / this._floatSizePerVer;
			this.addVertex(positionX-this._tempNumver0,positionY+this._tempNumver1,positionZ+this._tempNumver2,r,g,b,a);
			this.addVertex(positionX+this._tempNumver0,positionY+this._tempNumver1,positionZ+this._tempNumver2,r,g,b,a);
			this.addVertex(positionX-this._tempNumver0,positionY-this._tempNumver1,positionZ+this._tempNumver2,r,g,b,a);
			this.addVertex(positionX+this._tempNumver0,positionY-this._tempNumver1,positionZ+this._tempNumver2,r,g,b,a);
			this.addVertex(positionX+this._tempNumver0,positionY+this._tempNumver1,positionZ-this._tempNumver2,r,g,b,a);
			this.addVertex(positionX-this._tempNumver0,positionY+this._tempNumver1,positionZ-this._tempNumver2,r,g,b,a);
			this.addVertex(positionX+this._tempNumver0,positionY-this._tempNumver1,positionZ-this._tempNumver2,r,g,b,a);
			this.addVertex(positionX-this._tempNumver0,positionY-this._tempNumver1,positionZ-this._tempNumver2,r,g,b,a);
			this._tempUint1=this._tempUint0+1;
			this._tempUint2=this._tempUint0+2;
			this._tempUint3=this._tempUint0+3;
			this._tempUint4=this._tempUint0+4;
			this._tempUint5=this._tempUint0+5;
			this._tempUint6=this._tempUint0+6;
			this._tempUint7=this._tempUint0+7;
			this.addIndexes(this._tempUint0,this._tempUint1,this._tempUint2,this._tempUint2,this._tempUint1,this._tempUint3,
			this._tempUint4,this._tempUint5,this._tempUint6,this._tempUint6,this._tempUint5,this._tempUint7,
			this._tempUint5,this._tempUint0,this._tempUint7,this._tempUint7,this._tempUint0,this._tempUint2,
			this._tempUint1,this._tempUint4,this._tempUint3,this._tempUint3,this._tempUint4,this._tempUint6,
			this._tempUint5,this._tempUint4,this._tempUint0,this._tempUint0,this._tempUint4,this._tempUint1,
			this._tempUint2,this._tempUint3,this._tempUint7,this._tempUint7,this._tempUint3,this._tempUint6);
			return this;
		}

		__proto.cone=function(radius,length,Slices,r,g,b,a){
			if (!this._hasBegun || this._primitiveType!==0x0004)
				this.drawTrianglesException();
			if (this._posInVBData+(2 *Slices+2)*this._floatSizePerVer > this._vbData.length || this._posInIBData+6 *Slices > this._ibData.length)
				this.flush();
			this._tempUint0=this._posInVBData;
			this._tempUint1=this._posInVBData / this._floatSizePerVer;
			this._tempNumver0=Math.PI *2 / Slices;
			this.addVertexIndex(0,length,0,r,g,b,a,this._tempUint0);
			this.addVertexIndex(0,0,0,r,g,b,a,this._tempUint0+this._floatSizePerVer);
			this._tempInt0=2;
			this._tempNumver1=0;
			for (this._tempInt1=0;this._tempInt1 < Slices;this._tempInt1++){
				this._tempNumver2=Math.cos(this._tempNumver1);
				this._tempNumver3=Math.sin(this._tempNumver1);
				this.addVertexIndex(radius *this._tempNumver2,0,radius *this._tempNumver3,r,g,b,a,this._tempUint0+this._tempInt0 *this._floatSizePerVer);
				this.addIndexes(this._tempUint1,this._tempUint1+this._tempInt0);
				if (this._tempInt1==Slices-1)
					this.addIndexes(this._tempUint1+2);
				else
				this.addIndexes(this._tempUint1+this._tempInt0+1);
				this.addVertexIndex(radius *this._tempNumver2,0,radius *this._tempNumver3,r,g,b,a,this._tempUint0+(this._tempInt0+Slices)*this._floatSizePerVer);
				this.addIndexes(this._tempUint1+1);
				if (this._tempInt1==Slices-1)
					this.addIndexes(this._tempUint1+Slices+2);
				else
				this.addIndexes(this._tempUint1+this._tempInt0+Slices+1);
				this.addIndexes(this._tempUint1+this._tempInt0+Slices);
				this._tempInt0++;
				this._tempNumver1+=this._tempNumver0;
			}
			return this;
		}

		__proto.boundingBoxLine=function(minX,minY,minZ,maxX,maxY,maxZ,r,g,b,a){
			if (!this._hasBegun || this._primitiveType!==0x0001)
				this.drawLinesException();
			if (this._posInVBData+8 *this._floatSizePerVer > this._vbData.length || this._posInIBData+48 > this._ibData.length)
				this.flush();
			this._tempUint0=this._posInVBData / this._floatSizePerVer;
			this.addVertex(minX,maxY,maxZ,r,g,b,a);
			this.addVertex(maxX,maxY,maxZ,r,g,b,a);
			this.addVertex(minX,minY,maxZ,r,g,b,a);
			this.addVertex(maxX,minY,maxZ,r,g,b,a);
			this.addVertex(maxX,maxY,minZ,r,g,b,a);
			this.addVertex(minX,maxY,minZ,r,g,b,a);
			this.addVertex(maxX,minY,minZ,r,g,b,a);
			this.addVertex(minX,minY,minZ,r,g,b,a);
			this._tempUint1=this._tempUint0+1;
			this._tempUint2=this._tempUint0+2;
			this._tempUint3=this._tempUint0+3;
			this._tempUint4=this._tempUint0+4;
			this._tempUint5=this._tempUint0+5;
			this._tempUint6=this._tempUint0+6;
			this._tempUint7=this._tempUint0+7;
			this.addIndexes(this._tempUint0,this._tempUint1,this._tempUint1,this._tempUint3,this._tempUint3,this._tempUint2,this._tempUint2,this._tempUint0,
			this._tempUint4,this._tempUint5,this._tempUint5,this._tempUint7,this._tempUint7,this._tempUint6,this._tempUint6,this._tempUint4,
			this._tempUint5,this._tempUint0,this._tempUint0,this._tempUint2,this._tempUint2,this._tempUint7,this._tempUint7,this._tempUint5,
			this._tempUint1,this._tempUint4,this._tempUint4,this._tempUint6,this._tempUint6,this._tempUint3,this._tempUint3,this._tempUint1,
			this._tempUint5,this._tempUint4,this._tempUint4,this._tempUint1,this._tempUint1,this._tempUint0,this._tempUint0,this._tempUint5,
			this._tempUint2,this._tempUint3,this._tempUint3,this._tempUint6,this._tempUint6,this._tempUint7,this._tempUint7,this._tempUint2);
			return this;
		}

		__proto.addVertex=function(x,y,z,r,g,b,a){
			if (!this._hasBegun)
				this.addVertexIndexException();
			this._vbData[this._posInVBData]=x,this._vbData[this._posInVBData+1]=y,this._vbData[this._posInVBData+2]=z;
			this._vbData[this._posInVBData+3]=r,this._vbData[this._posInVBData+4]=g,this._vbData[this._posInVBData+5]=b,this._vbData[this._posInVBData+6]=a;
			this._posInVBData+=this._floatSizePerVer;
			return this;
		}

		__proto.addVertexIndex=function(x,y,z,r,g,b,a,index){
			if (!this._hasBegun)
				this.addVertexIndexException();
			this._vbData[index]=x,this._vbData[index+1]=y,this._vbData[index+2]=z;
			this._vbData[index+3]=r,this._vbData[index+4]=g,this._vbData[index+5]=b,this._vbData[index+6]=a;
			index+=this._floatSizePerVer;
			if (index > this._posInVBData)
				this._posInVBData=index;
			return this;
		}

		__proto.addIndexes=function(__indexes){
			var indexes=arguments;
			if (!this._hasBegun)
				this.addVertexIndexException();
			for (var i=0;i < indexes.length;i++){
				this._ibData[this._posInIBData]=indexes[i];
				this._posInIBData++;
			}
			return this;
		}

		__proto.begin=function(primitive,camera){
			if (this._hasBegun)
				this.beginException0();
			if (primitive!==0x0001 && primitive!==0x0004)
				this.beginException1();
			this._primitiveType=primitive;
			this._camera=camera;
			this._hasBegun=true;
			return this;
		}

		__proto.end=function(){
			if (!this._hasBegun)
				this.endException();
			this.flush();
			this._hasBegun=false;
			return this;
		}

		__proto.flush=function(){
			if (this._posInVBData===0)
				return;
			this._ib.setData(this._ibData);
			this._vb.setData(this._vbData);
			this._vb.bind();
			this._ib.bind();
			this._shader=this._shaderCompile.withCompile(0,0,0);
			this._shader.bind();
			this._shader.uploadAttributes(PhasorSpriter3D._vertexDeclaration._shaderValues._data,null);
			this._spriteShaderValue.setValue(1,(this._camera).projectionViewMatrix.elements);
			this._shader.uploadSpriteUniforms(this._spriteShaderValue._data);
			Stat.drawCall++;
			LayaGL.instance.drawElements(this._primitiveType,this._posInIBData,0x1403,0);
			this._posInIBData=0;
			this._posInVBData=0;
		}

		__proto.addVertexIndexException=function(){
			throw new Error("请先调用begin()函数");
		}

		__proto.beginException0=function(){
			throw new Error("调用begin()前请确保已成功调用end()！");
		}

		__proto.beginException1=function(){
			throw new Error("只支持“LINES”和“TRIANGLES”两种基元！");
		}

		__proto.endException=function(){
			throw new Error("调用end()前请确保已成功调用begin()！");
		}

		__proto.drawLinesException=function(){
			throw new Error("您必须确保在此之前已调用begin()且使用“LINES”基元！");
		}

		__proto.drawTrianglesException=function(){
			throw new Error("您必须确保在此之前已调用begin()且使用“TRIANGLES”基元！");
		}

		__static(PhasorSpriter3D,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(28,[new VertexElement(0,"vector3",0),new VertexElement(12,"vector4",1)]);}
		]);
		return PhasorSpriter3D;
	})()


	/**
	*<code>RenderContext3D</code> 类用于实现渲染状态。
	*/
	//class laya.d3.core.render.RenderContext3D
	var RenderContext3D=(function(){
		function RenderContext3D(){
			//this._staticBatch=null;
			//this._batchIndexStart=0;
			//this._batchIndexEnd=0;
			//this.viewMatrix=null;
			//this.projectionMatrix=null;
			//this.projectionViewMatrix=null;
			//this.viewport=null;
			//this.elapsedTime=NaN;
			//this.scene=null;
			//this.camera=null;
			//this.renderElement=null;
			//this.shader=null;
		}

		__class(RenderContext3D,'laya.d3.core.render.RenderContext3D');
		RenderContext3D.clientWidth=0;
		RenderContext3D.clientHeight=0;
		return RenderContext3D;
	})()


	/**
	*@private
	*<code>RenderElement</code> 类用于实现渲染元素。
	*/
	//class laya.d3.core.render.RenderElement
	var RenderElement=(function(){
		function RenderElement(){
			//this.transform=null;
			//this.geometry=null;
			//this.material=null;
			//this.render=null;
		}

		__class(RenderElement,'laya.d3.core.render.RenderElement');
		var __proto=RenderElement.prototype;
		/**
		*@private
		*/
		__proto.addToOpaqueRenderQueue=function(scene,queue){
			queue._elements.push(this);
		}

		/**
		*@private
		*/
		__proto.addToTransparentRenderQueue=function(queue){
			queue._elements.push(this);
		}

		return RenderElement;
	})()


	/**
	*@private
	*<code>RenderQuene</code> 类用于实现渲染队列。
	*/
	//class laya.d3.core.render.RenderQueue
	var RenderQueue=(function(){
		function RenderQueue(scene,isOpaque){
			this._id=0;
			this._lastRenderElement=null;
			this._lastBatched=null;
			this._elements=null;
			this._renderableRenderObjects=null;
			this._scene=null;
			this.isOpaque=false;
			(isOpaque===void 0)&& (isOpaque=true);
			this._id=++RenderQueue._uniqueIDCounter;
			this.isOpaque=isOpaque;
			this._scene=scene;
			this._elements=[];
			this._renderableRenderObjects=[];
		}

		__class(RenderQueue,'laya.d3.core.render.RenderQueue');
		var __proto=RenderQueue.prototype;
		/**
		*@private
		*准备渲染队列。
		*@param state 渲染状态。
		*/
		__proto._preRender=function(state){}
		/**
		*@private
		*渲染队列。
		*@param state 渲染状态。
		*/
		__proto._render=function(context,isTarget){
			RenderQueue._updateMark++;
			var lastStateRenderState,lastStateRender;
			var loopCount=Stat.loopCount;
			var scene=this._scene;
			var camera=context.camera;
			for (var i=0,n=this._elements.length;i < n;i++){
				var element=this.isOpaque ? this._elements[i] :this._elements[n-i-1];
				var transform=element.transform;
				var render=element.render;
				var geometry=element.geometry;
				var material=element.material;
				context.renderElement=element;
				if (render._updateMark!==RenderQueue._updateMark){
					render._renderUpdate(context,transform);
					render._updateMark=RenderQueue._updateMark;
				}
				if (geometry._prepareRender(context)){
					var renderStates=material._renderStates;
					var passes=material._shader._passes;
					for (var j=0,m=passes.length;j < m;j++){
						var publicDefine=(scene._defineDatas.value | geometry._vertexDeclarationDefine)& (~material._disablePublicDefineDatas.value);
						var shader=context.shader=passes[j].withCompile(publicDefine,render._defineDatas.value,material._defineDatas.value);
						var switchShader=shader.bind();
						var switchShaderLoop=(loopCount!==shader._uploadLoopCount);
						if (geometry._singletonVertexBuffer){
							var vertexBuffer=geometry._vertexBuffer;
							vertexBuffer.bind();
							shader.uploadAttributes(vertexBuffer.vertexDeclaration._shaderValues);
							}else {
							var vertexBuffers=geometry._vertexBuffers;
							for (var k=0,p=vertexBuffers.length;k < p;k++){
								var vb=vertexBuffers[k];
								vb.bind();
								shader.uploadAttributes(vb.vertexDeclaration._shaderValues);
							}
						};
						var uploadScene=(shader._uploadScene!==scene)|| switchShaderLoop;
						if (uploadScene || switchShader){
							shader.uploadUniforms(shader._sceneUniformParamsMap,scene._shaderValues,uploadScene);
							shader._uploadScene=scene;
						};
						var switchCamera=shader._uploadCamera!==camera;
						var uploadSprite3D=(switchCamera || shader._uploadRender!==render)|| switchShaderLoop;
						if (uploadSprite3D || switchShader){
							shader.uploadUniforms(shader._spriteUniformParamsMap,render._shaderValues,uploadSprite3D);
							shader._uploadRender=render;
						};
						var uploadCamera=switchCamera || switchShaderLoop;
						if (uploadCamera || switchShader){
							shader.uploadUniforms(shader._cameraUniformParamsMap,camera._shaderValues,uploadCamera);
							shader._uploadCamera=camera;
						};
						var uploadMaterial=(shader._uploadMaterial!==material)|| switchShaderLoop;
						if (uploadMaterial || switchShader){
							shader.uploadUniforms(shader._materialUniformParamsMap,material._shaderValues,uploadMaterial);
							shader._uploadMaterial=material;
						};
						var renderState=renderStates[j];
						if (lastStateRenderState!==renderState){
							renderState._setRenderStateBlendDepth();
							renderState._setRenderStateFrontFace(isTarget,transform);
							lastStateRenderState=renderState;
							lastStateRender=render;
							}else {
							if (lastStateRender!==render){
								renderState._setRenderStateFrontFace(isTarget,transform);
								lastStateRender=render;
							}
						}
						geometry._render(context);
						shader._uploadLoopCount=loopCount;
					}
				}
			}
		}

		/**
		*@private
		*渲染队列。
		*@param state 渲染状态。
		*/
		__proto._renderShadow=function(state,isOnePSSM){
			var loopCount=Stat.loopCount;
			var scene=this._scene;
			var camera=state.camera;
			var vertexBuffer,vertexDeclaration,shader;
			var forceUploadParams=false;
			var lastStateMaterial,lastStateOwner;
			for (var i=0,n=this._elements.length;i < n;i++){
				var renderElement=this._elements[i];
				var renderObj,material,owner;
				if (renderElement._type===0){
					if (!isOnePSSM && (owner._projectionViewWorldUpdateCamera!==camera || owner._projectionViewWorldUpdateLoopCount!==Stat.loopCount)){
						owner._render._renderUpdate(state);
						owner._projectionViewWorldUpdateLoopCount=Stat.loopCount;
						owner._projectionViewWorldUpdateCamera=camera;
					}
					state.renderElement=renderElement;
					renderObj=renderElement.geometry,material=renderElement.material;
					if (renderObj._beforeRender(state)){
						vertexBuffer=renderObj._getVertexBuffer(0);
						vertexDeclaration=vertexBuffer.vertexDeclaration;
						shader=state.shader=material._getShader(scene._defineDatas.value,vertexDeclaration.shaderDefineValue,owner._defineDatas.value);
						forceUploadParams=shader.bind()|| (loopCount!==shader._uploadLoopCount);
						if (shader._uploadVertexBuffers!==vertexBuffer || forceUploadParams){
							shader.uploadAttributes(vertexDeclaration._shaderValues,null);
							shader._uploadVertexBuffers=vertexBuffer;
						}
						if (camera!==shader._uploadCamera || shader._uploadRender!==owner || forceUploadParams){
							shader.uploadUniforms(shader._spriteUniformParamsMap,owner._shaderValues);
							shader._uploadRender=owner;
						}
						if (camera!==shader._uploadCamera || forceUploadParams){
							shader.uploadUniforms(shader._cameraUniformParamsMap,camera._shaderValues);
							shader._uploadCamera=camera;
						}
						if (shader._uploadMaterial!==material || forceUploadParams){
							shader.uploadUniforms(shader._materialUniformParamsMap,material._shaderValues);
							shader._uploadMaterial=material;
						}
						if (lastStateMaterial!==material){
							material._setRenderStateFrontFace(false,owner.transform);
							lastStateMaterial=material;
							lastStateOwner=owner;
							}else {
							if (lastStateOwner!==owner){
								material._setRenderStateFrontFace(false,owner.transform);
								lastStateOwner=owner;
							}
						}
						renderObj._render(state);
						shader._uploadLoopCount=loopCount;
					}
				}
			}
		}

		/**
		*@private
		*/
		__proto.clear=function(){
			this._elements.length=0;
			this._lastRenderElement=null;
			this._lastBatched=false;
		}

		/**
		*获取唯一标识ID(通常用于优化或识别)。
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		RenderQueue._uniqueIDCounter=0;
		RenderQueue.OPAQUE=1;
		RenderQueue.TRANSPARENT=2;
		RenderQueue._updateMark=-1;
		return RenderQueue;
	})()


	//class laya.d3.core.scene.OctreeNode
	var OctreeNode=(function(){
		function OctreeNode(scene,currentDepth){
			this._exactBox=null;
			this._relaxBox=null;
			this._scene=null;
			this._parent=null;
			this._currentDepth=0;
			this._boundingSphere=new BoundSphere(new Vector3(),0);
			this._corners=[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];
			this._boundingBoxCenter=new Vector3();
			this._children=__newvec(8);
			this._objects=[];
			this._tempBoundBoxCorners=[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];
			this._scene=scene;
			this._currentDepth=currentDepth;
		}

		__class(OctreeNode,'laya.d3.core.scene.OctreeNode');
		var __proto=OctreeNode.prototype;
		Laya.imps(__proto,{"laya.d3.core.scene.ITreeNode":true})
		__proto.init=function(center,treeSize){
			var min=new Vector3();
			var max=new Vector3();
			Vector3.scale(treeSize,-0.5,min);
			Vector3.scale(treeSize,0.5,max);
			Vector3.add(min,center,min);
			Vector3.add(max,center,max);
			this.exactBox=new BoundBox(min,max);
			this.relaxBox=new BoundBox(min,max);
		}

		__proto.addTreeNode=function(render){
			if (Collision.boxContainsBox(this._relaxBox,render.boundingBox)===1)
				this.addNodeDown(render,0);
			else
			this.addObject(render);
		}

		__proto.addChild=function(index){
			var child=this._children[index];
			if (child==null){
				child=new OctreeNode(this._scene,this._currentDepth+1);
				this._children[index]=child;
				child._parent=this;
				Vector3.subtract(this._exactBox.max,this._exactBox.min,OctreeNode.tempSize);
				Vector3.multiply(OctreeNode.tempSize,OctreeNode._octreeSplit[index],OctreeNode.tempCenter);
				Vector3.add(this._exactBox.min,OctreeNode.tempCenter,OctreeNode.tempCenter);
				Vector3.scale(OctreeNode.tempSize,0.25,OctreeNode.tempSize);
				var min=new Vector3();
				var max=new Vector3();
				Vector3.subtract(OctreeNode.tempCenter,OctreeNode.tempSize,min);
				Vector3.add(OctreeNode.tempCenter,OctreeNode.tempSize,max);
				child.exactBox=new BoundBox(min,max);
				Vector3.scale(OctreeNode.tempSize,OctreeNode.relax,OctreeNode.tempSize);
				var relaxMin=new Vector3();
				var relaxMax=new Vector3();
				Vector3.subtract(OctreeNode.tempCenter,OctreeNode.tempSize,relaxMin);
				Vector3.add(OctreeNode.tempCenter,OctreeNode.tempSize,relaxMax);
				child.relaxBox=new BoundBox(relaxMin,relaxMax);
			}
			return child;
		}

		__proto.addObject=function(object){
			object._treeNode=this;
			this._objects.push(object);
		}

		__proto.removeObject=function(object){
			if (object._treeNode !=this){
				console.log("OctreeNode::removeObject error");
				return false;
			};
			var index=this._objects.indexOf(object);
			if (index!==-1){
				this._objects.splice(index,1);
				return true;
			}
			return false;
		}

		__proto.clearObject=function(){
			this._objects.length=0;
		}

		__proto.addNodeUp=function(render,depth){
			if (this._parent && (Collision.boxContainsBox(this._exactBox,render.boundingBox)!==1)){
				this._parent.addNodeUp(render,depth-1);
			}else
			this.addNodeDown(render,depth);
		}

		__proto.addNodeDown=function(render,depth){
			if (depth < this._scene.treeLevel){
				var childIndex=this.inChildIndex(render.boundingBoxCenter);
				var child=this.addChild(childIndex);
				if (Collision.boxContainsBox(child._relaxBox,render.boundingBox)===1){
					child.addNodeDown(render,++depth);
				}else
				this.addObject(render);
				}else {
				this.addObject(render);
			}
		}

		__proto.inChildIndex=function(objectCenter){
			var z=objectCenter.z < this._boundingBoxCenter.z ? 0 :1;
			var y=objectCenter.y < this._boundingBoxCenter.y ? 0 :1;
			var x=objectCenter.x < this._boundingBoxCenter.x ? 0 :1;
			return z *4+y *2+x;
		}

		__proto.updateObject=function(render){
			if (Collision.boxContainsBox(this._relaxBox,render.boundingBox)===1){
				this.removeObject(render);
				render._treeNode=null;
				this.addNodeDown(render,this._currentDepth);
				}else if (this._parent){
				this.removeObject(render);
				render._treeNode=null;
				this._parent.addNodeUp(render,this._currentDepth-1);
			}
		}

		__proto.cullingObjects=function(boundFrustum,testVisible,flags,cameraPosition,projectionView){
			var i=0,j=0,n=0,m=0;
			var dynamicBatchManager=this._scene._dynamicBatchManager;
			for (i=0,n=this._objects.length;i < n;i++){
				var render=this._objects[i];
				if (Layer.isVisible(render._owner.layer.mask)&& render.enable){
					if (testVisible){
						Stat.treeSpriteCollision+=1;
						if (boundFrustum.containsBoundSphere(render.boundingSphere)===0)
							continue ;
					}
					render._renderUpdate(projectionView);
					render._distanceForSort=Vector3.distance(render.boundingSphere.center,cameraPosition)+render.sortingFudge;
					var renderElements=render._renderElements;
					for (j=0,m=renderElements.length;j < m;j++){
						var renderElement=renderElements[j];
						var staticBatch=renderElement.staticBatch;
						if (staticBatch){
							staticBatch._addBatchRenderElement(renderElement);
							}else {
							var renderObj=renderElement.geometry;
							if ((renderObj.triangleCount < DynamicBatch.maxCombineTriangleCount)&& (renderObj._vertexBufferCount===1)&& (renderObj._getIndexBuffer())&& (renderElement.material.renderQueue < 2)&& renderElement._canDynamicBatch && (!render._owner.isStatic))
								dynamicBatchManager._addPrepareRenderElement(renderElement);
							else
							this._scene.getRenderQueue(renderElement.material.renderQueue).addElement(renderElement);
						}
					}
				}
			}
			for (i=0;i < 8;i++){
				var child=this._children[i];
				if (child==null)
					continue ;
				var testVisibleChild=testVisible;
				if (testVisible){
					var type=boundFrustum.containsBoundBox(child._relaxBox);
					Stat.treeNodeCollision+=1;
					if (type===0)
						continue ;
					testVisibleChild=(type===2);
				}
				child.cullingObjects(boundFrustum,testVisibleChild,flags,cameraPosition,projectionView);
			}
		}

		/**
		*@private
		*/
		__proto.cullingShadowObjects=function(lightBoundFrustum,splitShadowQueues,testVisible,flags,scene){
			var i=0,j=0,n=0,m=0;
			var dynamicBatchManager=this._scene._dynamicBatchManager;
			for (i=0,n=this._objects.length;i < n;i++){
				var baseRender=this._objects[i];
				if (baseRender.castShadow && Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable){
					if (testVisible && lightBoundFrustum[0].containsBoundSphere(baseRender.boundingSphere)===0)
						continue ;
					for (var k=1,kNum=lightBoundFrustum.length;k < kNum;k++){
						var shadowQueue=splitShadowQueues[k-1];
						if (lightBoundFrustum[k].containsBoundSphere(baseRender.boundingSphere)!==0){
							var renderElements=baseRender._renderElements;
							for (j=0,m=renderElements.length;j < m;j++)
							shadowQueue.addElement(renderElements[j]);
						}
					}
				}
			}
			for (i=0;i < 8;i++){
				var child=this._children[i];
				if (child==null)
					continue ;
				var testVisibleChild=testVisible;
				if (testVisible){
					var type=lightBoundFrustum[0].containsBoundBox(child._relaxBox);
					if (type===0)
						continue ;
					testVisibleChild=(type===2);
				}
				child.cullingShadowObjects(lightBoundFrustum,splitShadowQueues,testVisibleChild,flags,scene);
			}
		}

		/**
		*@private
		*/
		__proto.cullingShadowObjectsOnePSSM=function(lightBoundFrustum,splitShadowQueues,lightViewProjectMatrix,testVisible,flags,scene){
			var shadowQueue=splitShadowQueues[0];
			var i=0,j=0,n=0,m=0;
			for (i=0,n=this._objects.length;i < n;i++){
				var baseRender=this._objects[i];
				if (baseRender.castShadow && Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable){
					if (testVisible && lightBoundFrustum.containsBoundSphere(baseRender.boundingSphere)===0)
						continue ;
					baseRender._renderUpdate(lightViewProjectMatrix);
					var renderElements=baseRender._renderElements;
					for (j=0,m=renderElements.length;j < m;j++)
					shadowQueue.addElement(renderElements[j]);
				}
			}
			for (i=0;i < 8;i++){
				var child=this._children[i];
				if (child==null)
					continue ;
				var testVisibleChild=testVisible;
				if (testVisible){
					var type=lightBoundFrustum.containsBoundBox(child._relaxBox);
					if (type===0)
						continue ;
					testVisibleChild=(type===2);
				}
				child.cullingShadowObjectsOnePSSM(lightBoundFrustum,splitShadowQueues,lightViewProjectMatrix,testVisibleChild,flags,scene);
			}
		}

		__proto.renderBoudingBox=function(linePhasor){
			this._renderBoudingBox(linePhasor);
			for (var i=0;i < 8;++i){
				var pChild=this._children[i];
				if (pChild){
					pChild.renderBoudingBox(linePhasor);
				}
			}
		}

		__proto.buildAllChild=function(depth){
			if (depth < this._scene.treeLevel){
				for (var i=0;i < 8;i++){
					var child=this.addChild(i);
					child.buildAllChild(depth+1);
				}
			}
		}

		__proto._renderBoudingBox=function(linePhasor){}
		__getset(0,__proto,'exactBox',function(){
			return this._exactBox;
			},function(value){
			this._exactBox=value;
			Vector3.add(value.min,value.max,this._boundingBoxCenter);
			Vector3.scale(this._boundingBoxCenter,0.5,this._boundingBoxCenter);
		});

		__getset(0,__proto,'relaxBox',function(){
			return this._relaxBox;
			},function(value){
			this._relaxBox=value;
			value.getCorners(this._corners);
			BoundSphere.createfromPoints(this._corners,this._boundingSphere);
		});

		OctreeNode.debugMode=false;
		OctreeNode.relax=1.15;
		OctreeNode.CHILDNUM=8;
		__static(OctreeNode,
		['tempVector0',function(){return this.tempVector0=new Vector3();},'tempSize',function(){return this.tempSize=new Vector3();},'tempCenter',function(){return this.tempCenter=new Vector3();},'_octreeSplit',function(){return this._octreeSplit=[new Vector3(0.250,0.250,0.250),new Vector3(0.750,0.250,0.250),new Vector3(0.250,0.750,0.250),new Vector3(0.750,0.750,0.250),new Vector3(0.250,0.250,0.750),new Vector3(0.750,0.250,0.750),new Vector3(0.250,0.750,0.750),new Vector3(0.750,0.750,0.750)];}
		]);
		return OctreeNode;
	})()


	/**
	*@private
	*<code>DynamicBatchManager</code> 类用于管理动态批处理。
	*/
	//class laya.d3.graphics.DynamicBatchManager
	var DynamicBatchManager=(function(){
		function DynamicBatchManager(){
			//this._batchRenderElementPool=null;
			//this._batchRenderElementPoolIndex=0;
			this._batchRenderElementPool=[];
		}

		__class(DynamicBatchManager,'laya.d3.graphics.DynamicBatchManager');
		var __proto=DynamicBatchManager.prototype;
		/**
		*@private
		*/
		__proto._clear=function(){
			this._batchRenderElementPoolIndex=0;
		}

		/**
		*@private
		*/
		__proto._getBatchRenderElementFromPool=function(){
			throw "StaticBatch:must override this function.";
		}

		/**
		*@private
		*/
		__proto.dispose=function(){}
		DynamicBatchManager._registerManager=function(manager){
			DynamicBatchManager._managers.push(manager);
		}

		DynamicBatchManager._managers=[];
		return DynamicBatchManager;
	})()


	/**
	*@private
	*<code>FrustumCulling</code> 类用于裁剪。
	*/
	//class laya.d3.graphics.FrustumCulling
	var FrustumCulling=(function(){
		/**
		*创建一个 <code>FrustumCulling</code> 实例。
		*/
		function FrustumCulling(){}
		__class(FrustumCulling,'laya.d3.graphics.FrustumCulling');
		FrustumCulling.renderObjectCulling=function(boundFrustum,scene,context){
			var i=0,n=0,j=0,m=0;
			var queues=scene._quenes;
			for (i=0,n=queues.length;i < n;i++){
				var queue=queues[i];
				(queue)&& (queue.clear());
			};
			var staticBatchManagers=StaticBatchManager._managers;
			for (i=0,n=staticBatchManagers.length;i < n;i++)
			staticBatchManagers[i]._clear();
			var dynamicBatchManagers=DynamicBatchManager._managers;
			for (i=0,n=dynamicBatchManagers.length;i < n;i++)
			dynamicBatchManagers[i]._clear();
			var renderObjects=scene._renderObjects;
			var camPos=context.camera.transform.position;
			var validCount=scene._cullingRendersLength;
			for (i=0;i < validCount;i++){
				var baseRender=renderObjects[i];
				if (Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable && baseRender._needRender(boundFrustum)){
					baseRender._distanceForSort=Vector3.distance(baseRender.boundingSphere.center,camPos)+baseRender.sortingFudge;
					}else {
					scene.swapRenderObject(i--,--validCount);
				}
			}
			(validCount > 0)&& (scene._quickSort(renderObjects,0,validCount-1));
			for (i=0;i < validCount;i++){
				var elements=renderObjects[i]._renderElements;
				for (j=0,m=elements.length;j < m;j++){
					var element=elements[j];
					var renderQueue=scene.getRenderQueue(element.material.renderQueue);
					if (renderQueue.isOpaque)
						element.addToOpaqueRenderQueue(scene,renderQueue);
					else
					element.addToTransparentRenderQueue(renderQueue);
				}
			}
		}

		FrustumCulling.renderShadowObjectCulling=function(scene,lightFrustum,shadowQueues,lightViewProjectMatrix,nPSSMNum){
			var i=0,j=0,n=0,m=0;
			for (i=0,n=shadowQueues.length;i < n;i++){
				var quene=shadowQueues[i];
				(quene)&& (quene.clear());
			};
			var frustumCullingObjects=scene._renderObjects;
			var baseRender,shadowQueue,renderElements;
			if (nPSSMNum > 1){
				for (i=0,n=scene._cullingRendersLength;i < n;i++){
					baseRender=frustumCullingObjects[i];
					if (baseRender.castShadow && Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable){
						for (var k=1,kNum=lightFrustum.length;k < kNum;k++){
							shadowQueue=shadowQueues[k-1];
							if (lightFrustum[k].containsBoundSphere(baseRender.boundingSphere)!==0){
								renderElements=baseRender._renderElements;
								for (j=0,m=renderElements.length;j < m;j++)
								shadowQueue.addElement(renderElements[j]);
							}
						}
					}
				}
				}else {
				for (i=0,n=scene._cullingRendersLength;i < n;i++){
					baseRender=frustumCullingObjects[i];
					if (baseRender.castShadow && Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable){
						if (lightFrustum[0].containsBoundSphere(baseRender.boundingSphere)!==0){
							baseRender._renderUpdate(lightViewProjectMatrix);
							shadowQueue=shadowQueues[0];
							renderElements=baseRender._renderElements;
							for (j=0,m=renderElements.length;j < m;j++)
							shadowQueue.addElement(renderElements[j]);
						}
					}
				}
			}
		}

		FrustumCulling.renderShadowObjectCullingOctree=function(scene,lightFrustum,quenesResult,lightViewProjectMatrix,nPSSMNum){
			for (var i=0,n=quenesResult.length;i < n;i++){
				var quene=quenesResult[i];
				(quene)&& (quene.clear());
			}
			if (nPSSMNum > 1){
				scene.treeRoot.cullingShadowObjects(lightFrustum,quenesResult,true,0,scene);
				}else {
				scene.treeRoot.cullingShadowObjectsOnePSSM(lightFrustum[0],quenesResult,lightViewProjectMatrix,true,0,scene);
			}
		}

		FrustumCulling.renderObjectCullingOctree=function(boundFrustum,scene,camera,view,projection,projectionView){
			var i=0,n=0;
			var queues=scene._quenes;
			var dynamicBatchManager=scene._dynamicBatchManager;
			for (i=0,n=queues.length;i < n;i++){
				var queue=queues[i];
				(queue)&& (queue.clear());
			};
			var staticBatchManagers=StaticBatchManager._managers;
			for (i=0,n=staticBatchManagers.length;i < n;i++)
			staticBatchManagers[i]._clear();
			dynamicBatchManager._clearRenderElements();
			scene._renderObjects.length=0;
			scene.treeRoot.cullingObjects(boundFrustum,true,0,camera.transform.position,projectionView);
			dynamicBatchManager._finishCombineDynamicBatch(scene);
			dynamicBatchManager._addToRenderQueue(scene,view,projection,projectionView);
		}

		return FrustumCulling;
	})()


	/**
	*<code>StaticBatchManager</code> 类用于静态批处理管理的父类。
	*/
	//class laya.d3.graphics.StaticBatchManager
	var StaticBatchManager=(function(){
		function StaticBatchManager(){
			//this._batchRenderElementPool=null;
			//this._batchRenderElementPoolIndex=0;
			//this._initBatchElements=null;
			//this._staticBatches=null;
			this._initBatchElements=[];
			this._staticBatches={};
			this._batchRenderElementPoolIndex=0;
			this._batchRenderElementPool=[];
		}

		__class(StaticBatchManager,'laya.d3.graphics.StaticBatchManager');
		var __proto=StaticBatchManager.prototype;
		/**
		*@private
		*/
		__proto._partition=function(items,left,right){
			var pivot=items[Math.floor((right+left)/ 2)];
			while (left <=right){
				while (this._compare(items[left],pivot)< 0)
				left++;
				while (this._compare(items[right],pivot)> 0)
				right--;
				if (left < right){
					var temp=items[left];
					items[left]=items[right];
					items[right]=temp;
					left++;
					right--;
					}else if (left===right){
					left++;
					break ;
				}
			}
			return left;
		}

		/**
		*@private
		*/
		__proto._quickSort=function(items,left,right){
			if (items.length > 1){
				var index=this._partition(items,left,right);
				var leftIndex=index-1;
				if (left < leftIndex)
					this._quickSort(items,left,leftIndex);
				if (index < right)
					this._quickSort(items,index,right);
			}
			return items;
		}

		/**
		*@private
		*/
		__proto._compare=function(left,right){
			throw "StaticBatch:must override this function.";
		}

		/**
		*@private
		*/
		__proto._initStaticBatchs=function(rootSprite){
			for (var key in this._staticBatches)
			this._staticBatches[key].finishInit();
			this._initBatchElements.length=0;
		}

		/**
		*@private
		*/
		__proto._getBatchRenderElementFromPool=function(){
			throw "StaticBatch:must override this function.";
		}

		/**
		*@private
		*/
		__proto._getStaticBatch=function(rootOwner,vertexDeclaration,number){
			throw "StaticBatch:must override this function.";
		}

		/**
		*@private
		*/
		__proto._addBatchSprite=function(renderableSprite3D){
			var renderElements=renderableSprite3D._render._renderElements;
			for (var i=0,n=renderElements.length;i < n;i++)
			this._initBatchElements.push(renderElements[i]);
		}

		/**
		*@private
		*/
		__proto._clear=function(){
			this._batchRenderElementPoolIndex=0;
		}

		/**
		*@private
		*/
		__proto._destroyRenderElement=function(renderElement){
			var staticBatch=renderElement.staticBatch;
			staticBatch.remove(renderElement);
			if (staticBatch.getBatchElementsCount()===0){
				staticBatch.dispose();
				delete this._staticBatches[staticBatch.key];
			}
		}

		/**
		*@private
		*/
		__proto._garbageCollection=function(){
			for (var key in this._staticBatches){
				var staticBatch=this._staticBatches[key];
				if (staticBatch.getBatchElementsCount()===0){
					staticBatch.dispose();
					delete this._staticBatches[staticBatch.key];
				}
			}
		}

		/**
		*@private
		*/
		__proto.dispose=function(){
			this._staticBatches=null;
		}

		StaticBatchManager._registerManager=function(manager){
			StaticBatchManager._managers.push(manager);
		}

		StaticBatchManager._addToStaticBatchQueue=function(sprite3D){
			if ((sprite3D instanceof laya.d3.core.RenderableSprite3D )&& sprite3D.isStatic)
				(sprite3D)._addToInitStaticBatchManager();
			for (var i=0,n=sprite3D.numChildren;i < n;i++)
			StaticBatchManager._addToStaticBatchQueue(sprite3D._children [i]);
		}

		StaticBatchManager.combine=function(staticBatchRoot,renderableSprite3Ds){
			var i=0,n=0;
			if (renderableSprite3Ds){
				for (i=0,n=renderableSprite3Ds.length;i < n;i++){
					var renderableSprite3D=renderableSprite3Ds[i];
					(renderableSprite3D.isStatic)&& (renderableSprite3D._addToInitStaticBatchManager());
				}
				}else {
				if (staticBatchRoot)
					StaticBatchManager._addToStaticBatchQueue(staticBatchRoot);
			}
			for (i=0,n=StaticBatchManager._managers.length;i < n;i++){
				var manager=StaticBatchManager._managers[i];
				manager._initStaticBatchs(staticBatchRoot);
			}
		}

		StaticBatchManager._managers=[];
		return StaticBatchManager;
	})()


	//class laya.d3.graphics.Vertex.VertexPosition
	var VertexPosition=(function(){
		function VertexPosition(position){
			this._position=null;
			this._position=position;
		}

		__class(VertexPosition,'laya.d3.graphics.Vertex.VertexPosition');
		var __proto=VertexPosition.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPosition._vertexDeclaration;
		});

		/*INTERFACE laya.d3.graphics.IVertex */
		__getset(1,VertexPosition,'vertexDeclaration',function(){
			return VertexPosition._vertexDeclaration;
		});

		__static(VertexPosition,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(12,[
			new VertexElement(0,"vector3",0)]);}
		]);
		return VertexPosition;
	})()


	//class laya.d3.graphics.Vertex.VertexPositionNormal
	var VertexPositionNormal=(function(){
		function VertexPositionNormal(position,normal){
			this._position=null;
			this._normal=null;
			this._position=position;
			this._normal=normal;
		}

		__class(VertexPositionNormal,'laya.d3.graphics.Vertex.VertexPositionNormal');
		var __proto=VertexPositionNormal.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormal._vertexDeclaration;
		});

		/*INTERFACE laya.d3.graphics.IVertex */
		__getset(1,VertexPositionNormal,'vertexDeclaration',function(){
			return VertexPositionNormal._vertexDeclaration;
		});

		__static(VertexPositionNormal,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(24,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3)]);}
		]);
		return VertexPositionNormal;
	})()


	/**
	*<code>VertexPositionNormalColor</code> 类用于创建位置、法线、颜色顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColor
	var VertexPositionNormalColor=(function(){
		function VertexPositionNormalColor(position,normal,color){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
		}

		__class(VertexPositionNormalColor,'laya.d3.graphics.Vertex.VertexPositionNormalColor');
		var __proto=VertexPositionNormalColor.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColor._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColor,'vertexDeclaration',function(){
			return VertexPositionNormalColor._vertexDeclaration;
		});

		__static(VertexPositionNormalColor,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(40,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1)]);}
		]);
		return VertexPositionNormalColor;
	})()


	/**
	*<code>VertexPositionNormalColorSkin</code> 类用于创建位置、法线、颜色、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorSkin
	var VertexPositionNormalColorSkin=(function(){
		function VertexPositionNormalColorSkin(position,normal,color,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorSkin,'laya.d3.graphics.Vertex.VertexPositionNormalColorSkin');
		var __proto=VertexPositionNormalColorSkin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorSkin._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorSkin,'vertexDeclaration',function(){
			return VertexPositionNormalColorSkin._vertexDeclaration;
		});

		__static(VertexPositionNormalColorSkin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(72,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector4",7),
			new VertexElement(56,"vector4",6)]);}
		]);
		return VertexPositionNormalColorSkin;
	})()


	/**
	*<code>VertexPositionNormalColorSkin</code> 类用于创建位置、法线、颜色、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorSkinSTangent
	var VertexPositionNormalColorSkinSTangent=(function(){
		function VertexPositionNormalColorSkinSTangent(position,normal,color,tangent,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorSkinSTangent,'laya.d3.graphics.Vertex.VertexPositionNormalColorSkinSTangent');
		var __proto=VertexPositionNormalColorSkinSTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorSkinSTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorSkinSTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorSkinSTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorSkinSTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(88,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector4",7),
			new VertexElement(56,"vector4",6),
			new VertexElement(72,"vector4",5)]);}
		]);
		return VertexPositionNormalColorSkinSTangent;
	})()


	/**
	*<code>VertexPositionNormalColorSkin</code> 类用于创建位置、法线、颜色、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorSkinTangent
	var VertexPositionNormalColorSkinTangent=(function(){
		function VertexPositionNormalColorSkinTangent(position,normal,color,tangent,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorSkinTangent,'laya.d3.graphics.Vertex.VertexPositionNormalColorSkinTangent');
		var __proto=VertexPositionNormalColorSkinTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorSkinTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorSkinTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorSkinTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorSkinTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(84,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector4",7),
			new VertexElement(56,"vector4",6),
			new VertexElement(72,"vector3",5)]);}
		]);
		return VertexPositionNormalColorSkinTangent;
	})()


	/**
	*<code>VertexPositionNormalColorTangent</code> 类用于创建位置、法线、颜色、切线顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorSTangent
	var VertexPositionNormalColorSTangent=(function(){
		function VertexPositionNormalColorSTangent(position,normal,color,tangent){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalColorSTangent,'laya.d3.graphics.Vertex.VertexPositionNormalColorSTangent');
		var __proto=VertexPositionNormalColorSTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorSTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorSTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorSTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorSTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(56,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector4",5)]);}
		]);
		return VertexPositionNormalColorSTangent;
	})()


	/**
	*<code>VertexPositionNormalColorTangent</code> 类用于创建位置、法线、颜色、切线顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorTangent
	var VertexPositionNormalColorTangent=(function(){
		function VertexPositionNormalColorTangent(position,normal,color,tangent){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalColorTangent,'laya.d3.graphics.Vertex.VertexPositionNormalColorTangent');
		var __proto=VertexPositionNormalColorTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(52,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector3",5)]);}
		]);
		return VertexPositionNormalColorTangent;
	})()


	/**
	*<code>VertexPositionNormalColorTexture</code> 类用于创建位置、法线、颜色、纹理顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorTexture
	var VertexPositionNormalColorTexture=(function(){
		function VertexPositionNormalColorTexture(position,normal,color,textureCoordinate){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate=textureCoordinate;
		}

		__class(VertexPositionNormalColorTexture,'laya.d3.graphics.Vertex.VertexPositionNormalColorTexture');
		var __proto=VertexPositionNormalColorTexture.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTexture,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTexture,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(48,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector2",2)]);}
		]);
		return VertexPositionNormalColorTexture;
	})()


	/**
	*<code>VertexPositionNormalColorTexture</code> 类用于创建位置、法线、颜色、纹理顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorTexture0Texture1
	var VertexPositionNormalColorTexture0Texture1=(function(){
		function VertexPositionNormalColorTexture0Texture1(position,normal,color,textureCoordinate0,textureCoordinate1){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
		}

		__class(VertexPositionNormalColorTexture0Texture1,'laya.d3.graphics.Vertex.VertexPositionNormalColorTexture0Texture1');
		var __proto=VertexPositionNormalColorTexture0Texture1.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(1,VertexPositionNormalColorTexture0Texture1,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTexture0Texture1,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(56,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector2",2),
			new VertexElement(48,"vector2",15)]);}
		]);
		return VertexPositionNormalColorTexture0Texture1;
	})()


	/**
	*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorTexture0Texture1Skin
	var VertexPositionNormalColorTexture0Texture1Skin=(function(){
		function VertexPositionNormalColorTexture0Texture1Skin(position,normal,color,textureCoordinate0,textureCoordinate1,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorTexture0Texture1Skin,'laya.d3.graphics.Vertex.VertexPositionNormalColorTexture0Texture1Skin');
		var __proto=VertexPositionNormalColorTexture0Texture1Skin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1Skin._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(1,VertexPositionNormalColorTexture0Texture1Skin,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1Skin._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTexture0Texture1Skin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(88,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector2",2),
			new VertexElement(48,"vector2",15),
			new VertexElement(56,"vector4",7),
			new VertexElement(72,"vector4",6)]);}
		]);
		return VertexPositionNormalColorTexture0Texture1Skin;
	})()


	/**
	*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorTexture0Texture1SkinSTangent
	var VertexPositionNormalColorTexture0Texture1SkinSTangent=(function(){
		function VertexPositionNormalColorTexture0Texture1SkinSTangent(position,normal,color,textureCoordinate0,textureCoordinate1,tangent,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorTexture0Texture1SkinSTangent,'laya.d3.graphics.Vertex.VertexPositionNormalColorTexture0Texture1SkinSTangent');
		var __proto=VertexPositionNormalColorTexture0Texture1SkinSTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1SkinSTangent._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(1,VertexPositionNormalColorTexture0Texture1SkinSTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1SkinSTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTexture0Texture1SkinSTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(104,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector2",2),
			new VertexElement(48,"vector2",15),
			new VertexElement(56,"vector4",7),
			new VertexElement(72,"vector4",6),
			new VertexElement(88,"vector4",5)]);}
		]);
		return VertexPositionNormalColorTexture0Texture1SkinSTangent;
	})()


	/**
	*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorTexture0Texture1SkinTangent
	var VertexPositionNormalColorTexture0Texture1SkinTangent=(function(){
		function VertexPositionNormalColorTexture0Texture1SkinTangent(){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
		}

		__class(VertexPositionNormalColorTexture0Texture1SkinTangent,'laya.d3.graphics.Vertex.VertexPositionNormalColorTexture0Texture1SkinTangent');
		var __proto=VertexPositionNormalColorTexture0Texture1SkinTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__proto.VertexPositionNormalColorTexture0SkinTangent=function(position,normal,color,textureCoordinate0,textureCoordinate1,tangent,blendIndex,blendWeight){
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1SkinTangent._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(1,VertexPositionNormalColorTexture0Texture1SkinTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1SkinTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTexture0Texture1SkinTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(100,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector2",2),
			new VertexElement(48,"vector2",15),
			new VertexElement(56,"vector4",7),
			new VertexElement(72,"vector4",6),
			new VertexElement(88,"vector3",5)]);}
		]);
		return VertexPositionNormalColorTexture0Texture1SkinTangent;
	})()


	/**
	*<code>VertexPositionNormalColorTextureTangent</code> 类用于创建位置、法线、颜色、纹理、切线顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorTexture0Texture1STangent
	var VertexPositionNormalColorTexture0Texture1STangent=(function(){
		function VertexPositionNormalColorTexture0Texture1STangent(position,normal,color,textureCoordinate0,textureCoordinate1,tangent){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalColorTexture0Texture1STangent,'laya.d3.graphics.Vertex.VertexPositionNormalColorTexture0Texture1STangent');
		var __proto=VertexPositionNormalColorTexture0Texture1STangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1STangent._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(1,VertexPositionNormalColorTexture0Texture1STangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1STangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTexture0Texture1STangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(72,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector2",2),
			new VertexElement(48,"vector2",15),
			new VertexElement(56,"vector4",5)]);}
		]);
		return VertexPositionNormalColorTexture0Texture1STangent;
	})()


	/**
	*<code>VertexPositionNormalColorTextureTangent</code> 类用于创建位置、法线、颜色、纹理、切线顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorTexture0Texture1Tangent
	var VertexPositionNormalColorTexture0Texture1Tangent=(function(){
		function VertexPositionNormalColorTexture0Texture1Tangent(){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._tangent=null;
		}

		__class(VertexPositionNormalColorTexture0Texture1Tangent,'laya.d3.graphics.Vertex.VertexPositionNormalColorTexture0Texture1Tangent');
		var __proto=VertexPositionNormalColorTexture0Texture1Tangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__proto.VertexPositionNormalColorTexture0Tangent=function(position,normal,color,textureCoordinate0,textureCoordinate1,tangent){
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._tangent=tangent;
		}

		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1Tangent._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(1,VertexPositionNormalColorTexture0Texture1Tangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1Tangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTexture0Texture1Tangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(68,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector2",2),
			new VertexElement(48,"vector2",15),
			new VertexElement(56,"vector3",5)]);}
		]);
		return VertexPositionNormalColorTexture0Texture1Tangent;
	})()


	/**
	*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorTextureSkin
	var VertexPositionNormalColorTextureSkin=(function(){
		function VertexPositionNormalColorTextureSkin(position,normal,color,textureCoordinate,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate=textureCoordinate;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorTextureSkin,'laya.d3.graphics.Vertex.VertexPositionNormalColorTextureSkin');
		var __proto=VertexPositionNormalColorTextureSkin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSkin._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTextureSkin,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSkin._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTextureSkin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(80,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector2",2),
			new VertexElement(48,"vector4",7),
			new VertexElement(64,"vector4",6)]);}
		]);
		return VertexPositionNormalColorTextureSkin;
	})()


	/**
	*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorTextureSkinSTangent
	var VertexPositionNormalColorTextureSkinSTangent=(function(){
		function VertexPositionNormalColorTextureSkinSTangent(position,normal,color,textureCoordinate,tangent,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorTextureSkinSTangent,'laya.d3.graphics.Vertex.VertexPositionNormalColorTextureSkinSTangent');
		var __proto=VertexPositionNormalColorTextureSkinSTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSkinSTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTextureSkinSTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSkinSTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTextureSkinSTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(96,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector2",2),
			new VertexElement(48,"vector4",7),
			new VertexElement(64,"vector4",6),
			new VertexElement(80,"vector4",5)]);}
		]);
		return VertexPositionNormalColorTextureSkinSTangent;
	})()


	/**
	*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorTextureSkinTangent
	var VertexPositionNormalColorTextureSkinTangent=(function(){
		function VertexPositionNormalColorTextureSkinTangent(position,normal,color,textureCoordinate,tangent,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorTextureSkinTangent,'laya.d3.graphics.Vertex.VertexPositionNormalColorTextureSkinTangent');
		var __proto=VertexPositionNormalColorTextureSkinTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSkinTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTextureSkinTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSkinTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTextureSkinTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(92,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector2",2),
			new VertexElement(48,"vector4",7),
			new VertexElement(64,"vector4",6),
			new VertexElement(80,"vector3",5)]);}
		]);
		return VertexPositionNormalColorTextureSkinTangent;
	})()


	/**
	*<code>VertexPositionNormalColorTextureTangent</code> 类用于创建位置、法线、颜色、纹理、切线顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorTextureSTangent
	var VertexPositionNormalColorTextureSTangent=(function(){
		function VertexPositionNormalColorTextureSTangent(position,normal,color,textureCoordinate,tangent){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalColorTextureSTangent,'laya.d3.graphics.Vertex.VertexPositionNormalColorTextureSTangent');
		var __proto=VertexPositionNormalColorTextureSTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTextureSTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTextureSTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(64,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector2",2),
			new VertexElement(48,"vector4",5)]);}
		]);
		return VertexPositionNormalColorTextureSTangent;
	})()


	/**
	*<code>VertexPositionNormalColorTextureTangent</code> 类用于创建位置、法线、颜色、纹理、切线顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalColorTextureTangent
	var VertexPositionNormalColorTextureTangent=(function(){
		function VertexPositionNormalColorTextureTangent(position,normal,color,textureCoordinate,tangent){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalColorTextureTangent,'laya.d3.graphics.Vertex.VertexPositionNormalColorTextureTangent');
		var __proto=VertexPositionNormalColorTextureTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTextureTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTextureTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(60,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",1),
			new VertexElement(40,"vector2",2),
			new VertexElement(48,"vector3",5)]);}
		]);
		return VertexPositionNormalColorTextureTangent;
	})()


	//class laya.d3.graphics.Vertex.VertexPositionNormalSTangent
	var VertexPositionNormalSTangent=(function(){
		function VertexPositionNormalSTangent(position,normal,tangent){
			this._position=null;
			this._normal=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalSTangent,'laya.d3.graphics.Vertex.VertexPositionNormalSTangent');
		var __proto=VertexPositionNormalSTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalSTangent._vertexDeclaration;
		});

		/*INTERFACE laya.d3.graphics.IVertex */
		__getset(1,VertexPositionNormalSTangent,'vertexDeclaration',function(){
			return VertexPositionNormalSTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalSTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(40,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector4",5)]);}
		]);
		return VertexPositionNormalSTangent;
	})()


	//class laya.d3.graphics.Vertex.VertexPositionNormalTangent
	var VertexPositionNormalTangent=(function(){
		function VertexPositionNormalTangent(position,normal,tangent){
			this._position=null;
			this._normal=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalTangent,'laya.d3.graphics.Vertex.VertexPositionNormalTangent');
		var __proto=VertexPositionNormalTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTangent._vertexDeclaration;
		});

		/*INTERFACE laya.d3.graphics.IVertex */
		__getset(1,VertexPositionNormalTangent,'vertexDeclaration',function(){
			return VertexPositionNormalTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(36,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector3",5)]);}
		]);
		return VertexPositionNormalTangent;
	})()


	/**
	*<code>VertexPositionNormalTexture</code> 类用于创建位置、法线、纹理顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalTexture
	var VertexPositionNormalTexture=(function(){
		function VertexPositionNormalTexture(position,normal,textureCoordinate){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
		}

		__class(VertexPositionNormalTexture,'laya.d3.graphics.Vertex.VertexPositionNormalTexture');
		var __proto=VertexPositionNormalTexture.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTexture._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTexture,'vertexDeclaration',function(){
			return VertexPositionNormalTexture._vertexDeclaration;
		});

		__static(VertexPositionNormalTexture,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(32,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector2",2)]);}
		]);
		return VertexPositionNormalTexture;
	})()


	/**
	*<code>VertexPositionNormalTexture</code> 类用于创建位置、法线、纹理顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalTexture0Texture1
	var VertexPositionNormalTexture0Texture1=(function(){
		function VertexPositionNormalTexture0Texture1(position,normal,textureCoordinate0,textureCoordinate1){
			this._position=null;
			this._normal=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
		}

		__class(VertexPositionNormalTexture0Texture1,'laya.d3.graphics.Vertex.VertexPositionNormalTexture0Texture1');
		var __proto=VertexPositionNormalTexture0Texture1.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(1,VertexPositionNormalTexture0Texture1,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1._vertexDeclaration;
		});

		__static(VertexPositionNormalTexture0Texture1,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(40,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector2",2),
			new VertexElement(32,"vector2",15)]);}
		]);
		return VertexPositionNormalTexture0Texture1;
	})()


	/**
	*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalTexture0Texture1Skin
	var VertexPositionNormalTexture0Texture1Skin=(function(){
		function VertexPositionNormalTexture0Texture1Skin(position,normal,textureCoordinate0,textureCoordinate1,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalTexture0Texture1Skin,'laya.d3.graphics.Vertex.VertexPositionNormalTexture0Texture1Skin');
		var __proto=VertexPositionNormalTexture0Texture1Skin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1Skin._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(1,VertexPositionNormalTexture0Texture1Skin,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1Skin._vertexDeclaration;
		});

		__static(VertexPositionNormalTexture0Texture1Skin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(72,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector2",2),
			new VertexElement(32,"vector2",15),
			new VertexElement(40,"vector4",7),
			new VertexElement(56,"vector4",6)]);}
		]);
		return VertexPositionNormalTexture0Texture1Skin;
	})()


	/**
	*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalTexture0Texture1SkinSTangent
	var VertexPositionNormalTexture0Texture1SkinSTangent=(function(){
		function VertexPositionNormalTexture0Texture1SkinSTangent(position,normal,textureCoordinate0,textureCoordinate1,tangent,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalTexture0Texture1SkinSTangent,'laya.d3.graphics.Vertex.VertexPositionNormalTexture0Texture1SkinSTangent');
		var __proto=VertexPositionNormalTexture0Texture1SkinSTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1SkinSTangent._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(1,VertexPositionNormalTexture0Texture1SkinSTangent,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1SkinSTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalTexture0Texture1SkinSTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(88,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector2",2),
			new VertexElement(32,"vector2",15),
			new VertexElement(40,"vector4",7),
			new VertexElement(56,"vector4",6),
			new VertexElement(72,"vector4",5)]);}
		]);
		return VertexPositionNormalTexture0Texture1SkinSTangent;
	})()


	/**
	*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalTexture0Texture1SkinTangent
	var VertexPositionNormalTexture0Texture1SkinTangent=(function(){
		function VertexPositionNormalTexture0Texture1SkinTangent(){
			this._position=null;
			this._normal=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
		}

		__class(VertexPositionNormalTexture0Texture1SkinTangent,'laya.d3.graphics.Vertex.VertexPositionNormalTexture0Texture1SkinTangent');
		var __proto=VertexPositionNormalTexture0Texture1SkinTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__proto.VertexPositionNormalTexture0SkinTangent=function(position,normal,textureCoordinate0,textureCoordinate1,tangent,blendIndex,blendWeight){
			this._position=position;
			this._normal=normal;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1SkinTangent._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(1,VertexPositionNormalTexture0Texture1SkinTangent,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1SkinTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalTexture0Texture1SkinTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(84,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector2",2),
			new VertexElement(32,"vector2",15),
			new VertexElement(40,"vector4",7),
			new VertexElement(56,"vector4",6),
			new VertexElement(72,"vector3",5)]);}
		]);
		return VertexPositionNormalTexture0Texture1SkinTangent;
	})()


	/**
	*<code>VertexPositionNormalTextureTangent</code> 类用于创建位置、法线、纹理、切线顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalTexture0Texture1STangent
	var VertexPositionNormalTexture0Texture1STangent=(function(){
		function VertexPositionNormalTexture0Texture1STangent(position,normal,textureCoordinate0,textureCoordinate1,tangent){
			this._position=null;
			this._normal=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalTexture0Texture1STangent,'laya.d3.graphics.Vertex.VertexPositionNormalTexture0Texture1STangent');
		var __proto=VertexPositionNormalTexture0Texture1STangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1STangent._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(1,VertexPositionNormalTexture0Texture1STangent,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1STangent._vertexDeclaration;
		});

		__static(VertexPositionNormalTexture0Texture1STangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(56,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector2",2),
			new VertexElement(32,"vector2",15),
			new VertexElement(40,"vector4",5)]);}
		]);
		return VertexPositionNormalTexture0Texture1STangent;
	})()


	/**
	*<code>VertexPositionNormalTextureTangent</code> 类用于创建位置、法线、纹理、切线顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalTexture0Texture1Tangent
	var VertexPositionNormalTexture0Texture1Tangent=(function(){
		function VertexPositionNormalTexture0Texture1Tangent(){
			this._position=null;
			this._normal=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._tangent=null;
		}

		__class(VertexPositionNormalTexture0Texture1Tangent,'laya.d3.graphics.Vertex.VertexPositionNormalTexture0Texture1Tangent');
		var __proto=VertexPositionNormalTexture0Texture1Tangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__proto.VertexPositionNormalTexture0Tangent=function(position,normal,textureCoordinate0,textureCoordinate1,tangent){
			this._position=position;
			this._normal=normal;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._tangent=tangent;
		}

		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1Tangent._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(1,VertexPositionNormalTexture0Texture1Tangent,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1Tangent._vertexDeclaration;
		});

		__static(VertexPositionNormalTexture0Texture1Tangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(52,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector2",2),
			new VertexElement(32,"vector2",15),
			new VertexElement(40,"vector3",5)]);}
		]);
		return VertexPositionNormalTexture0Texture1Tangent;
	})()


	/**
	*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalTextureSkin
	var VertexPositionNormalTextureSkin=(function(){
		function VertexPositionNormalTextureSkin(position,normal,textureCoordinate,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalTextureSkin,'laya.d3.graphics.Vertex.VertexPositionNormalTextureSkin');
		var __proto=VertexPositionNormalTextureSkin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSkin._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTextureSkin,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSkin._vertexDeclaration;
		});

		__static(VertexPositionNormalTextureSkin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(64,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector2",2),
			new VertexElement(32,"vector4",7),
			new VertexElement(48,"vector4",6)]);}
		]);
		return VertexPositionNormalTextureSkin;
	})()


	/**
	*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalTextureSkinSTangent
	var VertexPositionNormalTextureSkinSTangent=(function(){
		function VertexPositionNormalTextureSkinSTangent(position,normal,textureCoordinate,tangent,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalTextureSkinSTangent,'laya.d3.graphics.Vertex.VertexPositionNormalTextureSkinSTangent');
		var __proto=VertexPositionNormalTextureSkinSTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSkinSTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTextureSkinSTangent,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSkinSTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalTextureSkinSTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(80,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector2",2),
			new VertexElement(32,"vector4",7),
			new VertexElement(48,"vector4",6),
			new VertexElement(64,"vector4",5)]);}
		]);
		return VertexPositionNormalTextureSkinSTangent;
	})()


	/**
	*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalTextureSkinTangent
	var VertexPositionNormalTextureSkinTangent=(function(){
		function VertexPositionNormalTextureSkinTangent(position,normal,textureCoordinate,tangent,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalTextureSkinTangent,'laya.d3.graphics.Vertex.VertexPositionNormalTextureSkinTangent');
		var __proto=VertexPositionNormalTextureSkinTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSkinTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTextureSkinTangent,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSkinTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalTextureSkinTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(76,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector2",2),
			new VertexElement(32,"vector4",7),
			new VertexElement(48,"vector4",6),
			new VertexElement(64,"vector3",5)]);}
		]);
		return VertexPositionNormalTextureSkinTangent;
	})()


	/**
	*<code>VertexPositionNormalTextureTangent</code> 类用于创建位置、法线、纹理、切线顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalTextureSTangent
	var VertexPositionNormalTextureSTangent=(function(){
		function VertexPositionNormalTextureSTangent(position,normal,textureCoordinate,tangent){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalTextureSTangent,'laya.d3.graphics.Vertex.VertexPositionNormalTextureSTangent');
		var __proto=VertexPositionNormalTextureSTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTextureSTangent,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalTextureSTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(48,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector2",2),
			new VertexElement(32,"vector4",5)]);}
		]);
		return VertexPositionNormalTextureSTangent;
	})()


	/**
	*<code>VertexPositionNormalTextureTangent</code> 类用于创建位置、法线、纹理、切线顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNormalTextureTangent
	var VertexPositionNormalTextureTangent=(function(){
		function VertexPositionNormalTextureTangent(position,normal,textureCoordinate,tangent){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalTextureTangent,'laya.d3.graphics.Vertex.VertexPositionNormalTextureTangent');
		var __proto=VertexPositionNormalTextureTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTextureTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTextureTangent,'vertexDeclaration',function(){
			return VertexPositionNormalTextureTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalTextureTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(44,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector2",2),
			new VertexElement(32,"vector3",5)]);}
		]);
		return VertexPositionNormalTextureTangent;
	})()


	/**
	*<code>VertexPositionNormalTexture</code> 类用于创建位置、法线、纹理顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNTBTexture
	var VertexPositionNTBTexture=(function(){
		function VertexPositionNTBTexture(position,normal,textureCoordinate){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
		}

		__class(VertexPositionNTBTexture,'laya.d3.graphics.Vertex.VertexPositionNTBTexture');
		var __proto=VertexPositionNTBTexture.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNTBTexture._vertexDeclaration;
		});

		__getset(1,VertexPositionNTBTexture,'vertexDeclaration',function(){
			return VertexPositionNTBTexture._vertexDeclaration;
		});

		__static(VertexPositionNTBTexture,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(56,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector3",5),
			new VertexElement(36,"vector3",4),
			new VertexElement(48,"vector2",2)]);}
		]);
		return VertexPositionNTBTexture;
	})()


	/**
	*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionNTBTexture0Texture1Skin
	var VertexPositionNTBTexture0Texture1Skin=(function(){
		function VertexPositionNTBTexture0Texture1Skin(position,normal,binormal,textureCoordinate0,textureCoordinate1,tangent,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
			this.binormal=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._tangent=tangent;
			binormal=binormal;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNTBTexture0Texture1Skin,'laya.d3.graphics.Vertex.VertexPositionNTBTexture0Texture1Skin');
		var __proto=VertexPositionNTBTexture0Texture1Skin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNTBTexture0Texture1Skin._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(1,VertexPositionNTBTexture0Texture1Skin,'vertexDeclaration',function(){
			return VertexPositionNTBTexture0Texture1Skin._vertexDeclaration;
		});

		__static(VertexPositionNTBTexture0Texture1Skin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(96,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector3",5),
			new VertexElement(36,"vector3",4),
			new VertexElement(48,"vector2",2),
			new VertexElement(56,"vector2",15),
			new VertexElement(64,"vector4",7),
			new VertexElement(80,"vector4",6)]);}
		]);
		return VertexPositionNTBTexture0Texture1Skin;
	})()


	/**
	*<code>VertexPositionTerrain</code> 类用于创建位置、法线、纹理1、纹理2顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionTerrain
	var VertexPositionTerrain=(function(){
		function VertexPositionTerrain(position,normal,textureCoord0,textureCoord1){
			this._position=null;
			this._normal=null;
			this._textureCoord0=null;
			this._textureCoord1=null;
			this._position=position;
			this._normal=normal;
			this._textureCoord0=textureCoord0;
			this._textureCoord1=textureCoord1;
		}

		__class(VertexPositionTerrain,'laya.d3.graphics.Vertex.VertexPositionTerrain');
		var __proto=VertexPositionTerrain.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'textureCoord0',function(){
			return this._textureCoord0;
		});

		__getset(0,__proto,'textureCoord1',function(){
			return this._textureCoord1;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionTerrain._vertexDeclaration;
		});

		__getset(1,VertexPositionTerrain,'vertexDeclaration',function(){
			return VertexPositionTerrain._vertexDeclaration;
		});

		__static(VertexPositionTerrain,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(40,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector3",3),
			new VertexElement(24,"vector2",2),
			new VertexElement(32,"vector2",15)]);}
		]);
		return VertexPositionTerrain;
	})()


	/**
	*<code>VertexPositionNormalTexture</code> 类用于创建位置、纹理顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexPositionTexture0
	var VertexPositionTexture0=(function(){
		function VertexPositionTexture0(position,textureCoordinate0){
			this._position=null;
			this._textureCoordinate0=null;
			this._position=position;
			this._textureCoordinate0=textureCoordinate0;
		}

		__class(VertexPositionTexture0,'laya.d3.graphics.Vertex.VertexPositionTexture0');
		var __proto=VertexPositionTexture0.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionTexture0._vertexDeclaration;
		});

		__getset(1,VertexPositionTexture0,'vertexDeclaration',function(){
			return VertexPositionTexture0._vertexDeclaration;
		});

		__static(VertexPositionTexture0,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(20,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector2",2)]);}
		]);
		return VertexPositionTexture0;
	})()


	/**
	*<code>VertexShurikenParticle</code> 类用于创建粒子顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexShurikenParticleBillboard
	var VertexShurikenParticleBillboard=(function(){
		function VertexShurikenParticleBillboard(cornerTextureCoordinate,positionStartLifeTime,velocity,startColor,startSize,startRotation0,startRotation1,startRotation2,ageAddScale,time,startSpeed,randoms0,randoms1,simulationWorldPostion){
			this._cornerTextureCoordinate=null;
			this._positionStartLifeTime=null;
			this._velocity=null;
			this._startColor=null;
			this._startSize=null;
			this._startRotation0=null;
			this._startRotation1=null;
			this._startRotation2=null;
			this._startLifeTime=NaN;
			this._time=NaN;
			this._startSpeed=NaN;
			this._randoms0=null;
			this._randoms1=null;
			this._simulationWorldPostion=null;
			this._cornerTextureCoordinate=cornerTextureCoordinate;
			this._positionStartLifeTime=positionStartLifeTime;
			this._velocity=velocity;
			this._startColor=startColor;
			this._startSize=startSize;
			this._startRotation0=startRotation0;
			this._startRotation1=startRotation1;
			this._startRotation2=startRotation2;
			this._startLifeTime=ageAddScale;
			this._time=time;
			this._startSpeed=startSpeed;
			this._randoms0=this.random0;
			this._randoms1=this.random1;
			this._simulationWorldPostion=simulationWorldPostion;
		}

		__class(VertexShurikenParticleBillboard,'laya.d3.graphics.Vertex.VertexShurikenParticleBillboard');
		var __proto=VertexShurikenParticleBillboard.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'cornerTextureCoordinate',function(){
			return this._cornerTextureCoordinate;
		});

		__getset(0,__proto,'random1',function(){
			return this._randoms1;
		});

		__getset(0,__proto,'startRotation2',function(){
			return this._startRotation2;
		});

		__getset(0,__proto,'positionStartLifeTime',function(){
			return this._positionStartLifeTime;
		});

		__getset(0,__proto,'velocity',function(){
			return this._velocity;
		});

		__getset(0,__proto,'random0',function(){
			return this._randoms0;
		});

		__getset(0,__proto,'startSize',function(){
			return this._startSize;
		});

		__getset(0,__proto,'startColor',function(){
			return this._startColor;
		});

		__getset(0,__proto,'startRotation0',function(){
			return this._startRotation0;
		});

		__getset(0,__proto,'startRotation1',function(){
			return this._startRotation1;
		});

		__getset(0,__proto,'startLifeTime',function(){
			return this._startLifeTime;
		});

		__getset(0,__proto,'time',function(){
			return this._time;
		});

		__getset(0,__proto,'startSpeed',function(){
			return this._startSpeed;
		});

		__getset(0,__proto,'simulationWorldPostion',function(){
			return this._simulationWorldPostion;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexShurikenParticleBillboard._vertexDeclaration;
		});

		__getset(1,VertexShurikenParticleBillboard,'vertexDeclaration',function(){
			return VertexShurikenParticleBillboard._vertexDeclaration;
		});

		__static(VertexShurikenParticleBillboard,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(152,[
			new VertexElement(0,"vector4",17),
			new VertexElement(16,"vector4",30),
			new VertexElement(32,"vector4",32),
			new VertexElement(48,"vector4",19),
			new VertexElement(64,"vector3",20),
			new VertexElement(76,"vector3",22),
			new VertexElement(88,"single",31),
			new VertexElement(92,"vector4",34),
			new VertexElement(108,"vector4",35),
			new VertexElement(124,"vector3",36),
			new VertexElement(136,"vector4",37)]);}
		]);
		return VertexShurikenParticleBillboard;
	})()


	/**
	*<code>VertexShurikenParticle</code> 类用于创建粒子顶点结构。
	*/
	//class laya.d3.graphics.Vertex.VertexShurikenParticleMesh
	var VertexShurikenParticleMesh=(function(){
		function VertexShurikenParticleMesh(cornerTextureCoordinate,positionStartLifeTime,velocity,startColor,startSize,startRotation0,startRotation1,startRotation2,ageAddScale,time,startSpeed,randoms0,randoms1,simulationWorldPostion){
			this._cornerTextureCoordinate=null;
			this._positionStartLifeTime=null;
			this._velocity=null;
			this._startColor=null;
			this._startSize=null;
			this._startRotation0=null;
			this._startRotation1=null;
			this._startRotation2=null;
			this._startLifeTime=NaN;
			this._time=NaN;
			this._startSpeed=NaN;
			this._randoms0=null;
			this._randoms1=null;
			this._simulationWorldPostion=null;
			this._cornerTextureCoordinate=cornerTextureCoordinate;
			this._positionStartLifeTime=positionStartLifeTime;
			this._velocity=velocity;
			this._startColor=startColor;
			this._startSize=startSize;
			this._startRotation0=startRotation0;
			this._startRotation1=startRotation1;
			this._startRotation2=startRotation2;
			this._startLifeTime=ageAddScale;
			this._time=time;
			this._startSpeed=startSpeed;
			this._randoms0=this.random0;
			this._randoms1=this.random1;
			this._simulationWorldPostion=simulationWorldPostion;
		}

		__class(VertexShurikenParticleMesh,'laya.d3.graphics.Vertex.VertexShurikenParticleMesh');
		var __proto=VertexShurikenParticleMesh.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'cornerTextureCoordinate',function(){
			return this._cornerTextureCoordinate;
		});

		__getset(0,__proto,'velocity',function(){
			return this._velocity;
		});

		__getset(0,__proto,'position',function(){
			return this._positionStartLifeTime;
		});

		__getset(0,__proto,'random0',function(){
			return this._randoms0;
		});

		__getset(0,__proto,'startSize',function(){
			return this._startSize;
		});

		__getset(0,__proto,'startColor',function(){
			return this._startColor;
		});

		__getset(0,__proto,'startRotation0',function(){
			return this._startRotation0;
		});

		__getset(0,__proto,'startRotation1',function(){
			return this._startRotation1;
		});

		__getset(0,__proto,'random1',function(){
			return this._randoms1;
		});

		__getset(0,__proto,'startRotation2',function(){
			return this._startRotation2;
		});

		__getset(0,__proto,'startLifeTime',function(){
			return this._startLifeTime;
		});

		__getset(0,__proto,'time',function(){
			return this._time;
		});

		__getset(0,__proto,'startSpeed',function(){
			return this._startSpeed;
		});

		__getset(0,__proto,'simulationWorldPostion',function(){
			return this._simulationWorldPostion;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexShurikenParticleMesh._vertexDeclaration;
		});

		__getset(1,VertexShurikenParticleMesh,'vertexDeclaration',function(){
			return VertexShurikenParticleMesh._vertexDeclaration;
		});

		__static(VertexShurikenParticleMesh,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(172,[
			new VertexElement(0,"vector3",0),
			new VertexElement(12,"vector4",1),
			new VertexElement(28,"vector2",2),
			new VertexElement(36,"vector4",30),
			new VertexElement(52,"vector4",32),
			new VertexElement(68,"vector4",19),
			new VertexElement(84,"vector3",20),
			new VertexElement(96,"vector3",22),
			new VertexElement(108,"single",31),
			new VertexElement(112,"vector4",34),
			new VertexElement(128,"vector4",35),
			new VertexElement(144,"vector3",36),
			new VertexElement(156,"vector4",37)]);}
		]);
		return VertexShurikenParticleMesh;
	})()


	/**
	*@private
	*<code>VertexDeclaration</code> 类用于生成顶点声明。
	*/
	//class laya.d3.graphics.VertexDeclaration
	var VertexDeclaration=(function(){
		function VertexDeclaration(vertexStride,vertexElements){
			this._id=0;
			this._vertexStride=0;
			this._vertexElementsDic=null;
			this._shaderValues=null;
			this._defineDatas=null;
			this.vertexElements=null;
			this._id=++VertexDeclaration._uniqueIDCounter;
			this._defineDatas=new DefineDatas();
			this._vertexElementsDic={};
			this._vertexStride=vertexStride;
			this.vertexElements=vertexElements;
			var count=vertexElements.length;
			var maxLength=0;
			for (var i=0;i < count;i++)
			maxLength=Math.max(maxLength,vertexElements[i].elementUsage);
			this._shaderValues=new ShaderDatas(null,maxLength+1);
			for (var j=0;j < count;j++){
				var vertexElement=vertexElements[j];
				var name=vertexElement.elementUsage;
				this._vertexElementsDic[name]=vertexElement;
				var value=new Int32Array(5);
				value[0]=VertexDeclaration._getTypeSize(vertexElement.elementFormat)/ 4;
				value[1]=0x1406;
				value[2]=0;
				value[3]=this._vertexStride;
				value[4]=vertexElement.offset;
				this._shaderValues.setAttribute(name,value);
				switch (name){
					case 1:
						this._defineDatas.add(VertexDeclaration.SHADERDEFINE_COLOR);
						break
					case 2:
						this._defineDatas.add(VertexDeclaration.SHADERDEFINE_UV0);
						break ;
					case 15:
						this._defineDatas.add(VertexDeclaration.SHADERDEFINE_UV1);
						break ;
					}
			}
		}

		__class(VertexDeclaration,'laya.d3.graphics.VertexDeclaration');
		var __proto=VertexDeclaration.prototype;
		/**
		*@private
		*/
		__proto.getVertexElementByUsage=function(usage){
			return this._vertexElementsDic[usage];
		}

		/**
		*@private
		*/
		__proto.unBinding=function(){}
		/**
		*获取唯一标识ID(通常用于优化或识别)。
		*@return 唯一标识ID
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		/**
		*@private
		*/
		__getset(0,__proto,'vertexStride',function(){
			return this._vertexStride;
		});

		VertexDeclaration._getTypeSize=function(format){
			switch (format){
				case "single":
					return 4;
				case "vector2":
					return 8;
				case "vector3":
					return 12;
				case "vector4":
					return 16;
				case "color":
					return 4;
				case "byte4":
					return 4;
				case "short2":
					return 4;
				case "short4":
					return 8;
				case "normalizedshort2":
					return 4;
				case "normalizedshort4":
					return 8;
				case "halfvector2":
					return 4;
				case "halfvector4":
					return 8;
				}
			return 0;
		}

		VertexDeclaration.SHADERDEFINE_UV0=0;
		VertexDeclaration.SHADERDEFINE_COLOR=0;
		VertexDeclaration.SHADERDEFINE_UV1=0;
		VertexDeclaration._uniqueIDCounter=1;
		return VertexDeclaration;
	})()


	/**
	*<code>VertexElement</code> 类用于创建顶点结构分配。
	*/
	//class laya.d3.graphics.VertexElement
	var VertexElement=(function(){
		function VertexElement(offset,elementFormat,elementUsage){
			this.offset=0;
			this.elementFormat=null;
			this.elementUsage=0;
			this.offset=offset;
			this.elementFormat=elementFormat;
			this.elementUsage=elementUsage;
		}

		__class(VertexElement,'laya.d3.graphics.VertexElement');
		return VertexElement;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.graphics.VertexElementFormat
	var VertexElementFormat=(function(){
		function VertexElementFormat(){};
		__class(VertexElementFormat,'laya.d3.graphics.VertexElementFormat');
		VertexElementFormat.Single="single";
		VertexElementFormat.Vector2="vector2";
		VertexElementFormat.Vector3="vector3";
		VertexElementFormat.Vector4="vector4";
		VertexElementFormat.Color="color";
		VertexElementFormat.Byte4="byte4";
		VertexElementFormat.Short2="short2";
		VertexElementFormat.Short4="short4";
		VertexElementFormat.NormalizedShort2="normalizedshort2";
		VertexElementFormat.NormalizedShort4="normalizedshort4";
		VertexElementFormat.HalfVector2="halfvector2";
		VertexElementFormat.HalfVector4="halfvector4";
		return VertexElementFormat;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.graphics.VertexElementUsage
	var VertexElementUsage=(function(){
		function VertexElementUsage(){};
		__class(VertexElementUsage,'laya.d3.graphics.VertexElementUsage');
		VertexElementUsage.POSITION0=0;
		VertexElementUsage.COLOR0=1;
		VertexElementUsage.TEXTURECOORDINATE0=2;
		VertexElementUsage.NORMAL0=3;
		VertexElementUsage.BINORMAL0=4;
		VertexElementUsage.TANGENT0=5;
		VertexElementUsage.BLENDINDICES0=6;
		VertexElementUsage.BLENDWEIGHT0=7;
		VertexElementUsage.DEPTH0=8;
		VertexElementUsage.FOG0=9;
		VertexElementUsage.POINTSIZE0=10;
		VertexElementUsage.SAMPLE0=11;
		VertexElementUsage.TESSELLATEFACTOR0=12;
		VertexElementUsage.COLOR1=13;
		VertexElementUsage.NEXTTEXTURECOORDINATE0=14;
		VertexElementUsage.TEXTURECOORDINATE1=15;
		VertexElementUsage.NEXTTEXTURECOORDINATE1=16;
		VertexElementUsage.CORNERTEXTURECOORDINATE0=17;
		VertexElementUsage.VELOCITY0=18;
		VertexElementUsage.STARTCOLOR0=19;
		VertexElementUsage.STARTSIZE=20;
		VertexElementUsage.AGEADDSCALE0=21;
		VertexElementUsage.STARTROTATION=22;
		VertexElementUsage.ENDCOLOR0=23;
		VertexElementUsage.STARTLIFETIME=24;
		VertexElementUsage.TIME0=33;
		VertexElementUsage.SHAPEPOSITIONSTARTLIFETIME=30;
		VertexElementUsage.DIRECTIONTIME=32;
		VertexElementUsage.SIZEROTATION0=27;
		VertexElementUsage.RADIUS0=28;
		VertexElementUsage.RADIAN0=29;
		VertexElementUsage.STARTSPEED=31;
		VertexElementUsage.RANDOM0=34;
		VertexElementUsage.RANDOM1=35;
		VertexElementUsage.SIMULATIONWORLDPOSTION=36;
		VertexElementUsage.SIMULATIONWORLDROTATION=37;
		return VertexElementUsage;
	})()


	/**
	*@private
	*<code>LoadModel</code> 类用于模型加载。
	*/
	//class laya.d3.loaders.LoadModelV03
	var LoadModelV03=(function(){
		function LoadModelV03(){};
		__class(LoadModelV03,'laya.d3.loaders.LoadModelV03');
		LoadModelV03.parse=function(readData,version,mesh,subMeshes,materialMap){
			LoadModelV03._mesh=mesh;
			LoadModelV03._subMeshes=subMeshes;
			LoadModelV03._materialMap=materialMap;
			LoadModelV03._version=version;
			LoadModelV03._readData=readData;
			LoadModelV03.READ_DATA();
			LoadModelV03.READ_BLOCK();
			LoadModelV03.READ_STRINGS();
			for (var i=0,n=LoadModelV03._BLOCK.count;i < n;i++){
				LoadModelV03._readData.pos=LoadModelV03._BLOCK.blockStarts[i];
				var index=LoadModelV03._readData.getUint16();
				var blockName=LoadModelV03._strings[index];
				var fn=LoadModelV03["READ_"+blockName];
				if (fn==null)
					throw new Error("model file err,no this function:"+index+" "+blockName);
				else
				fn.call();
			}
			LoadModelV03._mesh._bindPoseIndices=new Uint16Array(LoadModelV03._bindPoseIndices);
			LoadModelV03._bindPoseIndices.length=0;
			LoadModelV03._strings.length=0;
			LoadModelV03._readData=null;
			LoadModelV03._version=null;
			LoadModelV03._mesh=null;
			LoadModelV03._subMeshes=null;
			LoadModelV03._materialMap=null;
		}

		LoadModelV03._readString=function(){
			return LoadModelV03._strings[LoadModelV03._readData.getUint16()];
		}

		LoadModelV03.READ_DATA=function(){
			LoadModelV03._DATA.offset=LoadModelV03._readData.getUint32();
			LoadModelV03._DATA.size=LoadModelV03._readData.getUint32();
		}

		LoadModelV03.READ_BLOCK=function(){
			var count=LoadModelV03._BLOCK.count=LoadModelV03._readData.getUint16();
			var blockStarts=LoadModelV03._BLOCK.blockStarts=[];
			var blockLengths=LoadModelV03._BLOCK.blockLengths=[];
			for (var i=0;i < count;i++){
				blockStarts.push(LoadModelV03._readData.getUint32());
				blockLengths.push(LoadModelV03._readData.getUint32());
			}
		}

		LoadModelV03.READ_STRINGS=function(){
			var offset=LoadModelV03._readData.getUint32();
			var count=LoadModelV03._readData.getUint16();
			var prePos=LoadModelV03._readData.pos;
			LoadModelV03._readData.pos=offset+LoadModelV03._DATA.offset;
			for (var i=0;i < count;i++)
			LoadModelV03._strings[i]=LoadModelV03._readData.readUTFString();
			LoadModelV03._readData.pos=prePos;
		}

		LoadModelV03.READ_MESH=function(){
			var name=LoadModelV03._readString();
			var arrayBuffer=LoadModelV03._readData.__getBuffer();
			var i=0,n=0;
			var vertexBufferCount=LoadModelV03._readData.getInt16();
			var offset=LoadModelV03._DATA.offset;
			for (i=0;i < vertexBufferCount;i++){
				var vbStart=offset+LoadModelV03._readData.getUint32();
				var vbLength=LoadModelV03._readData.getUint32();
				var vbDatas=new Float32Array(arrayBuffer.slice(vbStart,vbStart+vbLength));
				var bufferAttribute=LoadModelV03._readString();
				var vertexDeclaration;
				switch (LoadModelV03._version){
					case "LAYAMODEL:03":
						vertexDeclaration=LoadModelV03._vertexDeclarationMap_Discard[bufferAttribute];
						break ;
					case "LAYAMODEL:0301":
						vertexDeclaration=LoadModelV03._vertexDeclarationMap[bufferAttribute];
						break ;
					default :
						throw new Error("LoadModelV03: unknown version.");
					}
				if (!vertexDeclaration)
					throw new Error("LoadModelV03: unknown vertexDeclaration.");
				var vertexBuffer=new VertexBuffer3D(vbDatas.length *4,0x88E4,true);
				vertexBuffer.vertexDeclaration=vertexDeclaration;
				vertexBuffer.setData(vbDatas);
				LoadModelV03._mesh._vertexBuffers.push(vertexBuffer);
			};
			var ibStart=offset+LoadModelV03._readData.getUint32();
			var ibLength=LoadModelV03._readData.getUint32();
			var ibDatas=new Uint16Array(arrayBuffer.slice(ibStart,ibStart+ibLength));
			var indexBuffer=IndexBuffer3D.create("ushort",ibLength / 2,0x88E4,true);
			indexBuffer.setData(ibDatas);
			LoadModelV03._mesh._indexBuffer=indexBuffer;
			var boneNames=LoadModelV03._mesh._boneNames=[];
			var boneCount=LoadModelV03._readData.getUint16();
			boneNames.length=boneCount;
			for (i=0;i < boneCount;i++)
			boneNames[i]=LoadModelV03._strings[LoadModelV03._readData.getUint16()];
			LoadModelV03._readData.pos+=8;
			var bindPoseDataStart=LoadModelV03._readData.getUint32();
			var bindPoseDataLength=LoadModelV03._readData.getUint32();
			var bindPoseDatas=new Float32Array(arrayBuffer.slice(offset+bindPoseDataStart,offset+bindPoseDataStart+bindPoseDataLength));
			var bindPoseFloatCount=bindPoseDatas.length;
			var bindPoseCount=bindPoseFloatCount / 16;
			var bindPoseBuffer=LoadModelV03._mesh._inverseBindPosesBuffer=new ArrayBuffer(bindPoseFloatCount *4);
			LoadModelV03._mesh._inverseBindPoses=__newvec(bindPoseCount);
			for (i=0;i < bindPoseFloatCount;i+=16){
				var inverseGlobalBindPose=new Matrix4x4(bindPoseDatas[i+0],bindPoseDatas[i+1],bindPoseDatas[i+2],bindPoseDatas[i+3],bindPoseDatas[i+4],bindPoseDatas[i+5],bindPoseDatas[i+6],bindPoseDatas[i+7],bindPoseDatas[i+8],bindPoseDatas[i+9],bindPoseDatas[i+10],bindPoseDatas[i+11],bindPoseDatas[i+12],bindPoseDatas[i+13],bindPoseDatas[i+14],bindPoseDatas[i+15],new Float32Array(bindPoseBuffer,i *4,16));
				LoadModelV03._mesh._inverseBindPoses[i / 16]=inverseGlobalBindPose;
			}
			return true;
		}

		LoadModelV03.READ_SUBMESH=function(){
			var arrayBuffer=LoadModelV03._readData.__getBuffer();
			var submesh=new SubMesh(LoadModelV03._mesh);
			var vbIndex=LoadModelV03._readData.getInt16();
			var vbStart=LoadModelV03._readData.getUint32();
			var vbLength=LoadModelV03._readData.getUint32();
			submesh._setVertexBuffer(LoadModelV03._mesh._vertexBuffers[vbIndex]);
			submesh._vertexStart=vbStart;
			submesh._vertexCount=vbLength;
			var ibStart=LoadModelV03._readData.getUint32();
			var ibCount=LoadModelV03._readData.getUint32();
			var indexBuffer=LoadModelV03._mesh._indexBuffer;
			submesh._indexBuffer=indexBuffer;
			submesh._indexStart=ibStart;
			submesh._indexCount=ibCount;
			submesh._indices=new Uint16Array(indexBuffer.getData().buffer,ibStart *2,ibCount);
			var offset=LoadModelV03._DATA.offset;
			var subIndexBufferStart=submesh._subIndexBufferStart;
			var subIndexBufferCount=submesh._subIndexBufferCount;
			var boneIndicesList=submesh._boneIndicesList;
			var drawCount=LoadModelV03._readData.getUint16();
			subIndexBufferStart.length=drawCount;
			subIndexBufferCount.length=drawCount;
			boneIndicesList.length=drawCount;
			var pathMarks=LoadModelV03._mesh._skinDataPathMarks;
			var bindPoseIndices=LoadModelV03._bindPoseIndices;
			var subMeshIndex=LoadModelV03._subMeshes.length;
			for (var i=0;i < drawCount;i++){
				subIndexBufferStart[i]=LoadModelV03._readData.getUint32();
				subIndexBufferCount[i]=LoadModelV03._readData.getUint32();
				var boneDicofs=LoadModelV03._readData.getUint32();
				var boneDicsize=LoadModelV03._readData.getUint32();
				var boneIndices=boneIndicesList[i]=new Uint8Array(arrayBuffer.slice(offset+boneDicofs,offset+boneDicofs+boneDicsize));
				for (var j=0,m=boneIndices.length;j < m;j++){
					var index=boneIndices[j];
					var combineIndex=bindPoseIndices.indexOf(index);
					if (combineIndex===-1){
						boneIndices[j]=bindPoseIndices.length;
						bindPoseIndices.push(index);
						pathMarks.push([subMeshIndex,i,j]);
						}else {
						boneIndices[j]=combineIndex;
					}
				}
			}
			LoadModelV03._subMeshes.push(submesh);
			return true;
		}

		LoadModelV03._strings=[];
		LoadModelV03._readData=null
		LoadModelV03._version=null
		LoadModelV03._mesh=null
		LoadModelV03._subMeshes=null
		LoadModelV03._materialMap=null
		LoadModelV03._bindPoseIndices=[];
		__static(LoadModelV03,
		['_vertexDeclarationMap_Discard',function(){return this._vertexDeclarationMap_Discard={
				"POSITION,NORMAL,COLOR,UV,UV1,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalColorTexture0Texture1SkinTangent.vertexDeclaration,
				"POSITION,NORMAL,COLOR,UV,UV1,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalColorTexture0Texture1Skin.vertexDeclaration,
				"POSITION,NORMAL,TANGENT,BINORMAL,UV,UV1,BLENDWEIGHT,BLENDINDICES,":VertexPositionNTBTexture0Texture1Skin.vertexDeclaration,
				"POSITION,NORMAL,UV,UV1,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalTexture0Texture1SkinTangent.vertexDeclaration,
				"POSITION,NORMAL,UV,UV1,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalTexture0Texture1Skin.vertexDeclaration,
				"POSITION,NORMAL,COLOR,UV,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalColorTextureSkinTangent.vertexDeclaration,
				"POSITION,NORMAL,COLOR,UV,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalColorTextureSkin.vertexDeclaration,
				"POSITION,NORMAL,UV,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalTextureSkinTangent.vertexDeclaration,
				"POSITION,NORMAL,UV,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalTextureSkin.vertexDeclaration,
				"POSITION,NORMAL,COLOR,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalColorSkinTangent.vertexDeclaration,
				"POSITION,NORMAL,COLOR,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalColorSkin.vertexDeclaration,
				"POSITION,NORMAL,COLOR,UV,UV1,TANGENT":VertexPositionNormalColorTexture0Texture1Tangent.vertexDeclaration,
				"POSITION,NORMAL,COLOR,UV,UV1":VertexPositionNormalColorTexture0Texture1.vertexDeclaration,
				"POSITION,NORMAL,UV,UV1,TANGENT":VertexPositionNormalTexture0Texture1Tangent.vertexDeclaration,
				"POSITION,NORMAL,UV,UV1":VertexPositionNormalTexture0Texture1.vertexDeclaration,
				"POSITION,NORMAL,COLOR,UV,TANGENT":VertexPositionNormalColorTextureTangent.vertexDeclaration,
				"POSITION,NORMAL,UV,TANGENT,BINORMAL":VertexPositionNTBTexture.vertexDeclaration,
				"POSITION,NORMAL,COLOR,UV":VertexPositionNormalColorTexture.vertexDeclaration,
				"POSITION,NORMAL,UV,TANGENT":VertexPositionNormalTextureTangent.vertexDeclaration,
				"POSITION,NORMAL,UV":VertexPositionNormalTexture.vertexDeclaration,
				"POSITION,NORMAL,COLOR,TANGENT":VertexPositionNormalColorTangent.vertexDeclaration,
				"POSITION,NORMAL,COLOR":VertexPositionNormalColor.vertexDeclaration,
				"POSITION,NORMAL,TANGENT":VertexPositionNormalTangent.vertexDeclaration,
				"POSITION,NORMAL":VertexPositionNormal.vertexDeclaration,
				"POSITION,UV":VertexPositionTexture0.vertexDeclaration,
				"POSITION":VertexPosition.vertexDeclaration};},'_vertexDeclarationMap',function(){return this._vertexDeclarationMap={
				"POSITION,NORMAL,COLOR,UV,UV1,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalColorTexture0Texture1SkinSTangent.vertexDeclaration,
				"POSITION,NORMAL,COLOR,UV,UV1,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalColorTexture0Texture1Skin.vertexDeclaration,
				"POSITION,NORMAL,TANGENT,BINORMAL,UV,UV1,BLENDWEIGHT,BLENDINDICES,":VertexPositionNTBTexture0Texture1Skin.vertexDeclaration,
				"POSITION,NORMAL,UV,UV1,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalTexture0Texture1SkinSTangent.vertexDeclaration,
				"POSITION,NORMAL,UV,UV1,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalTexture0Texture1Skin.vertexDeclaration,
				"POSITION,NORMAL,COLOR,UV,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalColorTextureSkinSTangent.vertexDeclaration,
				"POSITION,NORMAL,COLOR,UV,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalColorTextureSkin.vertexDeclaration,
				"POSITION,NORMAL,UV,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalTextureSkinSTangent.vertexDeclaration,
				"POSITION,NORMAL,UV,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalTextureSkin.vertexDeclaration,
				"POSITION,NORMAL,COLOR,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalColorSkinSTangent.vertexDeclaration,
				"POSITION,NORMAL,COLOR,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalColorSkin.vertexDeclaration,
				"POSITION,NORMAL,COLOR,UV,UV1,TANGENT":VertexPositionNormalColorTexture0Texture1STangent.vertexDeclaration,
				"POSITION,NORMAL,COLOR,UV,UV1":VertexPositionNormalColorTexture0Texture1.vertexDeclaration,
				"POSITION,NORMAL,UV,UV1,TANGENT":VertexPositionNormalTexture0Texture1STangent.vertexDeclaration,
				"POSITION,NORMAL,UV,UV1":VertexPositionNormalTexture0Texture1.vertexDeclaration,
				"POSITION,NORMAL,COLOR,UV,TANGENT":VertexPositionNormalColorTextureSTangent.vertexDeclaration,
				"POSITION,NORMAL,UV,TANGENT,BINORMAL":VertexPositionNTBTexture.vertexDeclaration,
				"POSITION,NORMAL,COLOR,UV":VertexPositionNormalColorTexture.vertexDeclaration,
				"POSITION,NORMAL,UV,TANGENT":VertexPositionNormalTextureSTangent.vertexDeclaration,
				"POSITION,NORMAL,UV":VertexPositionNormalTexture.vertexDeclaration,
				"POSITION,NORMAL,COLOR,TANGENT":VertexPositionNormalColorSTangent.vertexDeclaration,
				"POSITION,NORMAL,COLOR":VertexPositionNormalColor.vertexDeclaration,
				"POSITION,NORMAL,TANGENT":VertexPositionNormalSTangent.vertexDeclaration,
				"POSITION,NORMAL":VertexPositionNormal.vertexDeclaration,
				"POSITION,UV":VertexPositionTexture0.vertexDeclaration,
				"POSITION":VertexPosition.vertexDeclaration};},'_BLOCK',function(){return this._BLOCK={count:0};},'_DATA',function(){return this._DATA={offset:0,size:0};}
		]);
		return LoadModelV03;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.loaders.MeshReader
	var MeshReader=(function(){
		function MeshReader(){}
		__class(MeshReader,'laya.d3.loaders.MeshReader');
		MeshReader.read=function(data,mesh,subMeshes,materialMap){
			var readData=new Byte(data);
			readData.pos=0;
			var version=readData.readUTFString();
			switch (version){
				case "LAYAMODEL:03":
				case "LAYAMODEL:0301":
					LoadModelV03.parse(readData,version,mesh,subMeshes,materialMap);
					break ;
				default :
					throw new Error("MeshReader: unknown mesh version.");
				}
			mesh._setSubMeshes(subMeshes);
		}

		return MeshReader;
	})()


	/**
	*<code>BaseVector</code> 抽象类，类用于向量的父类。
	*/
	//class laya.d3.math.BaseVector
	var BaseVector=(function(){
		function BaseVector(){
			this.elements=null;
		}

		__class(BaseVector,'laya.d3.math.BaseVector');
		return BaseVector;
	})()


	/**
	*<code>BoundBox</code> 类用于创建包围盒。
	*/
	//class laya.d3.math.BoundBox
	var BoundBox=(function(){
		function BoundBox(min,max){
			this.min=null;
			this.max=null;
			this.min=min;
			this.max=max;
		}

		__class(BoundBox,'laya.d3.math.BoundBox');
		var __proto=BoundBox.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*获取包围盒的8个角顶点。
		*@param corners 返回顶点的输出队列。
		*/
		__proto.getCorners=function(corners){
			corners.length=8;
			var mine=this.min.elements;
			var maxe=this.max.elements;
			var minX=mine[0];
			var minY=mine[1];
			var minZ=mine[2];
			var maxX=maxe[0];
			var maxY=maxe[1];
			var maxZ=maxe[2];
			corners[0]=new Vector3(minX,maxY,maxZ);
			corners[1]=new Vector3(maxX,maxY,maxZ);
			corners[2]=new Vector3(maxX,minY,maxZ);
			corners[3]=new Vector3(minX,minY,maxZ);
			corners[4]=new Vector3(minX,maxY,minZ);
			corners[5]=new Vector3(maxX,maxY,minZ);
			corners[6]=new Vector3(maxX,minY,minZ);
			corners[7]=new Vector3(minX,minY,minZ);
		}

		__proto.toDefault=function(){
			this.min.toDefault();
			this.max.toDefault();
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var dest=destObject;
			this.min.cloneTo(dest.min);
			this.max.cloneTo(dest.max);
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=new this.constructor(new Vector3(),new Vector3());
			this.cloneTo(dest);
			return dest;
		}

		BoundBox.createfromPoints=function(points,out){
			if (points==null)
				throw new Error("points");
			var min=out.min;
			var max=out.max;
			var minE=min.elements;
			minE[0]=Number.MAX_VALUE;
			minE[1]=Number.MAX_VALUE;
			minE[2]=Number.MAX_VALUE;
			var maxE=max.elements;
			maxE[0]=-Number.MAX_VALUE;
			maxE[1]=-Number.MAX_VALUE;
			maxE[2]=-Number.MAX_VALUE;
			for (var i=0,n=points.length;i < n;++i){
				Vector3.min(min,points[i],min);
				Vector3.max(max,points[i],max);
			}
		}

		BoundBox.merge=function(box1,box2,out){
			Vector3.min(box1.min,box2.min,out.min);
			Vector3.max(box1.max,box2.max,out.max);
		}

		return BoundBox;
	})()


	/**
	*<code>BoundFrustum</code> 类用于创建锥截体。
	*/
	//class laya.d3.math.BoundFrustum
	var BoundFrustum=(function(){
		function BoundFrustum(matrix){
			this._matrix=null;
			this._near=null;
			this._far=null;
			this._left=null;
			this._right=null;
			this._top=null;
			this._bottom=null;
			this._matrix=matrix;
			this._near=new Plane(new Vector3());
			this._far=new Plane(new Vector3());
			this._left=new Plane(new Vector3());
			this._right=new Plane(new Vector3());
			this._top=new Plane(new Vector3());
			this._bottom=new Plane(new Vector3());
			BoundFrustum._getPlanesFromMatrix(this._matrix,this._near,this._far,this._left,this._right,this._top,this._bottom);
		}

		__class(BoundFrustum,'laya.d3.math.BoundFrustum');
		var __proto=BoundFrustum.prototype;
		/**
		*判断是否与其他锥截体相等。
		*@param other 锥截体。
		*/
		__proto.equalsBoundFrustum=function(other){
			return this._matrix.equalsOtherMatrix(other.matrix)
		}

		/**
		*判断是否与其他对象相等。
		*@param obj 对象。
		*/
		__proto.equalsObj=function(obj){
			if ((obj instanceof laya.d3.math.BoundFrustum )){
				var bf=obj;
				return this.equalsBoundFrustum(bf);
			}
			return false;
		}

		/**
		*获取锥截体的任意一平面。
		*0:近平面
		*1:远平面
		*2:左平面
		*3:右平面
		*4:顶平面
		*5:底平面
		*@param index 索引。
		*/
		__proto.getPlane=function(index){
			switch (index){
				case 0:
					return this._near;
				case 1:
					return this._far;
				case 2:
					return this._left;
				case 3:
					return this._right;
				case 4:
					return this._top;
				case 5:
					return this._bottom;
				default :
					return null;
				}
		}

		/**
		*锥截体的8个顶点。
		*@param corners 返回顶点的输出队列。
		*/
		__proto.getCorners=function(corners){
			BoundFrustum._get3PlaneInterPoint(this._near,this._bottom,this._right).cloneTo(corners[0]);
			BoundFrustum._get3PlaneInterPoint(this._near,this._top,this._right).cloneTo(corners[1]);
			BoundFrustum._get3PlaneInterPoint(this._near,this._top,this._left).cloneTo(corners[2]);
			BoundFrustum._get3PlaneInterPoint(this._near,this._bottom,this._left).cloneTo(corners[3]);
			BoundFrustum._get3PlaneInterPoint(this._far,this._bottom,this._right).cloneTo(corners[4]);
			BoundFrustum._get3PlaneInterPoint(this._far,this._top,this._right).cloneTo(corners[5]);
			BoundFrustum._get3PlaneInterPoint(this._far,this._top,this._left).cloneTo(corners[6]);
			BoundFrustum._get3PlaneInterPoint(this._far,this._bottom,this._left).cloneTo(corners[7]);
		}

		/**
		*与点的位置关系。返回-1,包涵;0,相交;1,不相交
		*@param point 点。
		*/
		__proto.containsPoint=function(point){
			var result=Plane.PlaneIntersectionType_Front;
			var planeResult=Plane.PlaneIntersectionType_Front;
			for (var i=0;i < 6;i++){
				switch (i){
					case 0:
						planeResult=Collision.intersectsPlaneAndPoint(this._near,point);
						break ;
					case 1:
						planeResult=Collision.intersectsPlaneAndPoint(this._far,point);
						break ;
					case 2:
						planeResult=Collision.intersectsPlaneAndPoint(this._left,point);
						break ;
					case 3:
						planeResult=Collision.intersectsPlaneAndPoint(this._right,point);
						break ;
					case 4:
						planeResult=Collision.intersectsPlaneAndPoint(this._top,point);
						break ;
					case 5:
						planeResult=Collision.intersectsPlaneAndPoint(this._bottom,point);
						break ;
					}
				switch (planeResult){
					case Plane.PlaneIntersectionType_Back:
						return 0;
					case Plane.PlaneIntersectionType_Intersecting:
						result=Plane.PlaneIntersectionType_Intersecting;
						break ;
					}
			}
			switch (result){
				case Plane.PlaneIntersectionType_Intersecting:
					return 2;
				default :
					return 1;
				}
		}

		/**
		*与包围盒的位置关系。返回-1,包涵;0,相交;1,不相交
		*@param box 包围盒。
		*/
		__proto.containsBoundBox=function(box){
			var p=BoundFrustum._tempV30,n=BoundFrustum._tempV31;
			var plane;
			var result=1;
			for (var i=0;i < 6;i++){
				plane=this.getPlane(i);
				this._getBoxToPlanePVertexNVertex(box,plane.normal,p,n);
				if (Collision.intersectsPlaneAndPoint(plane,p)===Plane.PlaneIntersectionType_Back)
					return 0;
				if (Collision.intersectsPlaneAndPoint(plane,n)===Plane.PlaneIntersectionType_Back)
					result=2;
			}
			return result;
		}

		/**
		*与包围球的位置关系。返回-1,包涵;0,相交;1,不相交
		*@param sphere 包围球。
		*/
		__proto.containsBoundSphere=function(sphere){
			var result=Plane.PlaneIntersectionType_Front;
			var planeResult=Plane.PlaneIntersectionType_Front;
			for (var i=0;i < 6;i++){
				switch (i){
					case 0:
						planeResult=Collision.intersectsPlaneAndSphere(this._near,sphere);
						break ;
					case 1:
						planeResult=Collision.intersectsPlaneAndSphere(this._far,sphere);
						break ;
					case 2:
						planeResult=Collision.intersectsPlaneAndSphere(this._left,sphere);
						break ;
					case 3:
						planeResult=Collision.intersectsPlaneAndSphere(this._right,sphere);
						break ;
					case 4:
						planeResult=Collision.intersectsPlaneAndSphere(this._top,sphere);
						break ;
					case 5:
						planeResult=Collision.intersectsPlaneAndSphere(this._bottom,sphere);
						break ;
					}
				switch (planeResult){
					case Plane.PlaneIntersectionType_Back:
						return 0;
					case Plane.PlaneIntersectionType_Intersecting:
						result=Plane.PlaneIntersectionType_Intersecting;
						break ;
					}
			}
			switch (result){
				case Plane.PlaneIntersectionType_Intersecting:
					return 2;
				default :
					return 1;
				}
		}

		/**
		*@private
		*/
		__proto._getBoxToPlanePVertexNVertex=function(box,planeNormal,outP,outN){
			var boxMin=box.min;
			var boxMinE=boxMin.elements;
			var boxMax=box.max;
			var boxMaxE=boxMax.elements;
			var planeNorE=planeNormal.elements;
			var planeNorEX=planeNorE[0];
			var planeNorEY=planeNorE[1];
			var planeNorEZ=planeNorE[2];
			boxMin.cloneTo(outP);;
			var outPE=outP.elements;
			if (planeNorEX >=0)
				outPE[0]=boxMaxE[0];
			if (planeNorEY >=0)
				outPE[1]=boxMaxE[1];
			if (planeNorEZ >=0)
				outPE[2]=boxMaxE[2];
			boxMax.cloneTo(outN);
			var outNE=outN.elements;
			if (planeNorEX >=0)
				outNE[0]=boxMinE[0];
			if (planeNorEY >=0)
				outNE[1]=boxMinE[1];
			if (planeNorEZ >=0)
				outNE[2]=boxMinE[2];
		}

		/**
		*获取顶平面。
		*@return 顶平面。
		*/
		__getset(0,__proto,'top',function(){
			return this._top;
		});

		/**
		*设置描述矩阵。
		*@param matrix 描述矩阵。
		*/
		/**
		*获取描述矩阵。
		*@return 描述矩阵。
		*/
		__getset(0,__proto,'matrix',function(){
			return this._matrix;
			},function(matrix){
			this._matrix=matrix;
			BoundFrustum._getPlanesFromMatrix(this._matrix,this._near,this._far,this._left,this._right,this._top,this._bottom);
		});

		/**
		*获取近平面。
		*@return 近平面。
		*/
		__getset(0,__proto,'near',function(){
			return this._near;
		});

		/**
		*获取远平面。
		*@return 远平面。
		*/
		__getset(0,__proto,'far',function(){
			return this._far;
		});

		/**
		*获取左平面。
		*@return 左平面。
		*/
		__getset(0,__proto,'left',function(){
			return this._left;
		});

		/**
		*获取右平面。
		*@return 右平面。
		*/
		__getset(0,__proto,'right',function(){
			return this._right;
		});

		/**
		*获取底平面。
		*@return 底平面。
		*/
		__getset(0,__proto,'bottom',function(){
			return this._bottom;
		});

		BoundFrustum._getPlanesFromMatrix=function(m,np,fp,lp,rp,tp,bp){
			var matrixE=m.elements;
			var m11=matrixE[0];
			var m12=matrixE[1];
			var m13=matrixE[2];
			var m14=matrixE[3];
			var m21=matrixE[4];
			var m22=matrixE[5];
			var m23=matrixE[6];
			var m24=matrixE[7];
			var m31=matrixE[8];
			var m32=matrixE[9];
			var m33=matrixE[10];
			var m34=matrixE[11];
			var m41=matrixE[12];
			var m42=matrixE[13];
			var m43=matrixE[14];
			var m44=matrixE[15];
			var nearNorE=np.normal.elements;
			nearNorE[0]=m14+m13;
			nearNorE[1]=m24+m23;
			nearNorE[2]=m34+m33;
			np.distance=m44+m43;
			np.normalize();
			var farNorE=fp.normal.elements;
			farNorE[0]=m14-m13;
			farNorE[1]=m24-m23;
			farNorE[2]=m34-m33;
			fp.distance=m44-m43;
			fp.normalize();
			var leftNorE=lp.normal.elements;
			leftNorE[0]=m14+m11;
			leftNorE[1]=m24+m21;
			leftNorE[2]=m34+m31;
			lp.distance=m44+m41;
			lp.normalize();
			var rightNorE=rp.normal.elements;
			rightNorE[0]=m14-m11;
			rightNorE[1]=m24-m21;
			rightNorE[2]=m34-m31;
			rp.distance=m44-m41;
			rp.normalize();
			var topNorE=tp.normal.elements;
			topNorE[0]=m14-m12;
			topNorE[1]=m24-m22;
			topNorE[2]=m34-m32;
			tp.distance=m44-m42;
			tp.normalize();
			var bottomNorE=bp.normal.elements;
			bottomNorE[0]=m14+m12;
			bottomNorE[1]=m24+m22;
			bottomNorE[2]=m34+m32;
			bp.distance=m44+m42;
			bp.normalize();
		}

		BoundFrustum._get3PlaneInterPoint=function(p1,p2,p3){
			var p1Nor=p1.normal;
			var p2Nor=p2.normal;
			var p3Nor=p3.normal;
			Vector3.cross(p2Nor,p3Nor,BoundFrustum._tempV30);
			Vector3.cross(p3Nor,p1Nor,BoundFrustum._tempV31);
			Vector3.cross(p1Nor,p2Nor,BoundFrustum._tempV32);
			var a=Vector3.dot(p1Nor,BoundFrustum._tempV30);
			var b=Vector3.dot(p2Nor,BoundFrustum._tempV31);
			var c=Vector3.dot(p3Nor,BoundFrustum._tempV32);
			Vector3.scale(BoundFrustum._tempV30,-p1.distance / a,BoundFrustum._tempV33);
			Vector3.scale(BoundFrustum._tempV31,-p2.distance / b,BoundFrustum._tempV34);
			Vector3.scale(BoundFrustum._tempV32,-p3.distance / c,BoundFrustum._tempV35);
			Vector3.add(BoundFrustum._tempV33,BoundFrustum._tempV34,BoundFrustum._tempV36);
			Vector3.add(BoundFrustum._tempV35,BoundFrustum._tempV36,BoundFrustum._tempV37);
			var v=BoundFrustum._tempV37;
			return v;
		}

		__static(BoundFrustum,
		['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();},'_tempV33',function(){return this._tempV33=new Vector3();},'_tempV34',function(){return this._tempV34=new Vector3();},'_tempV35',function(){return this._tempV35=new Vector3();},'_tempV36',function(){return this._tempV36=new Vector3();},'_tempV37',function(){return this._tempV37=new Vector3();}
		]);
		return BoundFrustum;
	})()


	/**
	*<code>BoundSphere</code> 类用于创建包围球。
	*/
	//class laya.d3.math.BoundSphere
	var BoundSphere=(function(){
		function BoundSphere(center,radius){
			this.center=null;
			this.radius=NaN;
			this.center=center;
			this.radius=radius;
		}

		__class(BoundSphere,'laya.d3.math.BoundSphere');
		var __proto=BoundSphere.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		__proto.toDefault=function(){
			this.center.toDefault();
			this.radius=0;
		}

		/**
		*判断射线是否与碰撞球交叉，并返回交叉距离。
		*@param ray 射线。
		*@return 距离交叉点的距离，-1表示不交叉。
		*/
		__proto.intersectsRayDistance=function(ray){
			return Collision.intersectsRayAndSphereRD(ray,this);
		}

		/**
		*判断射线是否与碰撞球交叉，并返回交叉点。
		*@param ray 射线。
		*@param outPoint 交叉点。
		*@return 距离交叉点的距离，-1表示不交叉。
		*/
		__proto.intersectsRayPoint=function(ray,outPoint){
			return Collision.intersectsRayAndSphereRP(ray,this,outPoint);
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var dest=destObject;
			this.center.cloneTo(dest.center);
			dest.radius=this.radius;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=new this.constructor(new Vector3(),new Vector3());
			this.cloneTo(dest);
			return dest;
		}

		BoundSphere.createFromSubPoints=function(points,start,count,out){
			if (points==null){
				throw new Error("points");
			}
			if (start < 0 || start >=points.length){
				throw new Error("start"+start+"Must be in the range [0, "+(points.length-1)+"]");
			}
			if (count < 0 || (start+count)> points.length){
				throw new Error("count"+count+"Must be in the range <= "+points.length+"}");
			};
			var upperEnd=start+count;
			var center=BoundSphere._tempVector3;
			center.elements[0]=0;
			center.elements[1]=0;
			center.elements[2]=0;
			for (var i=start;i < upperEnd;++i){
				Vector3.add(points[i],center,center);
			};
			var outCenter=out.center;
			Vector3.scale(center,1 / count,outCenter);
			var radius=0.0;
			for (i=start;i < upperEnd;++i){
				var distance=Vector3.distanceSquared(outCenter,points[i]);
				if (distance > radius)
					radius=distance;
			}
			out.radius=Math.sqrt(radius);
		}

		BoundSphere.createfromPoints=function(points,out){
			if (points==null){
				throw new Error("points");
			}
			BoundSphere.createFromSubPoints(points,0,points.length,out);
		}

		__static(BoundSphere,
		['_tempVector3',function(){return this._tempVector3=new Vector3();}
		]);
		return BoundSphere;
	})()


	/**
	*<code>Collision</code> 类用于检测碰撞。
	*/
	//class laya.d3.math.Collision
	var Collision=(function(){
		/**
		*创建一个 <code>Collision</code> 实例。
		*/
		function Collision(){}
		__class(Collision,'laya.d3.math.Collision');
		Collision.distancePlaneToPoint=function(plane,point){
			var dot=Vector3.dot(plane.normal,point);
			return dot-plane.distance;
		}

		Collision.distanceBoxToPoint=function(box,point){
			var boxMine=box.min.elements;
			var boxMineX=boxMine[0];
			var boxMineY=boxMine[1];
			var boxMineZ=boxMine[2];
			var boxMaxe=box.max.elements;
			var boxMaxeX=boxMaxe[0];
			var boxMaxeY=boxMaxe[1];
			var boxMaxeZ=boxMaxe[2];
			var pointe=point.elements;
			var pointeX=pointe[0];
			var pointeY=pointe[1];
			var pointeZ=pointe[2];
			var distance=0;
			if (pointeX < boxMineX)
				distance+=(boxMineX-pointeX)*(boxMineX-pointeX);
			if (pointeX > boxMaxeX)
				distance+=(boxMaxeX-pointeX)*(boxMaxeX-pointeX);
			if (pointeY < boxMineY)
				distance+=(boxMineY-pointeY)*(boxMineY-pointeY);
			if (pointeY > boxMaxeY)
				distance+=(boxMaxeY-pointeY)*(boxMaxeY-pointeY);
			if (pointeZ < boxMineZ)
				distance+=(boxMineZ-pointeZ)*(boxMineZ-pointeZ);
			if (pointeZ > boxMaxeZ)
				distance+=(boxMaxeZ-pointeZ)*(boxMaxeZ-pointeZ);
			return Math.sqrt(distance);
		}

		Collision.distanceBoxToBox=function(box1,box2){
			var box1Mine=box1.min.elements;
			var box1MineX=box1Mine[0];
			var box1MineY=box1Mine[1];
			var box1MineZ=box1Mine[2];
			var box1Maxe=box1.max.elements;
			var box1MaxeX=box1Maxe[0];
			var box1MaxeY=box1Maxe[1];
			var box1MaxeZ=box1Maxe[2];
			var box2Mine=box2.min.elements;
			var box2MineX=box2Mine[0];
			var box2MineY=box2Mine[1];
			var box2MineZ=box2Mine[2];
			var box2Maxe=box2.max.elements;
			var box2MaxeX=box2Maxe[0];
			var box2MaxeY=box2Maxe[1];
			var box2MaxeZ=box2Maxe[2];
			var distance=0;
			var delta=NaN;
			if (box1MineX > box2MaxeX){
				delta=box1MineX-box2MaxeX;
				distance+=delta *delta;
				}else if (box2MineX > box1MaxeX){
				delta=box2MineX-box1MaxeX;
				distance+=delta *delta;
			}
			if (box1MineY > box2MaxeY){
				delta=box1MineY-box2MaxeY;
				distance+=delta *delta;
				}else if (box2MineY > box1MaxeY){
				delta=box2MineY-box1MaxeY;
				distance+=delta *delta;
			}
			if (box1MineZ > box2MaxeZ){
				delta=box1MineZ-box2MaxeZ;
				distance+=delta *delta;
				}else if (box2MineZ > box1MaxeZ){
				delta=box2MineZ-box1MaxeZ;
				distance+=delta *delta;
			}
			return Math.sqrt(distance);
		}

		Collision.distanceSphereToPoint=function(sphere,point){
			var distance=Math.sqrt(Vector3.distanceSquared(sphere.center,point));
			distance-=sphere.radius;
			return Math.max(distance,0);
		}

		Collision.distanceSphereToSphere=function(sphere1,sphere2){
			var distance=Math.sqrt(Vector3.distanceSquared(sphere1.center,sphere2.center));
			distance-=sphere1.radius+sphere2.radius;
			return Math.max(distance,0);
		}

		Collision.intersectsRayAndTriangleRD=function(ray,vertex1,vertex2,vertex3,out){
			var rayO=ray.origin;
			var rayOe=rayO.elements;
			var rayOeX=rayOe[0];
			var rayOeY=rayOe[1];
			var rayOeZ=rayOe[2];
			var rayD=ray.direction;
			var rayDe=rayD.elements;
			var rayDeX=rayDe[0];
			var rayDeY=rayDe[1];
			var rayDeZ=rayDe[2];
			var v1e=vertex1.elements;
			var v1eX=v1e[0];
			var v1eY=v1e[1];
			var v1eZ=v1e[2];
			var v2e=vertex2.elements;
			var v2eX=v2e[0];
			var v2eY=v2e[1];
			var v2eZ=v2e[2];
			var v3e=vertex3.elements;
			var v3eX=v3e[0];
			var v3eY=v3e[1];
			var v3eZ=v3e[2];
			var _tempV30e=Collision._tempV30.elements;
			var _tempV30eX=_tempV30e[0];
			var _tempV30eY=_tempV30e[1];
			var _tempV30eZ=_tempV30e[2];
			_tempV30eX=v2eX-v1eX;
			_tempV30eY=v2eY-v1eY;
			_tempV30eZ=v2eZ-v1eZ;
			var _tempV31e=Collision._tempV31.elements;
			var _tempV31eX=_tempV31e[0];
			var _tempV31eY=_tempV31e[1];
			var _tempV31eZ=_tempV31e[2];
			_tempV31eX=v3eX-v1eX;
			_tempV31eY=v3eY-v1eY;
			_tempV31eZ=v3eZ-v1eZ;
			var _tempV32e=Collision._tempV32.elements;
			var _tempV32eX=_tempV32e[0];
			var _tempV32eY=_tempV32e[1];
			var _tempV32eZ=_tempV32e[2];
			_tempV32eX=(rayDeY *_tempV31eZ)-(rayDeZ *_tempV31eY);
			_tempV32eY=(rayDeZ *_tempV31eX)-(rayDeX *_tempV31eZ);
			_tempV32eZ=(rayDeX *_tempV31eY)-(rayDeY *_tempV31eX);
			var determinant=(_tempV30eX *_tempV32eX)+(_tempV30eY *_tempV32eY)+(_tempV30eZ *_tempV32eZ);
			if (MathUtils3D.isZero(determinant)){
				out=0;
				return false;
			};
			var inversedeterminant=1 / determinant;
			var _tempV33e=Collision._tempV33.elements;
			var _tempV33eX=_tempV33e[0];
			var _tempV33eY=_tempV33e[1];
			var _tempV33eZ=_tempV33e[2];
			_tempV33eX=rayOeX-v1eX;
			_tempV33eY=rayOeY-v1eY;
			_tempV33eZ=rayOeZ-v1eZ;
			var triangleU=(_tempV33eX *_tempV32eX)+(_tempV33eY *_tempV32eY)+(_tempV33eZ *_tempV32eZ);
			triangleU *=inversedeterminant;
			if (triangleU < 0 || triangleU > 1){
				out=0;
				return false;
			};
			var _tempV34e=Collision._tempV34.elements;
			var _tempV34eX=_tempV34e[0];
			var _tempV34eY=_tempV34e[1];
			var _tempV34eZ=_tempV34e[2];
			_tempV34eX=(_tempV33eY *_tempV30eZ)-(_tempV33eZ *_tempV30eY);
			_tempV34eY=(_tempV33eZ *_tempV30eX)-(_tempV33eX *_tempV30eZ);
			_tempV34eZ=(_tempV33eX *_tempV30eY)-(_tempV33eY *_tempV30eX);
			var triangleV=((rayDeX *_tempV34eX)+(rayDeY *_tempV34eY))+(rayDeZ *_tempV34eZ);
			triangleV *=inversedeterminant;
			if (triangleV < 0 || triangleU+triangleV > 1){
				out=0;
				return false;
			};
			var raydistance=(_tempV31eX *_tempV34eX)+(_tempV31eY *_tempV34eY)+(_tempV31eZ *_tempV34eZ);
			raydistance *=inversedeterminant;
			if (raydistance < 0){
				out=0;
				return false;
			}
			out=raydistance;
			return true;
		}

		Collision.intersectsRayAndTriangleRP=function(ray,vertex1,vertex2,vertex3,out){
			var distance=NaN;
			if (!Collision.intersectsRayAndTriangleRD(ray,vertex1,vertex2,vertex3,distance)){
				out=Vector3.ZERO;
				return false;
			}
			Vector3.scale(ray.direction,distance,Collision._tempV30);
			Vector3.add(ray.origin,Collision._tempV30,out);
			return true;
		}

		Collision.intersectsRayAndPoint=function(ray,point){
			Vector3.subtract(ray.origin,point,Collision._tempV30);
			var b=Vector3.dot(Collision._tempV30,ray.direction);
			var c=Vector3.dot(Collision._tempV30,Collision._tempV30)-MathUtils3D.zeroTolerance;
			if (c > 0 && b > 0)
				return false;
			var discriminant=b *b-c;
			if (discriminant < 0)
				return false;
			return true;
		}

		Collision.intersectsRayAndRay=function(ray1,ray2,out){
			var ray1o=ray1.origin;
			var ray1oe=ray1o.elements;
			var ray1oeX=ray1oe[0];
			var ray1oeY=ray1oe[1];
			var ray1oeZ=ray1oe[2];
			var ray1d=ray1.direction;
			var ray1de=ray1d.elements;
			var ray1deX=ray1de[0];
			var ray1deY=ray1de[1];
			var ray1deZ=ray1de[2];
			var ray2o=ray2.origin;
			var ray2oe=ray2o.elements;
			var ray2oeX=ray2oe[0];
			var ray2oeY=ray2oe[1];
			var ray2oeZ=ray2oe[2];
			var ray2d=ray2.direction;
			var ray2de=ray2d.elements;
			var ray2deX=ray2de[0];
			var ray2deY=ray2de[1];
			var ray2deZ=ray2de[2];
			Vector3.cross(ray1d,ray2d,Collision._tempV30);
			var tempV3e=Collision._tempV30.elements;
			var denominator=Vector3.scalarLength(Collision._tempV30);
			if (MathUtils3D.isZero(denominator)){
				if (MathUtils3D.nearEqual(ray2oeX,ray1oeX)&& MathUtils3D.nearEqual(ray2oeY,ray1oeY)&& MathUtils3D.nearEqual(ray2oeZ,ray1oeZ)){
					out=Vector3.ZERO;
					return true;
				}
			}
			denominator=denominator *denominator;
			var m11=ray2oeX-ray1oeX;
			var m12=ray2oeY-ray1oeY;
			var m13=ray2oeZ-ray1oeZ;
			var m21=ray2deX;
			var m22=ray2deY;
			var m23=ray2deZ;
			var m31=tempV3e[0];
			var m32=tempV3e[1];
			var m33=tempV3e[2];
			var dets=m11 *m22 *m33+m12 *m23 *m31+m13 *m21 *m32-m11 *m23 *m32-m12 *m21 *m33-m13 *m22 *m31;
			m21=ray1deX;
			m22=ray1deY;
			m23=ray1deZ;
			var dett=m11 *m22 *m33+m12 *m23 *m31+m13 *m21 *m32-m11 *m23 *m32-m12 *m21 *m33-m13 *m22 *m31;
			var s=dets / denominator;
			var t=dett / denominator;
			Vector3.scale(ray1d,s,Collision._tempV30);
			Vector3.scale(ray2d,s,Collision._tempV31);
			Vector3.add(ray1o,Collision._tempV30,Collision._tempV32);
			Vector3.add(ray2o,Collision._tempV31,Collision._tempV33);
			var point1e=Collision._tempV32.elements;
			var point2e=Collision._tempV33.elements;
			if (!MathUtils3D.nearEqual(point2e[0],point1e[0])|| !MathUtils3D.nearEqual(point2e[1],point1e[1])|| !MathUtils3D.nearEqual(point2e[2],point1e[2])){
				out=Vector3.ZERO;
				return false;
			}
			out=Collision._tempV32;
			return true;
		}

		Collision.intersectsPlaneAndTriangle=function(plane,vertex1,vertex2,vertex3){
			var test1=Collision.intersectsPlaneAndPoint(plane,vertex1);
			var test2=Collision.intersectsPlaneAndPoint(plane,vertex2);
			var test3=Collision.intersectsPlaneAndPoint(plane,vertex3);
			if (test1==Plane.PlaneIntersectionType_Front && test2==Plane.PlaneIntersectionType_Front && test3==Plane.PlaneIntersectionType_Front)
				return Plane.PlaneIntersectionType_Front;
			if (test1==Plane.PlaneIntersectionType_Back && test2==Plane.PlaneIntersectionType_Back && test3==Plane.PlaneIntersectionType_Back)
				return Plane.PlaneIntersectionType_Back;
			return Plane.PlaneIntersectionType_Intersecting;
		}

		Collision.intersectsRayAndPlaneRD=function(ray,plane,out){
			var planeNor=plane.normal;
			var direction=Vector3.dot(planeNor,ray.direction);
			if (MathUtils3D.isZero(direction)){
				out=0;
				return false;
			};
			var position=Vector3.dot(planeNor,ray.origin);
			out=(-plane.distance-position)/ direction;
			if (out < 0){
				out=0;
				return false;
			}
			return true;
		}

		Collision.intersectsRayAndPlaneRP=function(ray,plane,out){
			var distance=NaN;
			if (!Collision.intersectsRayAndPlaneRD(ray,plane,distance)){
				out=Vector3.ZERO;
				return false;
			}
			Vector3.scale(ray.direction,distance,Collision._tempV30);
			Vector3.add(ray.origin,Collision._tempV30,Collision._tempV31);
			out=Collision._tempV31;
			return true;
		}

		Collision.intersectsRayAndBoxRD=function(ray,box){
			var rayoe=ray.origin.elements;
			var rayoeX=rayoe[0];
			var rayoeY=rayoe[1];
			var rayoeZ=rayoe[2];
			var rayde=ray.direction.elements;
			var raydeX=rayde[0];
			var raydeY=rayde[1];
			var raydeZ=rayde[2];
			var boxMine=box.min.elements;
			var boxMineX=boxMine[0];
			var boxMineY=boxMine[1];
			var boxMineZ=boxMine[2];
			var boxMaxe=box.max.elements;
			var boxMaxeX=boxMaxe[0];
			var boxMaxeY=boxMaxe[1];
			var boxMaxeZ=boxMaxe[2];
			var out=0;
			var tmax=MathUtils3D.MaxValue;
			if (MathUtils3D.isZero(raydeX)){
				if (rayoeX < boxMineX || rayoeX > boxMaxeX){
					return-1;
				}
				}else {
				var inverse=1 / raydeX;
				var t1=(boxMineX-rayoeX)*inverse;
				var t2=(boxMaxeX-rayoeX)*inverse;
				if (t1 > t2){
					var temp=t1;
					t1=t2;
					t2=temp;
				}
				out=Math.max(t1,out);
				tmax=Math.min(t2,tmax);
				if (out > tmax){
					return-1;
				}
			}
			if (MathUtils3D.isZero(raydeY)){
				if (rayoeY < boxMineY || rayoeY > boxMaxeY){
					return-1;
				}
				}else {
				var inverse1=1 / raydeY;
				var t3=(boxMineY-rayoeY)*inverse1;
				var t4=(boxMaxeY-rayoeY)*inverse1;
				if (t3 > t4){
					var temp1=t3;
					t3=t4;
					t4=temp1;
				}
				out=Math.max(t3,out);
				tmax=Math.min(t4,tmax);
				if (out > tmax){
					return-1;
				}
			}
			if (MathUtils3D.isZero(raydeZ)){
				if (rayoeZ < boxMineZ || rayoeZ > boxMaxeZ){
					return-1;
				}
				}else {
				var inverse2=1 / raydeZ;
				var t5=(boxMineZ-rayoeZ)*inverse2;
				var t6=(boxMaxeZ-rayoeZ)*inverse2;
				if (t5 > t6){
					var temp2=t5;
					t5=t6;
					t6=temp2;
				}
				out=Math.max(t5,out);
				tmax=Math.min(t6,tmax);
				if (out > tmax){
					return-1;
				}
			}
			return out;
		}

		Collision.intersectsRayAndBoxRP=function(ray,box,out){
			var distance=Collision.intersectsRayAndBoxRD(ray,box);
			if (distance===-1){
				Vector3.ZERO.cloneTo(out);
				return distance;
			}
			Vector3.scale(ray.direction,distance,Collision._tempV30);
			Vector3.add(ray.origin,Collision._tempV30,Collision._tempV31);
			Collision._tempV31.cloneTo(out);
			return distance;
		}

		Collision.intersectsRayAndSphereRD=function(ray,sphere){
			var sphereR=sphere.radius;
			Vector3.subtract(ray.origin,sphere.center,Collision._tempV30);
			var b=Vector3.dot(Collision._tempV30,ray.direction);
			var c=Vector3.dot(Collision._tempV30,Collision._tempV30)-(sphereR *sphereR);
			if (c > 0 && b > 0){
				return-1;
			};
			var discriminant=b *b-c;
			if (discriminant < 0){
				return-1;
			};
			var distance=-b-Math.sqrt(discriminant);
			if (distance < 0)
				distance=0;
			return distance;
		}

		Collision.intersectsRayAndSphereRP=function(ray,sphere,out){
			var distance=Collision.intersectsRayAndSphereRD(ray,sphere);
			if (distance===-1){
				Vector3.ZERO.cloneTo(out);
				return distance;
			}
			Vector3.scale(ray.direction,distance,Collision._tempV30);
			Vector3.add(ray.origin,Collision._tempV30,Collision._tempV31);
			Collision._tempV31.cloneTo(out);
			return distance;
		}

		Collision.intersectsSphereAndTriangle=function(sphere,vertex1,vertex2,vertex3){
			var sphereC=sphere.center;
			var sphereR=sphere.radius;
			Collision.closestPointPointTriangle(sphereC,vertex1,vertex2,vertex3,Collision._tempV30);
			Vector3.subtract(Collision._tempV30,sphereC,Collision._tempV31);
			var dot=Vector3.dot(Collision._tempV31,Collision._tempV31);
			return dot <=sphereR *sphereR;
		}

		Collision.intersectsPlaneAndPoint=function(plane,point){
			var distance=Vector3.dot(plane.normal,point)+plane.distance;
			if (distance > 0)
				return Plane.PlaneIntersectionType_Front;
			if (distance < 0)
				return Plane.PlaneIntersectionType_Back;
			return Plane.PlaneIntersectionType_Intersecting;
		}

		Collision.intersectsPlaneAndPlane=function(plane1,plane2){
			Vector3.cross(plane1.normal,plane2.normal,Collision._tempV30);
			var denominator=Vector3.dot(Collision._tempV30,Collision._tempV30);
			if (MathUtils3D.isZero(denominator))
				return false;
			return true;
		}

		Collision.intersectsPlaneAndPlaneRL=function(plane1,plane2,line){
			var plane1nor=plane1.normal;
			var plane2nor=plane2.normal;
			Vector3.cross(plane1nor,plane2nor,Collision._tempV34);
			var denominator=Vector3.dot(Collision._tempV34,Collision._tempV34);
			if (MathUtils3D.isZero(denominator))
				return false;
			Vector3.scale(plane2nor,plane1.distance,Collision._tempV30);
			Vector3.scale(plane1nor,plane2.distance,Collision._tempV31);
			Vector3.subtract(Collision._tempV30,Collision._tempV31,Collision._tempV32);
			Vector3.cross(Collision._tempV32,Collision._tempV34,Collision._tempV33);
			Vector3.normalize(Collision._tempV34,Collision._tempV34);
			line=new Ray(Collision._tempV33,Collision._tempV34);
			return true;
		}

		Collision.intersectsPlaneAndBox=function(plane,box){
			var planeD=plane.distance;
			var planeNor=plane.normal;
			var planeNore=planeNor.elements;
			var planeNoreX=planeNore[0];
			var planeNoreY=planeNore[1];
			var planeNoreZ=planeNore[2];
			var boxMine=box.min.elements;
			var boxMineX=boxMine[0];
			var boxMineY=boxMine[1];
			var boxMineZ=boxMine[2];
			var boxMaxe=box.max.elements;
			var boxMaxeX=boxMaxe[0];
			var boxMaxeY=boxMaxe[1];
			var boxMaxeZ=boxMaxe[2];
			Collision._tempV30.elements[0]=(planeNoreX > 0)? boxMineX :boxMaxeX;
			Collision._tempV30.elements[1]=(planeNoreY > 0)? boxMineY :boxMaxeY;
			Collision._tempV30.elements[2]=(planeNoreZ > 0)? boxMineZ :boxMaxeZ;
			Collision._tempV31.elements[0]=(planeNoreX > 0)? boxMaxeX :boxMineX;
			Collision._tempV31.elements[1]=(planeNoreY > 0)? boxMaxeY :boxMineY;
			Collision._tempV31.elements[2]=(planeNoreZ > 0)? boxMaxeZ :boxMineZ;
			var distance=Vector3.dot(planeNor,Collision._tempV30);
			if (distance+planeD > 0)
				return Plane.PlaneIntersectionType_Front;
			distance=Vector3.dot(planeNor,Collision._tempV31);
			if (distance+planeD < 0)
				return Plane.PlaneIntersectionType_Back;
			return Plane.PlaneIntersectionType_Intersecting;
		}

		Collision.intersectsPlaneAndSphere=function(plane,sphere){
			var sphereR=sphere.radius;
			var distance=Vector3.dot(plane.normal,sphere.center)+plane.distance;
			if (distance > sphereR)
				return Plane.PlaneIntersectionType_Front;
			if (distance <-sphereR)
				return Plane.PlaneIntersectionType_Back;
			return Plane.PlaneIntersectionType_Intersecting;
		}

		Collision.intersectsBoxAndBox=function(box1,box2){
			var box1Mine=box1.min.elements;
			var box1Maxe=box1.max.elements;
			var box2Mine=box2.min.elements;
			var box2Maxe=box2.max.elements;
			if (box1Mine[0] > box2Maxe[0] || box2Mine[0] > box1Maxe[0])
				return false;
			if (box1Mine[1] > box2Maxe[1] || box2Mine[1] > box1Maxe[1])
				return false;
			if (box1Mine[2] > box2Maxe[2] || box2Mine[2] > box1Maxe[2])
				return false;
			return true;
		}

		Collision.intersectsBoxAndSphere=function(box,sphere){
			var sphereC=sphere.center;
			var sphereR=sphere.radius;
			Vector3.Clamp(sphereC,box.min,box.max,Collision._tempV30);
			var distance=Vector3.distanceSquared(sphereC,Collision._tempV30);
			return distance <=sphereR *sphereR;
		}

		Collision.intersectsSphereAndSphere=function(sphere1,sphere2){
			var radiisum=sphere1.radius+sphere2.radius;
			return Vector3.distanceSquared(sphere1.center,sphere2.center)<=radiisum *radiisum;
		}

		Collision.boxContainsPoint=function(box,point){
			var boxMine=box.min.elements;
			var boxMaxe=box.max.elements;
			var pointe=point.elements;
			if (boxMine[0] <=pointe[0] && boxMaxe[0] >=pointe[0] && boxMine[1] <=pointe[1] && boxMaxe[1] >=pointe[1] && boxMine[2] <=pointe[2] && boxMaxe[2] >=pointe[2])
				return 1;
			return 0;
		}

		Collision.boxContainsBox=function(box1,box2){
			var box1Mine=box1.min.elements;
			var box1MineX=box1Mine[0];
			var box1MineY=box1Mine[1];
			var box1MineZ=box1Mine[2];
			var box1Maxe=box1.max.elements;
			var box1MaxeX=box1Maxe[0];
			var box1MaxeY=box1Maxe[1];
			var box1MaxeZ=box1Maxe[2];
			var box2Mine=box2.min.elements;
			var box2MineX=box2Mine[0];
			var box2MineY=box2Mine[1];
			var box2MineZ=box2Mine[2];
			var box2Maxe=box2.max.elements;
			var box2MaxeX=box2Maxe[0];
			var box2MaxeY=box2Maxe[1];
			var box2MaxeZ=box2Maxe[2];
			if (box1MaxeX < box2MineX || box1MineX > box2MaxeX)
				return 0;
			if (box1MaxeY < box2MineY || box1MineY > box2MaxeY)
				return 0;
			if (box1MaxeZ < box2MineZ || box1MineZ > box2MaxeZ)
				return 0;
			if (box1MineX <=box2MineX && box2MaxeX <=box2MaxeX && box1MineY <=box2MineY && box2MaxeY <=box1MaxeY && box1MineZ <=box2MineZ && box2MaxeZ <=box1MaxeZ){
				return 1;
			}
			return 2;
		}

		Collision.boxContainsSphere=function(box,sphere){
			var boxMin=box.min;
			var boxMine=boxMin.elements;
			var boxMineX=boxMine[0];
			var boxMineY=boxMine[1];
			var boxMineZ=boxMine[2];
			var boxMax=box.max;
			var boxMaxe=boxMax.elements;
			var boxMaxeX=boxMaxe[0];
			var boxMaxeY=boxMaxe[1];
			var boxMaxeZ=boxMaxe[2];
			var sphereC=sphere.center;
			var sphereCe=sphereC.elements;
			var sphereCeX=sphereCe[0];
			var sphereCeY=sphereCe[1];
			var sphereCeZ=sphereCe[2];
			var sphereR=sphere.radius;
			Vector3.Clamp(sphereC,boxMin,boxMax,Collision._tempV30);
			var distance=Vector3.distanceSquared(sphereC,Collision._tempV30);
			if (distance > sphereR *sphereR)
				return 0;
			if ((((boxMineX+sphereR <=sphereCeX)&& (sphereCeX <=boxMaxeX-sphereR))&& ((boxMaxeX-boxMineX > sphereR)&&
				(boxMineY+sphereR <=sphereCeY)))&& (((sphereCeY <=boxMaxeY-sphereR)&& (boxMaxeY-boxMineY > sphereR))&&
			(((boxMineZ+sphereR <=sphereCeZ)&& (sphereCeZ <=boxMaxeZ-sphereR))&& (boxMaxeZ-boxMineZ > sphereR))))
			return 1;
			return 2;
		}

		Collision.sphereContainsPoint=function(sphere,point){
			if (Vector3.distanceSquared(point,sphere.center)<=sphere.radius *sphere.radius)
				return 1;
			return 0;
		}

		Collision.sphereContainsTriangle=function(sphere,vertex1,vertex2,vertex3){
			var test1=Collision.sphereContainsPoint(sphere,vertex1);
			var test2=Collision.sphereContainsPoint(sphere,vertex2);
			var test3=Collision.sphereContainsPoint(sphere,vertex3);
			if (test1==1 && test2==1 && test3==1)
				return 1;
			if (Collision.intersectsSphereAndTriangle(sphere,vertex1,vertex2,vertex3))
				return 2;
			return 0;
		}

		Collision.sphereContainsBox=function(sphere,box){
			var sphereC=sphere.center;
			var sphereCe=sphereC.elements;
			var sphereCeX=sphereCe[0];
			var sphereCeY=sphereCe[1];
			var sphereCeZ=sphereCe[2];
			var sphereR=sphere.radius;
			var boxMin=box.min;
			var boxMine=boxMin.elements;
			var boxMineX=boxMine[0];
			var boxMineY=boxMine[1];
			var boxMineZ=boxMine[2];
			var boxMax=box.max;
			var boxMaxe=boxMax.elements;
			var boxMaxeX=boxMaxe[0];
			var boxMaxeY=boxMaxe[1];
			var boxMaxeZ=boxMaxe[2];
			var _tempV30e=Collision._tempV30.elements;
			var _tempV30eX=_tempV30e[0];
			var _tempV30eY=_tempV30e[1];
			var _tempV30eZ=_tempV30e[2];
			if (!Collision.intersectsBoxAndSphere(box,sphere))
				return 0;
			var radiusSquared=sphereR *sphereR;
			_tempV30eX=sphereCeX-boxMineX;
			_tempV30eY=sphereCeY-boxMaxeY;
			_tempV30eZ=sphereCeZ-boxMaxeZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return 2;
			_tempV30eX=sphereCeX-boxMaxeX;
			_tempV30eY=sphereCeY-boxMaxeY;
			_tempV30eZ=sphereCeZ-boxMaxeZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return 2;
			_tempV30eX=sphereCeX-boxMaxeX;
			_tempV30eY=sphereCeY-boxMineY;
			_tempV30eZ=sphereCeZ-boxMaxeZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return 2;
			_tempV30eX=sphereCeX-boxMineX;
			_tempV30eY=sphereCeY-boxMineY;
			_tempV30eZ=sphereCeZ-boxMaxeZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return 2;
			_tempV30eX=sphereCeX-boxMineX;
			_tempV30eY=sphereCeY-boxMaxeY;
			_tempV30eZ=sphereCeZ-boxMineZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return 2;
			_tempV30eX=sphereCeX-boxMaxeX;
			_tempV30eY=sphereCeY-boxMaxeY;
			_tempV30eZ=sphereCeZ-boxMineZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return 2;
			_tempV30eX=sphereCeX-boxMaxeX;
			_tempV30eY=sphereCeY-boxMineY;
			_tempV30eZ=sphereCeZ-boxMineZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return 2;
			_tempV30eX=sphereCeX-boxMineX;
			_tempV30eY=sphereCeY-boxMineY;
			_tempV30eZ=sphereCeZ-boxMineZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return 2;
			return 1;
		}

		Collision.sphereContainsSphere=function(sphere1,sphere2){
			var sphere1R=sphere1.radius;
			var sphere2R=sphere2.radius;
			var distance=Vector3.distance(sphere1.center,sphere2.center);
			if (sphere1R+sphere2R < distance)
				return 0;
			if (sphere1R-sphere2R < distance)
				return 2;
			return 1;
		}

		Collision.closestPointPointTriangle=function(point,vertex1,vertex2,vertex3,out){
			Vector3.subtract(vertex2,vertex1,Collision._tempV30);
			Vector3.subtract(vertex3,vertex1,Collision._tempV31);
			Vector3.subtract(point,vertex1,Collision._tempV32);
			Vector3.subtract(point,vertex2,Collision._tempV33);
			Vector3.subtract(point,vertex3,Collision._tempV34);
			var d1=Vector3.dot(Collision._tempV30,Collision._tempV32);
			var d2=Vector3.dot(Collision._tempV31,Collision._tempV32);
			var d3=Vector3.dot(Collision._tempV30,Collision._tempV33);
			var d4=Vector3.dot(Collision._tempV31,Collision._tempV33);
			var d5=Vector3.dot(Collision._tempV30,Collision._tempV34);
			var d6=Vector3.dot(Collision._tempV31,Collision._tempV34);
			if (d1 <=0 && d2 <=0){
				vertex1.cloneTo(out);
				return;
			}
			if (d3 >=0 && d4 <=d3){
				vertex2.cloneTo(out);
				return;
			};
			var vc=d1 *d4-d3 *d2;
			if (vc <=0 && d1 >=0 && d3 <=0){
				var v=d1 / (d1-d3);
				Vector3.scale(Collision._tempV30,v,out);
				Vector3.add(vertex1,out,out);
				return;
			}
			if (d6 >=0 && d5 <=d6){
				vertex3.cloneTo(out);
				return;
			};
			var vb=d5 *d2-d1 *d6;
			if (vb <=0 && d2 >=0 && d6 <=0){
				var w=d2 / (d2-d6);
				Vector3.scale(Collision._tempV31,w,out);
				Vector3.add(vertex1,out,out);
				return;
			};
			var va=d3 *d6-d5 *d4;
			if (va <=0 && (d4-d3)>=0 && (d5-d6)>=0){
				var w3=(d4-d3)/ ((d4-d3)+(d5-d6));
				Vector3.subtract(vertex3,vertex2,out);
				Vector3.scale(out,w3,out);
				Vector3.add(vertex2,out,out);
				return;
			};
			var denom=1 / (va+vb+vc);
			var v2=vb *denom;
			var w2=vc *denom;
			Vector3.scale(Collision._tempV30,v2,Collision._tempV35);
			Vector3.scale(Collision._tempV31,w2,Collision._tempV36);
			Vector3.add(Collision._tempV35,Collision._tempV36,out);
			Vector3.add(vertex1,out,out);
		}

		Collision.closestPointPlanePoint=function(plane,point,out){
			var planeN=plane.normal;
			var t=Vector3.dot(planeN,point)-plane.distance;
			Vector3.scale(planeN,t,Collision._tempV30);
			Vector3.subtract(point,Collision._tempV30,out);
		}

		Collision.closestPointBoxPoint=function(box,point,out){
			Vector3.max(point,box.min,Collision._tempV30);
			Vector3.min(Collision._tempV30,box.max,out);
		}

		Collision.closestPointSpherePoint=function(sphere,point,out){
			var sphereC=sphere.center;
			Vector3.subtract(point,sphereC,out);
			Vector3.normalize(out,out);
			Vector3.scale(out,sphere.radius,out);
			Vector3.add(out,sphereC,out);
		}

		Collision.closestPointSphereSphere=function(sphere1,sphere2,out){
			var sphere1C=sphere1.center;
			Vector3.subtract(sphere2.center,sphere1C,out);
			Vector3.normalize(out,out);
			Vector3.scale(out,sphere1.radius,out);
			Vector3.add(out,sphere1C,out);
		}

		__static(Collision,
		['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();},'_tempV33',function(){return this._tempV33=new Vector3();},'_tempV34',function(){return this._tempV34=new Vector3();},'_tempV35',function(){return this._tempV35=new Vector3();},'_tempV36',function(){return this._tempV36=new Vector3();}
		]);
		return Collision;
	})()


	/**
	*<code>ContainmentType</code> 类用于定义空间物体位置关系。
	*/
	//class laya.d3.math.ContainmentType
	var ContainmentType=(function(){
		function ContainmentType(){};
		__class(ContainmentType,'laya.d3.math.ContainmentType');
		ContainmentType.Disjoint=0;
		ContainmentType.Contains=1;
		ContainmentType.Intersects=2;
		return ContainmentType;
	})()


	/**
	*<code>MathUtils</code> 类用于创建数学工具。
	*/
	//class laya.d3.math.MathUtils3D
	var MathUtils3D=(function(){
		/**
		*创建一个 <code>MathUtils</code> 实例。
		*/
		function MathUtils3D(){}
		__class(MathUtils3D,'laya.d3.math.MathUtils3D');
		MathUtils3D.isZero=function(v){
			return Math.abs(v)< MathUtils3D.zeroTolerance;
		}

		MathUtils3D.nearEqual=function(n1,n2){
			if (MathUtils3D.isZero(n1-n2))
				return true;
			return false;
		}

		MathUtils3D.fastInvSqrt=function(value){
			if (MathUtils3D.isZero(value))
				return value;
			return 1.0 / Math.sqrt(value);
		}

		__static(MathUtils3D,
		['zeroTolerance',function(){return this.zeroTolerance=1e-6;},'MaxValue',function(){return this.MaxValue=3.40282347e+38;},'MinValue',function(){return this.MinValue=-3.40282347e+38;}
		]);
		return MathUtils3D;
	})()


	/**
	*<code>Matrix3x3</code> 类用于创建3x3矩阵。
	*/
	//class laya.d3.math.Matrix3x3
	var Matrix3x3=(function(){
		function Matrix3x3(){
			//this.elements=null;
			var e=this.elements=new Float32Array(9);
			e[0]=1;
			e[1]=0;
			e[2]=0;
			e[3]=0;
			e[4]=1;
			e[5]=0;
			e[6]=0;
			e[7]=0;
			e[8]=1;
		}

		__class(Matrix3x3,'laya.d3.math.Matrix3x3');
		var __proto=Matrix3x3.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*计算3x3矩阵的行列式
		*@return 矩阵的行列式
		*/
		__proto.determinant=function(){
			var f=this.elements;
			var a00=f[0],a01=f[1],a02=f[2];
			var a10=f[3],a11=f[4],a12=f[5];
			var a20=f[6],a21=f[7],a22=f[8];
			return a00 *(a22 *a11-a12 *a21)+a01 *(-a22 *a10+a12 *a20)+a02 *(a21 *a10-a11 *a20);
		}

		/**
		*通过一个二维向量转换3x3矩阵
		*@param tra 转换向量
		*@param out 输出矩阵
		*/
		__proto.translate=function(trans,out){
			var e=out.elements;
			var f=this.elements;
			var g=trans.elements;
			var a00=f[0],a01=f[1],a02=f[2];
			var a10=f[3],a11=f[4],a12=f[5];
			var a20=f[6],a21=f[7],a22=f[8];
			var x=g[0],y=g[1];
			e[0]=a00;
			e[1]=a01;
			e[2]=a02;
			e[3]=a10;
			e[4]=a11;
			e[5]=a12;
			e[6]=x *a00+y *a10+a20;
			e[7]=x *a01+y *a11+a21;
			e[8]=x *a02+y *a12+a22;
		}

		/**
		*根据指定角度旋转3x3矩阵
		*@param rad 旋转角度
		*@param out 输出矩阵
		*/
		__proto.rotate=function(rad,out){
			var e=out.elements;
			var f=this.elements;
			var a00=f[0],a01=f[1],a02=f[2];
			var a10=f[3],a11=f[4],a12=f[5];
			var a20=f[6],a21=f[7],a22=f[8];
			var s=Math.sin(rad);
			var c=Math.cos(rad);
			e[0]=c *a00+s *a10;
			e[1]=c *a01+s *a11;
			e[2]=c *a02+s *a12;
			e[3]=c *a10-s *a00;
			e[4]=c *a11-s *a01;
			e[5]=c *a12-s *a02;
			e[6]=a20;
			e[7]=a21;
			e[8]=a22;
		}

		/**
		*根据制定缩放3x3矩阵
		*@param scale 缩放值
		*@param out 输出矩阵
		*/
		__proto.scale=function(scale,out){
			var e=out.elements;
			var f=this.elements;
			var g=scale.elements;
			var x=g[0],y=g[1];
			e[0]=x *f[0];
			e[1]=x *f[1];
			e[2]=x *f[2];
			e[3]=y *f[3];
			e[4]=y *f[4];
			e[5]=y *f[5];
			e[6]=f[6];
			e[7]=f[7];
			e[8]=f[8];
		}

		/**
		*计算3x3矩阵的逆矩阵
		*@param out 输出的逆矩阵
		*/
		__proto.invert=function(out){
			var e=out.elements;
			var f=this.elements;
			var a00=f[0],a01=f[1],a02=f[2];
			var a10=f[3],a11=f[4],a12=f[5];
			var a20=f[6],a21=f[7],a22=f[8];
			var b01=a22 *a11-a12 *a21;
			var b11=-a22 *a10+a12 *a20;
			var b21=a21 *a10-a11 *a20;
			var det=a00 *b01+a01 *b11+a02 *b21;
			if (!det){
				out=null;
			}
			det=1.0 / det;
			e[0]=b01 *det;
			e[1]=(-a22 *a01+a02 *a21)*det;
			e[2]=(a12 *a01-a02 *a11)*det;
			e[3]=b11 *det;
			e[4]=(a22 *a00-a02 *a20)*det;
			e[5]=(-a12 *a00+a02 *a10)*det;
			e[6]=b21 *det;
			e[7]=(-a21 *a00+a01 *a20)*det;
			e[8]=(a11 *a00-a01 *a10)*det;
		}

		/**
		*计算3x3矩阵的转置矩阵
		*@param out 输出矩阵
		*/
		__proto.transpose=function(out){
			var e=out.elements;
			var f=this.elements;
			if (out===this){
				var a01=f[1],a02=f[2],a12=f[5];
				e[1]=f[3];
				e[2]=f[6];
				e[3]=a01;
				e[5]=f[7];
				e[6]=a02;
				e[7]=a12;
				}else {
				e[0]=f[0];
				e[1]=f[3];
				e[2]=f[6];
				e[3]=f[1];
				e[4]=f[4];
				e[5]=f[7];
				e[6]=f[2];
				e[7]=f[5];
				e[8]=f[8];
			}
		}

		/**设置已有的矩阵为单位矩阵*/
		__proto.identity=function(){
			var e=this.elements;
			e[0]=1;
			e[1]=0;
			e[2]=0;
			e[3]=0;
			e[4]=1;
			e[5]=0;
			e[6]=0;
			e[7]=0;
			e[8]=1;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var i,s,d;
			s=this.elements;
			d=destObject.elements;
			if (s===d){
				return;
			}
			for (i=0;i < 9;++i){
				d[i]=s[i];
			}
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		Matrix3x3.createFromTranslation=function(trans,out){
			var e=out.elements;
			var g=trans.elements;
			out[0]=1;
			out[1]=0;
			out[2]=0;
			out[3]=0;
			out[4]=1;
			out[5]=0;
			out[6]=g[0];
			out[7]=g[1];
			out[8]=1;
		}

		Matrix3x3.createFromRotation=function(rad,out){
			var e=out.elements;
			var s=Math.sin(rad),c=Math.cos(rad);
			e[0]=c;
			e[1]=s;
			e[2]=0;
			e[3]=-s;
			e[4]=c;
			e[5]=0;
			e[6]=0;
			e[7]=0;
			e[8]=1;
		}

		Matrix3x3.createFromScaling=function(scale,out){
			var e=out.elements;
			var g=scale.elements;
			e[0]=g[0];
			e[1]=0;
			e[2]=0;
			e[3]=0;
			e[4]=g[1];
			e[5]=0;
			e[6]=0;
			e[7]=0;
			e[8]=1;
		}

		Matrix3x3.createFromMatrix4x4=function(sou,out){
			out[0]=sou[0];
			out[1]=sou[1];
			out[2]=sou[2];
			out[3]=sou[4];
			out[4]=sou[5];
			out[5]=sou[6];
			out[6]=sou[8];
			out[7]=sou[9];
			out[8]=sou[10];
		}

		Matrix3x3.multiply=function(left,right,out){
			var e=out.elements;
			var f=left.elements;
			var g=right.elements;
			var a00=f[0],a01=f[1],a02=f[2];
			var a10=f[3],a11=f[4],a12=f[5];
			var a20=f[6],a21=f[7],a22=f[8];
			var b00=g[0],b01=g[1],b02=g[2];
			var b10=g[3],b11=g[4],b12=g[5];
			var b20=g[6],b21=g[7],b22=g[8];
			e[0]=b00 *a00+b01 *a10+b02 *a20;
			e[1]=b00 *a01+b01 *a11+b02 *a21;
			e[2]=b00 *a02+b01 *a12+b02 *a22;
			e[3]=b10 *a00+b11 *a10+b12 *a20;
			e[4]=b10 *a01+b11 *a11+b12 *a21;
			e[5]=b10 *a02+b11 *a12+b12 *a22;
			e[6]=b20 *a00+b21 *a10+b22 *a20;
			e[7]=b20 *a01+b21 *a11+b22 *a21;
			e[8]=b20 *a02+b21 *a12+b22 *a22;
		}

		Matrix3x3.lookAt=function(eye,target,up,out){
			Vector3.subtract(eye,target,Matrix3x3._tempV30);
			Vector3.normalize(Matrix3x3._tempV30,Matrix3x3._tempV30);
			Vector3.cross(up,Matrix3x3._tempV30,Matrix3x3._tempV31);
			Vector3.normalize(Matrix3x3._tempV31,Matrix3x3._tempV31);
			Vector3.cross(Matrix3x3._tempV30,Matrix3x3._tempV31,Matrix3x3._tempV32);
			var v0e=Matrix3x3._tempV30.elements;
			var v1e=Matrix3x3._tempV31.elements;
			var v2e=Matrix3x3._tempV32.elements;
			var me=out.elements;
			me[0]=v1e[0];
			me[3]=v1e[1];
			me[6]=v1e[2];
			me[1]=v2e[0];
			me[4]=v2e[1];
			me[7]=v2e[2];
			me[2]=v0e[0];
			me[5]=v0e[1];
			me[8]=v0e[2];
		}

		Matrix3x3.DEFAULT=new Matrix3x3();
		__static(Matrix3x3,
		['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();}
		]);
		return Matrix3x3;
	})()


	/**
	*<code>Matrix4x4</code> 类用于创建4x4矩阵。
	*/
	//class laya.d3.math.Matrix4x4
	var Matrix4x4=(function(){
		function Matrix4x4(m11,m12,m13,m14,m21,m22,m23,m24,m31,m32,m33,m34,m41,m42,m43,m44,elements){
			//this.elements=null;
			(m11===void 0)&& (m11=1);
			(m12===void 0)&& (m12=0);
			(m13===void 0)&& (m13=0);
			(m14===void 0)&& (m14=0);
			(m21===void 0)&& (m21=0);
			(m22===void 0)&& (m22=1);
			(m23===void 0)&& (m23=0);
			(m24===void 0)&& (m24=0);
			(m31===void 0)&& (m31=0);
			(m32===void 0)&& (m32=0);
			(m33===void 0)&& (m33=1);
			(m34===void 0)&& (m34=0);
			(m41===void 0)&& (m41=0);
			(m42===void 0)&& (m42=0);
			(m43===void 0)&& (m43=0);
			(m44===void 0)&& (m44=1);
			var e=elements ? this.elements=elements :this.elements=new Float32Array(16);
			e[0]=m11;
			e[1]=m12;
			e[2]=m13;
			e[3]=m14;
			e[4]=m21;
			e[5]=m22;
			e[6]=m23;
			e[7]=m24;
			e[8]=m31;
			e[9]=m32;
			e[10]=m33;
			e[11]=m34;
			e[12]=m41;
			e[13]=m42;
			e[14]=m43;
			e[15]=m44;
		}

		__class(Matrix4x4,'laya.d3.math.Matrix4x4');
		var __proto=Matrix4x4.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		__proto.getElementByRowColumn=function(row,column){
			if (row < 0 || row > 3)
				throw new Error("row","Rows and columns for matrices run from 0 to 3, inclusive.");
			if (column < 0 || column > 3)
				throw new Error("column","Rows and columns for matrices run from 0 to 3, inclusive.");
			return this.elements[(row *4)+column];
		}

		__proto.setElementByRowColumn=function(row,column,value){
			if (row < 0 || row > 3)
				throw new Error("row","Rows and columns for matrices run from 0 to 3, inclusive.");
			if (column < 0 || column > 3)
				throw new Error("column","Rows and columns for matrices run from 0 to 3, inclusive.");
			this.elements[(row *4)+column]=value;
		}

		/**
		*判断两个4x4矩阵的值是否相等。
		*@param other 4x4矩阵
		*/
		__proto.equalsOtherMatrix=function(other){
			var e=this.elements;
			var oe=other.elements;
			return (MathUtils3D.nearEqual(e[0],oe[0])&& MathUtils3D.nearEqual(e[1],oe[1])&& MathUtils3D.nearEqual(e[2],oe[2])&& MathUtils3D.nearEqual(e[3],oe[3])&& MathUtils3D.nearEqual(e[4],oe[4])&& MathUtils3D.nearEqual(e[5],oe[5])&& MathUtils3D.nearEqual(e[6],oe[6])&& MathUtils3D.nearEqual(e[7],oe[7])&& MathUtils3D.nearEqual(e[8],oe[8])&& MathUtils3D.nearEqual(e[9],oe[9])&& MathUtils3D.nearEqual(e[10],oe[10])&& MathUtils3D.nearEqual(e[11],oe[11])&& MathUtils3D.nearEqual(e[12],oe[12])&& MathUtils3D.nearEqual(e[13],oe[13])&& MathUtils3D.nearEqual(e[14],oe[14])&& MathUtils3D.nearEqual(e[15],oe[15]));
		}

		/**
		*分解矩阵为平移向量、旋转四元数、缩放向量。
		*@param translation 平移向量。
		*@param rotation 旋转四元数。
		*@param scale 缩放向量。
		*@return 是否分解成功。
		*/
		__proto.decomposeTransRotScale=function(translation,rotation,scale){
			var rotationMatrix=Matrix4x4._tempMatrix4x4;
			if (this.decomposeTransRotMatScale(translation,rotationMatrix,scale)){
				Quaternion.createFromMatrix4x4(rotationMatrix,rotation);
				return true;
				}else {
				rotation.identity();
				return false;
			}
		}

		/**
		*分解矩阵为平移向量、旋转矩阵、缩放向量。
		*@param translation 平移向量。
		*@param rotationMatrix 旋转矩阵。
		*@param scale 缩放向量。
		*@return 是否分解成功。
		*/
		__proto.decomposeTransRotMatScale=function(translation,rotationMatrix,scale){
			var e=this.elements;
			var te=translation.elements;
			var re=rotationMatrix.elements;
			var se=scale.elements;
			te[0]=e[12];
			te[1]=e[13];
			te[2]=e[14];
			var m11=e[0],m12=e[1],m13=e[2];
			var m21=e[4],m22=e[5],m23=e[6];
			var m31=e[8],m32=e[9],m33=e[10];
			var sX=se[0]=Math.sqrt((m11 *m11)+(m12 *m12)+(m13 *m13));
			var sY=se[1]=Math.sqrt((m21 *m21)+(m22 *m22)+(m23 *m23));
			var sZ=se[2]=Math.sqrt((m31 *m31)+(m32 *m32)+(m33 *m33));
			if (MathUtils3D.isZero(sX)|| MathUtils3D.isZero(sY)|| MathUtils3D.isZero(sZ)){
				re[1]=re[2]=re[3]=re[4]=re[6]=re[7]=re[8]=re[9]=re[11]=re[12]=re[13]=re[14]=0;
				re[0]=re[5]=re[10]=re[15]=1;
				return false;
			};
			var at=Matrix4x4._tempVector0;
			var atE=at.elements;
			atE[0]=m31 / sZ;
			atE[1]=m32 / sZ;
			atE[2]=m33 / sZ;
			var tempRight=Matrix4x4._tempVector1;
			var tempRightE=tempRight.elements;
			tempRightE[0]=m11 / sX;
			tempRightE[1]=m12 / sX;
			tempRightE[2]=m13 / sX;
			var up=Matrix4x4._tempVector2;
			Vector3.cross(at,tempRight,up);
			var right=Matrix4x4._tempVector1;
			Vector3.cross(up,at,right);
			re[3]=re[7]=re[11]=re[12]=re[13]=re[14]=0;
			re[15]=1;
			re[0]=right.x;
			re[1]=right.y;
			re[2]=right.z;
			re[4]=up.x;
			re[5]=up.y;
			re[6]=up.z;
			re[8]=at.x;
			re[9]=at.y;
			re[10]=at.z;
			((re[0] *m11+re[1] *m12+re[2] *m13)< 0.0)&& (se[0]=-sX);
			((re[4] *m21+re[5] *m22+re[6] *m23)< 0.0)&& (se[1]=-sY);
			((re[8] *m31+re[9] *m32+re[10] *m33)< 0.0)&& (se[2]=-sZ);
			return true;
		}

		/**
		*分解旋转矩阵的旋转为YawPitchRoll欧拉角。
		*@param out float yaw
		*@param out float pitch
		*@param out float roll
		*@return
		*/
		__proto.decomposeYawPitchRoll=function(yawPitchRoll){
			var yawPitchRollE=yawPitchRoll.elements;
			var pitch=Math.asin(-this.elements[9]);
			yawPitchRollE[1]=pitch;
			var test=Math.cos(pitch);
			if (test > MathUtils3D.zeroTolerance){
				yawPitchRollE[2]=Math.atan2(this.elements[1],this.elements[5]);
				yawPitchRollE[0]=Math.atan2(this.elements[8],this.elements[10]);
				}else {
				yawPitchRollE[2]=Math.atan2(-this.elements[4],this.elements[0]);
				yawPitchRollE[0]=0.0;
			}
		}

		/**归一化矩阵 */
		__proto.normalize=function(){
			var v=this.elements;
			var c=v[0],d=v[1],e=v[2],g=Math.sqrt(c *c+d *d+e *e);
			if (g){
				if (g==1)
					return;
				}else {
				v[0]=0;
				v[1]=0;
				v[2]=0;
				return;
			}
			g=1 / g;
			v[0]=c *g;
			v[1]=d *g;
			v[2]=e *g;
		}

		/**计算矩阵的转置矩阵*/
		__proto.transpose=function(){
			var e,t;
			e=this.elements;
			t=e[1];
			e[1]=e[4];
			e[4]=t;
			t=e[2];
			e[2]=e[8];
			e[8]=t;
			t=e[3];
			e[3]=e[12];
			e[12]=t;
			t=e[6];
			e[6]=e[9];
			e[9]=t;
			t=e[7];
			e[7]=e[13];
			e[13]=t;
			t=e[11];
			e[11]=e[14];
			e[14]=t;
			return this;
		}

		/**
		*计算一个矩阵的逆矩阵
		*@param out 输出矩阵
		*/
		__proto.invert=function(out){
			var ae=this.elements;
			var oe=out.elements;
			var a00=ae[0],a01=ae[1],a02=ae[2],a03=ae[3],a10=ae[4],a11=ae[5],a12=ae[6],a13=ae[7],a20=ae[8],a21=ae[9],a22=ae[10],a23=ae[11],a30=ae[12],a31=ae[13],a32=ae[14],a33=ae[15],
			b00=a00 *a11-a01 *a10,b01=a00 *a12-a02 *a10,b02=a00 *a13-a03 *a10,b03=a01 *a12-a02 *a11,b04=a01 *a13-a03 *a11,b05=a02 *a13-a03 *a12,b06=a20 *a31-a21 *a30,b07=a20 *a32-a22 *a30,b08=a20 *a33-a23 *a30,b09=a21 *a32-a22 *a31,b10=a21 *a33-a23 *a31,b11=a22 *a33-a23 *a32,
			det=b00 *b11-b01 *b10+b02 *b09+b03 *b08-b04 *b07+b05 *b06;
			if (Math.abs(det)===0.0){
				return;
			}
			det=1.0 / det;
			oe[0]=(a11 *b11-a12 *b10+a13 *b09)*det;
			oe[1]=(a02 *b10-a01 *b11-a03 *b09)*det;
			oe[2]=(a31 *b05-a32 *b04+a33 *b03)*det;
			oe[3]=(a22 *b04-a21 *b05-a23 *b03)*det;
			oe[4]=(a12 *b08-a10 *b11-a13 *b07)*det;
			oe[5]=(a00 *b11-a02 *b08+a03 *b07)*det;
			oe[6]=(a32 *b02-a30 *b05-a33 *b01)*det;
			oe[7]=(a20 *b05-a22 *b02+a23 *b01)*det;
			oe[8]=(a10 *b10-a11 *b08+a13 *b06)*det;
			oe[9]=(a01 *b08-a00 *b10-a03 *b06)*det;
			oe[10]=(a30 *b04-a31 *b02+a33 *b00)*det;
			oe[11]=(a21 *b02-a20 *b04-a23 *b00)*det;
			oe[12]=(a11 *b07-a10 *b09-a12 *b06)*det;
			oe[13]=(a00 *b09-a01 *b07+a02 *b06)*det;
			oe[14]=(a31 *b01-a30 *b03-a32 *b00)*det;
			oe[15]=(a20 *b03-a21 *b01+a22 *b00)*det;
		}

		/**设置矩阵为单位矩阵*/
		__proto.identity=function(){
			var e=this.elements;
			e[1]=e[2]=e[3]=e[4]=e[6]=e[7]=e[8]=e[9]=e[11]=e[12]=e[13]=e[14]=0;
			e[0]=e[5]=e[10]=e[15]=1;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var i,s,d;
			s=this.elements;
			d=destObject.elements;
			if (s===d){
				return;
			}
			for (i=0;i < 16;++i){
				d[i]=s[i];
			}
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		/**
		*获取平移向量。
		*@param out 平移向量。
		*/
		__proto.getTranslationVector=function(out){
			var me=this.elements;
			var te=out.elements;
			te[0]=me[12];
			te[1]=me[13];
			te[2]=me[14];
		}

		/**
		*设置平移向量。
		*@param translate 平移向量。
		*/
		__proto.setTranslationVector=function(translate){
			var me=this.elements;
			var ve=translate.elements;
			me[12]=ve[0];
			me[13]=ve[1];
			me[14]=ve[2];
		}

		/**
		*获取前向量。
		*@param out 前向量。
		*/
		__proto.getForward=function(out){
			var me=this.elements;
			var te=out.elements;
			te[0]=-me[8];
			te[1]=-me[9];
			te[2]=-me[10];
		}

		/**
		*设置前向量。
		*@param forward 前向量。
		*/
		__proto.setForward=function(forward){
			var me=this.elements;
			var ve=forward.elements;
			me[8]=-ve[0];
			me[9]=-ve[1];
			me[10]=-ve[2];
		}

		Matrix4x4.createRotationX=function(rad,out){
			var oe=out.elements;
			var s=Math.sin(rad),c=Math.cos(rad);
			oe[1]=oe[2]=oe[3]=oe[4]=oe[7]=oe[8]=oe[11]=oe[12]=oe[13]=oe[14]=0;
			oe[0]=oe[15]=1;
			oe[5]=oe[10]=c;
			oe[6]=s;
			oe[9]=-s;
		}

		Matrix4x4.createRotationY=function(rad,out){
			var oe=out.elements;
			var s=Math.sin(rad),c=Math.cos(rad);
			oe[1]=oe[3]=oe[4]=oe[6]=oe[7]=oe[9]=oe[11]=oe[12]=oe[13]=oe[14]=0;
			oe[5]=oe[15]=1;
			oe[0]=oe[10]=c;
			oe[2]=-s;
			oe[8]=s;
		}

		Matrix4x4.createRotationZ=function(rad,out){
			var oe=out.elements;
			var s=Math.sin(rad),c=Math.cos(rad);
			oe[2]=oe[3]=oe[6]=oe[7]=oe[8]=oe[9]=oe[11]=oe[12]=oe[13]=oe[14]=0;
			oe[10]=oe[15]=1;
			oe[0]=oe[5]=c;
			oe[1]=s;
			oe[4]=-s;
		}

		Matrix4x4.createRotationYawPitchRoll=function(yaw,pitch,roll,result){
			Quaternion.createFromYawPitchRoll(yaw,pitch,roll,Matrix4x4._tempQuaternion);
			Matrix4x4.createRotationQuaternion(Matrix4x4._tempQuaternion,result);
		}

		Matrix4x4.createRotationAxis=function(axis,angle,result){
			var axisE=axis.elements;
			var x=axisE[0];
			var y=axisE[1];
			var z=axisE[2];
			var cos=Math.cos(angle);
			var sin=Math.sin(angle);
			var xx=x *x;
			var yy=y *y;
			var zz=z *z;
			var xy=x *y;
			var xz=x *z;
			var yz=y *z;
			var resultE=result.elements;
			resultE[3]=resultE[7]=resultE[11]=resultE[12]=resultE[13]=resultE[14]=0;
			resultE[15]=1.0;
			resultE[0]=xx+(cos *(1.0-xx));
			resultE[1]=(xy-(cos *xy))+(sin *z);
			resultE[2]=(xz-(cos *xz))-(sin *y);
			resultE[4]=(xy-(cos *xy))-(sin *z);
			resultE[5]=yy+(cos *(1.0-yy));
			resultE[6]=(yz-(cos *yz))+(sin *x);
			resultE[8]=(xz-(cos *xz))+(sin *y);
			resultE[9]=(yz-(cos *yz))-(sin *x);
			resultE[10]=zz+(cos *(1.0-zz));
		}

		Matrix4x4.createRotationQuaternion=function(rotation,result){
			var rotationE=rotation.elements;
			var resultE=result.elements;
			var rotationX=rotationE[0];
			var rotationY=rotationE[1];
			var rotationZ=rotationE[2];
			var rotationW=rotationE[3];
			var xx=rotationX *rotationX;
			var yy=rotationY *rotationY;
			var zz=rotationZ *rotationZ;
			var xy=rotationX *rotationY;
			var zw=rotationZ *rotationW;
			var zx=rotationZ *rotationX;
			var yw=rotationY *rotationW;
			var yz=rotationY *rotationZ;
			var xw=rotationX *rotationW;
			resultE[3]=resultE[7]=resultE[11]=resultE[12]=resultE[13]=resultE[14]=0;
			resultE[15]=1.0;
			resultE[0]=1.0-(2.0 *(yy+zz));
			resultE[1]=2.0 *(xy+zw);
			resultE[2]=2.0 *(zx-yw);
			resultE[4]=2.0 *(xy-zw);
			resultE[5]=1.0-(2.0 *(zz+xx));
			resultE[6]=2.0 *(yz+xw);
			resultE[8]=2.0 *(zx+yw);
			resultE[9]=2.0 *(yz-xw);
			resultE[10]=1.0-(2.0 *(yy+xx));
		}

		Matrix4x4.createTranslate=function(trans,out){
			var te=trans.elements;
			var oe=out.elements;
			oe[4]=oe[8]=oe[1]=oe[9]=oe[2]=oe[6]=oe[3]=oe[7]=oe[11]=0;
			oe[0]=oe[5]=oe[10]=oe[15]=1;
			oe[12]=te[0];
			oe[13]=te[1];
			oe[14]=te[2];
		}

		Matrix4x4.createScaling=function(scale,out){
			var se=scale.elements;
			var oe=out.elements;
			oe[0]=se[0];
			oe[5]=se[1];
			oe[10]=se[2];
			oe[1]=oe[4]=oe[8]=oe[12]=oe[9]=oe[13]=oe[2]=oe[6]=oe[14]=oe[3]=oe[7]=oe[11]=0;
			oe[15]=1;
		}

		Matrix4x4.multiply=function(left,right,out){
			var i,e,a,b,ai0,ai1,ai2,ai3;
			e=out.elements;
			a=left.elements;
			b=right.elements;
			if (e===b){
				b=new Float32Array(16);
				for (i=0;i < 16;++i){
					b[i]=e[i];
				}
			};
			var b0=b[0],b1=b[1],b2=b[2],b3=b[3];
			var b4=b[4],b5=b[5],b6=b[6],b7=b[7];
			var b8=b[8],b9=b[9],b10=b[10],b11=b[11];
			var b12=b[12],b13=b[13],b14=b[14],b15=b[15];
			for (i=0;i < 4;i++){
				ai0=a[i];
				ai1=a[i+4];
				ai2=a[i+8];
				ai3=a[i+12];
				e[i]=ai0 *b0+ai1 *b1+ai2 *b2+ai3 *b3;
				e[i+4]=ai0 *b4+ai1 *b5+ai2 *b6+ai3 *b7;
				e[i+8]=ai0 *b8+ai1 *b9+ai2 *b10+ai3 *b11;
				e[i+12]=ai0 *b12+ai1 *b13+ai2 *b14+ai3 *b15;
			}
		}

		Matrix4x4.multiplyForNative=function(left,right,out){
			window.conch.matrix4x4Multiply(left.elements,right.elements,out.elements);
		}

		Matrix4x4.createFromQuaternion=function(rotation,out){
			var e=out.elements;
			var q=rotation.elements;
			var x=q[0],y=q[1],z=q[2],w=q[3];
			var x2=x+x;
			var y2=y+y;
			var z2=z+z;
			var xx=x *x2;
			var yx=y *x2;
			var yy=y *y2;
			var zx=z *x2;
			var zy=z *y2;
			var zz=z *z2;
			var wx=w *x2;
			var wy=w *y2;
			var wz=w *z2;
			e[0]=1-yy-zz;
			e[1]=yx+wz;
			e[2]=zx-wy;
			e[3]=0;
			e[4]=yx-wz;
			e[5]=1-xx-zz;
			e[6]=zy+wx;
			e[7]=0;
			e[8]=zx+wy;
			e[9]=zy-wx;
			e[10]=1-xx-yy;
			e[11]=0;
			e[12]=0;
			e[13]=0;
			e[14]=0;
			e[15]=1;
		}

		Matrix4x4.createAffineTransformation=function(trans,rot,scale,out){
			var te=trans.elements;
			var re=rot.elements;
			var se=scale.elements;
			var oe=out.elements;
			var x=re[0],y=re[1],z=re[2],w=re[3],x2=x+x,y2=y+y,z2=z+z;
			var xx=x *x2,xy=x *y2,xz=x *z2,yy=y *y2,yz=y *z2,zz=z *z2;
			var wx=w *x2,wy=w *y2,wz=w *z2,sx=se[0],sy=se[1],sz=se[2];
			oe[0]=(1-(yy+zz))*sx;
			oe[1]=(xy+wz)*sx;
			oe[2]=(xz-wy)*sx;
			oe[3]=0;
			oe[4]=(xy-wz)*sy;
			oe[5]=(1-(xx+zz))*sy;
			oe[6]=(yz+wx)*sy;
			oe[7]=0;
			oe[8]=(xz+wy)*sz;
			oe[9]=(yz-wx)*sz;
			oe[10]=(1-(xx+yy))*sz;
			oe[11]=0;
			oe[12]=te[0];
			oe[13]=te[1];
			oe[14]=te[2];
			oe[15]=1;
		}

		Matrix4x4.createLookAt=function(eye,target,up,out){
			var oE=out.elements;
			var xaxis=Matrix4x4._tempVector0;
			var yaxis=Matrix4x4._tempVector1;
			var zaxis=Matrix4x4._tempVector2;
			Vector3.subtract(eye,target,zaxis);
			Vector3.normalize(zaxis,zaxis);
			Vector3.cross(up,zaxis,xaxis);
			Vector3.normalize(xaxis,xaxis);
			Vector3.cross(zaxis,xaxis,yaxis);
			out.identity();
			oE[0]=xaxis.x;
			oE[4]=xaxis.y;
			oE[8]=xaxis.z;
			oE[1]=yaxis.x;
			oE[5]=yaxis.y;
			oE[9]=yaxis.z;
			oE[2]=zaxis.x;
			oE[6]=zaxis.y;
			oE[10]=zaxis.z;
			oE[12]=-Vector3.dot(xaxis,eye);
			oE[13]=-Vector3.dot(yaxis,eye);
			oE[14]=-Vector3.dot(zaxis,eye);
		}

		Matrix4x4.createPerspective=function(fov,aspect,near,far,out){
			var oe=out.elements;
			var f=1.0 / Math.tan(fov / 2),nf=1 / (near-far);
			oe[0]=f / aspect;
			oe[5]=f;
			oe[10]=(far+near)*nf;
			oe[11]=-1;
			oe[14]=(2 *far *near)*nf;
			oe[1]=oe[2]=oe[3]=oe[4]=oe[6]=oe[7]=oe[8]=oe[9]=oe[12]=oe[13]=oe[15]=0;
		}

		Matrix4x4.createOrthoOffCenterRH=function(left,right,bottom,top,near,far,out){
			var oe=out.elements;
			var lr=1 / (left-right);
			var bt=1 / (bottom-top);
			var nf=1 / (near-far);
			oe[1]=oe[2]=oe[3]=oe[4]=oe[6]=oe[7]=oe[8]=oe[9]=oe[11]=0;
			oe[15]=1;
			oe[0]=-2 *lr;
			oe[5]=-2 *bt;
			oe[10]=2 *nf;
			oe[12]=(left+right)*lr;
			oe[13]=(top+bottom)*bt;
			oe[14]=(far+near)*nf;
		}

		Matrix4x4.translation=function(v3,out){
			var ve=v3.elements;
			var oe=out.elements;
			oe[0]=oe[5]=oe[10]=oe[15]=1;
			oe[12]=ve[0];
			oe[13]=ve[1];
			oe[14]=ve[2];
		}

		__static(Matrix4x4,
		['_tempMatrix4x4',function(){return this._tempMatrix4x4=new Matrix4x4();},'_tempVector0',function(){return this._tempVector0=new Vector3();},'_tempVector1',function(){return this._tempVector1=new Vector3();},'_tempVector2',function(){return this._tempVector2=new Vector3();},'_tempQuaternion',function(){return this._tempQuaternion=new Quaternion();},'DEFAULT',function(){return this.DEFAULT=new Matrix4x4();},'ZERO',function(){return this.ZERO=new Matrix4x4(
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0);}
		]);
		return Matrix4x4;
	})()


	/**
	*<code>OrientedBoundBox</code> 类用于创建OBB包围盒。
	*/
	//class laya.d3.math.OrientedBoundBox
	var OrientedBoundBox=(function(){
		function OrientedBoundBox(extents,transformation){
			this.extents=null;
			this.transformation=null;
			this.extents=extents;
			this.transformation=transformation;
		}

		__class(OrientedBoundBox,'laya.d3.math.OrientedBoundBox');
		var __proto=OrientedBoundBox.prototype;
		/**
		*获取OBB包围盒的8个顶点。
		*@param corners 返回顶点的输出队列。
		*/
		__proto.getCorners=function(corners){
			var xve=OrientedBoundBox._tempV30.elements;
			var yve=OrientedBoundBox._tempV31.elements;
			var zve=OrientedBoundBox._tempV32.elements;
			var extentsE=this.extents.elements;
			xve[0]=extentsE[0];
			xve[1]=xve[2]=0;
			yve[1]=extentsE[1];
			yve[0]=yve[2]=0;
			zve[2]=extentsE[2];
			zve[0]=zve[1]=0;
			Vector3.TransformNormal(OrientedBoundBox._tempV30,this.transformation,OrientedBoundBox._tempV30);
			Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV31);
			Vector3.TransformNormal(OrientedBoundBox._tempV32,this.transformation,OrientedBoundBox._tempV32);
			var center=OrientedBoundBox._tempV33;
			this.transformation.getTranslationVector(center);
			corners.length=8;
			Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[0]);
			Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[1]);
			Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[2]);
			Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[3]);
			Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[4]);
			Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[5]);
			Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[6]);
			Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[7]);
		}

		/**
		*变换该包围盒的矩阵信息。
		*@param mat 矩阵
		*/
		__proto.transform=function(mat){
			Matrix4x4.multiply(this.transformation,mat,this.transformation);
		}

		/**
		*缩放该包围盒
		*@param scaling 各轴的缩放比。
		*/
		__proto.scale=function(scaling){
			Vector3.multiply(this.extents,scaling,this.extents);
		}

		/**
		*平移该包围盒。
		*@param translation 平移参数
		*/
		__proto.translate=function(translation){
			this.transformation.getTranslationVector(OrientedBoundBox._tempV30);
			Vector3.add(OrientedBoundBox._tempV30,translation,OrientedBoundBox._tempV31);
			this.transformation.setTranslationVector(OrientedBoundBox._tempV31);
		}

		/**
		*该包围盒的尺寸。
		*@param out 输出
		*/
		__proto.Size=function(out){
			Vector3.scale(this.extents,2,out);
		}

		/**
		*该包围盒需要考虑的尺寸
		*@param out 输出
		*/
		__proto.getSize=function(out){
			var extentsE=this.extents.elements;
			OrientedBoundBox._tempV30.x=extentsE[0];
			OrientedBoundBox._tempV31.y=extentsE[1];
			OrientedBoundBox._tempV32.z=extentsE[2];
			Vector3.TransformNormal(OrientedBoundBox._tempV30,this.transformation,OrientedBoundBox._tempV30);
			Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV31);
			Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV32);
			var oe=out.elements;
			oe[0]=Vector3.scalarLength(OrientedBoundBox._tempV30);
			oe[1]=Vector3.scalarLength(OrientedBoundBox._tempV31);
			oe[2]=Vector3.scalarLength(OrientedBoundBox._tempV32);
		}

		/**
		*该包围盒需要考虑尺寸的平方
		*@param out 输出
		*/
		__proto.getSizeSquared=function(out){
			var extentsE=this.extents.elements;
			OrientedBoundBox._tempV30.x=extentsE[0];
			OrientedBoundBox._tempV31.y=extentsE[1];
			OrientedBoundBox._tempV32.z=extentsE[2];
			Vector3.TransformNormal(OrientedBoundBox._tempV30,this.transformation,OrientedBoundBox._tempV30);
			Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV31);
			Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV32);
			var oe=out.elements;
			oe[0]=Vector3.scalarLengthSquared(OrientedBoundBox._tempV30);
			oe[1]=Vector3.scalarLengthSquared(OrientedBoundBox._tempV31);
			oe[2]=Vector3.scalarLengthSquared(OrientedBoundBox._tempV32);
		}

		/**
		*该包围盒的几何中心
		*/
		__proto.getCenter=function(center){
			this.transformation.getTranslationVector(center);
		}

		/**
		*该包围盒是否包含空间中一点
		*@param point 点
		*@return 返回位置关系
		*/
		__proto.containsPoint=function(point){
			var extentsE=this.extents.elements;
			var extentsEX=extentsE[0];
			var extentsEY=extentsE[1];
			var extentsEZ=extentsE[2];
			this.transformation.invert(OrientedBoundBox._tempM0);
			Vector3.transformCoordinate(point,OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
			var _tempV30e=OrientedBoundBox._tempV30.elements;
			var _tempV30ex=Math.abs(_tempV30e[0]);
			var _tempV30ey=Math.abs(_tempV30e[1]);
			var _tempV30ez=Math.abs(_tempV30e[2]);
			if (MathUtils3D.nearEqual(_tempV30ex,extentsEX)&& MathUtils3D.nearEqual(_tempV30ey,extentsEY)&& MathUtils3D.nearEqual(_tempV30ez,extentsEZ))
				return 2;
			if (_tempV30ex < extentsEX && _tempV30ey < extentsEY && _tempV30ez < extentsEZ)
				return 1;
			else
			return 0;
		}

		/**
		*该包围盒是否包含空间中多点
		*@param point 点
		*@return 返回位置关系
		*/
		__proto.containsPoints=function(points){
			var extentse=this.extents.elements;
			var extentsex=extentse[0];
			var extentsey=extentse[1];
			var extentsez=extentse[2];
			this.transformation.invert(OrientedBoundBox._tempM0);
			var containsAll=true;
			var containsAny=false;
			for (var i=0;i < points.length;i++){
				Vector3.transformCoordinate(points[i],OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
				var _tempV30e=OrientedBoundBox._tempV30.elements;
				var _tempV30ex=Math.abs(_tempV30e[0]);
				var _tempV30ey=Math.abs(_tempV30e[1]);
				var _tempV30ez=Math.abs(_tempV30e[2]);
				if (MathUtils3D.nearEqual(_tempV30ex,extentsex)&& MathUtils3D.nearEqual(_tempV30ey,extentsey)&& MathUtils3D.nearEqual(_tempV30ez,extentsez))
					containsAny=true;
				if (_tempV30ex < extentsex && _tempV30ey < extentsey && extentsez < _tempV30ez)
					containsAny=true;
				else
				containsAll=false;
			}
			if (containsAll)
				return 1;
			else if (containsAny)
			return 2;
			else
			return 0;
		}

		/**
		*该包围盒是否包含空间中一包围球
		*@param sphere 包围球
		*@param ignoreScale 是否考虑该包围盒的缩放
		*@return 返回位置关系
		*/
		__proto.containsSphere=function(sphere,ignoreScale){
			(ignoreScale===void 0)&& (ignoreScale=false);
			var extentsE=this.extents.elements;
			var extentsEX=extentsE[0];
			var extentsEY=extentsE[1];
			var extentsEZ=extentsE[2];
			var sphereR=sphere.radius;
			this.transformation.invert(OrientedBoundBox._tempM0);
			Vector3.transformCoordinate(sphere.center,OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
			var locRadius=NaN;
			if (ignoreScale){
				locRadius=sphereR;
				}else {
				Vector3.scale(Vector3.UnitX,sphereR,OrientedBoundBox._tempV31);
				Vector3.TransformNormal(OrientedBoundBox._tempV31,OrientedBoundBox._tempM0,OrientedBoundBox._tempV31);
				locRadius=Vector3.scalarLength(OrientedBoundBox._tempV31);
			}
			Vector3.scale(this.extents,-1,OrientedBoundBox._tempV32);
			Vector3.Clamp(OrientedBoundBox._tempV30,OrientedBoundBox._tempV32,this.extents,OrientedBoundBox._tempV33);
			var distance=Vector3.distanceSquared(OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
			if (distance > locRadius *locRadius)
				return 0;
			var tempV30e=OrientedBoundBox._tempV30.elements;
			var tempV30ex=tempV30e[0];
			var tempV30ey=tempV30e[1];
			var tempV30ez=tempV30e[2];
			var tempV32e=OrientedBoundBox._tempV32.elements;
			var tempV32ex=tempV32e[0];
			var tempV32ey=tempV32e[1];
			var tempV32ez=tempV32e[2];
			if ((((tempV32ex+locRadius <=tempV30ex)&& (tempV30ex <=extentsEX-locRadius))&& ((extentsEX-tempV32ex > locRadius)&& (tempV32ey+locRadius <=tempV30ey)))&& (((tempV30ey <=extentsEY-locRadius)&& (extentsEY-tempV32ey > locRadius))&& (((tempV32ez+locRadius <=tempV30ez)&& (tempV30ez <=extentsEZ-locRadius))&& (extentsEZ-tempV32ez > locRadius)))){
				return 1;
			}
			return 2;
		}

		/**
		*该包围盒是否包含空间中另一OBB包围盒
		*@param obb OBB包围盒
		*@return 返回位置关系
		*/
		__proto.containsOrientedBoundBox=function(obb){
			var i=0,k=0;
			obb.getCorners(OrientedBoundBox._corners);
			var cornersCheck=this.containsPoints(OrientedBoundBox._corners);
			if (cornersCheck !=0)
				return cornersCheck;
			var sizeAe=this.extents.elements;
			obb.extents.cloneTo(OrientedBoundBox._tempV35);
			var sizeBe=OrientedBoundBox._tempV35.elements;
			OrientedBoundBox._getRows(this.transformation,OrientedBoundBox._rows1);
			OrientedBoundBox._getRows(obb.transformation,OrientedBoundBox._rows2);
			var extentA=NaN,extentB=NaN,separation=NaN,dotNumber=NaN;
			for (i=0;i < 4;i++){
				for (k=0;k < 4;k++){
					if (i==3 || k==3){
						OrientedBoundBox._tempM0.setElementByRowColumn(i,k,0);
						OrientedBoundBox._tempM1.setElementByRowColumn(i,k,0);
						}else {
						dotNumber=Vector3.dot(OrientedBoundBox._rows1[i],OrientedBoundBox._rows2[k]);
						OrientedBoundBox._tempM0.setElementByRowColumn(i,k,dotNumber);
						OrientedBoundBox._tempM1.setElementByRowColumn(i,k,Math.abs(dotNumber));
					}
				}
			}
			obb.getCenter(OrientedBoundBox._tempV34);
			this.getCenter(OrientedBoundBox._tempV36);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV36,OrientedBoundBox._tempV30);
			var vsepAe=OrientedBoundBox._tempV31.elements;
			vsepAe[0]=Vector3.dot(OrientedBoundBox._tempV30,OrientedBoundBox._rows1[0]);
			vsepAe[1]=Vector3.dot(OrientedBoundBox._tempV30,OrientedBoundBox._rows1[1]);
			vsepAe[2]=Vector3.dot(OrientedBoundBox._tempV30,OrientedBoundBox._rows1[2]);
			var _tempV32e=OrientedBoundBox._tempV32.elements;
			var _tempV33e=OrientedBoundBox._tempV33.elements;
			for (i=0;i < 3;i++){
				_tempV32e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(i,0);
				_tempV32e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(i,1);
				_tempV32e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(i,2);
				extentA=sizeAe[i];
				extentB=Vector3.dot(OrientedBoundBox._tempV35,OrientedBoundBox._tempV32);
				separation=Math.abs(vsepAe[i]);
				if (separation > extentA+extentB)
					return 0;
			}
			for (k=0;k < 3;k++){
				_tempV32e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(0,k);
				_tempV32e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(1,k);
				_tempV32e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(2,k);
				_tempV33e[0]=OrientedBoundBox._tempM0.getElementByRowColumn(0,k);
				_tempV33e[1]=OrientedBoundBox._tempM0.getElementByRowColumn(1,k);
				_tempV33e[2]=OrientedBoundBox._tempM0.getElementByRowColumn(2,k);
				extentA=Vector3.dot(this.extents,OrientedBoundBox._tempV32);
				extentB=sizeBe[k];
				separation=Math.abs(Vector3.dot(OrientedBoundBox._tempV31,OrientedBoundBox._tempV33));
				if (separation > extentA+extentB)
					return 0;
			}
			for (i=0;i < 3;i++){
				for (k=0;k < 3;k++){
					var i1=(i+1)% 3,i2=(i+2)% 3;
					var k1=(k+1)% 3,k2=(k+2)% 3;
					extentA=sizeAe[i1] *OrientedBoundBox._tempM1.getElementByRowColumn(i2,k)+sizeBe[i2] *OrientedBoundBox._tempM1.getElementByRowColumn(i1,k);
					extentB=sizeAe[k1] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k2)+sizeBe[k2] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k1);
					separation=Math.abs(vsepAe[i2] *OrientedBoundBox._tempM0.getElementByRowColumn(i1,k)-vsepAe[i1] *OrientedBoundBox._tempM0.getElementByRowColumn(i2,k));
					if (separation > extentA+extentB)
						return 0;
				}
			}
			return 2;
		}

		/**
		*该包围盒是否包含空间中一条线
		*@param point1 点1
		*@param point2 点2
		*@return 返回位置关系
		*/
		__proto.containsLine=function(point1,point2){
			OrientedBoundBox._corners[0]=point1;
			OrientedBoundBox._corners[1]=point2;
			var cornersCheck=this.containsPoints(OrientedBoundBox._corners);
			if (cornersCheck !=0)
				return cornersCheck;
			var extentsE=this.extents.elements;
			var extentsX=extentsE[0];
			var extentsY=extentsE[1];
			var extentsZ=extentsE[2];
			this.transformation.invert(OrientedBoundBox._tempM0);
			Vector3.transformCoordinate(point1,OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
			Vector3.transformCoordinate(point2,OrientedBoundBox._tempM0,OrientedBoundBox._tempV31);
			Vector3.add(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
			Vector3.scale(OrientedBoundBox._tempV32,0.5,OrientedBoundBox._tempV32);
			Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV32,OrientedBoundBox._tempV33);
			var _tempV33e=OrientedBoundBox._tempV33.elements;
			var _tempV33X=_tempV33e[0];
			var _tempV33Y=_tempV33e[1];
			var _tempV33Z=_tempV33e[2];
			var _tempV34e=OrientedBoundBox._tempV34.elements;
			var _tempV34X=_tempV34e[0]=Math.abs(_tempV33e[0]);
			var _tempV34Y=_tempV34e[1]=Math.abs(_tempV33e[1]);
			var _tempV34Z=_tempV34e[2]=Math.abs(_tempV33e[2]);
			var _tempV32e=OrientedBoundBox._tempV32.elements;
			var _tempV32X=_tempV32e[0];
			var _tempV32Y=_tempV32e[1];
			var _tempV32Z=_tempV32e[2];
			if (Math.abs(_tempV32X)> extentsX+_tempV34X)
				return 0;
			if (Math.abs(_tempV32Y)> extentsY+_tempV34Y)
				return 0;
			if (Math.abs(_tempV32Z)> extentsZ+_tempV34Z)
				return 0;
			if (Math.abs(_tempV32Y *_tempV33Z-_tempV32Z *_tempV33Y)> (extentsY *_tempV34Z+extentsZ *_tempV34Y))
				return 0;
			if (Math.abs(_tempV32X *_tempV33Z-_tempV32Z *_tempV33X)> (extentsX *_tempV34Z+extentsZ *_tempV34X))
				return 0;
			if (Math.abs(_tempV32X *_tempV33Y-_tempV32Y *_tempV33X)> (extentsX *_tempV34Y+extentsY *_tempV34X))
				return 0;
			return 2;
		}

		/**
		*该包围盒是否包含空间中另一OBB包围盒
		*@param box 包围盒
		*@return 返回位置关系
		*/
		__proto.containsBoundBox=function(box){
			var i=0,k=0;
			var min=box.min;
			var max=box.max;
			box.getCorners(OrientedBoundBox._corners);
			var cornersCheck=this.containsPoints(OrientedBoundBox._corners);
			if (cornersCheck !=0)
				return cornersCheck;
			Vector3.subtract(max,min,OrientedBoundBox._tempV30);
			Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
			Vector3.add(min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV30);
			Vector3.subtract(max,OrientedBoundBox._tempV30,OrientedBoundBox._tempV31);
			var sizeAe=this.extents.elements;
			var sizeBe=OrientedBoundBox._tempV31.elements;
			OrientedBoundBox._getRows(this.transformation,OrientedBoundBox._rows1);
			this.transformation.invert(OrientedBoundBox._tempM0);
			var extentA=NaN,extentB=NaN,separation=NaN,dotNumber=NaN;
			for (i=0;i < 3;i++){
				for (k=0;k < 3;k++){
					OrientedBoundBox._tempM1.setElementByRowColumn(i,k,Math.abs(OrientedBoundBox._tempM0.getElementByRowColumn(i,k)));
				}
			}
			this.getCenter(OrientedBoundBox._tempV35);
			Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV35,OrientedBoundBox._tempV32);
			var vsepAe=OrientedBoundBox._tempV31.elements;
			vsepAe[0]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[0]);
			vsepAe[1]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[1]);
			vsepAe[2]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[2]);
			var _tempV33e=OrientedBoundBox._tempV33.elements;
			var _tempV34e=OrientedBoundBox._tempV34.elements;
			for (i=0;i < 3;i++){
				_tempV33e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(i,0);
				_tempV33e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(i,1);
				_tempV33e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(i,2);
				extentA=sizeAe[i];
				extentB=Vector3.dot(OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
				separation=Math.abs(vsepAe[i]);
				if (separation > extentA+extentB)
					return 0;
			}
			for (k=0;k < 3;k++){
				_tempV33e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(0,k);
				_tempV33e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(1,k);
				_tempV33e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(2,k);
				_tempV34e[0]=OrientedBoundBox._tempM0.getElementByRowColumn(0,k);
				_tempV34e[1]=OrientedBoundBox._tempM0.getElementByRowColumn(1,k);
				_tempV34e[2]=OrientedBoundBox._tempM0.getElementByRowColumn(2,k);
				extentA=Vector3.dot(this.extents,OrientedBoundBox._tempV33);
				extentB=sizeBe[k];
				separation=Math.abs(Vector3.dot(OrientedBoundBox._tempV31,OrientedBoundBox._tempV34));
				if (separation > extentA+extentB)
					return 0;
			}
			for (i=0;i < 3;i++){
				for (k=0;k < 3;k++){
					var i1=(i+1)% 3,i2=(i+2)% 3;
					var k1=(k+1)% 3,k2=(k+2)% 3;
					extentA=sizeAe[i1] *OrientedBoundBox._tempM1.getElementByRowColumn(i2,k)+sizeAe[i2] *OrientedBoundBox._tempM1.getElementByRowColumn(i1,k);
					extentB=sizeBe[k1] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k2)+sizeBe[k2] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k1);
					separation=Math.abs(vsepAe[i2] *OrientedBoundBox._tempM0.getElementByRowColumn(i1,k)-vsepAe[i1] *OrientedBoundBox._tempM0.getElementByRowColumn(i2,k));
					if (separation > extentA+extentB)
						return 0;
				}
			}
			return 2;
		}

		/**
		*该包围盒是否与空间中另一射线相交
		*@param ray
		*@param out
		*@return
		*/
		__proto.intersectsRay=function(ray,out){
			Vector3.scale(this.extents,-1,OrientedBoundBox._tempV30);
			this.transformation.invert(OrientedBoundBox._tempM0);
			Vector3.TransformNormal(ray.direction,OrientedBoundBox._tempM0,OrientedBoundBox._ray.direction);
			Vector3.transformCoordinate(ray.origin,OrientedBoundBox._tempM0,OrientedBoundBox._ray.origin);
			OrientedBoundBox._boxBound1.min=OrientedBoundBox._tempV30;
			OrientedBoundBox._boxBound1.max=this.extents;
			var intersects=Collision.intersectsRayAndBoxRP(OrientedBoundBox._ray,OrientedBoundBox._boxBound1,out);
			if (intersects!==-1)
				Vector3.transformCoordinate(out,this.transformation,out);
			return intersects;
		}

		__proto._getLocalCorners=function(corners){
			corners.length=8;
			var extentsE=this.extents.elements;
			OrientedBoundBox._tempV30.x=extentsE[0];
			OrientedBoundBox._tempV31.y=extentsE[1];
			OrientedBoundBox._tempV32.z=extentsE[2];
			Vector3.add(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
			Vector3.add(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[0]);
			Vector3.add(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
			Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[1]);
			Vector3.subtract(OrientedBoundBox._tempV31,OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
			Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV30,corners[2]);
			Vector3.subtract(OrientedBoundBox._tempV31,OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
			Vector3.add(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[3]);
			Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
			Vector3.add(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[4]);
			Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
			Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[5]);
			Vector3.scale(corners[0],-1,corners[6]);
			Vector3.subtract(OrientedBoundBox._tempV32,OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
			Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV31,corners[7]);
		}

		/**
		*判断两个包围盒是否相等
		*@param obb obb包围盒
		*@return Boolean
		*/
		__proto.equals=function(obb){
			return this.extents==obb.extents && this.transformation==obb.transformation;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var dest=destObject;
			this.extents.cloneTo(dest.extents);
			this.transformation.cloneTo(dest.transformation);
		}

		OrientedBoundBox.createByBoundBox=function(box,out){
			var min=box.min;
			var max=box.max;
			Vector3.subtract(max,min,OrientedBoundBox._tempV30);
			Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
			Vector3.add(min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV31);
			Vector3.subtract(max,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
			Matrix4x4.translation(OrientedBoundBox._tempV31,OrientedBoundBox._tempM0);
			var extents=OrientedBoundBox._tempV32.clone();
			var transformation=OrientedBoundBox._tempM0.clone();
			out.extents=extents;
			out.transformation=transformation;
		}

		OrientedBoundBox.createByMinAndMaxVertex=function(min,max){
			Vector3.subtract(max,min,OrientedBoundBox._tempV30);
			Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
			Vector3.add(min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV31);
			Vector3.subtract(max,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
			Matrix4x4.translation(OrientedBoundBox._tempV31,OrientedBoundBox._tempM0);
			var obb=new OrientedBoundBox(OrientedBoundBox._tempV32,OrientedBoundBox._tempM0);
			return obb;
		}

		OrientedBoundBox._getRows=function(mat,out){
			out.length=3;
			var mate=mat.elements;
			var row0e=out[0].elements;
			row0e[0]=mate[0];
			row0e[1]=mate[1];
			row0e[2]=mate[2];
			var row1e=out[1].elements;
			row1e[0]=mate[4];
			row1e[1]=mate[5];
			row1e[2]=mate[6];
			var row2e=out[2].elements;
			row2e[0]=mate[8];
			row2e[1]=mate[9];
			row2e[2]=mate[10];
		}

		OrientedBoundBox.getObbtoObbMatrix4x4=function(a,b,noMatrixScaleApplied,out){
			var at=a.transformation;
			var bt=b.transformation;
			if (noMatrixScaleApplied){
				OrientedBoundBox._getRows(at,OrientedBoundBox._rows1);
				OrientedBoundBox._getRows(bt,OrientedBoundBox._rows2);
				for (var i=0;i < 3;i++){
					for (var k=0;k < 3;k++){
						out.setElementByRowColumn(i,k,Vector3.dot(OrientedBoundBox._rows2[i],OrientedBoundBox._rows1[k]));
					}
				}
				b.getCenter(OrientedBoundBox._tempV30);
				a.getCenter(OrientedBoundBox._tempV31);
				Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
				var AtoBMe=out.elements;
				AtoBMe[12]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[0]);
				AtoBMe[13]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[1]);
				AtoBMe[14]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[2]);
				AtoBMe[15]=1;
				}else {
				at.invert(OrientedBoundBox._tempM0);
				Matrix4x4.multiply(bt,OrientedBoundBox._tempM0,out);
			}
		}

		OrientedBoundBox.merge=function(a,b,noMatrixScaleApplied){
			var ae=a.extents;
			var at=a.transformation;
			OrientedBoundBox.getObbtoObbMatrix4x4(a,b,noMatrixScaleApplied,OrientedBoundBox._tempM0);
			b._getLocalCorners(OrientedBoundBox._corners);
			Vector3.transformCoordinate(OrientedBoundBox._corners[0],OrientedBoundBox._tempM0,OrientedBoundBox._corners[0]);
			Vector3.transformCoordinate(OrientedBoundBox._corners[1],OrientedBoundBox._tempM0,OrientedBoundBox._corners[1]);
			Vector3.transformCoordinate(OrientedBoundBox._corners[2],OrientedBoundBox._tempM0,OrientedBoundBox._corners[2]);
			Vector3.transformCoordinate(OrientedBoundBox._corners[3],OrientedBoundBox._tempM0,OrientedBoundBox._corners[3]);
			Vector3.transformCoordinate(OrientedBoundBox._corners[4],OrientedBoundBox._tempM0,OrientedBoundBox._corners[4]);
			Vector3.transformCoordinate(OrientedBoundBox._corners[5],OrientedBoundBox._tempM0,OrientedBoundBox._corners[5]);
			Vector3.transformCoordinate(OrientedBoundBox._corners[6],OrientedBoundBox._tempM0,OrientedBoundBox._corners[6]);
			Vector3.transformCoordinate(OrientedBoundBox._corners[7],OrientedBoundBox._tempM0,OrientedBoundBox._corners[7]);
			Vector3.scale(ae,-1,OrientedBoundBox._boxBound1.min);
			ae.cloneTo(OrientedBoundBox._boxBound1.max);
			BoundBox.createfromPoints(OrientedBoundBox._corners,OrientedBoundBox._boxBound2);
			BoundBox.merge(OrientedBoundBox._boxBound2,OrientedBoundBox._boxBound1,OrientedBoundBox._boxBound3);
			var box3Min=OrientedBoundBox._boxBound3.min;
			var box3Max=OrientedBoundBox._boxBound3.max;
			Vector3.subtract(box3Max,box3Min,OrientedBoundBox._tempV30);
			Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
			Vector3.add(box3Min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV32);
			Vector3.subtract(box3Max,OrientedBoundBox._tempV32,ae);
			Vector3.transformCoordinate(OrientedBoundBox._tempV32,at,OrientedBoundBox._tempV33);
		}

		__static(OrientedBoundBox,
		['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();},'_tempV33',function(){return this._tempV33=new Vector3();},'_tempV34',function(){return this._tempV34=new Vector3();},'_tempV35',function(){return this._tempV35=new Vector3();},'_tempV36',function(){return this._tempV36=new Vector3();},'_tempM0',function(){return this._tempM0=new Matrix4x4();},'_tempM1',function(){return this._tempM1=new Matrix4x4();},'_corners',function(){return this._corners=[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];},'_rows1',function(){return this._rows1=[new Vector3(),new Vector3(),new Vector3()];},'_rows2',function(){return this._rows2=[new Vector3(),new Vector3(),new Vector3()];},'_ray',function(){return this._ray=new Ray(new Vector3(),new Vector3());},'_boxBound1',function(){return this._boxBound1=new BoundBox(new Vector3(),new Vector3());},'_boxBound2',function(){return this._boxBound2=new BoundBox(new Vector3(),new Vector3());},'_boxBound3',function(){return this._boxBound3=new BoundBox(new Vector3(),new Vector3());}
		]);
		return OrientedBoundBox;
	})()


	/**
	*<code>Plane</code> 类用于创建平面。
	*/
	//class laya.d3.math.Plane
	var Plane=(function(){
		function Plane(normal,d){
			this.normal=null;
			this.distance=NaN;
			(d===void 0)&& (d=0);
			this.normal=normal;
			this.distance=d;
		}

		__class(Plane,'laya.d3.math.Plane');
		var __proto=Plane.prototype;
		/**
		*更改平面法线向量的系数，使之成单位长度。
		*/
		__proto.normalize=function(){
			var normalE=this.normal.elements;
			var normalEX=normalE[0];
			var normalEY=normalE[1];
			var normalEZ=normalE[2];
			var magnitude=1 / Math.sqrt(normalEX *normalEX+normalEY *normalEY+normalEZ *normalEZ);
			normalE[0]=normalEX *magnitude;
			normalE[1]=normalEY *magnitude;
			normalE[2]=normalEZ *magnitude;
			this.distance *=magnitude;
		}

		Plane.createPlaneBy3P=function(point1,point2,point3){
			var point1e=point1.elements;
			var point2e=point2.elements;
			var point3e=point3.elements;
			var x1=point2e[0]-point1e[0];
			var y1=point2e[1]-point1e[1];
			var z1=point2e[2]-point1e[2];
			var x2=point3e[0]-point1e[0];
			var y2=point3e[1]-point1e[1];
			var z2=point3e[2]-point1e[2];
			var yz=(y1 *z2)-(z1 *y2);
			var xz=(z1 *x2)-(x1 *z2);
			var xy=(x1 *y2)-(y1 *x2);
			var invPyth=1 / (Math.sqrt((yz *yz)+(xz *xz)+(xy *xy)));
			var x=yz *invPyth;
			var y=xz *invPyth;
			var z=xy *invPyth;
			var TEMPVec3e=Plane._TEMPVec3.elements;
			TEMPVec3e[0]=x;
			TEMPVec3e[1]=y;
			TEMPVec3e[2]=z;
			var d=-((x *point1e[0])+(y *point1e[1])+(z *point1e[2]));
			var plane=new Plane(Plane._TEMPVec3,d);
			return plane;
		}

		Plane.PlaneIntersectionType_Back=0;
		Plane.PlaneIntersectionType_Front=1;
		Plane.PlaneIntersectionType_Intersecting=2;
		__static(Plane,
		['_TEMPVec3',function(){return this._TEMPVec3=new Vector3();}
		]);
		return Plane;
	})()


	/**
	*<code>Quaternion</code> 类用于创建四元数。
	*/
	//class laya.d3.math.Quaternion
	var Quaternion=(function(){
		function Quaternion(x,y,z,w){
			this.elements=new Float32Array(4);
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(z===void 0)&& (z=0);
			(w===void 0)&& (w=1);
			this.elements[0]=x;
			this.elements[1]=y;
			this.elements[2]=z;
			this.elements[3]=w;
		}

		__class(Quaternion,'laya.d3.math.Quaternion');
		var __proto=Quaternion.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*根据缩放值缩放四元数
		*@param scale 缩放值
		*@param out 输出四元数
		*/
		__proto.scaling=function(scaling,out){
			var e=out.elements;
			var f=this.elements;
			e[0]=f[0] *scaling;
			e[1]=f[1] *scaling;
			e[2]=f[2] *scaling;
			e[3]=f[3] *scaling;
		}

		/**
		*归一化四元数
		*@param out 输出四元数
		*/
		__proto.normalize=function(out){
			var e=out.elements;
			var f=this.elements;
			var x=f[0],y=f[1],z=f[2],w=f[3];
			var len=x *x+y *y+z *z+w *w;
			if (len > 0){
				len=1 / Math.sqrt(len);
				e[0]=x *len;
				e[1]=y *len;
				e[2]=z *len;
				e[3]=w *len;
			}
		}

		/**
		*计算四元数的长度
		*@return 长度
		*/
		__proto.length=function(){
			var f=this.elements;
			var x=f[0],y=f[1],z=f[2],w=f[3];
			return Math.sqrt(x *x+y *y+z *z+w *w);
		}

		/**
		*根据绕X轴的角度旋转四元数
		*@param rad 角度
		*@param out 输出四元数
		*/
		__proto.rotateX=function(rad,out){
			var e=out.elements;
			var f=this.elements;
			rad *=0.5;
			var ax=f[0],ay=f[1],az=f[2],aw=f[3];
			var bx=Math.sin(rad),bw=Math.cos(rad);
			e[0]=ax *bw+aw *bx;
			e[1]=ay *bw+az *bx;
			e[2]=az *bw-ay *bx;
			e[3]=aw *bw-ax *bx;
		}

		/**
		*根据绕Y轴的制定角度旋转四元数
		*@param rad 角度
		*@param out 输出四元数
		*/
		__proto.rotateY=function(rad,out){
			var e=out.elements;
			var f=this.elements;
			rad *=0.5;
			var ax=f[0],ay=f[1],az=f[2],aw=f[3],by=Math.sin(rad),bw=Math.cos(rad);
			e[0]=ax *bw-az *by;
			e[1]=ay *bw+aw *by;
			e[2]=az *bw+ax *by;
			e[3]=aw *bw-ay *by;
		}

		/**
		*根据绕Z轴的制定角度旋转四元数
		*@param rad 角度
		*@param out 输出四元数
		*/
		__proto.rotateZ=function(rad,out){
			var e=out.elements;
			var f=this.elements;
			rad *=0.5;
			var ax=f[0],ay=f[1],az=f[2],aw=f[3],bz=Math.sin(rad),bw=Math.cos(rad);
			e[0]=ax *bw+ay *bz;
			e[1]=ay *bw-ax *bz;
			e[2]=az *bw+aw *bz;
			e[3]=aw *bw-az *bz;
		}

		/**
		*分解四元数到欧拉角（顺序为Yaw、Pitch、Roll），参考自http://xboxforums.create.msdn.com/forums/p/4574/23988.aspx#23988,问题绕X轴翻转超过±90度时有，会产生瞬间反转
		*@param quaternion 源四元数
		*@param out 欧拉角值
		*/
		__proto.getYawPitchRoll=function(out){
			Vector3.transformQuat(Vector3.ForwardRH,this,Quaternion.TEMPVector31);
			Vector3.transformQuat(Vector3.Up,this,Quaternion.TEMPVector32);
			var upe=Quaternion.TEMPVector32.elements;
			Quaternion.angleTo(Vector3.ZERO,Quaternion.TEMPVector31,Quaternion.TEMPVector33);
			var anglee=Quaternion.TEMPVector33.elements;
			if (anglee[0]==Math.PI / 2){
				anglee[1]=Quaternion.arcTanAngle(upe[2],upe[0]);
				anglee[2]=0;
				}else if (anglee[0]==-Math.PI / 2){
				anglee[1]=Quaternion.arcTanAngle(-upe[2],-upe[0]);
				anglee[2]=0;
				}else {
				Matrix4x4.createRotationY(-anglee[1],Quaternion.TEMPMatrix0);
				Matrix4x4.createRotationX(-anglee[0],Quaternion.TEMPMatrix1);
				Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix0,Quaternion.TEMPVector32);
				Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix1,Quaternion.TEMPVector32);
				anglee[2]=Quaternion.arcTanAngle(upe[1],-upe[0]);
			}
			if (anglee[1] <=-Math.PI)
				anglee[1]=Math.PI;
			if (anglee[2] <=-Math.PI)
				anglee[2]=Math.PI;
			if (anglee[1] >=Math.PI && anglee[2] >=Math.PI){
				anglee[1]=0;
				anglee[2]=0;
				anglee[0]=Math.PI-anglee[0];
			};
			var oe=out.elements;
			oe[0]=anglee[1];
			oe[1]=anglee[0];
			oe[2]=anglee[2];
		}

		/**
		*求四元数的逆
		*@param out 输出四元数
		*/
		__proto.invert=function(out){
			var e=out.elements;
			var f=this.elements;
			var a0=f[0],a1=f[1],a2=f[2],a3=f[3];
			var dot=a0 *a0+a1 *a1+a2 *a2+a3 *a3;
			var invDot=dot ? 1.0 / dot :0;
			e[0]=-a0 *invDot;
			e[1]=-a1 *invDot;
			e[2]=-a2 *invDot;
			e[3]=a3 *invDot;
		}

		/**
		*设置四元数为单位算数
		*@param out 输出四元数
		*/
		__proto.identity=function(){
			var e=this.elements;
			e[0]=0;
			e[1]=0;
			e[2]=0;
			e[3]=1;
		}

		/**
		*从Array数组拷贝值。
		*@param array 数组。
		*@param offset 数组偏移。
		*/
		__proto.fromArray=function(array,offset){
			(offset===void 0)&& (offset=0);
			this.elements[0]=array[offset+0];
			this.elements[1]=array[offset+1];
			this.elements[2]=array[offset+2];
			this.elements[3]=array[offset+3];
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var i,s,d;
			s=this.elements;
			d=destObject.elements;
			if (s===d){
				return;
			}
			for (i=0;i < 4;++i){
				d[i]=s[i];
			}
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		__proto.equals=function(b){
			var ae=this.elements;
			var be=b.elements;
			return MathUtils3D.nearEqual(ae[0],be[0])&& MathUtils3D.nearEqual(ae[1],be[1])&& MathUtils3D.nearEqual(ae[2],be[2])&& MathUtils3D.nearEqual(ae[3],be[3]);
		}

		/**
		*计算长度的平方。
		*@return 长度的平方。
		*/
		__proto.lengthSquared=function(){
			var x=this.elements[0];
			var y=this.elements[1];
			var z=this.elements[2];
			var w=this.elements[3];
			return (x *x)+(y *y)+(z *z)+(w *w);
		}

		/**
		*获取四元数的x值
		*/
		__getset(0,__proto,'x',function(){
			return this.elements[0];
		});

		/**
		*获取四元数的y值
		*/
		__getset(0,__proto,'y',function(){
			return this.elements[1];
		});

		/**
		*获取四元数的z值
		*/
		__getset(0,__proto,'z',function(){
			return this.elements[2];
		});

		/**
		*获取四元数的w值
		*/
		__getset(0,__proto,'w',function(){
			return this.elements[3];
		});

		Quaternion.createFromYawPitchRoll=function(yaw,pitch,roll,out){
			var halfRoll=roll *0.5;
			var halfPitch=pitch *0.5;
			var halfYaw=yaw *0.5;
			var sinRoll=Math.sin(halfRoll);
			var cosRoll=Math.cos(halfRoll);
			var sinPitch=Math.sin(halfPitch);
			var cosPitch=Math.cos(halfPitch);
			var sinYaw=Math.sin(halfYaw);
			var cosYaw=Math.cos(halfYaw);
			var oe=out.elements;
			oe[0]=(cosYaw *sinPitch *cosRoll)+(sinYaw *cosPitch *sinRoll);
			oe[1]=(sinYaw *cosPitch *cosRoll)-(cosYaw *sinPitch *sinRoll);
			oe[2]=(cosYaw *cosPitch *sinRoll)-(sinYaw *sinPitch *cosRoll);
			oe[3]=(cosYaw *cosPitch *cosRoll)+(sinYaw *sinPitch *sinRoll);
		}

		Quaternion.multiply=function(left,right,out){
			var le=left.elements;
			var re=right.elements;
			var oe=out.elements;
			var lx=le[0];
			var ly=le[1];
			var lz=le[2];
			var lw=le[3];
			var rx=re[0];
			var ry=re[1];
			var rz=re[2];
			var rw=re[3];
			var a=(ly *rz-lz *ry);
			var b=(lz *rx-lx *rz);
			var c=(lx *ry-ly *rx);
			var d=(lx *rx+ly *ry+lz *rz);
			oe[0]=(lx *rw+rx *lw)+a;
			oe[1]=(ly *rw+ry *lw)+b;
			oe[2]=(lz *rw+rz *lw)+c;
			oe[3]=lw *rw-d;
		}

		Quaternion.arcTanAngle=function(x,y){
			if (x==0){
				if (y==1)
					return Math.PI / 2;
				return-Math.PI / 2;
			}
			if (x > 0)
				return Math.atan(y / x);
			if (x < 0){
				if (y > 0)
					return Math.atan(y / x)+Math.PI;
				return Math.atan(y / x)-Math.PI;
			}
			return 0;
		}

		Quaternion.angleTo=function(from,location,angle){
			Vector3.subtract(location,from,Quaternion.TEMPVector30);
			Vector3.normalize(Quaternion.TEMPVector30,Quaternion.TEMPVector30);
			angle.elements[0]=Math.asin(Quaternion.TEMPVector30.y);
			angle.elements[1]=Quaternion.arcTanAngle(-Quaternion.TEMPVector30.z,-Quaternion.TEMPVector30.x);
		}

		Quaternion.createFromAxisAngle=function(axis,rad,out){
			var e=out.elements;
			var f=axis.elements;
			rad=rad *0.5;
			var s=Math.sin(rad);
			e[0]=s *f[0];
			e[1]=s *f[1];
			e[2]=s *f[2];
			e[3]=Math.cos(rad);
		}

		Quaternion.createFromMatrix3x3=function(sou,out){
			var e=out.elements;
			var f=sou.elements;
			var fTrace=f[0]+f[4]+f[8];
			var fRoot;
			if (fTrace > 0.0){
				fRoot=Math.sqrt(fTrace+1.0);
				e[3]=0.5 *fRoot;
				fRoot=0.5 / fRoot;
				e[0]=(f[5]-f[7])*fRoot;
				e[1]=(f[6]-f[2])*fRoot;
				e[2]=(f[1]-f[3])*fRoot;
				}else {
				var i=0;
				if (f[4] > f[0])
					i=1;
				if (f[8] > f[i *3+i])
					i=2;
				var j=(i+1)% 3;
				var k=(i+2)% 3;
				fRoot=Math.sqrt(f[i *3+i]-f[j *3+j]-f[k *3+k]+1.0);
				e[i]=0.5 *fRoot;
				fRoot=0.5 / fRoot;
				e[3]=(f[j *3+k]-f[k *3+j])*fRoot;
				e[j]=(f[j *3+i]+f[i *3+j])*fRoot;
				e[k]=(f[k *3+i]+f[i *3+k])*fRoot;
			}
			return;
		}

		Quaternion.createFromMatrix4x4=function(mat,out){
			var me=mat.elements;
			var oe=out.elements;
			var sqrt;
			var half;
			var scale=me[0]+me[5]+me[10];
			if (scale > 0.0){
				sqrt=Math.sqrt(scale+1.0);
				oe[3]=sqrt *0.5;
				sqrt=0.5 / sqrt;
				oe[0]=(me[6]-me[9])*sqrt;
				oe[1]=(me[8]-me[2])*sqrt;
				oe[2]=(me[1]-me[4])*sqrt;
				}else if ((me[0] >=me[5])&& (me[0] >=me[10])){
				sqrt=Math.sqrt(1.0+me[0]-me[5]-me[10]);
				half=0.5 / sqrt;
				oe[0]=0.5 *sqrt;
				oe[1]=(me[1]+me[4])*half;
				oe[2]=(me[2]+me[8])*half;
				oe[3]=(me[6]-me[9])*half;
				}else if (me[5] > me[10]){
				sqrt=Math.sqrt(1.0+me[5]-me[0]-me[10]);
				half=0.5 / sqrt;
				oe[0]=(me[4]+me[1])*half;
				oe[1]=0.5 *sqrt;
				oe[2]=(me[9]+me[6])*half;
				oe[3]=(me[8]-me[2])*half;
				}else {
				sqrt=Math.sqrt(1.0+me[10]-me[0]-me[5]);
				half=0.5 / sqrt;
				oe[0]=(me[8]+me[2])*half;
				oe[1]=(me[9]+me[6])*half;
				oe[2]=0.5 *sqrt;
				oe[3]=(me[1]-me[4])*half;
			}
		}

		Quaternion.slerp=function(left,right,t,out){
			var a=left.elements;
			var b=right.elements;
			var oe=out.elements;
			var ax=a[0],ay=a[1],az=a[2],aw=a[3],bx=b[0],by=b[1],bz=b[2],bw=b[3];
			var omega,cosom,sinom,scale0,scale1;
			cosom=ax *bx+ay *by+az *bz+aw *bw;
			if (cosom < 0.0){
				cosom=-cosom;
				bx=-bx;
				by=-by;
				bz=-bz;
				bw=-bw;
			}
			if ((1.0-cosom)> 0.000001){
				omega=Math.acos(cosom);
				sinom=Math.sin(omega);
				scale0=Math.sin((1.0-t)*omega)/ sinom;
				scale1=Math.sin(t *omega)/ sinom;
				}else {
				scale0=1.0-t;
				scale1=t;
			}
			oe[0]=scale0 *ax+scale1 *bx;
			oe[1]=scale0 *ay+scale1 *by;
			oe[2]=scale0 *az+scale1 *bz;
			oe[3]=scale0 *aw+scale1 *bw;
			return oe;
		}

		Quaternion.lerp=function(left,right,t,out){
			var e=out.elements;
			var f=left.elements;
			var g=right.elements;
			var ax=f[0],ay=f[1],az=f[2],aw=f[3];
			e[0]=ax+t *(g[0]-ax);
			e[1]=ay+t *(g[1]-ay);
			e[2]=az+t *(g[2]-az);
			e[3]=aw+t *(g[3]-aw);
		}

		Quaternion.add=function(left,right,out){
			var e=out.elements;
			var f=left.elements;
			var g=right.elements;
			e[0]=f[0]+g[0];
			e[1]=f[1]+g[1];
			e[2]=f[2]+g[2];
			e[3]=f[3]+g[3];
		}

		Quaternion.dot=function(left,right){
			var f=left.elements;
			var g=right.elements;
			return f[0] *g[0]+f[1] *g[1]+f[2] *g[2]+f[3] *g[3];
		}

		Quaternion.rotationLookAt=function(forward,up,out){
			Quaternion.lookAt(Vector3.ZERO,forward,up,out);
		}

		Quaternion.lookAt=function(eye,target,up,out){
			Matrix3x3.lookAt(eye,target,up,Quaternion._tempMatrix3x3);
			Quaternion.rotationMatrix(Quaternion._tempMatrix3x3,out);
		}

		Quaternion.invert=function(value,out){
			var vE=value.elements;
			var oE=out.elements;
			var lengthSq=value.lengthSquared();
			if (!MathUtils3D.isZero(lengthSq)){
				lengthSq=1.0 / lengthSq;
				oE[0]=-vE[0] *lengthSq;
				oE[1]=-vE[1] *lengthSq;
				oE[2]=-vE[2] *lengthSq;
				oE[3]=vE[3] *lengthSq;
			}
		}

		Quaternion.rotationMatrix=function(matrix3x3,out){
			var me=matrix3x3.elements;
			var m11=me[0];
			var m12=me[1];
			var m13=me[2];
			var m21=me[3];
			var m22=me[4];
			var m23=me[5];
			var m31=me[6];
			var m32=me[7];
			var m33=me[8];
			var oe=out.elements;
			var sqrt=NaN,half=NaN;
			var scale=m11+m22+m33;
			if (scale > 0){
				sqrt=Math.sqrt(scale+1);
				oe[3]=sqrt *0.5;
				sqrt=0.5 / sqrt;
				oe[0]=(m23-m32)*sqrt;
				oe[1]=(m31-m13)*sqrt;
				oe[2]=(m12-m21)*sqrt;
				}else if ((m11 >=m22)&& (m11 >=m33)){
				sqrt=Math.sqrt(1+m11-m22-m33);
				half=0.5 / sqrt;
				oe[0]=0.5 *sqrt;
				oe[1]=(m12+m21)*half;
				oe[2]=(m13+m31)*half;
				oe[3]=(m23-m32)*half;
				}else if (m22 > m33){
				sqrt=Math.sqrt(1+m22-m11-m33);
				half=0.5 / sqrt;
				oe[0]=(m21+m12)*half;
				oe[1]=0.5 *sqrt;
				oe[2]=(m32+m23)*half;
				oe[3]=(m31-m13)*half;
				}else {
				sqrt=Math.sqrt(1+m33-m11-m22);
				half=0.5 / sqrt;
				oe[0]=(m31+m13)*half;
				oe[1]=(m32+m23)*half;
				oe[2]=0.5 *sqrt;
				oe[3]=(m12-m21)*half;
			}
		}

		Quaternion.DEFAULT=new Quaternion();
		__static(Quaternion,
		['TEMPVector30',function(){return this.TEMPVector30=new Vector3();},'TEMPVector31',function(){return this.TEMPVector31=new Vector3();},'TEMPVector32',function(){return this.TEMPVector32=new Vector3();},'TEMPVector33',function(){return this.TEMPVector33=new Vector3();},'TEMPMatrix0',function(){return this.TEMPMatrix0=new Matrix4x4();},'TEMPMatrix1',function(){return this.TEMPMatrix1=new Matrix4x4();},'_tempMatrix3x3',function(){return this._tempMatrix3x3=new Matrix3x3();},'NAN',function(){return this.NAN=new Quaternion(NaN,NaN,NaN,NaN);}
		]);
		return Quaternion;
	})()


	/**
	*<code>Rand</code> 类用于通过32位无符号整型随机种子创建随机数。
	*/
	//class laya.d3.math.Rand
	var Rand=(function(){
		function Rand(seed){
			this._temp=new Uint32Array(1);
			this.seeds=new Uint32Array(4);
			this.seeds[0]=seed;
			this.seeds[1]=this.seeds[0] *0x6C078965+1;
			this.seeds[2]=this.seeds[1] *0x6C078965+1;
			this.seeds[3]=this.seeds[2] *0x6C078965+1;
		}

		__class(Rand,'laya.d3.math.Rand');
		var __proto=Rand.prototype;
		/**
		*获取无符号32位整形随机数。
		*@return 无符号32位整形随机数。
		*/
		__proto.getUint=function(){
			this._temp[0]=this.seeds[0] ^ (this.seeds[0] << 11);
			this.seeds[0]=this.seeds[1];
			this.seeds[1]=this.seeds[2];
			this.seeds[2]=this.seeds[3];
			this.seeds[3]=(this.seeds[3] ^ (this.seeds[3] >>> 19))^ (this._temp[0] ^ (this._temp[0] >>> 8));
			return this.seeds[3];
		}

		/**
		*获取0到1之间的浮点随机数。
		*@return 0到1之间的浮点随机数。
		*/
		__proto.getFloat=function(){
			this.getUint();
			return (this.seeds[3] & 0x007FFFFF)*(1.0 / 8388607.0);
		}

		/**
		*获取-1到1之间的浮点随机数。
		*@return-1到1之间的浮点随机数。
		*/
		__proto.getSignedFloat=function(){
			return this.getFloat()*2.0-1.0;
		}

		/**
		*设置随机种子。
		*@param seed 随机种子。
		*/
		/**
		*获取随机种子。
		*@return 随机种子。
		*/
		__getset(0,__proto,'seed',function(){
			return this.seeds[0];
			},function(seed){
			this.seeds[0]=seed;
			this.seeds[1]=this.seeds[0] *0x6C078965+1;
			this.seeds[2]=this.seeds[1] *0x6C078965+1;
			this.seeds[3]=this.seeds[2] *0x6C078965+1;
		});

		Rand.getFloatFromInt=function(v){
			return (v & 0x007FFFFF)*(1.0 / 8388607.0)
		}

		Rand.getByteFromInt=function(v){
			return (v & 0x007FFFFF)>>> 15;
		}

		return Rand;
	})()


	/**
	*<code>Ray</code> 类用于创建射线。
	*/
	//class laya.d3.math.Ray
	var Ray=(function(){
		function Ray(origin,direction){
			this.origin=null;
			this.direction=null;
			this.origin=origin;
			this.direction=direction;
		}

		__class(Ray,'laya.d3.math.Ray');
		return Ray;
	})()


	/**
	*<code>Viewport</code> 类用于创建视口。
	*/
	//class laya.d3.math.Viewport
	var Viewport=(function(){
		function Viewport(x,y,width,height){
			//this.x=NaN;
			//this.y=NaN;
			//this.width=NaN;
			//this.height=NaN;
			//this.minDepth=NaN;
			//this.maxDepth=NaN;
			this.minDepth=0.0;
			this.maxDepth=1.0;
			this.x=x;
			this.y=y;
			this.width=width;
			this.height=height;
		}

		__class(Viewport,'laya.d3.math.Viewport');
		var __proto=Viewport.prototype;
		/**
		*变换一个三维向量。
		*@param source 源三维向量。
		*@param matrix 变换矩阵。
		*@param vector 输出三维向量。
		*/
		__proto.project=function(source,matrix,out){
			Vector3.transformV3ToV3(source,matrix,out);
			var sourceEleme=source.elements;
			var matrixEleme=matrix.elements;
			var outEleme=out.elements;
			var a=(((sourceEleme[0] *matrixEleme[3])+(sourceEleme[1] *matrixEleme[7]))+(sourceEleme[2] *matrixEleme[11]))+matrixEleme[15];
			if (a!==1.0){
				outEleme[0]=outEleme[0] / a;
				outEleme[1]=outEleme[1] / a;
				outEleme[2]=outEleme[2] / a;
			}
			outEleme[0]=(((outEleme[0]+1.0)*0.5)*this.width)+this.x;
			outEleme[1]=(((-outEleme[1]+1.0)*0.5)*this.height)+this.y;
			outEleme[2]=(outEleme[2] *(this.maxDepth-this.minDepth))+this.minDepth;
		}

		/**
		*反变换一个三维向量。
		*@param source 源三维向量。
		*@param matrix 变换矩阵。
		*@param vector 输出三维向量。
		*/
		__proto.unprojectFromMat=function(source,matrix,out){
			var sourceEleme=source.elements;
			var matrixEleme=matrix.elements;
			var outEleme=out.elements;
			outEleme[0]=(((sourceEleme[0]-this.x)/ (this.width))*2.0)-1.0;
			outEleme[1]=-((((sourceEleme[1]-this.y)/ (this.height))*2.0)-1.0);
			var halfDepth=(this.maxDepth-this.minDepth)/ 2;
			outEleme[2]=(sourceEleme[2]-this.minDepth-halfDepth)/ halfDepth;
			var a=(((outEleme[0] *matrixEleme[3])+(outEleme[1] *matrixEleme[7]))+(outEleme[2] *matrixEleme[11]))+matrixEleme[15];
			Vector3.transformV3ToV3(out,matrix,out);
			if (a!==1.0){
				outEleme[0]=outEleme[0] / a;
				outEleme[1]=outEleme[1] / a;
				outEleme[2]=outEleme[2] / a;
			}
		}

		/**
		*反变换一个三维向量。
		*@param source 源三维向量。
		*@param projection 透视投影矩阵。
		*@param view 视图矩阵。
		*@param world 世界矩阵,可设置为null。
		*@param out 输出向量。
		*/
		__proto.unprojectFromWVP=function(source,projection,view,world,out){
			Matrix4x4.multiply(projection,view,Viewport._tempMatrix4x4);
			(world)&& (Matrix4x4.multiply(Viewport._tempMatrix4x4,world,Viewport._tempMatrix4x4));
			Viewport._tempMatrix4x4.invert(Viewport._tempMatrix4x4);
			this.unprojectFromMat(source,Viewport._tempMatrix4x4,out);
		}

		__static(Viewport,
		['_tempMatrix4x4',function(){return this._tempMatrix4x4=new Matrix4x4();}
		]);
		return Viewport;
	})()


	/**
	*...
	*@author
	*/
	//class laya.d3.physics.PhysicsWorker
	var PhysicsWorker=(function(){
		function PhysicsWorker(scene){
			this._scene=null;
			this.ITEMSIZE=14;
			this.MESSAGETYPES_WORLDREPORT=0;
			this.MESSAGETYPES_COLLISIONREPORT=1;
			this.MESSAGETYPES_VEHICLEREPORT=2;
			this.MESSAGETYPES_CONSTRAINTREPORT=3;
			this._eventListeners=new Object();
			var _$this=this;
			this._scene=scene;
			PhysicsWorker._worker=new Browser.window.Worker("PhysicsWorker.js");
			var ab=new ArrayBuffer(1);
			PhysicsWorker._worker.postMessage(ab,[ab]);
			this.addEventListener('update',function(){
				_$this.simulate(undefined,1);
			});
			PhysicsWorker._worker.onmessage=function (event){
				var data=event.data;
				var _temp;
				if ((data instanceof ArrayBuffer)&& data.byteLength!==1){
					data=new Float32Array(data);
				}
				if ((data instanceof Float32Array)){
					switch (data[0]){
						case _$this.MESSAGETYPES_WORLDREPORT:
							_$this._updateScene(data);
							break ;
						default :
							break ;
						}
					}else {
					if (data.cmd){
						switch (data.cmd){
							case 'objectReady':
								_temp=data.params;
								if (Collider._physicsObjects[_temp]){
									_$this.dispatchEvent('ready');
								}
								break ;
							case 'worldReady':
								_$this.dispatchEvent('ready');
								break ;
							default :
								console.debug('Received: '+data.cmd);
								console.dir(data.params);
								break ;
							}
						}else {
						switch (data[0]){
							case _$this.MESSAGETYPES_WORLDREPORT:
								_$this._updateScene(data);
								break ;
							default :
								break ;
							}
					}
				}
			};
			var params=params || {};
			params.ammo="ammo.js";
			params.fixedTimeStep=params.fixedTimeStep || 1 / 60;
			params.rateLimit=params.rateLimit || true;
			this.execute('init',params);
			var gravity={};
			gravity.x=0;
			gravity.y=-30;
			gravity.z=0;
			this.execute('setGravity',gravity);
		}

		__class(PhysicsWorker,'laya.d3.physics.PhysicsWorker');
		var __proto=PhysicsWorker.prototype;
		__proto._updateScene=function(data){
			var objectNum=data[1];
			var object;
			var i=0,offset=0;
			for (i=0;i < objectNum;i++){
				offset=2+i *this.ITEMSIZE;
				object=Collider._physicsObjects[data[offset]];
				if (object===undefined){
					continue ;
				}
				if (!object.dirtyPosition){
					object.transform.position=new Vector3(-data[offset+1],data[offset+2],data[offset+3]);
				}
				if (!object.dirtyRotation){
					object.transform.rotation=new Quaternion(-data[offset+4],data[offset+5],data[offset+6],-data[offset+7]);
				}
			}
			PhysicsWorker._worker.postMessage(data.buffer,[data.buffer]);
			this.dispatchEvent('update');
		}

		__proto.simulate=function(timeStep,maxSubSteps){
			var i=0;
			var length=Collider._physicsObjects.length;
			var object;
			var updateObject=new Object();
			for (i=0;i < length;i++){
				object=Collider._physicsObjects[i];
				if (object.dirtyPosition || object.dirtyRotation){
					updateObject.id=object.physicsObjectId;
					if (object.dirtyPosition){
						updateObject.pos={x:-object.transform.position.x,y:object.transform.position.y,z:object.transform.position.z};
						object.dirtyPosition=false;
					}
					if (object.dirtyRotation){
						updateObject.quat={x:object.transform.rotation.x,y:object.transform.rotation.y,z:object.transform.rotation.z,w:object.transform.rotation.w};
						object.dirtyRotation=false;
					}
					this.execute('updateTransform',updateObject);
				}
			}
			this.execute('simulate',{timeStep:timeStep,maxSubSteps:maxSubSteps});
			return true;
		}

		__proto.execute=function(cmd,params){
			PhysicsWorker._worker.postMessage({cmd:cmd,params:params});
		}

		__proto.addEventListener=function(event_name,callback){
			if (!this._eventListeners.hasOwnProperty(event_name)){
				this._eventListeners[event_name]=[];
			}
			this._eventListeners[event_name].push(callback);
		}

		__proto.dispatchEvent=function(event_name){
			var i,parameters=Array.prototype.splice.call(arguments,1);
			if (this._eventListeners.hasOwnProperty(event_name)){
				for (i=0;i < this._eventListeners[event_name].length;i++){
					this._eventListeners[event_name][i].apply(this,parameters);
				}
			}
		}

		PhysicsWorker.WORKERPATH="PhysicsWorker.js";
		PhysicsWorker.PhysicsEngine="ammo.js";
		PhysicsWorker._worker=null
		PhysicsWorker._physicsObjects=null
		return PhysicsWorker;
	})()


	/**
	*<code>Sky</code> 类用于创建天空的父类，抽象类不允许实例。
	*/
	//class laya.d3.resource.models.Sky
	var Sky=(function(){
		function Sky(){
			//this._sharedMaterial=null;
			//this._vertexBuffer=null;
			//this._indexBuffer=null;
		}

		__class(Sky,'laya.d3.resource.models.Sky');
		var __proto=Sky.prototype;
		/**
		*@private
		*/
		__proto._changeMaterialReference=function(lastValue,value){
			(lastValue)&& (lastValue._removeReference());
			value._addReference();
		}

		/**
		*@private
		*/
		__proto._render=function(state){}
		/**
		*设置天空立方体纹理。
		*@param value 天空立方体纹理。
		*/
		/**
		*获取天空立方体纹理。
		*@return 天空立方体纹理。
		*/
		__getset(0,__proto,'sharedMaterial',function(){
			return this._sharedMaterial;
			},function(value){
			if (this._sharedMaterial!==value){
				this._sharedMaterial=value;
				this._changeMaterialReference(this._sharedMaterial,value);
			}
		});

		return Sky;
	})()


	/**
	*<code>DefineDatas</code> 类用于创建宏定义数据。
	*/
	//class laya.d3.shader.DefineDatas
	var DefineDatas=(function(){
		function DefineDatas(){
			//this.value=0;
			this.value=0;
		}

		__class(DefineDatas,'laya.d3.shader.DefineDatas');
		var __proto=DefineDatas.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*增加Shader宏定义。
		*@param value 宏定义。
		*/
		__proto.add=function(define){
			this.value |=define;
		}

		/**
		*移除Shader宏定义。
		*@param value 宏定义。
		*/
		__proto.remove=function(define){
			this.value &=~define;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destDefineData=destObject;
			this.value=destDefineData.value;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		return DefineDatas;
	})()


	/**
	*@private
	*<code>Shader3D</code> 类用于创建Shader3D。
	*/
	//class laya.d3.shader.Shader3D
	var Shader3D=(function(){
		function Shader3D(name,attributeMap,uniformMap,includeFiles){
			//this._attributeMap=null;
			//this._uniformMap=null;
			//this._publicDefines=null;
			//this._publicDefinesMap=null;
			//this._publicDefinesValue=0;
			//this._spriteDefines=null;
			//this._spriteDefinesMap=null;
			//this._spriteDefinesValue=0;
			//this._materialDefines=null;
			//this._materialDefinesMap=null;
			//this._materialDefinesValue=0;
			//this._name=null;
			//this._passes=null;
			this._name=name;
			this._publicDefines=[];
			this._publicDefinesMap={};
			this._spriteDefines=[];
			this._spriteDefinesMap={};
			this._materialDefines=[];
			this._materialDefinesMap={};
			this._publicDefinesValue=this._addDefines(this._publicDefines,this._publicDefinesMap,Shader3D._globleDefines);
			this._passes=[];
			this._attributeMap=attributeMap;
			this._uniformMap=uniformMap;
		}

		__class(Shader3D,'laya.d3.shader.Shader3D');
		var __proto=Shader3D.prototype;
		/**
		*@private
		*/
		__proto._addDefines=function(defines,definesMap,supportDefines){
			var validDefineValue=0;
			for (var k in supportDefines){
				var name=supportDefines[k];
				var i=parseInt(k);
				defines[i]=name;
				definesMap[name]=i;
				validDefineValue |=i;
			}
			return validDefineValue;
		}

		/**
		*@private
		*/
		__proto._addShaderPass=function(vs,ps){
			this._passes.push(new ShaderPass(this,vs,ps));
		}

		/**
		*注册材质宏定义。
		*@param name 宏定义名称。zx
		*@return
		*/
		__proto.addMaterialDefines=function(shaderDefines){
			this._materialDefinesValue=this._addDefines(this._materialDefines,this._materialDefinesMap,shaderDefines.defines);
		}

		/**
		*注册精灵宏定义。
		*@param name 宏定义名称。
		*@return
		*/
		__proto.addSpriteDefines=function(shaderDefines){
			this._spriteDefinesValue=this._addDefines(this._spriteDefines,this._spriteDefinesMap,shaderDefines.defines);
		}

		/**
		*通过名称获取宏定义值。
		*@param name 名称。
		*@return 宏定义值。
		*/
		__proto.getMaterialDefineByName=function(name){
			return this._materialDefinesMap[name];
		}

		Shader3D.addInclude=function(fileName,txt){
			ShaderCompile.addInclude(fileName,txt);
		}

		Shader3D.registerPublicDefine=function(name){
			var value=Math.pow(2,Shader3D._publicCounter++);
			Shader3D._globleDefines[value]=name;
			return value;
		}

		Shader3D.compileShader=function(name,passIndex,publicDefine,spriteDefine,materialDefine){
			var shader=laya.d3.shader.Shader3D.get(name);
			if (shader){
				var pass=shader._passes[passIndex];
				if (pass){
					if (WebGL.shaderHighPrecision)
						pass.withCompile(73,4,20);
					else
					pass.withCompile(73-laya.d3.shader.Shader3D.SHADERDEFINE_HIGHPRECISION,4,20);
					}else {
					console.warn("Shader3D: unknown shader passIndex.");
				}
				}else {
				console.warn("Shader3D: unknown shader name.");
			}
		}

		Shader3D.add=function(name,attributeMap,uniformMap){
			return laya.d3.shader.Shader3D._preCompileShader[name]=new Shader3D(name,attributeMap,uniformMap,ShaderCompile.includes);
		}

		Shader3D.get=function(name){
			return laya.d3.shader.Shader3D._preCompileShader[name];
		}

		Shader3D.PERIOD_CUSTOM=0;
		Shader3D.PERIOD_MATERIAL=1;
		Shader3D.PERIOD_SPRITE=2;
		Shader3D.PERIOD_CAMERA=3;
		Shader3D.PERIOD_SCENE=4;
		Shader3D.SHADERDEFINE_HIGHPRECISION=0;
		Shader3D._publicCounter=0;
		Shader3D._globleDefines=[];
		Shader3D._preCompileShader={};
		Shader3D.debugMode=false;
		return Shader3D;
	})()


	/**
	*@private
	*/
	//class laya.d3.shader.ShaderDatas
	var ShaderDatas=(function(){
		function ShaderDatas(ownerResource,length){
			//this._ownerResource=null;
			//this._data=null;
			//this._int32Data=null;
			//this._float32Data=null;
			//this._nativeArray=null;
			this._ownerResource=ownerResource;
			this._initData(length);
		}

		__class(ShaderDatas,'laya.d3.shader.ShaderDatas');
		var __proto=ShaderDatas.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*@private
		*/
		__proto._initData=function(length){
			this._data=new Array(length);
		}

		/**
		*获取布尔。
		*@param index shader索引。
		*@return 布尔。
		*/
		__proto.getBool=function(index){
			return this._data[index];
		}

		/**
		*设置布尔。
		*@param index shader索引。
		*@param value 布尔。
		*/
		__proto.setBool=function(index,value){
			this._data[index]=value;
		}

		/**
		*获取整形。
		*@param index shader索引。
		*@return 整形。
		*/
		__proto.getInt=function(index){
			return this._data[index];
		}

		/**
		*设置整型。
		*@param index shader索引。
		*@param value 整形。
		*/
		__proto.setInt=function(index,value){
			this._data[index]=value;
		}

		/**
		*获取浮点。
		*@param index shader索引。
		*@return 浮点。
		*/
		__proto.getNumber=function(index){
			return this._data[index];
		}

		/**
		*设置浮点。
		*@param index shader索引。
		*@param value 浮点。
		*/
		__proto.setNumber=function(index,value){
			this._data[index]=value;
		}

		/**
		*获取颜色。
		*@param index shader索引。
		*@return 颜色向量。
		*/
		__proto.getVector=function(index){
			return this._data[index];
		}

		/**
		*设置向量。
		*@param index shader索引。
		*@param value 向量。
		*/
		__proto.setVector=function(index,value){
			this._data[index]=value;
		}

		/**
		*获取四元数。
		*@param index shader索引。
		*@return 四元。
		*/
		__proto.getQuaternion=function(index){
			return this._data[index];
		}

		/**
		*设置四元数。
		*@param index shader索引。
		*@param value 四元数。
		*/
		__proto.setQuaternion=function(index,value){
			this._data[index]=value;
		}

		/**
		*获取矩阵。
		*@param index shader索引。
		*@return 矩阵。
		*/
		__proto.getMatrix4x4=function(index){
			return this._data[index];
		}

		/**
		*设置矩阵。
		*@param index shader索引。
		*@param value 矩阵。
		*/
		__proto.setMatrix4x4=function(index,value){
			this._data[index]=value;
		}

		/**
		*获取Buffer。
		*@param index shader索引。
		*@return
		*/
		__proto.getBuffer=function(shaderIndex){
			return this._data[shaderIndex];
		}

		/**
		*设置Buffer。
		*@param index shader索引。
		*@param value buffer数据。
		*/
		__proto.setBuffer=function(index,value){
			this._data[index]=value;
		}

		/**
		*设置纹理。
		*@param index shader索引。
		*@param value 纹理。
		*/
		__proto.setTexture=function(index,value){
			var lastValue=this._data[index];
			this._data[index]=value;
			if (this._ownerResource.referenceCount > 0){
				(lastValue)&& (lastValue._removeReference());
				(value)&& (value._addReference());
			}
		}

		/**
		*获取纹理。
		*@param index shader索引。
		*@return 纹理。
		*/
		__proto.getTexture=function(index){
			return this._data[index];
		}

		/**
		*设置Attribute。
		*@param index shader索引。
		*@param value 纹理。
		*/
		__proto.setAttribute=function(index,value){
			this._data[index]=value;
		}

		/**
		*获取Attribute。
		*@param index shader索引。
		*@return 纹理。
		*/
		__proto.getAttribute=function(index){
			return this._data[index];
		}

		/**
		*获取长度。
		*@return 长度。
		*/
		__proto.getLength=function(){
			return this._data.length;
		}

		/**
		*设置长度。
		*@param 长度。
		*/
		__proto.setLength=function(value){
			this._data.length=value;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var dest=destObject;
			var destData=dest._data;
			var dataCount=this._data.length;
			destData.length=dataCount;
			for (var i=0;i < dataCount;i++){
				var value=this._data[i];
				if (value){
					if ((typeof value=='number')){
						destData[i]=value;
						}else if (((typeof value=='number')&& Math.floor(value)==value)){
						destData[i]=value;
						}else if ((typeof value=='boolean')){
						destData[i]=value;
						}else if ((value instanceof laya.d3.math.Vector2 )){
						var v2=(destData[i])|| (destData[i]=new Vector2());
						(value).cloneTo(v2);
						destData[i]=v2;
						}else if ((value instanceof laya.d3.math.Vector3 )){
						var v3=(destData[i])|| (destData[i]=new Vector3());
						(value).cloneTo(v3);
						destData[i]=v3;
						}else if ((value instanceof laya.d3.math.Vector4 )){
						var v4=(destData[i])|| (destData[i]=new Vector4());
						(value).cloneTo(v4);
						destData[i]=v4;
						}else if ((value instanceof laya.d3.math.Matrix4x4 )){
						var mat=(destData[i])|| (destData[i]=new Matrix4x4());
						(value).cloneTo(mat);
						destData[i]=mat;
						}else if ((value instanceof laya.webgl.resource.BaseTexture )){
						destData[i]=value;
					}
				}
			}
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		/**
		*@private [NATIVE]
		*/
		__proto._initDataForNative=function(length){
			this._nativeArray=[];
			this._data=new ArrayBuffer(length *4);
			this._int32Data=new Int32Array(this._data);
			this._float32Data=new Float32Array(this._data);
			LayaGL.createArrayBufferRef(this._data,0,true);
		}

		/**
		*@private [NATIVE]
		*/
		__proto.getIntForNative=function(index){
			return this._int32Data[index];
		}

		/**
		*@private [NATIVE]
		*/
		__proto.setIntForNative=function(index,value){
			this._int32Data[index]=value;
		}

		/**
		*@private [NATIVE]
		*/
		__proto.getBoolForNative=function(index){
			return this._int32Data[index]==1;
		}

		/**
		*@private [NATIVE]
		*/
		__proto.setBoolForNative=function(index,value){
			this._int32Data[index]=value;
		}

		/**
		*@private [NATIVE]
		*/
		__proto.getNumberForNative=function(index){
			return this._float32Data[index];
		}

		/**
		*@private [NATIVE]
		*/
		__proto.setNumberForNative=function(index,value){
			this._float32Data[index]=value;
		}

		/**
		*@private [NATIVE]
		*/
		__proto.getMatrix4x4ForNative=function(index){
			alert("ShaderData getMatrix4x4 can't support");
			return null;
		}

		/**
		*@private [NATIVE]
		*/
		__proto.setMatrix4x4ForNative=function(index,value){
			this._nativeArray[index]=value;
			var elements=value.elements;
			if (!elements["_ptrID"]){
				LayaGL.createArrayBufferRef(elements,0,true);
			}
			LayaGL.syncBufferToRenderThread(elements["_ptrID"]);
			this._int32Data[index]=elements["_ptrID"];
		}

		/**
		*@private [NATIVE]
		*/
		__proto.getVectorForNative=function(index){
			alert("ShaderData getVector can't support");
			return null;
		}

		/**
		*@private [NATIVE]
		*/
		__proto.setVectorForNative=function(index,value){
			this._nativeArray[index]=value;
			var elements=value.elements;
			if (!elements["_ptrID"]){
				LayaGL.createArrayBufferRef(elements,0,true);
			}
			LayaGL.syncBufferToRenderThread(elements["_ptrID"]);
			this._int32Data[index]=elements["_ptrID"];
		}

		/**
		*@private [NATIVE]
		*/
		__proto.getQuaternionForNative=function(index){
			alert("ShaderData getQuaternion can't support");
			return null;
		}

		/**
		*@private [NATIVE]
		*/
		__proto.setQuaternionForNative=function(index,value){
			this._nativeArray[index]=value;
			var elements=value.elements;
			if (!elements["_ptrID"]){
				LayaGL.createArrayBufferRef(elements,0,true);
			}
			LayaGL.syncBufferToRenderThread(elements["_ptrID"]);
			this._int32Data[index]=elements["_ptrID"];
		}

		/**
		*@private [NATIVE]
		*/
		__proto.getBufferForNative=function(shaderIndex){
			alert("ShaderData getBuffer can't support");
			return null;
		}

		/**
		*@private [NATIVE]
		*/
		__proto.setBufferForNative=function(index,value){
			this._nativeArray[index]=value;
			if (!value["_ptrID"]){
				LayaGL.createArrayBufferRef(value,0,true);
			}
			LayaGL.syncBufferToRenderThread(value["_ptrID"]);
			this._int32Data[index]=value["_ptrID"];
		}

		/**
		*@private [NATIVE]
		*/
		__proto.getAttributeForNative=function(index){
			alert("ShaderData  getAttribute can't support");
			return null;
		}

		/**
		*@private [NATIVE]
		*/
		__proto.setAttributeForNative=function(index,value){
			this._nativeArray[index]=value;
			if (!value["_ptrID"]){
				LayaGL.createArrayBufferRef(value,0,true);
			}
			LayaGL.syncBufferToRenderThread(value["_ptrID"]);
			this._int32Data[index]=value["_ptrID"];
		}

		/**
		*@private [NATIVE]
		*/
		__proto.getTextureForNative=function(index){
			alert("ShaderData getTexture can't support");
			return null;
		}

		/**
		*@private [NATIVE]
		*/
		__proto.setTextureForNative=function(index,value){
			this._nativeArray[index]=value;
			var lastValue=this._int32Data[index];
			this._int32Data[index]=value._getSource();
			if (this._ownerResource.referenceCount > 0){
				(lastValue)&& (lastValue._removeReference());
				(value)&& (value._addReference());
			}
		}

		return ShaderDatas;
	})()


	/**
	*@private
	*/
	//class laya.d3.shader.ShaderDefines
	var ShaderDefines$1=(function(){
		function ShaderDefines(superDefines){
			this._counter=0;
			this.defines=null;
			if (superDefines){
				this._counter=superDefines._counter;
				this.defines=superDefines.defines.slice();
				}else {
				this._counter=0;
				this.defines=[];
			}
		}

		__class(ShaderDefines,'laya.d3.shader.ShaderDefines',null,'ShaderDefines$1');
		var __proto=ShaderDefines.prototype;
		/**
		*@private
		*/
		__proto.registerDefine=function(name){
			var value=Math.pow(2,this._counter++);
			this.defines[value]=name;
			return value;
		}

		return ShaderDefines;
	})()


	/**
	*@private
	*<code>ShaderInit</code> 类用于初始化内置Shader。
	*/
	//class laya.d3.shader.ShaderInit3D
	var ShaderInit3D=(function(){
		/**
		*创建一个 <code>ShaderInit</code> 实例。
		*/
		function ShaderInit3D(){}
		__class(ShaderInit3D,'laya.d3.shader.ShaderInit3D');
		ShaderInit3D.__init__=function(){
			Shader3D.SHADERDEFINE_HIGHPRECISION=Shader3D.registerPublicDefine("HIGHPRECISION");
			VertexDeclaration.SHADERDEFINE_UV0=Shader3D.registerPublicDefine("UV");
			VertexDeclaration.SHADERDEFINE_COLOR=Shader3D.registerPublicDefine("COLOR");
			VertexDeclaration.SHADERDEFINE_UV1=Shader3D.registerPublicDefine("UV1");
			Scene.SHADERDEFINE_FOG=Shader3D.registerPublicDefine("FOG");
			Scene.SHADERDEFINE_DIRECTIONLIGHT=Shader3D.registerPublicDefine("DIRECTIONLIGHT");
			Scene.SHADERDEFINE_POINTLIGHT=Shader3D.registerPublicDefine("POINTLIGHT");
			Scene.SHADERDEFINE_SPOTLIGHT=Shader3D.registerPublicDefine("SPOTLIGHT");
			Scene.SHADERDEFINE_CAST_SHADOW=Shader3D.registerPublicDefine("CASTSHADOW");
			Scene.SHADERDEFINE_SHADOW_PSSM1=Shader3D.registerPublicDefine("SHADOWMAP_PSSM1");
			Scene.SHADERDEFINE_SHADOW_PSSM2=Shader3D.registerPublicDefine("SHADOWMAP_PSSM2");
			Scene.SHADERDEFINE_SHADOW_PSSM3=Shader3D.registerPublicDefine("SHADOWMAP_PSSM3");
			Scene.SHADERDEFINE_SHADOW_PCF_NO=Shader3D.registerPublicDefine("SHADOWMAP_PCF_NO");
			Scene.SHADERDEFINE_SHADOW_PCF1=Shader3D.registerPublicDefine("SHADOWMAP_PCF1");
			Scene.SHADERDEFINE_SHADOW_PCF2=Shader3D.registerPublicDefine("SHADOWMAP_PCF2");
			Scene.SHADERDEFINE_SHADOW_PCF3=Shader3D.registerPublicDefine("SHADOWMAP_PCF3");
			Scene.SAHDERDEFINE_DEPTHFOG=Shader3D.registerPublicDefine("DEPTHFOG");
			Shader3D.addInclude("Lighting.glsl","\nstruct DirectionLight\n{\n	vec3 Color;\n	vec3 Direction;\n};\n\nstruct PointLight\n{\n	vec3 Color;\n	vec3 Position;\n	float Range;\n};\n\nstruct SpotLight\n{\n	vec3 Color;\n	vec3 Position;\n	vec3 Direction;\n	float Spot;\n	float Range;\n};\n\n// U3D中使用衰减纹理,此函数模拟并非正确\n//float U3DAttenuation(in vec3 L,in float invLightRadius)\n//{\n//	float fRatio = clamp(length(L) * invLightRadius,0.0,1.0);\n//	fRatio *= fRatio;\n//	return 1.0 / (1.0 + 25.0 * fRatio)* clamp(4.0*(1.0 - fRatio),0.0,1.0); //fade to black as if 4 pixel texture\n//} \n\n// Same as Just Cause 2 and Crysis 2 (you can read GPU Pro 1 book for more information)\nfloat BasicAttenuation(in vec3 L,in float invLightRadius)\n{\n	vec3 distance = L * invLightRadius;\n	float attenuation = clamp(1.0 - dot(distance, distance),0.0,1.0); // Equals float attenuation = saturate(1.0f - dot(L, L) / (lightRadius *  lightRadius)); 	\n	return attenuation * attenuation;\n} \n\n// Inspired on http://fools.slindev.com/viewtopic.php?f=11&t=21&view=unread#unread	\nfloat NaturalAttenuation(in vec3 L,in float invLightRadius)\n{\n	float attenuationFactor = 30.0;\n	vec3 distance = L * invLightRadius;\n	float attenuation = dot(distance, distance); // Equals float attenuation = dot(L, L) / (lightRadius *  lightRadius);\n	attenuation = 1.0 / (attenuation * attenuationFactor + 1.0);\n	// Second we move down the function therewith it reaches zero at abscissa 1:\n	attenuationFactor = 1.0 / (attenuationFactor + 1.0); //attenuationFactor contains now the value we have to subtract\n	attenuation = max(attenuation - attenuationFactor, 0.0); // The max fixes a bug.\n	// Finally we expand the equation along the y-axis so that it starts with a function value of 1 again.\n	attenuation /= 1.0 - attenuationFactor;\n	return attenuation;\n} \n\nvoid LayaAirBlinnPhongLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir,in vec3 lightColor, in vec3 lightVec,out vec3 diffuseColor,out vec3 specularColor)\n{\n    mediump vec3 h = normalize(viewDir-lightVec);\n    lowp float ln = max (0.0, dot (-lightVec,normal));\n    float nh = max (0.0, dot (h,normal));\n	diffuseColor=lightColor * ln;\n	specularColor=lightColor *specColor*pow (nh, specColorIntensity*128.0) * gloss;\n}\n\nvoid LayaAirBlinnPhongDiectionLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in DirectionLight light,out vec3 diffuseColor,out vec3 specularColor)\n{\n	vec3 lightVec=normalize(light.Direction);\n	LayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec,diffuseColor,specularColor);\n}\n\nvoid LayaAirBlinnPhongPointLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in PointLight light,out vec3 diffuseColor,out vec3 specularColor)\n{\n	vec3 lightVec =  pos-light.Position;\n	//if( length(lightVec) > light.Range )\n	//	return;\n	LayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec/length(lightVec),diffuseColor,specularColor);\n	float attenuate = BasicAttenuation(lightVec, 1.0/light.Range);\n	diffuseColor *= attenuate;\n	specularColor*= attenuate;\n}\n\nvoid LayaAirBlinnPhongSpotLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in SpotLight light,out vec3 diffuseColor,out vec3 specularColor)\n{\n	vec3 lightVec =  pos-light.Position;\n	//if( length(lightVec) > light.Range )\n	//	return;\n	vec3 normalLightVec=lightVec/length(lightVec);\n	LayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,normalLightVec,diffuseColor,specularColor);\n	float spot = pow(max(dot(normalLightVec, normalize(light.Direction)), 0.0), light.Spot);\n	float attenuate = spot*BasicAttenuation(lightVec, 1.0/light.Range);\n	diffuseColor *= attenuate;\n	specularColor*= attenuate;\n}\n\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent,vec3 binormal)\n{\n	vec3 normalT =vec3(2.0*normalMapSample.x - 1.0,1.0-2.0*normalMapSample.y,2.0*normalMapSample.z - 1.0);\n	\n	// Build orthonormal basis.\n	vec3 N = normalize(unitNormal);\n	vec3 T = normalize(tangent);\n	vec3 B = normalize(binormal);\n	mat3 TBN = mat3(T, B, N);\n	\n	// Transform from tangent space to world space.\n	vec3 bumpedNormal = TBN*normalT;\n\n	return bumpedNormal;\n}\n\n\n");
			Shader3D.addInclude("ShadowHelper.glsl","uniform sampler2D u_shadowMap1;\nuniform sampler2D u_shadowMap2;\nuniform sampler2D u_shadowMap3;\nuniform vec2	  u_shadowPCFoffset;\nuniform vec4     u_shadowPSSMDistance;\nvec4 packDepth(const in float depth)\n{\n	const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\n	const vec4 bitMask	= vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\n	vec4 res = mod(depth*bitShift*vec4(255), vec4(256))/vec4(255);\n	res -= res.xxyz * bitMask;\n	return res;\n}\nfloat unpackDepth(const in vec4 rgbaDepth)\n{\n	const vec4 bitShift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\n	float depth = dot(rgbaDepth, bitShift);\n	return depth;\n}\nfloat tex2DPCF( sampler2D shadowMap,vec2 texcoord,vec2 invsize,float zRef )\n{\n	vec2 texelpos =texcoord / invsize;\n	vec2 lerps = fract( texelpos );\n	float sourcevals[4];\n	sourcevals[0] = float( unpackDepth(texture2D(shadowMap,texcoord)) > zRef );\n	sourcevals[1] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x,0))) > zRef );\n	sourcevals[2] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(0,invsize.y))) > zRef );\n	sourcevals[3] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x, invsize.y) )) > zRef );\n	return mix( mix(sourcevals[0],sourcevals[2],lerps.y),mix(sourcevals[1],sourcevals[3],lerps.y),lerps.x );\n}\nfloat getShadowPSSM3( sampler2D shadowMap1,sampler2D shadowMap2,sampler2D shadowMap3,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\n{\n	float value = 1.0;\n	int nPSNum = int(posViewZ>pssmDistance.x);\n	nPSNum += int(posViewZ>pssmDistance.y);\n	nPSNum += int(posViewZ>pssmDistance.z);\n	//真SB,webgl不支持在PS中直接访问数组\n	mat4 lightVP;\n	if( nPSNum == 0 )\n	{\n		lightVP = lightShadowVP[1];\n	}\n	else if( nPSNum == 1 )\n	{\n		lightVP = lightShadowVP[2];\n	}\n	else if( nPSNum == 2 )\n	{\n		lightVP = lightShadowVP[3];\n	}\n	vec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\n	//为了效率，在CPU计算/2.0 + 0.5\n	//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\n	vec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\n	float fMyZ = vText.z - zBias;\n	/*\n	bvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n	bool bInFrustum = all( bInFrustumVec );\n	bvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n	bool bFrustumTest = all( bFrustumTestVec );\n	if ( bFrustumTest ) \n	*/\n	if( fMyZ <= 1.0 )\n	{\n		float zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n		if ( nPSNum == 0 )\n		{\n			value =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,	fMyZ );\n			value = value/4.0;\n		} \n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 2 )\n		{\n			vec4 color = texture2D( shadowMap3,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n#endif\n#ifdef SHADOWMAP_PCF2\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 2 )\n		{\n			vec4 color = texture2D( shadowMap3,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n\n#endif\n#ifdef SHADOWMAP_PCF1\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			vec4 color = texture2D( shadowMap2,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n		else if( nPSNum == 2 )\n		{\n			vec4 color = texture2D( shadowMap3,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n#endif\n#ifdef SHADOWMAP_PCF_NO\n		vec4 color;\n		if ( nPSNum == 0 )\n		{\n			color = texture2D( shadowMap1,vText.xy );\n		}\n		else if( nPSNum == 1 )\n		{\n			color = texture2D( shadowMap2,vText.xy );\n		}\n		else if( nPSNum == 2 )\n		{\n			color = texture2D( shadowMap3,vText.xy );\n		}\n		zdepth = unpackDepth(color);\n		value = float(fMyZ < zdepth);\n#endif\n	}\n	return value;\n}\nfloat getShadowPSSM2( sampler2D shadowMap1,sampler2D shadowMap2,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\n{\n	float value = 1.0;\n	int nPSNum = int(posViewZ>pssmDistance.x);\n	nPSNum += int(posViewZ>pssmDistance.y);\n	//真SB,webgl不支持在PS中直接访问数组\n	mat4 lightVP;\n	if( nPSNum == 0 )\n	{\n		lightVP = lightShadowVP[1];\n	}\n	else if( nPSNum == 1 )\n	{\n		lightVP = lightShadowVP[2];\n	}\n	vec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\n	//为了效率，在CPU计算/2.0 + 0.5\n	//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\n	vec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\n	float fMyZ = vText.z - zBias;\n	/*\n	bvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n	bool bInFrustum = all( bInFrustumVec );\n	bvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n	bool bFrustumTest = all( bFrustumTestVec );\n	if ( bFrustumTest ) \n	*/\n	if( fMyZ <= 1.0 )\n	{\n		float zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n		if ( nPSNum == 0 )\n		{\n			value =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,	fMyZ );\n			value = value/4.0;\n		}\n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n#endif\n#ifdef SHADOWMAP_PCF2\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n#endif\n#ifdef SHADOWMAP_PCF1\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			vec4 color = texture2D( shadowMap2,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n#endif\n#ifdef SHADOWMAP_PCF_NO\n		vec4 color;\n		if ( nPSNum == 0 )\n		{\n			color = texture2D( shadowMap1,vText.xy );\n		}\n		else if( nPSNum == 1 )\n		{\n			color = texture2D( shadowMap2,vText.xy );\n		}\n		zdepth = unpackDepth(color);\n		value = float(fMyZ < zdepth);\n#endif\n	}\n	return value;\n}\nfloat getShadowPSSM1( sampler2D shadowMap1,vec4 lightMVPPos,vec4 pssmDistance,vec2 shadowPCFOffset,float posViewZ,float zBias )\n{\n	float value = 1.0;\n	if( posViewZ < pssmDistance.x )\n	{\n		vec3 vText = lightMVPPos.xyz / lightMVPPos.w;\n		float fMyZ = vText.z - zBias;\n		/*\n		bvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n		bool bInFrustum = all( bInFrustumVec );\n		bvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n		bool bFrustumTest = all( bFrustumTestVec );\n		*/\n		if ( fMyZ <= 1.0 ) \n		{\n			float zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n			value =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,fMyZ );\n			value = value/4.0;\n#endif\n#ifdef SHADOWMAP_PCF2		\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n#endif\n#ifdef SHADOWMAP_PCF1\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n#endif\n#ifdef SHADOWMAP_PCF_NO		\n			vec4 color = texture2D( shadowMap1,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n#endif\n		}\n	}\n	return value;\n}");
			Shader3D.addInclude("WaveFunction.glsl","\nuniform vec2 u_WaveInfoD[20];\nuniform vec4 u_WaveInfo[20];\n\nuniform float TEXWAVE_UV_SCALE ;//= 20.0; //每texwidth像素代表的实际距离\n/**\n	这里的计算都是\n*/\n\n/**\n* 计算一个波形\n*  开始计算的时候都按照z向上，最后输出的时候，颠倒一下。\n* @param tm {float} 毫秒\n*/\nvoid calcGerstnerWave(float curtm, vec3 pos, float deep, vec2 uvpos, out vec3 opos, out vec3 B, out vec3 T, out vec3 N, out float foamS){\n	float tm = curtm/1000.;\n	opos = pos;\n	vec3 wpos=vec3(0.);		//累加的位置\n	N=vec3(0.,0.,0.);	//输出的法线初始化一下\n	T=vec3(0.,0.,0.);\n	B=vec3(0.,0.,0.);\n	vec2 cD ;//= D;\n	//float deepAtt = max(0.,min(deep,1.0));\n	//A*=deepAtt; //TODO\n	\n	for( int i=0; i<4; i++){\n		cD = u_WaveInfoD[i];//vec2(wi.winfo[0],wi.winfo[1]);// wi.vDir;\n		float Q = u_WaveInfo[i].x;//wi.QorK;\n		float A = u_WaveInfo[i].y;//wi.A;\n		float W = u_WaveInfo[i].z;//wi.omega;\n		float P = u_WaveInfo[i].w;//wi.phi;\n		float dop = dot(cD,uvpos);\n		float c = cos(dop*W - tm*P);//TODO 优化\n		float s = sin(dop*W - tm*P);\n		float AWs = A*W*s;\n		float AWc = A*W*c;\n		float _QxyAWs = -Q*cD.x*cD.y*AWs;\n		\n		wpos += vec3(Q*A*cD.x*c,\n					Q*A*cD.y*c,\n					A*s);\n		N += vec3(-cD.x*AWc,\n				-cD.y*AWc,\n				Q*AWs);//记得最后1-\n		T += vec3(_QxyAWs,\n				Q*cD.y*cD.y*AWs,//记得1-\n				cD.y*AWc\n			);\n		B += vec3(Q*cD.x*cD.x*AWs,//记得1-\n				_QxyAWs,\n				cD.x*AWc\n			);\n		//float v1 = exp(-tan((dop*W - tm*P)/2.+1.07));//除2，+pi/2 这样正好能对齐\n#ifdef USE_FOAM		\n		float v1 = 0.5-sin((dop*W - tm*P)/1.+2.0)/2.;\n		foamS += pow(v1,9.)/4.;\n#endif\n	}\n	T.y=1.-T.y; B.x=1.-B.x;N.z=1.-N.z;\n	opos += vec3(wpos.x,wpos.z*min(deep/10.,1.),wpos.y);\n	//y和z交换一下。现在根据uv计算的位置，所以直接交换yz就行。其他情况下有问题么\n	T.xyz=T.xzy;\n	B.xyz=B.xzy;\n	N.xyz=N.xzy;\n}\n\n\nvoid calcWave(float curtm, vec2 uv, out vec3 B, out vec3 T, out vec3 N){\n	float tm = curtm/1000.;\n	N=vec3(0.,0.,0.);	//输出的法线初始化一下\n	vec2 uvpos = uv*TEXWAVE_UV_SCALE; //TODO 这个范围是什么 就是1？\n	uvpos.y*=-1.;\n	vec2 cD;// = D;\n	const int NumWaves = 4;\n	float scale = 1./float(NumWaves);\n	for( int i=0; i<NumWaves; i++){\n		cD = u_WaveInfoD[i];//vec2(wi.winfo[0],wi.winfo[1]);// wi.vDir;\n		float k = 1.5;//u_WaveInfo[i].x;//wi.QorK; TODO  不知道为什么，这个取u_WaveInfo[i].x，在mi3w上就会闪。测试发现实际值也传过来了，就是1.5\n		float A = u_WaveInfo[i].y;//wi.A;\n		float W = u_WaveInfo[i].z;//wi.omega;\n		float P = u_WaveInfo[i].w;//wi.phi;\n		\n		float dop = dot(cD,uvpos);\n		float c = cos(dop*W - tm*P);//TODO 优化\n		float s = sin(dop*W - tm*P);\n		/*\n		float AWs = A*W*s;\n		float AWc = A*W*c;\n		float _QxyAWs = -Q*cD.x*cD.y*AWs;\n		\n		N += vec3(-cD.x*AWc,\n				-cD.y*AWc,\n				Q*AWs);//记得最后1-\n		*/\n		float kWAc = scale*c;//k*W*A*c;  为了提高精度，这里只保留sin，cos部分，实际使用的时候再乘回来。\n		//float kWAc = k*W*A*c;  \n		N += vec3(\n			-kWAc*cD.x*pow((s+1.)/2.,k-1.),\n			-kWAc*cD.y*pow((s+1.)/2.,k-1.),\n			1.\n		);\n	}\n	//N.z=1.-N.z;\n	//y和z交换一下。现在根据uv计算的位置，所以直接交换yz就行。其他情况下有问题么\n	N.xyz=N.xzy;\n}\n");
			Shader3D.addInclude("BRDF.glsl","vec4 LayaAirBRDF(in vec3 diffuseColor, in vec3 specularColor, in float oneMinusReflectivity, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in vec3 gi)\n{\n	float perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n	vec3 halfDir = SafeNormalize(viewDir - lightDir);\n	\n	float nv = abs(dot(normal, viewDir));\n	\n	float nl = clamp(dot(normal,   -lightDir),  0.0, 1.0);\n	float nh = clamp(dot(normal,     halfDir),  0.0, 1.0);\n	float lv = clamp(dot(lightDir,   viewDir),  0.0, 1.0);\n	float lh = clamp(dot(lightDir,  -halfDir),  0.0, 1.0);\n	\n	float diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;\n	\n	float roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n	\n	//#if UNITY_BRDF_GGX\n	float V = SmithJointGGXVisibilityTerm(nl, nv, roughness);\n	float D = GGXTerm(nh, roughness);\n	\n	float specularTerm = V * D * PI;\n	\n	specularTerm = sqrt(max(0.0001, specularTerm));\n	specularTerm = max(0.0, specularTerm * nl);\n	\n	vec4 color;\n	color.rgb = diffuseColor * (gi + lightColor * diffuseTerm) + specularTerm * lightColor * FresnelTerm (specularColor, lh);\n	\n	color.a = 1.0;\n	return color;\n}");
			Shader3D.addInclude("PBRUtils.glsl","struct DirectionLight\n{\n	vec3 Color;\n	vec3 Direction;\n};\n\nvec3 UnpackScaleNormal(in vec2 uv0)\n{\n	#ifdef NORMALTEXTURE\n		vec3 normalT;\n		vec4 normalMapSample = texture2D(u_NormalTexture, uv0);\n		normalT.x = 2.0 * normalMapSample.x - 1.0;\n		normalT.y = 1.0 - 2.0 * normalMapSample.y;\n		normalT.xy *= u_normalScale;\n		normalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\n		\n		vec3 T = normalize(v_Tangent);\n		vec3 B = normalize(v_Binormal);\n		vec3 N = normalize(v_Normal);\n		mat3 TBN = mat3(T, B, N);\n		\n		vec3 bumpedNormal = TBN * normalize(normalT);\n		return bumpedNormal;\n	#else\n		return normalize(v_Normal);\n	#endif\n}\n\nvec4 DielectricSpecularColor = vec4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301);\n\nfloat PI = 3.14159265359;\n\nvec3 FresnelTerm (in vec3 F0, in float cosA)\n{\n	return F0 + (vec3(1.0) - F0) * pow(1.0 - cosA, 5.0);\n}\n\nfloat PerceptualRoughnessToRoughness(in float perceptualRoughness)\n{\n	return perceptualRoughness * perceptualRoughness;\n}\n\nfloat PerceptualRoughnessToSpecularPower(in float perceptualRoughness)\n{\n	float m = PerceptualRoughnessToRoughness(perceptualRoughness);\n	float sq = max(0.0001, m * m);\n	float n = (2.0 / sq) - 2.0;\n	n = max(n, 0.0001);\n	return n;\n}\n\nfloat RoughnessToPerceptualRoughness(in float roughness)\n{\n	return sqrt(roughness);\n}\n\nfloat SmoothnessToRoughness(in float smoothness)\n{\n	return (1.0 - smoothness) * (1.0 - smoothness);\n}\n\nfloat SmoothnessToPerceptualRoughness(in float smoothness)\n{\n	return (1.0 - smoothness);\n}\n\nvec3 SafeNormalize(in vec3 inVec)\n{\n	float dp3 = max(0.001,dot(inVec,inVec));\n	return inVec * (1.0 / sqrt(dp3));\n}\n\nfloat DisneyDiffuse(in float NdotV, in float NdotL, in float LdotH, in float perceptualRoughness)\n{\n	float fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n	float lightScatter	= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotL,5.0));\n	float viewScatter	= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotV,5.0));\n\n	return lightScatter * viewScatter;\n}\n\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n	float a = roughness;\n	float lambdaV = NdotL * (NdotV * (1.0 - a) + a);\n	float lambdaL = NdotV * (NdotL * (1.0 - a) + a);\n\n	return 0.5 / (lambdaV + lambdaL + 0.00001);\n}\n\nfloat GGXTerm (float NdotH, float roughness)\n{\n	float a2 = roughness * roughness;\n	float d = (NdotH * a2 - NdotH) * NdotH + 1.0;\n	return 0.31830988618 * a2 / (d * d + 0.0000001);\n}\n\nfloat OneMinusReflectivityFromMetallic(in float metallic)\n{\n	float oneMinusDielectricSpec = DielectricSpecularColor.a;\n	return oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\n}\n\nfloat SpecularStrength(vec3 specular)\n{\n    //(SHADER_TARGET < 30)return specular.r; \n    return max (max (specular.r, specular.g), specular.b);\n}\n\nvec3 DiffuseAndSpecularFromMetallic(in vec3 diffuseColor, in float metallic, out vec3 specularColor, out float oneMinusReflectivity)\n{\n	specularColor = mix(DielectricSpecularColor.rgb, diffuseColor, metallic);\n	oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\n	return diffuseColor * oneMinusReflectivity;\n}\n\nvec3 EnergyConservationBetweenDiffuseAndSpecular(in vec3 diffuseColor, in vec3 specularColor, out float oneMinusReflectivity)\n{\n	oneMinusReflectivity = 1.0 - SpecularStrength(specularColor);\n	return diffuseColor * oneMinusReflectivity;\n}\n\nvec4 Occlusion(in vec2 uv0){\n	#ifdef OCCLUSIONTEXTURE\n		vec4 occlusionTextureColor = texture2D(u_OcclusionTexture, uv0);\n		float occ = occlusionTextureColor.g;\n		float oneMinusT = 1.0 - u_occlusionStrength;\n		float lerpOneTo = oneMinusT + occ * u_occlusionStrength;\n		return occlusionTextureColor * lerpOneTo;\n	#else\n		return vec4(1.0);\n	#endif\n}\n\nvec2 ParallaxOffset(in vec3 viewDir){\n	#ifdef PARALLAXTEXTURE\n		float h = texture2D(u_ParallaxTexture, v_Texcoord0).g;\n		h = h * u_parallaxScale - u_parallaxScale / 2.0;\n		vec3 v = viewDir;\n		v.z += 0.42;\n		vec2 offset = h * (v.xy / v.z);\n		return v_Texcoord0 + offset;\n	#else\n		return v_Texcoord0;\n	#endif\n}\n\n");
			Shader3D.addInclude("PBRStandardLighting.glsl","#include \"PBRUtils.glsl\"\n#include \"BRDF.glsl\"\n\nvec4 PBRStandardLight(in vec3 diffuseColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in vec3 gi)\n{\n	float oneMinusReflectivity;\n	vec3 specularColor;\n	diffuseColor = DiffuseAndSpecularFromMetallic (diffuseColor, metallic, specularColor, oneMinusReflectivity);\n	\n	vec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\n	return color;\n}\n\nvec4 PBRStandardDiectionLight (in vec3 diffuseColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in vec3 gi)\n{\n	vec3 lightVec = normalize(light.Direction);\n	return PBRStandardLight(diffuseColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi);\n}\n\nvec2 MetallicGloss(in float diffuseTextureAlpha, in vec2 uv0)\n{\n	vec2 mg;\n	\n	#ifdef METALLICGLOSSTEXTURE\n		vec4 metallicGlossTextureColor = texture2D(u_MetallicGlossTexture, uv0);\n		#ifdef SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA\n			mg.r = metallicGlossTextureColor.r;\n			mg.g = diffuseTextureAlpha;\n		#else\n		    mg = metallicGlossTextureColor.ra;\n		#endif\n		mg.g *= u_smoothnessScale;\n	#else\n		mg.r = u_metallic;\n		#ifdef SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA\n			mg.g = diffuseTextureAlpha * u_smoothnessScale;\n		#else\n			mg.g = u_smoothness;\n		#endif\n	#endif\n	\n	return mg;\n}\n\n");
			Shader3D.addInclude("PBRSpecularLighting.glsl","#include \"PBRUtils.glsl\"\n#include \"BRDF.glsl\"\n\nvec4 PBRSpecularLight(in vec3 diffuseColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in vec3 gi)\n{\n	float oneMinusReflectivity;\n	diffuseColor = EnergyConservationBetweenDiffuseAndSpecular (diffuseColor, specularColor, oneMinusReflectivity);\n	\n	vec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\n	return color;\n}\n\nvec4 PBRSpecularDiectionLight (in vec3 diffuseColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in vec3 gi)\n{\n	vec3 lightVec = normalize(light.Direction);\n	return PBRSpecularLight(diffuseColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi);\n}\n\nvec4 SpecularGloss(float diffuseTextureAlpha, in vec2 uv0)\n{\n    vec4 sg;\n	\n	#ifdef SPECULARTEXTURE\n		vec4 specularTextureColor = texture2D(u_SpecularTexture, uv0);\n		#ifdef SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA\n			sg.rgb = specularTextureColor.rgb;\n			sg.a = diffuseTextureAlpha;\n		#else\n			sg = specularTextureColor;\n		#endif\n		sg.a *= u_smoothnessScale;\n	#else\n		sg.rgb = u_SpecularColor.rgb;\n		#ifdef SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA\n			sg.a = diffuseTextureAlpha * u_smoothnessScale;\n		#else\n			sg.a = u_smoothness;\n		#endif\n	#endif\n	\n    return sg;\n}\n\n");
			Shader3D.addInclude("LightHelper.glsl","\nstruct DirectionLight\n{\n vec3 Direction;\n vec3 Diffuse;\n};\n\nstruct PointLight\n{\n vec3 Diffuse;\n vec3 Attenuation;\n vec3 Position;\n float Range;\n};\n\nstruct SpotLight\n{\n vec3 Diffuse;\n vec3 Attenuation;\n vec3 Position;\n vec3 Direction;\n float Spot;\n float Range;\n};\n\n\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent)\n{\n	vec3 normalT = 2.0*normalMapSample - 1.0;\n\n	// Build orthonormal basis.\n	vec3 N = normalize(unitNormal);\n	vec3 T = normalize(tangent- dot(tangent, N)*N);\n	vec3 B = cross(T, N);\n\n	mat3 TBN = mat3(T, B, N);\n\n	// Transform from tangent space to world space.\n	vec3 bumpedNormal = TBN*normalT;\n\n	return bumpedNormal;\n}\n\n\nvoid  computeDirectionLight(in vec3 matDif,in vec3 matAmb,in vec4 matSpe,in DirectionLight dirLight,in vec3 ambinentColor,in vec3 normal,in vec3 toEye,out vec3 dif,out vec3 amb,out vec3 spec)\n{\n	dif=vec3(0.0);//不初始化在IOS中闪烁，PC中不会闪烁\n	amb=vec3(0.0);\n	spec=vec3(0.0);\n	vec3 lightVec=-normalize(dirLight.Direction);\n	\n	amb=matAmb*ambinentColor;\n	\n	float  diffuseFactor=dot(lightVec, normal);\n	\n	if(diffuseFactor>0.0)\n	{\n	   vec3 v = reflect(-lightVec, normal);\n	   float specFactor = pow(max(dot(v, toEye), 0.0), matSpe.w);\n	   \n	   dif = diffuseFactor * matDif * dirLight.Diffuse;\n	   spec = specFactor * matSpe.rgb;\n	}\n	\n}\n\nvoid computePointLight(in vec3 matDif,in vec3 matAmb,in vec4 matSpe,in PointLight poiLight,in vec3 ambinentColor, in vec3 pos,in vec3 normal,in vec3 toEye,out vec3 dif,out vec3 amb,out vec3 spec)\n{\n	dif=vec3(0.0);\n	amb=vec3(0.0);\n	spec=vec3(0.0);\n	vec3 lightVec = poiLight.Position - pos;\n		\n	float d = length(lightVec);\n	\n	if( d > poiLight.Range )\n		return;\n		\n	lightVec /= d; \n	\n	amb = matAmb*ambinentColor;	\n\n	float diffuseFactor = dot(lightVec, normal);\n\n	if( diffuseFactor > 0.0 )\n	{\n		vec3 v= reflect(-lightVec, normal);\n		float specFactor = pow(max(dot(v, toEye), 0.0), matSpe.w);\n					\n		dif = diffuseFactor * matDif * poiLight.Diffuse;\n		spec = specFactor * matSpe.rgb;\n	}\n\n	float attenuate = 1.0 / dot(poiLight.Attenuation, vec3(1.0, d, d*d));\n\n	dif *= attenuate;\n	spec*= attenuate;\n}\n\nvoid ComputeSpotLight(in vec3 matDif,in vec3 matAmb,in vec4 matSpe,in SpotLight spoLight,in vec3 ambinentColor,in vec3 pos, in vec3 normal,in vec3 toEye,out vec3 dif,out vec3 amb,out vec3 spec)\n{\n	amb = vec3(0.0);\n	dif =vec3(0.0);\n	spec= vec3(0.0);\n	vec3 lightVec = spoLight.Position - pos;\n		\n	float d = length(lightVec);\n	\n	if( d > spoLight.Range)\n		return;\n		\n	lightVec /= d; \n	\n	amb = matAmb*ambinentColor;	\n\n	float diffuseFactor = dot(lightVec, normal);\n\n	if(diffuseFactor > 0.0)\n	{\n		vec3 v= reflect(-lightVec, normal);\n		float specFactor = pow(max(dot(v, toEye), 0.0), matSpe.w);\n					\n		dif = diffuseFactor * matDif * spoLight.Diffuse;\n		spec = specFactor * matSpe.rgb;\n	}\n	\n	float spot = pow(max(dot(-lightVec, normalize(spoLight.Direction)), 0.0), spoLight.Spot);\n\n	float attenuate = spot/dot(spoLight.Attenuation, vec3(1.0, d, d*d));\n\n	amb *= spot;\n	dif *= attenuate;\n	spec*= attenuate;\n}\n\n");
			var vs,ps;
			var attributeMap={
				'a_Position':0,
				'a_Color':1,
				'a_Normal':3,
				'a_Texcoord0':2,
				'a_Texcoord1':15,
				'a_BoneWeights':7,
				'a_BoneIndices':6,
				'a_Tangent0':5};
			var uniformMap={
				'u_Bones':[0,0],
				'u_DiffuseTexture':[1,1],
				'u_SpecularTexture':[3,1],
				'u_NormalTexture':[2,1],
				'u_ReflectTexture':[5,1],
				'u_AlphaTestValue':[0,1],
				'u_DiffuseColor':[6,1],
				'u_MaterialSpecular':[8,1],
				'u_Shininess':[9,1],
				'u_MaterialReflect':[10,1],
				'u_TilingOffset':[11,1],
				'u_WorldMat':[0,2],
				'u_MvpMatrix':[1,2],
				'u_LightmapScaleOffset':[2,2],
				'u_LightMap':[3,2],
				'u_CameraPos':[0,3],
				'u_FogStart':[1,4],
				'u_FogRange':[2,4],
				'u_FogColor':[0,4],
				'u_DirectionLight.Color':[4,4],
				'u_DirectionLight.Direction':[3,4],
				'u_PointLight.Position':[5,4],
				'u_PointLight.Range':[6,4],
				'u_PointLight.Color':[8,4],
				'u_SpotLight.Position':[9,4],
				'u_SpotLight.Direction':[10,4],
				'u_SpotLight.Range':[12,4],
				'u_SpotLight.Spot':[11,4],
				'u_SpotLight.Color':[14,4],
				'u_AmbientColor':[21,4],
				'u_shadowMap1':[18,4],
				'u_shadowMap2':[19,4],
				'u_shadowMap3':[20,4],
				'u_shadowPSSMDistance':[15,4],
				'u_lightShadowVP':[16,4],
				'u_shadowPCFoffset':[17,4]};
			vs="attribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\n	attribute vec2 a_Texcoord0;\n	varying vec2 v_Texcoord0;\n#endif\n\n#if defined(LIGHTMAP)&&defined(UV1)\n	attribute vec2 a_Texcoord1;\n#endif\n\n#ifdef LIGHTMAP\n	uniform vec4 u_LightmapScaleOffset;\n	varying vec2 v_LightMapUV;\n#endif\n\n#ifdef COLOR\n	attribute vec4 a_Color;\n	varying vec4 v_Color;\n#endif\n\n#ifdef BONE\n	const int c_MaxBoneCount = 24;\n	attribute vec4 a_BoneIndices;\n	attribute vec4 a_BoneWeights;\n	uniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n	attribute vec3 a_Normal;\n	varying vec3 v_Normal; \n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n	uniform vec3 u_CameraPos;\n	varying vec3 v_ViewDir; \n#endif\n\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP))&&defined(NORMALMAP)\n	attribute vec4 a_Tangent0;\n	varying vec3 v_Tangent;\n	varying vec3 v_Binormal;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)||defined(RECEIVESHADOW)\n	uniform mat4 u_WorldMat;\n	varying vec3 v_PositionWorld;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n  varying vec4 v_lightMVPPos;\n  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef TILINGOFFSET\n	uniform vec4 u_TilingOffset;\n#endif\n\nvoid main_castShadow()\n{\n	#ifdef BONE\n		mat4 skinTransform=mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position=skinTransform*a_Position;\n		gl_Position = u_MvpMatrix * position;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n	 \n	//TODO没考虑UV动画呢\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		v_Texcoord0=a_Texcoord0;\n	#endif\n		v_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n	#ifdef BONE\n		mat4 skinTransform=mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position=skinTransform*a_Position;\n		gl_Position = u_MvpMatrix * position;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n		mat3 worldMat;\n		#ifdef BONE\n			worldMat=mat3(u_WorldMat*skinTransform);\n		#else\n			worldMat=mat3(u_WorldMat);\n		#endif  \n		v_Normal=worldMat*a_Normal;//TODO:法线可以用\"魔法\"矩阵\n		#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n			v_Tangent=worldMat*a_Tangent0.xyz;\n			v_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\n		#endif\n	#endif\n\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)||defined(RECEIVESHADOW)\n		#ifdef BONE\n			v_PositionWorld=(u_WorldMat*position).xyz;\n		#else\n			v_PositionWorld=(u_WorldMat*a_Position).xyz;\n		#endif\n	#endif\n	\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n		v_ViewDir=u_CameraPos-v_PositionWorld;\n	#endif\n\n	#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\n		v_Texcoord0=a_Texcoord0;\n		#ifdef TILINGOFFSET\n			v_Texcoord0=(vec2(v_Texcoord0.x,v_Texcoord0.y-1.0)*u_TilingOffset.xy)+u_TilingOffset.zw;\n			v_Texcoord0=vec2(v_Texcoord0.x,1.0+v_Texcoord0.y);\n		#endif\n	#endif\n\n	#ifdef LIGHTMAP\n		#ifdef UV1\n			v_LightMapUV=vec2(a_Texcoord1.x*u_LightmapScaleOffset.x+u_LightmapScaleOffset.z,1.0+a_Texcoord1.y*u_LightmapScaleOffset.y+u_LightmapScaleOffset.w);\n		#else\n			v_LightMapUV=vec2(a_Texcoord0.x,a_Texcoord0.y-1.0)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\n		#endif \n	#endif\n\n	#ifdef COLOR\n		v_Color=a_Color;\n	#endif\n\n	#ifdef RECEIVESHADOW\n		v_posViewZ = gl_Position.w;\n		#ifdef SHADOWMAP_PSSM1 \n			v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n		#endif\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW\n		main_castShadow();\n	#else\n		main_normal();\n	#endif\n}";
			ps="#ifdef HIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\n#include \"Lighting.glsl\";\n\nuniform vec4 u_DiffuseColor;\n\n#ifdef COLOR\n	varying vec4 v_Color;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n	varying vec3 v_ViewDir; \n#endif\n\n#ifdef ALPHATEST\n	uniform float u_AlphaTestValue;\n#endif\n\n#ifdef DIFFUSEMAP\n	uniform sampler2D u_DiffuseTexture;\n#endif\n\n#ifdef REFLECTMAP\n	uniform samplerCube u_ReflectTexture;\n	uniform vec3 u_MaterialReflect;\n#endif\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\n	varying vec2 v_Texcoord0;\n#endif\n\n#ifdef LIGHTMAP\n	varying vec2 v_LightMapUV;\n	uniform sampler2D u_LightMap;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	uniform vec3 u_MaterialSpecular;\n	uniform float u_Shininess;\n	#ifdef SPECULARMAP \n		uniform sampler2D u_SpecularTexture;\n	#endif\n#endif\n\n#ifdef FOG\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	#ifdef ADDTIVEFOG\n	#else\n		uniform vec3 u_FogColor;\n	#endif\n#endif\n\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n	varying vec3 v_Normal;\n#endif\n\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n	uniform sampler2D u_NormalTexture;\n	varying vec3 v_Tangent;\n	varying vec3 v_Binormal;\n#endif\n\n#ifdef DIRECTIONLIGHT\n	uniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\n	uniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\n	uniform SpotLight u_SpotLight;\n#endif\n\nuniform vec3 u_AmbientColor;\n\n\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)||defined(RECEIVESHADOW)\n	varying vec3 v_PositionWorld;\n#endif\n\n#include \"ShadowHelper.glsl\"\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n		uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n		varying vec4 v_lightMVPPos;\n	#endif\n#endif\n\nvoid main_castShadow()\n{\n	//gl_FragColor=vec4(v_posViewZ,0.0,0.0,1.0);\n	gl_FragColor=packDepth(v_posViewZ);\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		float alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\n		if( alpha < u_AlphaTestValue )\n		{\n			discard;\n		}\n	#endif\n}\nvoid main_normal()\n{\n	vec4 mainColor=u_DiffuseColor;\n	#ifdef DIFFUSEMAP\n		vec4 difTexColor=texture2D(u_DiffuseTexture, v_Texcoord0);\n		mainColor=mainColor*difTexColor;\n	#endif \n	#ifdef COLOR\n		mainColor=mainColor*v_Color;\n	#endif \n    \n	#ifdef ALPHATEST\n		if(mainColor.a<u_AlphaTestValue)\n			discard;\n	#endif\n  \n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n		vec3 normal;\n		#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n			vec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\n			normal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent,v_Binormal));\n		#else\n			normal = normalize(v_Normal);\n		#endif\n	#endif\n	\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		vec3 viewDir= normalize(v_ViewDir);\n		vec3 diffuse = vec3(0.0);\n		vec3 specular= vec3(0.0);\n		vec3 dif,spe;\n		#ifdef SPECULARMAP\n			vec3 gloss=texture2D(u_SpecularTexture, v_Texcoord0).rgb;\n		#else\n			#ifdef DIFFUSEMAP\n				vec3 gloss=vec3(difTexColor.a);\n			#else\n				vec3 gloss=vec3(1.0);\n			#endif\n		#endif\n	#endif\n\n	\n	#ifdef DIRECTIONLIGHT\n		LayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_DirectionLight,dif,spe);\n		diffuse+=dif;\n		specular+=spe;\n	#endif\n \n	#ifdef POINTLIGHT\n		LayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_PointLight,dif,spe);\n		diffuse+=dif;\n		specular+=spe;\n	#endif\n\n	#ifdef SPOTLIGHT\n		LayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_SpotLight,dif,spe);\n		diffuse+=dif;\n		specular+=spe;\n	#endif\n\n	\n	vec3 finalDiffuse;\n	#ifdef LIGHTMAP\n		finalDiffuse=texture2D(u_LightMap, v_LightMapUV).rgb*2.0;\n	#else\n		finalDiffuse=vec3(0.0);\n	#endif\n\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		finalDiffuse+=diffuse;\n	#endif\n\n	#ifdef RECEIVESHADOW\n		float shadowValue = 1.0;\n		#ifdef SHADOWMAP_PSSM3\n			shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif\n		#ifdef SHADOWMAP_PSSM2\n			shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif \n		#ifdef SHADOWMAP_PSSM1\n			shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n		#endif\n		gl_FragColor =vec4(mainColor.rgb*(u_AmbientColor + finalDiffuse)*shadowValue,mainColor.a);\n	#else\n		gl_FragColor =vec4(mainColor.rgb*(u_AmbientColor + finalDiffuse),mainColor.a);\n	#endif\n	\n\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		#ifdef RECEIVESHADOW\n			gl_FragColor.rgb+=specular*shadowValue;\n		#else\n			gl_FragColor.rgb+=specular;\n		#endif\n	#endif\n\n\n	#ifdef REFLECTMAP\n		vec3 incident = -viewDir;\n		vec3 reflectionVector = reflect(incident,normal);\n		vec3 reflectionColor  = textureCube(u_ReflectTexture,reflectionVector).rgb;\n		gl_FragColor.rgb += u_MaterialReflect*reflectionColor;\n	#endif\n	  \n	#ifdef FOG\n		float lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\n		#ifdef ADDTIVEFOG\n			gl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\n		#else\n			gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n		#endif\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW		\n		main_castShadow();\n	#else\n	  main_normal();\n	#endif  \n}\n\n";
			var shaderCompile=Shader3D.add("BLINNPHONG",attributeMap,uniformMap);
			shaderCompile._addShaderPass(vs,ps);
			shaderCompile.addSpriteDefines(SkinnedMeshSprite3D.shaderDefines);
			shaderCompile.addMaterialDefines(BlinnPhongMaterial.shaderDefines);
			attributeMap={
				'a_Position':0,
				'a_Color':1,
				'a_Normal':3,
				'a_Texcoord0':2,
				'a_Texcoord1':15,
				'a_TexcoordNext0':14,
				'a_BoneWeights':7,
				'a_BoneIndices':6,
				'a_Tangent0':5};
			uniformMap={
				'u_Bones':[0,0],
				'u_DiffuseTexture':[1,1],
				'u_SpecularTexture':[3,1],
				'u_NormalTexture':[2,1],
				'u_AmbientTexture':[5,1],
				'u_ReflectTexture':[6,1],
				'u_AlphaTestValue':[0,1],
				'u_Albedo':[7,1],
				'u_UVMatrix':[13,1],
				'u_UVAge':[14,1],
				'u_UVAniAge':[8,1],
				'u_MaterialDiffuse':[10,1],
				'u_MaterialAmbient':[9,1],
				'u_MaterialSpecular':[11,1],
				'u_MaterialReflect':[12,1],
				'u_TilingOffset':[15,1],
				'u_WorldMat':[0,2],
				'u_MvpMatrix':[1,2],
				'u_LightmapScaleOffset':[2,2],
				'u_LightMap':[3,2],
				'u_CameraPos':[0,3],
				'u_FogStart':[1,4],
				'u_FogRange':[2,4],
				'u_FogColor':[0,4],
				'u_DirectionLight.Direction':[3,4],
				'u_DirectionLight.Diffuse':[4,4],
				'u_PointLight.Position':[5,4],
				'u_PointLight.Range':[6,4],
				'u_PointLight.Attenuation':[7,4],
				'u_PointLight.Diffuse':[8,4],
				'u_SpotLight.Position':[9,4],
				'u_SpotLight.Direction':[10,4],
				'u_SpotLight.Range':[12,4],
				'u_SpotLight.Spot':[11,4],
				'u_SpotLight.Attenuation':[13,4],
				'u_SpotLight.Diffuse':[14,4],
				'u_AmbientColor':[21,4],
				'u_shadowMap1':[18,4],
				'u_shadowMap2':[19,4],
				'u_shadowMap3':[20,4],
				'u_shadowPSSMDistance':[15,4],
				'u_lightShadowVP':[16,4],
				'u_shadowPCFoffset':[17,4]};
			vs="attribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\nattribute vec2 a_Texcoord0;\nvarying vec2 v_Texcoord0;\n\n#ifdef COLOR\nattribute vec4 a_Color;\nvarying vec4 v_Color;\n#endif\n\n#ifdef BONE\nattribute vec4 a_BoneIndices;\nattribute vec4 a_BoneWeights;\nuniform mat4 u_Bones[24];\n#endif\n\nvoid main_normal()\n{\n#ifdef BONE\n	mat4 skinTransform=mat4(0.0);\n	skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n	skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n	skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n	skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n	vec4 position=skinTransform*a_Position;\n	gl_Position = u_MvpMatrix * position;\n#else\n	gl_Position = u_MvpMatrix * a_Position;\n#endif\n	v_Texcoord0=a_Texcoord0;\n#ifdef COLOR\n	v_Color=a_Color;\n#endif\n}\n\nvoid main()\n{\n	main_normal();\n}";
			ps="#ifdef HIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D u_DiffuseTexture;\nvarying vec2 v_Texcoord0;\n#ifdef COLOR\nvarying vec4 v_Color;\n#endif\n\nvoid main_normal()\n{\n#ifdef COLOR\n	vec4 texColor=texture2D(u_DiffuseTexture, v_Texcoord0);\n	gl_FragColor=texColor*v_Color;\n#else\n	gl_FragColor=texture2D(u_DiffuseTexture, v_Texcoord0)*vec4(0.8,0.8,0.8,1.0);\n#endif\n}\nvoid main()\n{\n	main_normal();\n}\n\n";
			shaderCompile=Shader3D.add("SIMPLE",attributeMap,uniformMap);
			shaderCompile._addShaderPass(vs,ps);
			shaderCompile.addSpriteDefines(SkinnedMeshSprite3D.shaderDefines);
			shaderCompile.addMaterialDefines(StandardMaterial.shaderDefines);
			attributeMap={
				'a_Position':0,
				'a_Color':1};
			uniformMap={
				'u_MvpMatrix':[1,2]};
			vs="attribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\nattribute vec4 a_Color;\nvarying vec4 v_Color;\n\n\nvoid main()\n{\n  gl_Position = u_MvpMatrix * a_Position;\n  v_Color=a_Color;\n}";
			ps="#ifdef HIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec4 v_Color;\n\nvoid main()\n{\n  gl_FragColor=v_Color; \n}\n\n";
			shaderCompile=Shader3D.add("LINE",attributeMap,uniformMap);
			shaderCompile._addShaderPass(vs,ps);
			attributeMap={
				'a_position':0,
				'a_normal':3,
				'tangent':5,
				'binormal':4,
				'uv':2,
				'a_BoneWeights':7,
				'a_BoneIndices':6,
				'a_Tangent0':5};
			uniformMap={
				'u_Bones':[0,0],
				'u_lodRect':[9,3],
				'irrad_mat_red':[10,3],
				'irrad_mat_green':[11,3],
				'irrad_mat_blue':[12,3],
				'u_hdrexposure':[13,3],
				'u_aoObjPos':[14,1],
				'texBaseColor':[1,1],
				'texNormal':[2,1],
				'texPbrInfo':[3,1],
				'texPrefilterdEnv':[8,3],
				'texHSNoise':[15,1],
				'texPrefilterDiff':[7,3],
				'u_AlphaTestValue':[0,1],
				'texBRDFLUT':[4,1],
				'u_UVAniAge':[5,1],
				'u_roughness':[6,1],
				'u_metaless':[7,1],
				'u_UVMatrix':[8,1],
				'u_UVAge':[9,1],
				'modelMatrix':[0,2],
				'mvp':[1,2],
				'cameraPosition':[0,3],
				'u_View':[1,3],
				'u_Project':[2,3],
				'u_FogStart':[1,4],
				'u_FogRange':[2,4],
				'u_FogColor':[0,4],
				'u_DirectionLight.Direction':[3,4],
				'u_DirectionLight.Diffuse':[4,4],
				'u_PointLight.Position':[5,4],
				'u_PointLight.Range':[6,4],
				'u_PointLight.Attenuation':[7,4],
				'u_PointLight.Diffuse':[8,4],
				'u_SpotLight.Position':[9,4],
				'u_SpotLight.Direction':[10,4],
				'u_SpotLight.Range':[12,4],
				'u_SpotLight.Spot':[11,4],
				'u_SpotLight.Attenuation':[13,4],
				'u_SpotLight.Diffuse':[14,4],
				'u_shadowMap1':[18,4],
				'u_shadowMap2':[19,4],
				'u_shadowMap3':[20,4],
				'u_shadowPSSMDistance':[15,4],
				'u_lightShadowVP':[16,4],
				'u_shadowPCFoffset':[17,4]};
			vs="\nuniform mat4 modelMatrix;\n//uniform mat4 modelViewMatrix;\n//uniform mat4 projectionMatrix;\nuniform mat4 u_View;\nuniform mat4 u_Project;\nuniform mat4 mvp;\n//uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n\nattribute vec3 a_position;\nattribute vec3 a_normal;\n#ifdef HAS_TANGENT\nattribute vec3 tangent;\nattribute vec3 binormal;\n#endif\nattribute vec2 uv;\n#ifdef BONE\nattribute vec4 a_BoneIndices;\nattribute vec4 a_BoneWeights;\nconst int c_MaxBoneCount = 24;\nuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvarying vec2 vUv;\nvarying vec3 vWorldNorm;\nvarying vec4 vViewPos;\nvarying vec4 vWorldPos;\nvarying vec3 vLightDir;\nvarying vec3 vViewDir;\n#ifdef HAS_TANGENT\nvarying vec3 vWorldTangent;\nvarying vec3 vWorldBinormal;\n#endif\n\n#ifdef RECEIVESHADOW\nvarying float v_posViewZ;\n  #ifdef SHADOWMAP_PSSM1 \n  varying vec4 v_lightMVPPos;\n  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\nvoid main() {\n#ifdef BONE\n	mat4 skinTransform=mat4(0.0);\n	skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n	skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n	skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n	skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n	gl_Position = mvp*skinTransform*vec4(a_position,1.);\n	mat4 modelMat = modelMatrix*skinTransform;\n#else\n	gl_Position = mvp*vec4(a_position,1.);\n	mat4 modelMat = modelMatrix;\n#endif	\n	vWorldPos = modelMat*vec4(a_position,1.);\n\n#ifdef CASTSHADOW \n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		vUv = uv;\n	#endif	\n#else\n    vUv = uv;\n	vWorldNorm = normalize((modelMat*vec4(a_normal,0.0)).xyz);\n	#ifdef HAS_TANGENT\n	vWorldTangent = normalize((modelMat*vec4(tangent,0.0)).xyz);\n	vWorldBinormal = normalize((modelMat*vec4(binormal,0.0)).xyz);\n	#endif\n    \n    vViewDir = (vWorldPos.xyz-cameraPosition);//这个不能normalize。否则无法线性差值了\n#ifdef RECEIVESHADOW\n	v_posViewZ = gl_Position.z;\n	#ifdef SHADOWMAP_PSSM1 \n		v_lightMVPPos = u_lightShadowVP[0] * vWorldPos;\n	#endif\n#endif	\n#endif\n}\n";
			ps="//#version 300 es\n\nprecision highp float;\nprecision lowp int;\n\nconst float PI = 3.14159265358979323846264;\nconst float _2PI = 6.2831853071796;\nvarying vec2 vUv;\nvarying vec3 vWorldNorm;\n#ifdef HAS_TANGENT\nvarying vec3 vWorldTangent;\nvarying vec3 vWorldBinormal;\n#endif\nvarying vec3 vViewDir;\nvarying vec4 vViewPos;\nvarying vec4 vWorldPos;\n//\nuniform sampler2D texBaseColor;\nuniform sampler2D texNormal;\n//预计算的贴图\nuniform sampler2D texPrefilterdEnv;\nuniform sampler2D texBRDFLUT;\nuniform sampler2D texPrefilterDiff;\n#ifdef HAS_PBRINFO\nuniform sampler2D texPbrInfo;   //Ao, Roughness, Metallic\n#endif\nuniform float u_hdrexposure;\nuniform float u_AlphaTestValue;\n\nuniform float u_roughness;\nuniform float u_metaless;\nconst float maxlv = 7.;	//现在只支持512分辨率的环境贴图\nconst int nmaxlv = 9;//\n							\nuniform mat4 irrad_mat_red;\nuniform mat4 irrad_mat_green;\nuniform mat4 irrad_mat_blue;							\n\nvec3 speccontrib = vec3(0.);\n\nconst float _maxu8 = 255.0;\nconst float _maxu16 = 65535.0;\nconst float _shift8 = 256.0;    //平移的话是*256而不是255\nvec2 _RGBAToU16(const in vec4 rgba){\n    return vec2((rgba.r*_maxu8+rgba.g*_maxu8*_shift8)/_maxu16, (rgba.b*_maxu8+rgba.a*_maxu8*_shift8)/_maxu16);\n}\nvec3 _RGBEToRGB( const in vec4 rgba ){\n    float f = pow(2.0, rgba.w * 255.0 - (128.0 + 8.0));\n    return rgba.rgb * (255.0 * f);\n}\n\nfloat saturate(float v){\n    return min(max(v,0.),1.);\n}\n\nvec4 tex2dLod(sampler2D tex, float u, float v, float lod){\n	vec2 uv = vec2(u,v);\n	uv+=mod(gl_FragCoord.xy-vec2(0.5),2.0)*vec2(128.,0.);\n	return texture2D(tex,uv,lod-16.);\n}\n\n/*\n* 对一个全景图进行采样。假设x轴指向中心。\n*/\nvec4 texPanorama(sampler2D tex, const in vec3 dir){\n	float envu = atan(dir.z,dir.x)/_2PI+0.5; 	\n	float envv = acos(dir.y)/PI;//(1.0-dir.y)/2.0;\n	return texture2D(tex,vec2(envu,envv));\n}\n\nvec4 texPanoramaLod(sampler2D tex, const in vec3 dir, float lod){\n	float envu = atan(dir.z,dir.x)/_2PI+0.5; 	\n	float envv = acos(dir.y)/PI;//(1.0-dir.y)/2.0;\n	return tex2dLod(tex,envu,envv,lod);\n}\n\n/*\n    计算sh光照。\n    使用level=2，所以需要9个系数。\n    https://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf\n*/\nfloat environment_exposure = 1.0;\nvec3 diff_sh9(vec3 dir){\n	vec4 shDir = vec4(dir.x,-dir.z,dir.y,1.0);\n  return max(vec3(0.0), vec3(\n	dot(shDir, irrad_mat_red * shDir),\n	dot(shDir, irrad_mat_green * shDir),\n	dot(shDir, irrad_mat_blue * shDir)\n	)) * environment_exposure;	\n}\n\n#ifdef HAS_TANGENT\nvec3 applyNormalTex( vec3 norm, vec3 surf_norm ) {\n    vec3 mapN = norm * 2.0 - 1.0;\n    //mapN.xy = normalScale * mapN.xy;\n    mat3 tsn = mat3( vWorldTangent, vWorldBinormal, surf_norm );\n    return normalize( tsn * mapN );\n}\n#endif\n\nvec4 pbrlight(vec3 normal, float rough, float NoV, vec3 R){\n    vec4 basecolor = texture2D(texBaseColor,vUv);\n	basecolor.rgb = pow(basecolor.rgb,vec3(2.2));\n	float metaless = 1.0; 	\n	const float ismetalinfov = (128./255.);\n	if(basecolor.a>=ismetalinfov){//这时候表示金属度\n		metaless = (basecolor.a-ismetalinfov)*2.;\n		basecolor.a = 1.0;\n	}else{\n		metaless = 0.;\n		basecolor.a = basecolor.a*2.0;\n	}\n	#ifdef FIX_METALESS\n	metaless = u_metaless;\n	#endif\n	#ifdef HAS_PBRINFO	\n	vec4 pbrinfo = texture2D(texPbrInfo, vUv);\n	metaless = pbrinfo.b;\n	rough = pbrinfo.g;\n	#endif\n    const vec3 nonmetalF0 =vec3(0.02);\n    vec3 F0 =  mix(nonmetalF0, basecolor.rgb, metaless);\n	\n    vec4 PrefilteredColor = texPanoramaLod(texPrefilterdEnv, R, rough*maxlv);\n    PrefilteredColor.rgb = _RGBEToRGB(PrefilteredColor);\n    vec4 EnvBRDF = texture2D(texBRDFLUT,vec2(rough , NoV));//TODO lod\n    vec2 rg = _RGBAToU16(EnvBRDF);    \n    speccontrib = (F0* rg.x + saturate( 50.0 * PrefilteredColor.g ) * rg.y);\n	vec3 color_spec = PrefilteredColor.rgb*speccontrib;\n	\n	vec3 color_diff=diff_sh9(normal);\n	vec3 outc =  color_diff*mix(basecolor.rgb,vec3(0.),metaless)*(vec3(1.0)-speccontrib)+color_spec;\n	#ifdef HAS_PBRINFO\n	outc*=pbrinfo.r;\n	#endif\n	return vec4(outc, basecolor.a);\n}\n\nvec3 oldlight(vec4 normal, float NoV, vec3 R){\n    vec4 basecolor = texture2D(texBaseColor,vUv);\n	const vec3 lightdir=normalize(vec3(1.,1.,0.));\n	const vec3 spcecol = vec3(1.,0.8,0.8);\n	const vec3 amb = vec3(0.5);\n	vec3 diffv =  (vec3(saturate(dot(lightdir,normal.xyz)))+amb);\n	//vec3 spec = spcecol* pow(saturate(dot(R,lightdir)),(1.-pbrinfo.g)*5.);\n	return diffv*basecolor.rgb;//+spec;\n}\n\n#include \"ShadowHelper.glsl\"\n#ifdef RECEIVESHADOW\nvarying float v_posViewZ;\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n	uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n	varying vec4 v_lightMVPPos;\n	#endif\n#endif\n\nvoid main() {\n#ifdef CASTSHADOW\n	gl_FragColor=packDepth(gl_FragCoord.w);\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		float alpha = texture2D(texBaseColor,vUv).w;\n		if( alpha < u_AlphaTestValue ){\n			discard;\n		}\n	#endif\n#else\n\n	#ifdef RECEIVESHADOW\n		float shadowValue = 1.0;\n		#ifdef SHADOWMAP_PSSM3\n			shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,vWorldPos.xyz,v_posViewZ,0.0001);\n		#endif\n		#ifdef SHADOWMAP_PSSM2\n			shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,vWorldPos.xyz,v_posViewZ,0.0001);\n		#endif \n		#ifdef SHADOWMAP_PSSM1\n			shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.0001);\n		#endif\n	#endif	\n	\n    vec3 normal =  normalize(vWorldNorm);\n	vec4 normtex = texture2D( texNormal, vUv );\n	#ifdef HAS_TANGENT	\n	normal = applyNormalTex(normtex.xyz, normal);\n	#endif\n    vec3 view   = -normalize(vViewDir);\n    float NoV = saturate(dot( view, normal ));\n    vec3 R = 2. * NoV * normal - view;\n	float roughness = normtex.a;\n	#ifdef FIX_ROUGHNESS\n	roughness = u_roughness;\n	#endif\n	\n	vec4 pbrl = pbrlight(normal,roughness,NoV,R)*u_hdrexposure;\n    gl_FragColor.rgb =  pow(pbrl.rgb,vec3(0.45455));\n	//gl_FragColor.rgb = oldlight(normtex,NoV,R);\n	#ifdef RECEIVESHADOW\n	gl_FragColor.rgb *= max(shadowValue,0.7);\n	#endif\n	\n    gl_FragColor.a = pbrl.a;\n\n#endif\n}\n";
			shaderCompile=Shader3D.add("PBR",attributeMap,uniformMap);
			shaderCompile._addShaderPass(vs,ps);
			shaderCompile.addSpriteDefines(SkinnedMeshSprite3D.shaderDefines);
			shaderCompile.addMaterialDefines(PBRMaterial.shaderDefines);
			attributeMap={
				'a_Position':0,
				'a_Normal':3,
				'a_Tangent0':5,
				'a_Texcoord0':2,
				'a_BoneWeights':7,
				'a_BoneIndices':6
			};
			uniformMap={
				'u_Bones':[0,0],
				'u_MvpMatrix':[1,2],
				'u_WorldMat':[0,2],
				'u_CameraPos':[0,3],
				'u_AlphaTestValue':[0,1],
				'u_DiffuseColor':[7,1],
				'u_EmissionColor':[8,1],
				'u_DiffuseTexture':[1,1],
				'u_NormalTexture':[3,1],
				'u_ParallaxTexture':[4,1],
				'u_MetallicGlossTexture':[2,1],
				'u_OcclusionTexture':[5,1],
				'u_EmissionTexture':[6,1],
				'u_metallic':[9,1],
				'u_smoothness':[10,1],
				'u_smoothnessScale':[11,1],
				'u_occlusionStrength':[13,1],
				'u_normalScale':[14,1],
				'u_parallaxScale':[15,1],
				'u_TilingOffset':[17,1],
				'u_DirectionLight.Direction':[3,4],
				'u_DirectionLight.Color':[4,4],
				'u_AmbientColor':[21,4],
				'u_shadowMap1':[18,4],
				'u_shadowMap2':[19,4],
				'u_shadowMap3':[20,4],
				'u_shadowPSSMDistance':[15,4],
				'u_lightShadowVP':[16,4],
				'u_shadowPCFoffset':[17,4]
			};
			vs="attribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec4 a_Tangent0;\nattribute vec2 a_Texcoord0;\n\nuniform mat4 u_MvpMatrix;\nuniform mat4 u_WorldMat;\nuniform vec3 u_CameraPos;\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\n#ifdef TILINGOFFSET\n	uniform vec4 u_TilingOffset;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n	  varying vec4 v_lightMVPPos;\n	  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef BONE\n	const int c_MaxBoneCount = 24;\n	attribute vec4 a_BoneIndices;\n	attribute vec4 a_BoneWeights;\n	uniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main_castShadow()\n{\n	#ifdef BONE\n		mat4 skinTransform=mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position = skinTransform * a_Position;\n		gl_Position = u_MvpMatrix * position;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n	 \n	//TODO没考虑UV动画呢\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		v_Texcoord0 = a_Texcoord0;\n	#endif\n		v_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n	mat3 worldMat;\n	#ifdef BONE\n		mat4 skinTransform = mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position = skinTransform * a_Position;\n		gl_Position = u_MvpMatrix * position;\n		worldMat=mat3(u_WorldMat*skinTransform);\n		v_PositionWorld = (u_WorldMat * position).xyz;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n		worldMat = mat3(u_WorldMat);\n		v_PositionWorld = (u_WorldMat * a_Position).xyz;\n	#endif\n	\n	v_Normal = worldMat * a_Normal;\n	v_Tangent = worldMat * a_Tangent0.xyz;\n	v_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\n  \n	v_Texcoord0 = a_Texcoord0;\n	#ifdef TILINGOFFSET\n		v_Texcoord0=(vec2(v_Texcoord0.x,v_Texcoord0.y-1.0)*u_TilingOffset.xy)+u_TilingOffset.zw;\n	#endif\n		v_Texcoord0=vec2(v_Texcoord0.x,1.0 + v_Texcoord0.y);\n  \n	v_ViewDir = u_CameraPos - v_PositionWorld;\n  \n	#ifdef RECEIVESHADOW\n		v_posViewZ = gl_Position.w;\n		#ifdef SHADOWMAP_PSSM1 \n			v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n		#endif\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW\n		main_castShadow();\n	#else\n		main_normal();\n	#endif\n}";
			ps="#ifdef FSHIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\n\nuniform vec4 u_AmbientColor;\nuniform vec4 u_DiffuseColor;\n\n#ifdef DIFFUSETEXTURE\n	uniform sampler2D u_DiffuseTexture;\n#endif\n#ifdef METALLICGLOSSTEXTURE\n	uniform sampler2D u_MetallicGlossTexture;\n#endif\n#ifdef NORMALTEXTURE\n	uniform sampler2D u_NormalTexture;\n	uniform float u_normalScale;\n#endif\n#ifdef PARALLAXTEXTURE\n	uniform sampler2D u_ParallaxTexture;\n	uniform float u_parallaxScale;\n#endif\n#ifdef OCCLUSIONTEXTURE\n	uniform sampler2D u_OcclusionTexture;\n	uniform float u_occlusionStrength;\n#endif\n#ifdef EMISSION\n	#ifdef EMISSIONTEXTURE\n		uniform sampler2D u_EmissionTexture;\n	#endif\n	uniform vec4 u_EmissionColor;\n#endif\n\nuniform float u_AlphaTestValue;\nuniform float u_metallic;\nuniform float u_smoothness;\nuniform float u_smoothnessScale;\n\n#include \"PBRStandardLighting.glsl\"\n#include \"ShadowHelper.glsl\"\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n		uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n		varying vec4 v_lightMVPPos;\n	#endif\n#endif\n\nuniform DirectionLight u_DirectionLight;\n\nvoid main_castShadow()\n{\n	gl_FragColor=packDepth(v_posViewZ);\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		float alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\n		if( alpha < u_AlphaTestValue )\n		{\n			discard;\n		}\n	#endif\n}\n\nvoid main_normal()\n{	\n	vec3 viewDir = normalize(v_ViewDir);\n	\n	vec2 uv0 = ParallaxOffset(viewDir);\n	\n	vec2 mg;\n	#ifdef DIFFUSETEXTURE\n		vec4 diffuseTextureColor = texture2D(u_DiffuseTexture, uv0);\n		vec4 diffuseColor = diffuseTextureColor * u_DiffuseColor;\n		mg = MetallicGloss(diffuseTextureColor.a, uv0);\n	#else\n		vec4 diffuseColor = u_DiffuseColor;\n		mg = MetallicGloss(1.0, uv0);\n	#endif\n	\n	#ifdef ALPHATEST\n		if(diffuseColor.a < u_AlphaTestValue)\n			discard;\n	#endif\n	\n	gl_FragColor = diffuseColor;\n	\n	vec3 normal = UnpackScaleNormal(uv0);\n  \n	vec3 gi = (u_AmbientColor * Occlusion(uv0)).rgb;\n  \n	vec4 color = PBRStandardDiectionLight(diffuseColor.rgb, mg.r, mg.g, normal, viewDir, u_DirectionLight, gi);\n	\n	color.a = diffuseColor.a;\n	\n	#ifdef EMISSION\n		vec4 emissionColor = u_EmissionColor;\n		#ifdef EMISSIONTEXTURE\n			emissionColor *=  texture2D(u_EmissionTexture, uv0);\n		#endif\n		color.rgb += emissionColor.rgb;\n	#endif\n	\n	#ifdef RECEIVESHADOW\n		float shadowValue = 1.0;\n		#ifdef SHADOWMAP_PSSM3\n			shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif\n		#ifdef SHADOWMAP_PSSM2\n			shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif \n		#ifdef SHADOWMAP_PSSM1\n			shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n		#endif\n		gl_FragColor = vec4(color.rgb * shadowValue, color.a);\n	#else\n		gl_FragColor = color;\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW		\n		main_castShadow();\n	#else\n		main_normal();\n	#endif  \n}\n\n";
			shaderCompile=Shader3D.add("PBRStandard",attributeMap,uniformMap);
			shaderCompile._addShaderPass(vs,ps);
			shaderCompile.addSpriteDefines(SkinnedMeshSprite3D.shaderDefines);
			shaderCompile.addMaterialDefines(PBRStandardMaterial.shaderDefines);
			attributeMap={
				'a_Position':0,
				'a_Normal':3,
				'a_Tangent0':5,
				'a_Texcoord0':2,
				'a_BoneWeights':7,
				'a_BoneIndices':6
			};
			uniformMap={
				'u_Bones':[0,0],
				'u_MvpMatrix':[1,2],
				'u_WorldMat':[0,2],
				'u_CameraPos':[0,3],
				'u_AlphaTestValue':[0,1],
				'u_DiffuseColor':[7,1],
				'u_SpecularColor':[8,1],
				'u_EmissionColor':[9,1],
				'u_DiffuseTexture':[1,1],
				'u_NormalTexture':[3,1],
				'u_ParallaxTexture':[4,1],
				'u_SpecularTexture':[2,1],
				'u_OcclusionTexture':[5,1],
				'u_EmissionTexture':[6,1],
				'u_smoothness':[10,1],
				'u_smoothnessScale':[11,1],
				'u_occlusionStrength':[13,1],
				'u_normalScale':[14,1],
				'u_parallaxScale':[15,1],
				'u_TilingOffset':[17,1],
				'u_DirectionLight.Direction':[3,4],
				'u_DirectionLight.Color':[4,4],
				'u_AmbientColor':[21,4],
				'u_shadowMap1':[18,4],
				'u_shadowMap2':[19,4],
				'u_shadowMap3':[20,4],
				'u_shadowPSSMDistance':[15,4],
				'u_lightShadowVP':[16,4],
				'u_shadowPCFoffset':[17,4]
			};
			vs="attribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec4 a_Tangent0;\nattribute vec2 a_Texcoord0;\n\nuniform mat4 u_MvpMatrix;\nuniform mat4 u_WorldMat;\nuniform vec3 u_CameraPos;\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\n#ifdef TILINGOFFSET\n	uniform vec4 u_TilingOffset;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n	  varying vec4 v_lightMVPPos;\n	  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef BONE\n	const int c_MaxBoneCount = 24;\n	attribute vec4 a_BoneIndices;\n	attribute vec4 a_BoneWeights;\n	uniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main_castShadow()\n{\n	#ifdef BONE\n		mat4 skinTransform=mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position = skinTransform * a_Position;\n		gl_Position = u_MvpMatrix * position;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n	 \n	//TODO没考虑UV动画呢\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		v_Texcoord0 = a_Texcoord0;\n	#endif\n		v_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n	mat3 worldMat;\n	#ifdef BONE\n		mat4 skinTransform = mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position = skinTransform * a_Position;\n		gl_Position = u_MvpMatrix * position;\n		worldMat=mat3(u_WorldMat*skinTransform);\n		v_PositionWorld = (u_WorldMat * position).xyz;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n		worldMat = mat3(u_WorldMat);\n		v_PositionWorld = (u_WorldMat * a_Position).xyz;\n	#endif\n	\n	v_Normal = worldMat * a_Normal;\n	v_Tangent = worldMat * a_Tangent0.xyz;\n	v_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\n  \n	v_Texcoord0 = a_Texcoord0;\n	#ifdef TILINGOFFSET\n		v_Texcoord0=(vec2(v_Texcoord0.x,v_Texcoord0.y-1.0)*u_TilingOffset.xy)+u_TilingOffset.zw;\n	#endif\n		v_Texcoord0=vec2(v_Texcoord0.x,1.0 + v_Texcoord0.y);\n  \n	v_ViewDir = u_CameraPos - v_PositionWorld;\n  \n	#ifdef RECEIVESHADOW\n		v_posViewZ = gl_Position.w;\n		#ifdef SHADOWMAP_PSSM1 \n			v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n		#endif\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW\n		main_castShadow();\n	#else\n		main_normal();\n	#endif\n}";
			ps="#ifdef FSHIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\n\nuniform vec4 u_AmbientColor;\nuniform vec4 u_DiffuseColor;\nuniform vec4 u_SpecularColor;\n\n#ifdef DIFFUSETEXTURE\n	uniform sampler2D u_DiffuseTexture;\n#endif\n#ifdef SPECULARTEXTURE\n	uniform sampler2D u_SpecularTexture;\n#endif\n#ifdef NORMALTEXTURE\n	uniform sampler2D u_NormalTexture;\n	uniform float u_normalScale;\n#endif\n#ifdef PARALLAXTEXTURE\n	uniform sampler2D u_ParallaxTexture;\n	uniform float u_parallaxScale;\n#endif\n#ifdef OCCLUSIONTEXTURE\n	uniform sampler2D u_OcclusionTexture;\n	uniform float u_occlusionStrength;\n#endif\n#ifdef EMISSION\n	#ifdef EMISSIONTEXTURE\n		uniform sampler2D u_EmissionTexture;\n	#endif\n	uniform vec4 u_EmissionColor;\n#endif\n\nuniform float u_AlphaTestValue;\nuniform float u_metallic;\nuniform float u_smoothness;\nuniform float u_smoothnessScale;\n\n#include \"PBRSpecularLighting.glsl\"\n#include \"ShadowHelper.glsl\"\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n		uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n		varying vec4 v_lightMVPPos;\n	#endif\n#endif\n\nuniform DirectionLight u_DirectionLight;\n\nvoid main_castShadow()\n{\n	gl_FragColor=packDepth(v_posViewZ);\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		float alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\n		if( alpha < u_AlphaTestValue )\n		{\n			discard;\n		}\n	#endif\n}\n\nvoid main_normal()\n{	\n	vec3 viewDir = normalize(v_ViewDir);\n	\n	vec2 uv0 = ParallaxOffset(viewDir);\n	\n	vec4 sg;\n	#ifdef DIFFUSETEXTURE\n		vec4 diffuseTextureColor = texture2D(u_DiffuseTexture, uv0);\n		vec4 diffuseColor = diffuseTextureColor * u_DiffuseColor;\n		sg = SpecularGloss(diffuseTextureColor.a, uv0);\n	#else\n		vec4 diffuseColor = u_DiffuseColor;\n		sg = SpecularGloss(1.0, uv0);\n	#endif\n	\n	#ifdef ALPHATEST\n		if(diffuseColor.a < u_AlphaTestValue)\n			discard;\n	#endif\n  \n	vec3 normal = UnpackScaleNormal(uv0);\n	\n	vec3 gi = (u_AmbientColor * Occlusion(uv0)).rgb;\n	\n	//float a = (sg.r+sg.g+sg.b) / 3.0;\n  \n	vec4 color = PBRSpecularDiectionLight(diffuseColor.rgb, sg.rgb, sg.a, normal,viewDir, u_DirectionLight, gi);\n	\n	color.a = diffuseColor.a;\n	\n	#ifdef EMISSION\n		vec4 emissionColor = u_EmissionColor;\n		#ifdef EMISSIONTEXTURE\n			emissionColor *=  texture2D(u_EmissionTexture, uv0);\n		#endif\n		color.rgb += emissionColor.rgb;\n	#endif\n	\n	#ifdef RECEIVESHADOW\n		float shadowValue = 1.0;\n		#ifdef SHADOWMAP_PSSM3\n			shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif\n		#ifdef SHADOWMAP_PSSM2\n			shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif \n		#ifdef SHADOWMAP_PSSM1\n			shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n		#endif\n		gl_FragColor = vec4(color.rgb * shadowValue, color.a);\n	#else\n		gl_FragColor = color;\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW		\n		main_castShadow();\n	#else\n		main_normal();\n	#endif  \n}\n\n";
			shaderCompile=Shader3D.add("PBRSpecular",attributeMap,uniformMap);
			shaderCompile._addShaderPass(vs,ps);
			shaderCompile.addSpriteDefines(SkinnedMeshSprite3D.shaderDefines);
			shaderCompile.addMaterialDefines(PBRSpecularMaterial.shaderDefines);
			attributeMap={
				'a_position':0,
				'a_normal':3,
				'uv':2};
			uniformMap={
				'irrad_mat_red':[10,3],
				'irrad_mat_green':[11,3],
				'irrad_mat_blue':[12,3],
				'u_hdrexposure':[13,3],
				'texBaseColor':[1,1],
				'texNormal':[2,1],
				'texSky':[11,1],
				'texUnderWater':[3,1],
				'texPrefilterdEnv':[8,3],
				'texPrefilterDiff':[7,3],
				'texWaterDisp':[4,1],
				'texWaveDetail':[9,1],
				'texDeepColor':[10,1],
				'texWaterInfo':[16,1],
				'texFoam':[17,1],
				'GEOWAVE_UV_SCALE':[18,1],
				'modelMatrix':[0,2],
				'mvp':[1,2],
				'cameraPosition':[0,3],
				'u_curTm':[8,1],
				'u_scrsize':[15,1],
				'u_WaveInfoD':[13,1],
				'u_WaveInfo':[12,1],
				'u_WaveMainDir':[14,1],
				'u_DeepScale':[20,1],
				'u_SeaColor':[19,1],
				'u_View':[1,3],
				'u_Project':[2,3],
				'u_FogStart':[1,4],
				'u_FogRange':[2,4],
				'u_FogColor':[0,4],
				'u_DirectionLight.Direction':[3,4],
				'u_DirectionLight.Diffuse':[4,4],
				'u_PointLight.Position':[5,4],
				'u_PointLight.Range':[6,4],
				'u_PointLight.Attenuation':[7,4],
				'u_PointLight.Diffuse':[8,4],
				'u_SpotLight.Position':[9,4],
				'u_SpotLight.Direction':[10,4],
				'u_SpotLight.Range':[12,4],
				'u_SpotLight.Spot':[11,4],
				'u_SpotLight.Attenuation':[13,4],
				'u_SpotLight.Diffuse':[14,4]};
			vs="\nuniform mat4 modelMatrix;\n//uniform mat4 modelViewMatrix;\n//uniform mat4 projectionMatrix;\nuniform mat4 u_View;\nuniform mat4 u_Project;\nuniform mat4 mvp;\n//uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform float u_curTm;\n\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 uv;\n//uniform sampler2D texWaterDisp;\n#ifdef USE_VERTEX_DEEPINFO\n#else\nuniform sampler2D texWaterInfo;\nvarying vec4 vWaterInfo;\nuniform float u_DeepScale;//texWaterInfo.r*vDeepScale\n#endif\nuniform float u_WaveMainDir;	//主波方向\nuniform float GEOWAVE_UV_SCALE ;//= 100.0;\n\n\nvarying vec2 vUv;\nvarying vec3 vWorldNorm;\nvarying vec3 vWorldTan;\nvarying vec3 vWorldBin;\nvarying vec4 vViewPos;\nvarying vec4 vWorldPos;\nvarying vec3 vLightDir;\nvarying vec3 vViewDir;\nvarying vec3 vDisp;\nvarying float fDeep;\nvarying mat2 matUVTrans;\nvarying float fFoam;\n\nconst float PI = 3.14159265358979323846264;\n\n#include \"WaveFunction.glsl\"\n\nvec2 getPosFromUV(vec2 uv){\n	return uv*50.;\n}\n\nvoid main() {\n	vec3 pos = a_position;\n    vUv = uv;\n	\n	//vDisp = texture2D(texWaterDisp,uv).rgb;\n	//vec3 disp = vDisp;\n	\n	//TODO 这里有个潜规则。\n	float tt = pos.y; pos.y=pos.z; pos.z=-tt;\n	\n	#ifdef USE_VERTEX_DEEPINFO\n	fDeep = -pos.y;\n	pos.y=0.0;\n	#else\n	vWaterInfo = texture2D(texWaterInfo,uv);\n	fDeep = vWaterInfo.r*u_DeepScale;\n	#endif\n	\n	\n	//计算波形\n	mat4 modelMat = modelMatrix;\n	vec3 opos, T,B,N;\n	float foams=0.;\n	vec2 uvpos = uv*GEOWAVE_UV_SCALE+vec2(modelMat[3][0],0.);//TODO 如果有旋转缩放怎么办\n	calcGerstnerWave(u_curTm, pos,fDeep, uvpos,opos,B,T,N,foams);\n	fFoam = foams;\n	gl_Position = mvp*vec4(opos,1.);\n	vWorldPos = modelMat*vec4(opos,1.);\n\n	vWorldNorm = normalize((modelMatrix*vec4(N,0.0)).xyz);\n	vWorldTan = normalize((modelMatrix*vec4(T,0.0)).xyz);\n	vWorldBin = normalize((modelMatrix*vec4(B,0.0)).xyz);\n    vViewDir = vWorldPos.xyz-cameraPosition; //这个不能取normalize，否则会引入非线性\n	\n	float s = sin(u_WaveMainDir);\n	float c = cos(u_WaveMainDir);\n	matUVTrans = mat2(c,-s,s,c);\n}\n";
			ps="//#version 300 es\n\nprecision highp float;\nprecision lowp int;\n\nconst float PI = 3.14159265358979323846264;\nconst float _2PI = 6.2831853071796;\nvarying vec2 vUv;\nvarying vec3 vWorldNorm;\nvarying vec3 vWorldTan;\nvarying vec3 vWorldBin;\nvarying vec3 vViewDir;//入射。pos-cam\nvarying vec4 vViewPos;\nvarying vec4 vWorldPos;\nvarying float fDeep;\nvarying mat2 matUVTrans;\n#ifdef USE_VERTEX_DEEPINFO\n#else\nvarying vec4 vWaterInfo;\n#endif\nmat3 matTBNOff;//\n\n//\nuniform sampler2D texBaseColor;\nuniform sampler2D texNormal;\n#ifdef CUBE_ENV\nuniform samplerCube texSky;\n#else\nuniform sampler2D texSky;\n#endif\nuniform sampler2D texUnderWater;\nuniform sampler2D texWaveDetail;\n//uniform sampler2D texDeepColor;\nuniform sampler2D texFoam;\nvarying float fFoam;\nuniform float u_curTm;\nuniform vec2 u_scrsize;\nuniform vec3 u_SeaColor;//\n\nconst int NumTexWaves=4;\nconst float Amp_over_L = 0.01;\n//const vec3 SEA_COLOR1 = vec3(0.0292,0.672,0.7467);//大洋\n//const vec3 SEA_COLOR2 = vec3(0,0.927,0.43);//近海\n\nconst float _maxu8 = 255.0;\nconst float _maxu16 = 65535.0;\nconst float _shift8 = 256.0;    //平移的话是*256而不是255\nvec2 _RGBAToU16(const in vec4 rgba){\n    return vec2((rgba.r*_maxu8+rgba.g*_maxu8*_shift8)/_maxu16, (rgba.b*_maxu8+rgba.a*_maxu8*_shift8)/_maxu16);\n}\nvec3 _RGBEToRGB( const in vec4 rgba ){\n    float f = pow(2.0, rgba.w * 255.0 - (128.0 + 8.0));\n    return rgba.rgb * (255.0 * f);\n}\n\nfloat saturate(float v){\n    return min(max(v,0.),1.);\n}\n\n/*\n	各种 ToneMap\n*/\n//Reinhard\nvec3 ReinhardToneMapping(vec3 color, float adapted_lum) {\n    const float MIDDLE_GREY = 1.;\n    color *= MIDDLE_GREY / adapted_lum;\n    return color / (1.0 + color);\n}\n\n//CE2\nvec3 CEToneMapping(vec3 color, float adapted_lum){\n    return 1. - exp(-adapted_lum * color);\n}\n\n//UC2\nvec3 F1(vec3 x){\n	const float A = 0.22;\n	const float B = 0.30;\n	const float C = 0.10;\n	const float D = 0.20;\n	const float E = 0.01;\n	const float F = 0.30;\n \n	return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\nvec3 Uncharted2ToneMapping(vec3 color, float adapted_lum){\n	const vec3 WHITE = vec3(11.2);\n	return F1(1.6 * adapted_lum * color) / F1(WHITE);\n}\n\n//ACES\nvec3 ACESToneMapping(vec3 color, float adapted_lum){\n	const float A = 2.51;\n	const float B = 0.03;\n	const float C = 2.43;\n	const float D = 0.59;\n	const float E = 0.14;\n\n	color *= adapted_lum;\n	return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\n\n/*\n* 对一个全景图进行采样。假设x轴指向中心。\n*/\nvec4 texPanorama(sampler2D tex, const in vec3 dir){\n	float envu = atan(dir.z,dir.x)/_2PI+0.5; 	\n	float envv = acos(dir.y)/PI;//(1.0-dir.y)/2.0;\n	return texture2D(tex,vec2(envu,envv));\n}\n\n/*\n	与位于0点的测试棒的相交测试交点\n	这个是瞎写的，只是为了测试\n*/\nbool hitClydiner(vec3 pos, vec3 dir, out vec3 hitpos, out vec3 hitnormal){\n	const float r = 0.5;\n	float a = dir.x*dir.x+dir.z*dir.z;\n	float b = 2.*dir.x*pos.x+2.*dir.z*pos.z;\n	float c = pos.x*pos.x+pos.z*pos.z-r*r;\n	float d = b*b-4.*a*c;\n	if(d>=0.0){\n		float t = (-b+sqrt(d))/2./a;\n		t =min(t, (-b-sqrt(d))/2./a);\n		hitpos = pos+dir*t;\n		return true;\n	}\n	/*\n	vec3 v1 = normalize(cross(dir,vec3(0.,1.,0.)));//公垂线\n	float dist = dot(pos,v1);//最短距离\n	if(abs(dist)<r){\n		return true;\n	}\n	*/\n	return false;\n}\n\n///* 根据散射公式来计算某个方向的颜色 *///\n//\nfloat phase_function(float costheta, float g, float g2){\n	return 1.5*( (1.0-g2) / (2.0+g2) ) * (1.0+costheta*costheta) / pow(1.0+g2-2.0*g*costheta, 1.5);	\n}\n\nconst float _density = .2;\nconst vec3 _vLightDir=vec3(0.,-1.,0.);//必须是规格化的\nconst int _SAMPLENUM = 20;\nconst float _K1 = 1.0;\nconst float _g = -0.93;\n//\nvec3 calcScatter(vec3 start, vec3 dir, vec3 end){\n	float len = length(end-start);\n	float costheta = dot(dir,_vLightDir);\n	float g2 = _g*_g;\n	float K = _K1*len*_density*phase_function(costheta,_g,g2);\n	//用分段的方式来积分\n	float dlen = len/float(_SAMPLENUM);//距离平分\n	float ddeep = (start.y-end.y)/float(_SAMPLENUM);//深度平分\n	float sum=0.;\n	for( int i=0; i<_SAMPLENUM; i++){\n		float fi = float(i);\n		float v1 = exp(-_density*(dlen+ddeep)*fi);//TODO 应该可以用分析法计算出来\n		sum += v1;\n	}\n	return vec3(K*sum);\n}\n///* 根据散射公式来计算某个方向的亮度  END *///\n\nconst float cDeep = -2.;	//假设水的深度\nvec3 getShuiDiColor(vec3 pos, vec3 dir, vec3 normal){\n	//一个无限大的水底，黑白格纹理。纹理长度为1米\n	float t = ( cDeep-pos.y )/dir.y;\n	if(t<0.) return vec3(1.,0.,0.);//TEST\n	bool bhit = false;\n	vec3 hitpos;\n	vec3 hitcolor;\n	vec3 hn;\n	if(hitClydiner(pos,dir,hitpos,hn) && hitpos.y>cDeep && hitpos.y<pos.y){\n		bhit=true;\n		hitcolor = vec3(.8,.8,.8);\n\n	}else\n	{\n		hitpos = pos+dir*t;\n		vec3 hp = floor(hitpos);\n		float a = mod((hp.x+hp.z),2.);\n		hitcolor = (a<.9)?vec3(0.,0.,0.):vec3(1.,1.,1.);\n		//hitcolor = texture2D(texUnderWater,hitpos.xz/10.).rgb;\n	}\n	\n	float l = length(hitpos-pos);\n	//return texture2D(texDeepColor,vec2(min(max(l/400.,0.),1.),0.5)).rgb;\n	//return SEA_COLOR1*calcScatter(pos,dir,hitpos);\n	float left = pow(0.8,l);//假设透过率为80%，则到达水底的时候的光强。\n	return mix(hitcolor,u_SeaColor,1.-left);\n}\n\n/*\n	view已经normalize了\n*/\nvec3 getRefractColor(vec3 view,vec3 normal){\n	vec3 T = refract(-view, normal, 0.7);\n	return getShuiDiColor(vWorldPos.xyz,T,normal); \n}\n\nvec4 calcWaterC(vec3 view, vec3 normal, float von, vec3 R, float rough){\n	/*\n	只有浪顶的法线向下，也就是波形形成了交叠的时候，才会这样，所以要通过参数控制避免出现这种情况，而不是在这里保护。\n	if(dot(R,vec3(0.,1.,0.))<0.){\n		R = -R;\n	}\n	*/\n	//vec3 refr = getRefractColor(-view,normal);\n#ifdef USE_REFR_TEX	\n	vec3 refr = texture2D(texUnderWater, gl_FragCoord.xy/u_scrsize+normal.xz/8.).rgb;\n#else\n	vec3 refr = u_SeaColor;\n#endif\n	float F0=0.02;\n	//菲涅尔，越大反射越强\n	float f =  F0+(1.0-F0)*exp2((-5.55473*von-6.98316)*von);\n	//float f = F0+(1.0-F0)*pow(1.-von,5.);\n	//能看到水底的程度。反射剩余的*水中的衰减\n	//float a = (1.-f)*(1.-deepk);\n#ifdef CUBE_ENV\n	vec4 reflc = textureCube(texSky,R);\n#else\n	vec4 reflc = texPanorama(texSky, R);\n#endif\n#ifdef HDR_ENV\n	vec3 refl = _RGBEToRGB(reflc)*f;\n#else\n	vec3 refl = reflc.rgb*f;\n#endif\n	//return vec4(refl*(1.-rough),1.);\n	\n	//vec3 refl = reflc.rgb*f;\n	vec3 final = mix(refr, u_SeaColor, min(fDeep/10.,1.))+refl*(max(0.,1.-rough));\n#ifdef HDR_ENV\n	final = ACESToneMapping(final,1.);//TODO 这个要uniform传入\n#endif\n	return vec4(final,f);\n}\n\nvoid main() {\n    vec3 normal =  normalize(vWorldNorm);\n	//如果uv=1为100米，希望每个细节纹理表示20米的小波形，则uv缩放是 100/20。细节纹理内部也要用这个值，即pos=uv*20\n	vec2 ruv = matUVTrans*vUv;\n	vec3 detailNorm = texture2D(texWaveDetail,fract(ruv*5.)).rgb*2.-vec3(1.);//TODO uv怎么算\n	float texNormScale = 2.*PI*float(NumTexWaves)*Amp_over_L*2.5;\n	detailNorm *= vec3(texNormScale,1.,texNormScale);\n	//旋转\n	//细节纹理来自rendertarget，因此需要颠倒z\n	\n	matTBNOff = mat3(matUVTrans[0][0],0.,matUVTrans[1][0],\n	0.,1.,0.,\n	matUVTrans[0][1],0.,matUVTrans[1][1]\n	);\n	\n	/*\n	matTBNOff = mat3(0.,0.,1.,\n	0.,1.,0.,\n	-1.,0.,0.\n	);\n	*/\n\n    mat3 tsn = mat3( vWorldBin, normal, vWorldTan);	\n    //normal = normalize(tsn * matTBNOff * detailNorm);\n	normal = normalize(tsn * detailNorm); //这个应该更正确。因为本身方向就是根据uv算的，如果是静态图片才需要转换。\n	//vec4 normtex = texture2D( texNormal, vUv );\n    vec3 view   = -normalize(vViewDir);//view 是指向camera的\n    float NoV = saturate(dot( view, normal ));\n    //vec3 R = 2. * NoV * normal - view;\n	\n#ifdef USE_FOAM	\n	vec4 foamc = (texture2D(texFoam,vUv*50.)+texture2D(texFoam,vUv*20.))/2.;\n	float nearcoast = 1.-min(fDeep/10.,1.);// 1.-vWaterInfo.r;\n	float foams = (nearcoast/4.+fFoam)*2.*nearcoast;\n#else\n	float foams =0.;\n#endif\n	\n	vec3 R = reflect(-view,normal);\n	vec4 wc = calcWaterC(view, normal,NoV,R, foams);\n\n	gl_FragColor.rgb = wc.rgb;//normalize(detailNorm).rrr;//((normal)+vec3(0.0))/1.;//normalize(normal).rgb;//texture2D(texWaveDetail,vUv).rgb;// fracColor * texture2D(texUnderWater, vUv*20.0).rgb;// vec3(1.0);//pbrl.rgb;\n    gl_FragColor.a = 1.0;//wc.a;\n#ifdef USE_FOAM\n	gl_FragColor.rgb = mix(gl_FragColor.rgb,vec3(1.),foamc.a*foams);\n	gl_FragColor.a = foamc.r;\n#endif\n	//if(mod(vUv.x*100.,1.0)<0.02 || mod(vUv.y*100.,1.0)<0.02) gl_FragColor.rgb=vec3(0.5,.5,.5);\n	//gl_FragColor.rgb = detailNorm;\n}\n";
			shaderCompile=Shader3D.add("Water",attributeMap,uniformMap);
			shaderCompile._addShaderPass(vs,ps);
			shaderCompile.addMaterialDefines(WaterMaterial.shaderDefines);
			attributeMap={
				'a_CornerTextureCoordinate':17,
				'a_MeshPosition':0,
				'a_MeshColor':1,
				'a_MeshTextureCoordinate':2,
				'a_ShapePositionStartLifeTime':30,
				'a_DirectionTime':32,
				'a_StartColor':19,
				'a_EndColor':23,
				'a_StartSize':20,
				'a_StartRotation0':22,
				'a_StartSpeed':31,
				'a_Random0':34,
				'a_Random1':35,
				'a_SimulationWorldPostion':36,
				'a_SimulationWorldRotation':37};
			uniformMap={
				'u_Tintcolor':[2,1],
				'u_TilingOffset':[3,1],
				'u_texture':[1,1],
				'u_WorldPosition':[0,2],
				'u_WorldRotation':[1,2],
				'u_PositionScale':[4,2],
				'u_SizeScale':[5,2],
				'u_ScalingMode':[6,2],
				'u_Gravity':[7,2],
				'u_ThreeDStartRotation':[8,2],
				'u_StretchedBillboardLengthScale':[9,2],
				'u_StretchedBillboardSpeedScale':[10,2],
				'u_SimulationSpace':[11,2],
				'u_CurrentTime':[12,2],
				'u_ColorOverLifeGradientAlphas':[22,2],
				'u_ColorOverLifeGradientColors':[23,2],
				'u_MaxColorOverLifeGradientAlphas':[24,2],
				'u_MaxColorOverLifeGradientColors':[25,2],
				'u_VOLVelocityConst':[13,2],
				'u_VOLVelocityGradientX':[14,2],
				'u_VOLVelocityGradientY':[15,2],
				'u_VOLVelocityGradientZ':[16,2],
				'u_VOLVelocityConstMax':[17,2],
				'u_VOLVelocityGradientMaxX':[18,2],
				'u_VOLVelocityGradientMaxY':[19,2],
				'u_VOLVelocityGradientMaxZ':[20,2],
				'u_VOLSpaceType':[21,2],
				'u_SOLSizeGradient':[26,2],
				'u_SOLSizeGradientX':[27,2],
				'u_SOLSizeGradientY':[28,2],
				'u_SOLSizeGradientZ':[29,2],
				'u_SOLSizeGradientMax':[30,2],
				'u_SOLSizeGradientMaxX':[31,2],
				'u_SOLSizeGradientMaxY':[32,2],
				'u_SOLSizeGradientMaxZ':[33,2],
				'u_ROLAngularVelocityConst':[34,2],
				'u_ROLAngularVelocityConstSeprarate':[35,2],
				'u_ROLAngularVelocityGradient':[36,2],
				'u_ROLAngularVelocityGradientX':[37,2],
				'u_ROLAngularVelocityGradientY':[38,2],
				'u_ROLAngularVelocityGradientZ':[39,2],
				'u_ROLAngularVelocityGradientW':[40,2],
				'u_ROLAngularVelocityConstMax':[41,2],
				'u_ROLAngularVelocityConstMaxSeprarate':[42,2],
				'u_ROLAngularVelocityGradientMax':[43,2],
				'u_ROLAngularVelocityGradientMaxX':[44,2],
				'u_ROLAngularVelocityGradientMaxY':[45,2],
				'u_ROLAngularVelocityGradientMaxZ':[46,2],
				'u_ROLAngularVelocityGradientMaxW':[47,2],
				'u_TSACycles':[48,2],
				'u_TSASubUVLength':[49,2],
				'u_TSAGradientUVs':[50,2],
				'u_TSAMaxGradientUVs':[51,2],
				'u_CameraPosition':[0,3],
				'u_CameraDirection':[5,3],
				'u_CameraUp':[6,3],
				'u_View':[1,3],
				'u_Projection':[2,3],
				'u_FogStart':[1,4],
				'u_FogRange':[2,4],
				'u_FogColor':[0,4]};
			vs="#ifdef HIGHPRECISION\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\n	attribute vec4 a_CornerTextureCoordinate;\n#endif\n#ifdef RENDERMODE_MESH\n	attribute vec3 a_MeshPosition;\n	attribute vec4 a_MeshColor;\n	attribute vec2 a_MeshTextureCoordinate;\n	varying vec4 v_MeshColor;\n#endif\n\nattribute vec4 a_ShapePositionStartLifeTime;\nattribute vec4 a_DirectionTime;\nattribute vec4 a_StartColor;\nattribute vec3 a_StartSize;\nattribute vec3 a_StartRotation0;\nattribute float a_StartSpeed;\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n  attribute vec4 a_Random0;\n#endif\n#if defined(TEXTURESHEETANIMATIONRANDOMCURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  attribute vec4 a_Random1;\n#endif\nattribute vec3 a_SimulationWorldPostion;\nattribute vec4 a_SimulationWorldRotation;\n\nvarying float v_Discard;\nvarying vec4 v_Color;\n#ifdef DIFFUSEMAP\n	varying vec2 v_TextureCoordinate;\n#endif\n\nuniform float u_CurrentTime;\nuniform vec3 u_Gravity;\n\nuniform vec3 u_WorldPosition;\nuniform vec4 u_WorldRotation;\nuniform bool u_ThreeDStartRotation;\nuniform int u_ScalingMode;\nuniform vec3 u_PositionScale;\nuniform vec3 u_SizeScale;\nuniform mat4 u_View;\nuniform mat4 u_Projection;\n\n#ifdef STRETCHEDBILLBOARD\n	uniform vec3 u_CameraPosition;\n#endif\nuniform vec3 u_CameraDirection;//TODO:只有几种广告牌模式需要用\nuniform vec3 u_CameraUp;\n\nuniform  float u_StretchedBillboardLengthScale;\nuniform  float u_StretchedBillboardSpeedScale;\nuniform int u_SimulationSpace;\n\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  uniform  int  u_VOLSpaceType;\n#endif\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\n  uniform  vec3 u_VOLVelocityConst;\n#endif\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  uniform  vec2 u_VOLVelocityGradientX[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientY[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientZ[4];//x为key,y为速度\n#endif\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n  uniform  vec3 u_VOLVelocityConstMax;\n#endif\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n  uniform  vec2 u_VOLVelocityGradientMaxX[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientMaxY[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientMaxZ[4];//x为key,y为速度\n#endif\n\n#ifdef COLOROVERLIFETIME\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n#endif\n#ifdef RANDOMCOLOROVERLIFETIME\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n  uniform  vec4 u_MaxColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_MaxColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n#endif\n\n\n#if defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMERANDOMCURVES)\n  uniform  vec2 u_SOLSizeGradient[4];//x为key,y为尺寸\n#endif\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\n  uniform  vec2 u_SOLSizeGradientMax[4];//x为key,y为尺寸\n#endif\n#if defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\n  uniform  vec2 u_SOLSizeGradientX[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientY[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientZ[4];//x为key,y为尺寸\n#endif\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n  uniform  vec2 u_SOLSizeGradientMaxX[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientMaxY[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientMaxZ[4];//x为key,y为尺寸\n#endif\n\n\n#ifdef ROTATIONOVERLIFETIME\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\n    uniform  float u_ROLAngularVelocityConst;\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n    uniform  float u_ROLAngularVelocityConstMax;\n  #endif\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n    uniform  vec2 u_ROLAngularVelocityGradient[4];//x为key,y为旋转\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n    uniform  vec2 u_ROLAngularVelocityGradientMax[4];//x为key,y为旋转\n  #endif\n#endif\n#ifdef ROTATIONOVERLIFETIMESEPERATE\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\n    uniform  vec3 u_ROLAngularVelocityConstSeprarate;\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n    uniform  vec3 u_ROLAngularVelocityConstMaxSeprarate;\n  #endif\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n    uniform  vec2 u_ROLAngularVelocityGradientX[4];\n    uniform  vec2 u_ROLAngularVelocityGradientY[4];\n    uniform  vec2 u_ROLAngularVelocityGradientZ[4];\n	uniform  vec2 u_ROLAngularVelocityGradientW[4];\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n    uniform  vec2 u_ROLAngularVelocityGradientMaxX[4];\n    uniform  vec2 u_ROLAngularVelocityGradientMaxY[4];\n    uniform  vec2 u_ROLAngularVelocityGradientMaxZ[4];\n	uniform  vec2 u_ROLAngularVelocityGradientMaxW[4];\n  #endif\n#endif\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\n  uniform  float u_TSACycles;\n  uniform  vec2 u_TSASubUVLength;\n  uniform  vec2 u_TSAGradientUVs[4];//x为key,y为frame\n#endif\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\n  uniform  vec2 u_TSAMaxGradientUVs[4];//x为key,y为frame\n#endif\n\n#ifdef FOG\n	varying vec3 v_PositionWorld;\n#endif\n\n#ifdef TILINGOFFSET\n	uniform vec4 u_TilingOffset;\n#endif\n\nvec3 rotationByEuler(in vec3 vector,in vec3 rot)\n{\n	float halfRoll = rot.z * 0.5;\n    float halfPitch = rot.x * 0.5;\n	float halfYaw = rot.y * 0.5;\n\n	float sinRoll = sin(halfRoll);\n	float cosRoll = cos(halfRoll);\n	float sinPitch = sin(halfPitch);\n	float cosPitch = cos(halfPitch);\n	float sinYaw = sin(halfYaw);\n	float cosYaw = cos(halfYaw);\n\n	float quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n	float quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n	float quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n	float quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n	\n	//vec4 q=vec4(quaX,quaY,quaZ,quaW);\n	//vec3 temp = cross(q.xyz, vector) + q.w * vector;\n	//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\n	\n	float x = quaX + quaX;\n    float y = quaY + quaY;\n    float z = quaZ + quaZ;\n    float wx = quaW * x;\n    float wy = quaW * y;\n    float wz = quaW * z;\n	float xx = quaX * x;\n    float xy = quaX * y;\n	float xz = quaX * z;\n    float yy = quaY * y;\n    float yz = quaY * z;\n    float zz = quaZ * z;\n\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n	\n}\n\n//假定axis已经归一化\nvec3 rotationByAxis(in vec3 vector,in vec3 axis, in float angle)\n{\n	float halfAngle = angle * 0.5;\n	float sin = sin(halfAngle);\n	\n	float quaX = axis.x * sin;\n	float quaY = axis.y * sin;\n	float quaZ = axis.z * sin;\n	float quaW = cos(halfAngle);\n	\n	//vec4 q=vec4(quaX,quaY,quaZ,quaW);\n	//vec3 temp = cross(q.xyz, vector) + q.w * vector;\n	//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\n	\n	float x = quaX + quaX;\n    float y = quaY + quaY;\n    float z = quaZ + quaZ;\n    float wx = quaW * x;\n    float wy = quaW * y;\n    float wz = quaW * z;\n	float xx = quaX * x;\n    float xy = quaX * y;\n	float xz = quaX * z;\n    float yy = quaY * y;\n    float yz = quaY * z;\n    float zz = quaZ * z;\n\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n	\n}\n\nvec3 rotationByQuaternions(in vec3 v,in vec4 q) \n{\n	return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n \n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\nfloat getCurValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\n{\n	float curValue;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientNumber=gradientNumbers[i];\n		float key=gradientNumber.x;\n		if(key>=normalizedAge)\n		{\n			vec2 lastGradientNumber=gradientNumbers[i-1];\n			float lastKey=lastGradientNumber.x;\n			float age=(normalizedAge-lastKey)/(key-lastKey);\n			curValue=mix(lastGradientNumber.y,gradientNumber.y,age);\n			break;\n		}\n	}\n	return curValue;\n}\n#endif\n\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\n{\n	float totalValue=0.0;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientNumber=gradientNumbers[i];\n		float key=gradientNumber.x;\n		vec2 lastGradientNumber=gradientNumbers[i-1];\n		float lastValue=lastGradientNumber.y;\n		\n		if(key>=normalizedAge){\n			float lastKey=lastGradientNumber.x;\n			float age=(normalizedAge-lastKey)/(key-lastKey);\n			totalValue+=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0*a_ShapePositionStartLifeTime.w*(normalizedAge-lastKey);\n			break;\n		}\n		else{\n			totalValue+=(lastValue+gradientNumber.y)/2.0*a_ShapePositionStartLifeTime.w*(key-lastGradientNumber.x);\n		}\n	}\n	return totalValue;\n}\n#endif\n\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)\nvec4 getColorFromGradient(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float normalizedAge)\n{\n	vec4 overTimeColor;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientAlpha=gradientAlphas[i];\n		float alphaKey=gradientAlpha.x;\n		if(alphaKey>=normalizedAge)\n		{\n			vec2 lastGradientAlpha=gradientAlphas[i-1];\n			float lastAlphaKey=lastGradientAlpha.x;\n			float age=(normalizedAge-lastAlphaKey)/(alphaKey-lastAlphaKey);\n			overTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\n			break;\n		}\n	}\n	\n	for(int i=1;i<4;i++)\n	{\n		vec4 gradientColor=gradientColors[i];\n		float colorKey=gradientColor.x;\n		if(colorKey>=normalizedAge)\n		{\n			vec4 lastGradientColor=gradientColors[i-1];\n			float lastColorKey=lastGradientColor.x;\n			float age=(normalizedAge-lastColorKey)/(colorKey-lastColorKey);\n			overTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\n			break;\n		}\n	}\n	return overTimeColor;\n}\n#endif\n\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\nfloat getFrameFromGradient(in vec2 gradientFrames[4],in float normalizedAge)\n{\n	float overTimeFrame;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientFrame=gradientFrames[i];\n		float key=gradientFrame.x;\n		if(key>=normalizedAge)\n		{\n			vec2 lastGradientFrame=gradientFrames[i-1];\n			float lastKey=lastGradientFrame.x;\n			float age=(normalizedAge-lastKey)/(key-lastKey);\n			overTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\n			break;\n		}\n	}\n	return floor(overTimeFrame);\n}\n#endif\n\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\nvec3 computeParticleLifeVelocity(in float normalizedAge)\n{\n  vec3 outLifeVelocity;\n  #ifdef VELOCITYOVERLIFETIMECONSTANT\n	 outLifeVelocity=u_VOLVelocityConst; \n  #endif\n  #ifdef VELOCITYOVERLIFETIMECURVE\n     outLifeVelocity= vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\n  #endif\n  #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n	 outLifeVelocity=mix(u_VOLVelocityConst,u_VOLVelocityConstMax,vec3(a_Random1.y,a_Random1.z,a_Random1.w)); \n  #endif\n  #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n     outLifeVelocity=vec3(mix(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y),\n	                 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z),\n					 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\n  #endif\n					\n  return outLifeVelocity;\n} \n#endif\n\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float normalizedAge,vec3 gravityVelocity,vec4 worldRotation)\n{\n   vec3 startPosition;\n   vec3 lifePosition;\n   #if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n	#ifdef VELOCITYOVERLIFETIMECONSTANT\n		  startPosition=startVelocity*age;\n		  lifePosition=lifeVelocity*age;\n	#endif\n	#ifdef VELOCITYOVERLIFETIMECURVE\n		  startPosition=startVelocity*age;\n		  lifePosition=vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\n	#endif\n	#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n		  startPosition=startVelocity*age;\n		  lifePosition=lifeVelocity*age;\n	#endif\n	#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n		  startPosition=startVelocity*age;\n		  lifePosition=vec3(mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y)\n	      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z)\n	      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\n	#endif\n	\n	vec3 finalPosition;\n	if(u_VOLSpaceType==0){\n	  if(u_ScalingMode!=2)\n	   finalPosition =rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition),worldRotation);\n	  else\n	   finalPosition =rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition,worldRotation);\n	}\n	else{\n	  if(u_ScalingMode!=2)\n	    finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation)+lifePosition;\n	  else\n	    finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation)+lifePosition;\n	}\n  #else\n	 startPosition=startVelocity*age;\n	 vec3 finalPosition;\n	 if(u_ScalingMode!=2)\n	   finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation);\n	 else\n	   finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation);\n  #endif\n  \n  if(u_SimulationSpace==0)\n    finalPosition=finalPosition+a_SimulationWorldPostion;\n  else if(u_SimulationSpace==1) \n    finalPosition=finalPosition+u_WorldPosition;\n  \n  finalPosition+=0.5*gravityVelocity*age;\n \n  return  finalPosition;\n}\n\n\nvec4 computeParticleColor(in vec4 color,in float normalizedAge)\n{\n	#ifdef COLOROVERLIFETIME\n	  color*=getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge);\n	#endif\n	\n	#ifdef RANDOMCOLOROVERLIFETIME\n	  color*=mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge),getColorFromGradient(u_MaxColorOverLifeGradientAlphas,u_MaxColorOverLifeGradientColors,normalizedAge),a_Random0.y);\n	#endif\n\n    return color;\n}\n\nvec2 computeParticleSizeBillbard(in vec2 size,in float normalizedAge)\n{\n	#ifdef SIZEOVERLIFETIMECURVE\n		size*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\n	#endif\n	#ifdef SIZEOVERLIFETIMERANDOMCURVES\n	    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \n	#endif\n	#ifdef SIZEOVERLIFETIMECURVESEPERATE\n		size*=vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge));\n	#endif\n	#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n	    size*=vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\n	    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z));\n	#endif\n	return size;\n}\n\n#ifdef RENDERMODE_MESH\nvec3 computeParticleSizeMesh(in vec3 size,in float normalizedAge)\n{\n	#ifdef SIZEOVERLIFETIMECURVE\n		size*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\n	#endif\n	#ifdef SIZEOVERLIFETIMERANDOMCURVES\n	    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \n	#endif\n	#ifdef SIZEOVERLIFETIMECURVESEPERATE\n		size*=vec3(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge));\n	#endif\n	#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n	    size*=vec3(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\n	    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z)\n		,mix(getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxZ,normalizedAge),a_Random0.z));\n	#endif\n	return size;\n}\n#endif\n\nfloat computeParticleRotationFloat(in float rotation,in float age,in float normalizedAge)\n{ \n	#ifdef ROTATIONOVERLIFETIME\n		#ifdef ROTATIONOVERLIFETIMECONSTANT\n			float ageRot=u_ROLAngularVelocityConst*age;\n	        rotation+=ageRot;\n		#endif\n		#ifdef ROTATIONOVERLIFETIMECURVE\n			rotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\n		#endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n			float ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\n	        rotation+=ageRot;\n	    #endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n			rotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\n		#endif\n	#endif\n	#ifdef ROTATIONOVERLIFETIMESEPERATE\n		#ifdef ROTATIONOVERLIFETIMECONSTANT\n			float ageRot=u_ROLAngularVelocityConstSeprarate.z*age;\n	        rotation+=ageRot;\n		#endif\n		#ifdef ROTATIONOVERLIFETIMECURVE\n			rotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge);\n		#endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n			float ageRot=mix(u_ROLAngularVelocityConstSeprarate.z,u_ROLAngularVelocityConstMaxSeprarate.z,a_Random0.w)*age;\n	        rotation+=ageRot;\n	    #endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n			rotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\n		#endif\n	#endif\n	return rotation;\n}\n\n#if defined(RENDERMODE_MESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE))\nvec3 computeParticleRotationVec3(in vec3 rotation,in float age,in float normalizedAge)\n{ \n	#ifdef ROTATIONOVERLIFETIME\n	#ifdef ROTATIONOVERLIFETIMECONSTANT\n			float ageRot=u_ROLAngularVelocityConst*age;\n	        rotation+=ageRot;\n		#endif\n		#ifdef ROTATIONOVERLIFETIMECURVE\n			rotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\n		#endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n			float ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\n	        rotation+=ageRot;\n	    #endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n			rotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\n		#endif\n	#endif\n	#ifdef ROTATIONOVERLIFETIMESEPERATE\n	#ifdef ROTATIONOVERLIFETIMECONSTANT\n			vec3 ageRot=u_ROLAngularVelocityConstSeprarate*age;\n	        rotation+=ageRot;\n		#endif\n		#ifdef ROTATIONOVERLIFETIMECURVE\n			rotation+=vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge));\n		#endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n			vec3 ageRot=mix(u_ROLAngularVelocityConstSeprarate,u_ROLAngularVelocityConstMaxSeprarate,a_Random0.w)*age;\n	        rotation+=ageRot;\n	    #endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n			rotation+=vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,normalizedAge),a_Random0.w)\n	        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,normalizedAge),a_Random0.w)\n	        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\n		#endif\n	#endif\n	return rotation;\n}\n#endif\n\nvec2 computeParticleUV(in vec2 uv,in float normalizedAge)\n{ \n	#ifdef TEXTURESHEETANIMATIONCURVE\n		float cycleNormalizedAge=normalizedAge*u_TSACycles;\n		float frame=getFrameFromGradient(u_TSAGradientUVs,cycleNormalizedAge-floor(cycleNormalizedAge));\n		float totalULength=frame*u_TSASubUVLength.x;\n		float floorTotalULength=floor(totalULength);\n	    uv.x+=totalULength-floorTotalULength;\n		uv.y+=floorTotalULength*u_TSASubUVLength.y;\n    #endif\n	#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\n		float cycleNormalizedAge=normalizedAge*u_TSACycles;\n		float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n	    float frame=floor(mix(getFrameFromGradient(u_TSAGradientUVs,uvNormalizedAge),getFrameFromGradient(u_TSAMaxGradientUVs,uvNormalizedAge),a_Random1.x));\n		float totalULength=frame*u_TSASubUVLength.x;\n		float floorTotalULength=floor(totalULength);\n	    uv.x+=totalULength-floorTotalULength;\n		uv.y+=floorTotalULength*u_TSASubUVLength.y;\n    #endif\n	return uv;\n}\n\nvoid main()\n{\n	float age = u_CurrentTime - a_DirectionTime.w;\n	float normalizedAge = age/a_ShapePositionStartLifeTime.w;\n	vec3 lifeVelocity;\n	if(normalizedAge<1.0){ \n	vec3 startVelocity=a_DirectionTime.xyz*a_StartSpeed;\n	#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n		lifeVelocity= computeParticleLifeVelocity(normalizedAge);//计算粒子生命周期速度\n	#endif \n	vec3 gravityVelocity=u_Gravity*age;\n	\n	vec4 worldRotation;\n	if(u_SimulationSpace==0)\n		worldRotation=a_SimulationWorldRotation;\n	else\n		worldRotation=u_WorldRotation;\n	\n	vec3 center=computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge,gravityVelocity,worldRotation);//计算粒子位置\n   \n   \n   #ifdef SPHERHBILLBOARD\n		vec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n        vec3 cameraUpVector =normalize(u_CameraUp);//TODO:是否外面归一化\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\n        vec3 upVector = normalize(cross(sideVector,u_CameraDirection));\n	    corner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n		#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\n			if(u_ThreeDStartRotation){\n				vec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z,age,normalizedAge));\n				center += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,rotation);\n			}\n			else{\n				float rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n				float c = cos(rot);\n				float s = sin(rot);\n				mat2 rotation= mat2(c, -s, s, c);\n				corner=rotation*corner;\n				center += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n			}\n		#else\n			if(u_ThreeDStartRotation){\n				center += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,a_StartRotation0);\n			}\n			else{\n				float c = cos(a_StartRotation0.x);\n				float s = sin(a_StartRotation0.x);\n				mat2 rotation= mat2(c, -s, s, c);\n				corner=rotation*corner;\n				center += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n			}\n		#endif\n   #endif\n   \n   #ifdef STRETCHEDBILLBOARD\n	vec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n	vec3 velocity;\n	#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n	    if(u_VOLSpaceType==0)\n		  velocity=rotationByQuaternions(u_SizeScale*(startVelocity+lifeVelocity),worldRotation)+gravityVelocity;\n	    else\n		  velocity=rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+lifeVelocity+gravityVelocity;\n    #else\n	    velocity= rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+gravityVelocity;\n    #endif	\n		vec3 cameraUpVector = normalize(velocity);\n		vec3 direction = normalize(center-u_CameraPosition);\n        vec3 sideVector = normalize(cross(direction,normalize(velocity)));\n		\n		sideVector=u_SizeScale.xzy*sideVector;\n		cameraUpVector=length(vec3(u_SizeScale.x,0.0,0.0))*cameraUpVector;\n		\n	    vec2 size=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n		\n	    const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\n	    corner=rotaionZHalfPI*corner;\n	    corner.y=corner.y-abs(corner.y);\n		\n	    float speed=length(velocity);//TODO:\n	    center +=sign(u_SizeScale.x)*(sign(u_StretchedBillboardLengthScale)*size.x*corner.x*sideVector+(speed*u_StretchedBillboardSpeedScale+size.y*u_StretchedBillboardLengthScale)*corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef HORIZONTALBILLBOARD\n		vec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n        const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\n	    const vec3 sideVector = vec3(-1.0,0.0,0.0);\n		\n		float rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n        float c = cos(rot);\n        float s = sin(rot);\n        mat2 rotation= mat2(c, -s, s, c);\n	    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\n		corner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef VERTICALBILLBOARD\n		vec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n        const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\n		\n		float rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n        float c = cos(rot);\n        float s = sin(rot);\n        mat2 rotation= mat2(c, -s, s, c);\n	    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\n		corner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef RENDERMODE_MESH\n	    vec3 size=computeParticleSizeMesh(a_StartSize,normalizedAge);\n		#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\n			if(u_ThreeDStartRotation){\n				vec3 rotation=vec3(a_StartRotation0.xy,-computeParticleRotationFloat(a_StartRotation0.z, age,normalizedAge));\n				center+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,rotation),worldRotation);\n			}\n			else{\n				#ifdef ROTATIONOVERLIFETIME\n					float angle=computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n					if(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\n						center+= (rotationByQuaternions(rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),angle),worldRotation));//已验证\n					}\n					else{\n						#ifdef SHAPE\n							center+= u_SizeScale.xzy*(rotationByQuaternions(rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\n						#else\n							if(u_SimulationSpace==0)\n								center+=rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle);//已验证\n							else if(u_SimulationSpace==1)\n								center+=rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle),worldRotation);//已验证\n						#endif\n					}\n				#endif\n				#ifdef ROTATIONOVERLIFETIMESEPERATE\n					//TODO:是否应合并if(u_ThreeDStartRotation)分支代码,待测试\n					vec3 angle=computeParticleRotationVec3(vec3(0.0,0.0,a_StartRotation0.z), age,normalizedAge);\n					center+= (rotationByQuaternions(rotationByEuler(u_SizeScale*a_MeshPosition*size,vec3(angle.x,angle.y,angle.z)),worldRotation));//已验证\n				#endif		\n			}\n		#else\n			if(u_ThreeDStartRotation){\n				center+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,a_StartRotation0),worldRotation);//已验证\n			}\n			else{\n				if(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\n					if(u_SimulationSpace==0)\n						center+= rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x);\n					else if(u_SimulationSpace==1)\n						center+= (rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x),worldRotation));//已验证\n				}\n				else{\n					#ifdef SHAPE\n						if(u_SimulationSpace==0)\n							center+= u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x);\n						else if(u_SimulationSpace==1)\n							center+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x),worldRotation);	\n					#else\n						if(u_SimulationSpace==0)\n							center+= rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x);\n						else if(u_SimulationSpace==1)\n							center+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x),worldRotation);//已验证\n					#endif\n				}\n			}\n		#endif\n		v_MeshColor=a_MeshColor;\n   #endif\n   \n    gl_Position=u_Projection*u_View*vec4(center,1.0);\n    v_Color = computeParticleColor(a_StartColor, normalizedAge);\n	#ifdef DIFFUSEMAP\n		#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\n			v_TextureCoordinate =computeParticleUV(a_CornerTextureCoordinate.zw, normalizedAge);\n		#endif\n		#ifdef RENDERMODE_MESH\n			v_TextureCoordinate =computeParticleUV(a_MeshTextureCoordinate, normalizedAge);\n		#endif\n		\n		#ifdef TILINGOFFSET\n			v_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y)*u_TilingOffset.xy+vec2(u_TilingOffset.z,-u_TilingOffset.w);//需要特殊处理\n			v_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y);//需要特殊处理\n		#endif\n	#endif\n    v_Discard=0.0;\n	  \n	#ifdef FOG\n		v_PositionWorld=center;\n	#endif\n   }\n   else\n	{\n		v_Discard=1.0;\n	}\n}\n\n";
			ps="#ifdef HIGHPRECISION\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nvarying float v_Discard;\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\nuniform sampler2D u_texture;\nuniform vec4 u_Tintcolor;\n\n#ifdef RENDERMODE_MESH\n	varying vec4 v_MeshColor;\n#endif\n\n#ifdef FOG\n	varying vec3 v_PositionWorld;\n	uniform vec3 u_CameraPosition;\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	#ifdef ADDTIVEFOG\n	#else\n		uniform vec3 u_FogColor;\n	#endif\n#endif\n\n\nvoid main()\n{	\n	#ifdef RENDERMODE_MESH\n		gl_FragColor=v_MeshColor;\n	#else\n		gl_FragColor=vec4(1.0);	\n	#endif\n		\n	#ifdef DIFFUSEMAP\n		if(v_Discard!=0.0)\n			discard;\n		#ifdef TINTCOLOR\n			gl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*u_Tintcolor*2.0*v_Color;\n		#else\n			gl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*v_Color;\n		#endif\n	#else\n		#ifdef TINTCOLOR\n			gl_FragColor*=u_Tintcolor*2.0*v_Color;\n		#else\n			gl_FragColor*=v_Color;\n		#endif\n	#endif\n	\n	#ifdef FOG\n		vec3 toEye=u_CameraPosition-v_PositionWorld;\n		float toEyeLength=length(toEye);\n		toEye/=toEyeLength;\n		\n		float lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n		#ifdef ADDTIVEFOG\n			gl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\n		#else\n			gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n		#endif\n	#endif\n}";
			shaderCompile=Shader3D.add("PARTICLESHURIKEN",attributeMap,uniformMap);
			shaderCompile._addShaderPass(vs,ps);
			shaderCompile.addSpriteDefines(ShuriKenParticle3D.shaderDefines);
			shaderCompile.addMaterialDefines(ShurikenParticleMaterial.shaderDefines);
			attributeMap={
				'a_Position':0};
			uniformMap={
				'u_TintColor':[1,1],
				'u_Exposure':[2,1],
				'u_Rotation':[3,1],
				'u_CubeTexture':[4,1],
				'u_MvpMatrix':[4,3]};
			vs="attribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\nuniform float u_Rotation;\nvarying vec3 v_Texcoord;\n\n\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\n{\n	float angle = degrees * 3.141593 / 180.0;\n	float sina=sin(angle);\n	float cosa=cos(angle);\n	mat2 m = mat2(cosa, -sina, sina, cosa);\n	return vec4(m*vertex.xz, vertex.yw).xzyw;\n}\n		\nvoid main()\n{\n	vec4 position=rotateAroundYInDegrees(a_Position,u_Rotation);\n	gl_Position = (u_MvpMatrix*position).xyww;\n	v_Texcoord=vec3(-a_Position.x,a_Position.yz);\n}\n";
			ps="#ifdef HIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec3 v_Texcoord;\n\nuniform samplerCube u_CubeTexture;\nuniform float u_Exposure;\nuniform vec4 u_TintColor;\n\n\nvoid main()\n{	\n	vec3 color=textureCube(u_CubeTexture, v_Texcoord).rgb*u_TintColor.rgb*u_Exposure*2.0;\n	gl_FragColor=vec4(color,1.0);\n}\n\n";
			shaderCompile=Shader3D.add("SkyBox",attributeMap,uniformMap);
			shaderCompile._addShaderPass(vs,ps);
			attributeMap={
				'a_Position':0,
				'a_Texcoord0':2};
			uniformMap={
				'u_Intensity':[Sky.INTENSITY,1],
				'u_AlphaBlending':[Sky.ALPHABLENDING,1],
				'u_texture':[Sky.DIFFUSETEXTURE,1],
				'u_MvpMatrix':[4,3]};
			vs="attribute vec4 a_Position;\nattribute vec2 a_Texcoord0;\nuniform mat4 u_MvpMatrix;\nvarying vec2 v_Texcoord;\n\n\nvoid main()\n{\n  gl_Position = (u_MvpMatrix*a_Position).xyww;\n  v_Texcoord = a_Texcoord0;\n}\n";
			ps="#ifdef HIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform float u_Intensity;\nuniform float u_AlphaBlending;\nuniform sampler2D u_texture;\n\nvarying vec2 v_Texcoord;\n\n\nvoid main()\n{	\n  gl_FragColor=vec4(texture2D(u_texture, v_Texcoord).rgb*u_Intensity,u_AlphaBlending);\n}\n\n";
			shaderCompile=Shader3D.add("SkyDome",attributeMap,uniformMap);
			shaderCompile._addShaderPass(vs,ps);
			attributeMap={
				'a_Position':0,
				'a_Normal':3,
				'a_Texcoord0':2,
				'a_Texcoord1':15};
			uniformMap={
				'u_MvpMatrix':[1,2],
				'u_WorldMat':[0,2],
				'u_LightmapScaleOffset':[2,2],
				'u_LightMap':[3,2],
				'u_SplatAlphaTexture':[0,1],
				'u_NormalTexture':[1,1],
				'u_DiffuseTexture1':[2,1],
				'u_DiffuseTexture2':[3,1],
				'u_DiffuseTexture3':[4,1],
				'u_DiffuseTexture4':[5,1],
				'u_DiffuseScale1':[6,1],
				'u_DiffuseScale2':[7,1],
				'u_DiffuseScale3':[8,1],
				'u_DiffuseScale4':[9,1],
				'u_MaterialDiffuse':[11,1],
				'u_MaterialAmbient':[10,1],
				'u_MaterialSpecular':[12,1],
				'u_CameraPos':[0,3],
				'u_FogStart':[1,4],
				'u_FogRange':[2,4],
				'u_FogColor':[0,4],
				'u_DirectionLight.Direction':[3,4],
				'u_DirectionLight.Diffuse':[4,4],
				'u_PointLight.Position':[5,4],
				'u_PointLight.Range':[6,4],
				'u_PointLight.Attenuation':[7,4],
				'u_PointLight.Diffuse':[8,4],
				'u_SpotLight.Position':[9,4],
				'u_SpotLight.Direction':[10,4],
				'u_SpotLight.Range':[12,4],
				'u_SpotLight.Spot':[11,4],
				'u_SpotLight.Attenuation':[13,4],
				'u_SpotLight.Diffuse':[14,4],
				'u_AmbientColor':[21,4],
				'u_shadowMap1':[18,4],
				'u_shadowMap2':[19,4],
				'u_shadowMap3':[20,4],
				'u_shadowPSSMDistance':[15,4],
				'u_lightShadowVP':[16,4],
				'u_shadowPCFoffset':[17,4]};
			vs="attribute vec4 a_Position;\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\n	attribute vec3 a_Normal;\n	varying vec3 v_Normal;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\n	uniform mat4 u_WorldMat;\n	varying vec3 v_PositionWorld;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n  varying vec4 v_lightMVPPos;\n  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef LIGHTMAP\n	uniform vec4 u_LightmapScaleOffset;\n	varying vec2 v_LightMapUV;\n#endif\n\nattribute vec2 a_Texcoord0;\nattribute vec2 a_Texcoord1;\nvarying vec2 v_Texcoord0;\nvarying vec2 v_Texcoord1;\nuniform mat4 u_MvpMatrix;\n\nvoid main()\n{\n	gl_Position = u_MvpMatrix * a_Position;\n	v_Texcoord0=a_Texcoord0;\n	v_Texcoord1=a_Texcoord1;\n	\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	v_Normal=a_Normal;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\n	v_PositionWorld=(u_WorldMat*a_Position).xyz;\n#endif\n\n#ifdef LIGHTMAP\n	//这个地方使用a_Normal 并不是真的代表normal，其实凑巧法线图的uv正好是符合 light_Map的UV\n	v_LightMapUV=vec2(a_Normal.x*u_LightmapScaleOffset.x+u_LightmapScaleOffset.z,(a_Normal.y-1.0)*u_LightmapScaleOffset.y+u_LightmapScaleOffset.w);\n#endif\n\n#ifdef RECEIVESHADOW\n	v_posViewZ = gl_Position.w;\n	#ifdef SHADOWMAP_PSSM1\n		v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n	#endif\n#endif\n\n}";
			ps="#ifdef HIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\n#include?DIRECTIONLIGHT||POINTLIGHT||SPOTLIGHT \"LightHelper.glsl\";\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	uniform vec3 u_MaterialDiffuse;\n	uniform vec4 u_MaterialSpecular;\n	uniform vec3 u_CameraPos;\n	varying vec3 v_Normal;\n	varying vec3 v_PositionWorld;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\n	uniform vec3 u_MaterialAmbient;\n#endif\n\n#ifdef FOG\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	uniform vec3 u_FogColor;\n#endif\n\n\n#ifdef DIRECTIONLIGHT\n	uniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\n	uniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\n	uniform SpotLight u_SpotLight;\n#endif\n\nuniform vec3 u_AmbientColor;\n\n#include \"ShadowHelper.glsl\"\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n	uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n	varying vec4 v_lightMVPPos;\n	#endif\n#endif\nvarying float v_posViewZ;\n\n\nuniform sampler2D u_SplatAlphaTexture;\nuniform sampler2D u_NormalTexture;\nuniform sampler2D u_DiffuseTexture1;\nuniform sampler2D u_DiffuseTexture2;\nuniform sampler2D u_DiffuseTexture3;\nuniform sampler2D u_DiffuseTexture4;\nuniform vec2 u_DiffuseScale1;\nuniform vec2 u_DiffuseScale2;\nuniform vec2 u_DiffuseScale3;\nuniform vec2 u_DiffuseScale4;\nvarying vec2 v_Texcoord0;\nvarying vec2 v_Texcoord1;\n\n#ifdef LIGHTMAP\n	uniform sampler2D u_LightMap;\n	varying vec2 v_LightMapUV;\n#endif\n\nvoid main()\n{\n#ifdef DETAIL_NUM1\n	vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord1/u_DiffuseScale1);\n	vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n	gl_FragColor.xyz = color1.xyz;\n#endif\n#ifdef DETAIL_NUM2\n	vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord1/u_DiffuseScale1);\n	vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord1/u_DiffuseScale2);\n	vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n	gl_FragColor.xyz = color1.xyz * (1.0-splatAlpha.r) + color2.xyz * splatAlpha.r;\n#endif\n#ifdef DETAIL_NUM3\n	vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord1/u_DiffuseScale1);\n	vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord1/u_DiffuseScale2);\n	vec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord1/u_DiffuseScale3);\n	vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n	gl_FragColor.xyz = color1.xyz * (1.0-(splatAlpha.r+splatAlpha.g)) + color2.xyz * splatAlpha.r + color3.xyz * splatAlpha.g;\n#endif\n#ifdef DETAIL_NUM4\n	vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord1/u_DiffuseScale1);\n	vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord1/u_DiffuseScale2);\n	vec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord1/u_DiffuseScale3);\n	vec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord1/u_DiffuseScale4);\n	vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n	gl_FragColor.xyz = color1.xyz * (1.0-(splatAlpha.r+splatAlpha.g+splatAlpha.b))+ color2.xyz * splatAlpha.r + color3.xyz * splatAlpha.g + color4.xyz * splatAlpha.b;\n#endif\n	gl_FragColor.w = splatAlpha.a;\n		\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n    vec3 normal = texture2D(u_NormalTexture,v_Normal.xy).xyz;\n	normal = normal*2.0 - vec3(1.0);\n	vec3 diffuse = vec3(0.0);\n	vec3 ambient = vec3(0.0);\n	vec3 specular= vec3(0.0);\n	vec3 dif, amb, spe;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\n	vec3 toEye;\n	#ifdef FOG\n		toEye=u_CameraPos-v_PositionWorld;\n		float toEyeLength=length(toEye);\n		toEye/=toEyeLength;\n	#else\n		toEye=normalize(u_CameraPos-v_PositionWorld);\n	#endif\n#endif\n\n#ifdef DIRECTIONLIGHT\n	computeDirectionLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_DirectionLight,u_AmbientColor,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n \n#ifdef POINTLIGHT\n	computePointLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_PointLight,u_AmbientColor,v_PositionWorld,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n\n#ifdef SPOTLIGHT\n	ComputeSpotLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_SpotLight,u_AmbientColor,v_PositionWorld,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n\n#ifdef RECEIVESHADOW\n	float shadowValue = 1.0;\n	#ifdef SHADOWMAP_PSSM3\n		shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif\n	#ifdef SHADOWMAP_PSSM2\n		shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif \n	#ifdef SHADOWMAP_PSSM1\n		shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n	#endif\n#endif\n\n#ifdef LIGHTMAP\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient + texture2D(u_LightMap, v_LightMapUV).rgb);\n	#else\n		#if defined(RECEIVESHADOW)\n			gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient + texture2D(u_LightMap, v_LightMapUV).rgb * shadowValue);\n		#else\n			gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient + texture2D(u_LightMap, v_LightMapUV).rgb);\n		#endif\n	#endif\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	#ifdef RECEIVESHADOW\n		gl_FragColor =vec4( gl_FragColor.rgb*(ambient + diffuse*shadowValue) + specular * shadowValue,gl_FragColor.a);\n	#else\n		gl_FragColor =vec4( gl_FragColor.rgb*(ambient + diffuse) + specular, gl_FragColor.a);\n	#endif\n#endif\n\n#ifdef FOG\n	float lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n	gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n#endif\n}\n\n";
			shaderCompile=Shader3D.add("Terrain",attributeMap,uniformMap);
			shaderCompile._addShaderPass(vs,ps);
			shaderCompile.addSpriteDefines(RenderableSprite3D.shaderDefines);
			shaderCompile.addMaterialDefines(TerrainMaterial.shaderDefines);
			attributeMap={
				'a_Position':0,
				'a_Normal':3,
				'a_Texcoord0':2
			};
			uniformMap={
				'u_MvpMatrix':[1,2],
				'u_WorldMat':[0,2],
				'u_CameraPos':[0,3],
				'u_LightmapScaleOffset':[2,2],
				'u_LightMap':[3,2],
				'u_SplatAlphaTexture':[0,1],
				'u_DiffuseTexture1':[1,1],
				'u_DiffuseTexture2':[2,1],
				'u_DiffuseTexture3':[3,1],
				'u_DiffuseTexture4':[4,1],
				'u_DiffuseTexture5':[5,1],
				'u_DiffuseScaleOffset1':[6,1],
				'u_DiffuseScaleOffset2':[7,1],
				'u_DiffuseScaleOffset3':[8,1],
				'u_DiffuseScaleOffset4':[9,1],
				'u_DiffuseScaleOffset5':[10,1],
				'u_MaterialAlbedo':[14,1],
				'u_MaterialDiffuse':[12,1],
				'u_MaterialAmbient':[11,1],
				'u_MaterialSpecular':[13,1],
				'u_FogStart':[1,4],
				'u_FogRange':[2,4],
				'u_FogColor':[0,4],
				'u_DirectionLight.Direction':[3,4],
				'u_DirectionLight.Diffuse':[4,4],
				'u_PointLight.Position':[5,4],
				'u_PointLight.Range':[6,4],
				'u_PointLight.Attenuation':[7,4],
				'u_PointLight.Diffuse':[8,4],
				'u_SpotLight.Position':[9,4],
				'u_SpotLight.Direction':[10,4],
				'u_SpotLight.Range':[12,4],
				'u_SpotLight.Spot':[11,4],
				'u_SpotLight.Attenuation':[13,4],
				'u_SpotLight.Diffuse':[14,4],
				'u_AmbientColor':[21,4],
				'u_shadowMap1':[18,4],
				'u_shadowMap2':[19,4],
				'u_shadowMap3':[20,4],
				'u_shadowPSSMDistance':[15,4],
				'u_lightShadowVP':[16,4],
				'u_shadowPCFoffset':[17,4]
			};
			vs="attribute vec4 a_Position;\nattribute vec2 a_Texcoord0;\n\nuniform mat4 u_MvpMatrix;\n\nvarying vec2 v_Texcoord0;\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\n	attribute vec3 a_Normal;\n	varying vec3 v_Normal;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\n	uniform mat4 u_WorldMat;\n	varying vec3 v_PositionWorld;\n#endif\n\n#ifdef LIGHTMAP\n	varying vec2 v_LightMapUV;\n	uniform vec4 u_LightmapScaleOffset;\n#endif\n\n#ifdef RECEIVESHADOW\n	varying float v_posViewZ;\n	#ifdef SHADOWMAP_PSSM1 \n		varying vec4 v_lightMVPPos;\n		uniform mat4 u_lightShadowVP[4];\n	#endif\n#endif\n\nvoid main()\n{\n	gl_Position = u_MvpMatrix * a_Position;\n  \n	v_Texcoord0 = a_Texcoord0;\n  \n	#ifdef LIGHTMAP\n		v_LightMapUV = vec2(a_Texcoord0.x*u_LightmapScaleOffset.x+u_LightmapScaleOffset.z,(a_Texcoord0.y-1.0)*u_LightmapScaleOffset.y+u_LightmapScaleOffset.w);\n	#endif\n  \n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		v_Normal = a_Normal;\n	#endif\n\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\n		v_PositionWorld=(u_WorldMat*a_Position).xyz;\n	#endif\n\n	#ifdef RECEIVESHADOW\n		v_posViewZ = gl_Position.w;\n		#ifdef SHADOWMAP_PSSM1\n			v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n		#endif\n	#endif\n}";
			ps="#ifdef HIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\n#include?DIRECTIONLIGHT||POINTLIGHT||SPOTLIGHT \"LightHelper.glsl\";\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\n	uniform vec3 u_MaterialDiffuse;\n	uniform vec4 u_MaterialSpecular;\n	uniform vec3 u_CameraPos;\n	varying vec3 v_Normal;\n	varying vec3 v_PositionWorld;\n#endif\n\n#ifdef FOG\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	uniform vec3 u_FogColor;\n#endif\n\n\n#ifdef DIRECTIONLIGHT\n	uniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\n	uniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\n	uniform SpotLight u_SpotLight;\n#endif\n\nuniform vec3 u_AmbientColor;\n\n#include \"ShadowHelper.glsl\"\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n	uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n	varying vec4 v_lightMVPPos;\n	#endif\n#endif\nvarying float v_posViewZ;\n\n\nuniform sampler2D u_SplatAlphaTexture;\n\nuniform sampler2D u_DiffuseTexture1;\nuniform sampler2D u_DiffuseTexture2;\nuniform sampler2D u_DiffuseTexture3;\nuniform sampler2D u_DiffuseTexture4;\nuniform sampler2D u_DiffuseTexture5;\n\nuniform vec4 u_DiffuseScaleOffset1;\nuniform vec4 u_DiffuseScaleOffset2;\nuniform vec4 u_DiffuseScaleOffset3;\nuniform vec4 u_DiffuseScaleOffset4;\nuniform vec4 u_DiffuseScaleOffset5;\n\nvarying vec2 v_Texcoord0;\n\nuniform vec3 u_MaterialAmbient;\nuniform vec4 u_MaterialAlbedo;\n\n#ifdef LIGHTMAP\n	uniform sampler2D u_LightMap;\n	varying vec2 v_LightMapUV;\n#endif\n\nvoid main()\n{\n	#ifdef ExtendTerrain_DETAIL_NUM1\n		vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n		vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n		gl_FragColor.xyz = color1.xyz * splatAlpha.r;\n	#endif\n	#ifdef ExtendTerrain_DETAIL_NUM2\n		vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n		vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n		vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n		gl_FragColor.xyz = color1.xyz * splatAlpha.r + color2.xyz * (1.0 - splatAlpha.r);\n	#endif\n	#ifdef ExtendTerrain_DETAIL_NUM3\n		vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n		vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n		vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n		vec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\n		gl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * (1.0 - splatAlpha.r - splatAlpha.g);\n	#endif\n	#ifdef ExtendTerrain_DETAIL_NUM4\n		vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n		vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n		vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n		vec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\n		vec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\n		gl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b);\n	#endif\n	#ifdef ExtendTerrain_DETAIL_NUM5\n		vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n		vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n		vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n		vec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\n		vec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\n		vec4 color5 = texture2D(u_DiffuseTexture5, v_Texcoord0 * u_DiffuseScaleOffset5.xy);\n		gl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * splatAlpha.a + color5.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b - splatAlpha.a);\n	#endif\n		gl_FragColor.w = splatAlpha.a;\n		\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n    vec3 normal = v_Normal;\n	vec3 diffuse = vec3(0.0);\n	vec3 ambient = vec3(0.0);\n	vec3 specular= vec3(0.0);\n	vec3 dif, amb, spe;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\n	vec3 toEye;\n	#ifdef FOG\n		toEye=u_CameraPos-v_PositionWorld;\n		float toEyeLength=length(toEye);\n		toEye/=toEyeLength;\n	#else\n		toEye=normalize(u_CameraPos-v_PositionWorld);\n	#endif\n#endif\n\n#ifdef DIRECTIONLIGHT\n	computeDirectionLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_DirectionLight,u_AmbientColor,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n \n#ifdef POINTLIGHT\n	computePointLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_PointLight,u_AmbientColor,v_PositionWorld,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n\n#ifdef SPOTLIGHT\n	ComputeSpotLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_SpotLight,u_AmbientColor,v_PositionWorld,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n\n#ifdef RECEIVESHADOW\n	float shadowValue = 1.0;\n	#ifdef SHADOWMAP_PSSM3\n		shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif\n	#ifdef SHADOWMAP_PSSM2\n		shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif \n	#ifdef SHADOWMAP_PSSM1\n		shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n	#endif\n#endif\n\n#ifdef LIGHTMAP\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient + texture2D(u_LightMap, v_LightMapUV).rgb);\n	#else\n		#if defined(RECEIVESHADOW)		\n			gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient+texture2D(u_LightMap, v_LightMapUV).rgb * shadowValue);\n			//vec3 tColor= u_MaterialAmbient + texture2D(u_LightMap, v_LightMapUV).rgb * shadowValue + mix(vec3(0.15,0.15,0.15),vec3(0.0),shadowValue);\n			//gl_FragColor.rgb*=tColor;\n		#else\n			gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient + texture2D(u_LightMap, v_LightMapUV).rgb);\n		#endif\n	#endif\n#endif\n\ngl_FragColor=gl_FragColor*u_MaterialAlbedo;\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	#ifdef RECEIVESHADOW\n		gl_FragColor = vec4( gl_FragColor.rgb*(ambient + diffuse*shadowValue) + specular * shadowValue,gl_FragColor.a);\n	#else\n		gl_FragColor =vec4( gl_FragColor.rgb*(ambient + diffuse) + specular, gl_FragColor.a);\n	#endif\n#endif\n\n#ifdef FOG\n	float lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n	gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n#endif\n}\n\n\n\n\n\n";
			shaderCompile=Shader3D.add("ExtendTerrain",attributeMap,uniformMap);
			shaderCompile._addShaderPass(vs,ps);
			shaderCompile.addSpriteDefines(RenderableSprite3D.shaderDefines);
			shaderCompile.addSpriteDefines(ExtendTerrainMaterial.shaderDefines);
		}

		return ShaderInit3D;
	})()


	/**
	*@private
	*<code>shaderVariable</code> 类用于保存shader变量上传相关信息。
	*/
	//class laya.d3.shader.ShaderVariable
	var ShaderVariable=(function(){
		function ShaderVariable(){
			//this.name=null;
			//this.type=0;
			//this.location=0;
			//this.isArray=false;
			//this.textureID=0;
			//this.dataOffset=0;
			//this.caller=null;
			//this.fun=null;
			//this.uploadedValue=null;
			this.textureID=-1;
		}

		__class(ShaderVariable,'laya.d3.shader.ShaderVariable');
		return ShaderVariable;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.shadowMap.ParallelSplitShadowMap
	var ParallelSplitShadowMap=(function(){
		function ParallelSplitShadowMap(){
			//this.lastNearPlane=NaN;
			//this.lastFieldOfView=NaN;
			//this.lastAspectRatio=NaN;
			this._currentPSSM=-1;
			this._numberOfPSSM=3;
			this._maxDistance=200.0;
			this._ratioOfDistance=1.0 / this._numberOfPSSM;
			this._statesDirty=true;
			this._lightCulling=null;
			this._renderTarget=null;
			this._lightVPMatrix=null;
			this._lightCameras=null;
			this._shadowQuenes=null;
			this._shadowMapTextureSize=1024;
			this._scene=null;
			this._PCFType=0;
			this._shaderValueLightVP=null;
			this._shaderValueVPs=null;
			this._spiltDistance=new Array(3+1);
			this._globalParallelLightDir=new Vector3(0,-1,0);
			this._boundingSphere=new Array(3+1);
			this._boundingBox=new Array(3+1);
			this._frustumPos=new Array((3+1)*4);
			this._uniformDistance=new Array(3+1);
			this._logDistance=new Array(3+1);
			this._dimension=new Array(3+1);
			this._tempLookAt3=new Vector3();
			this._tempLookAt4=new Vector4();
			this._tempValue=new Vector4();
			this._tempPos=new Vector3();
			this._tempLightUp=new Vector3();
			this._tempMin=new Vector4();
			this._tempMax=new Vector4();
			this._tempMatrix44=new Matrix4x4;
			this._splitFrustumCulling=new BoundFrustum(Matrix4x4.DEFAULT);
			this._tempScaleMatrix44=new Matrix4x4;
			this._shadowPCFOffset=new Vector2(1.0 / 1024.0,1.0 / 1024.0);
			this._shaderValueDistance=new Vector4();
			var i=0;
			for (i=0;i < this._spiltDistance.length;i++){
				this._spiltDistance[i]=0.0;
			}
			for (i=0;i < this._dimension.length;i++){
				this._dimension[i]=new Vector2();
			}
			for (i=0;i < this._frustumPos.length;i++){
				this._frustumPos[i]=new Vector3();
			}
			for (i=0;i < this._boundingBox.length;i++){
				this._boundingBox[i]=new BoundBox(new Vector3(),new Vector3());
			}
			for (i=0;i < this._boundingSphere.length;i++){
				this._boundingSphere[i]=new BoundSphere(new Vector3(),0.0);
			}
			Matrix4x4.createScaling(new Vector3(0.5,0.5,1.0),this._tempScaleMatrix44);
			this._tempScaleMatrix44.elements[12]=0.5;
			this._tempScaleMatrix44.elements[13]=0.5;
		}

		__class(ParallelSplitShadowMap,'laya.d3.shadowMap.ParallelSplitShadowMap');
		var __proto=ParallelSplitShadowMap.prototype;
		__proto.setInfo=function(scene,maxDistance,globalParallelDir,shadowMapTextureSize,numberOfPSSM,PCFType){
			if (numberOfPSSM > 3){
				this._numberOfPSSM=3;
			}
			this._scene=scene;
			this._maxDistance=maxDistance;
			this.PSSMNum=numberOfPSSM;
			this._globalParallelLightDir=globalParallelDir;
			this._ratioOfDistance=1.0 / this._numberOfPSSM;
			for (var i=0;i < this._spiltDistance.length;i++){
				this._spiltDistance[i]=0.0;
			}
			this._shadowMapTextureSize=shadowMapTextureSize;
			this._shadowPCFOffset.x=1.0 / this._shadowMapTextureSize;
			this._shadowPCFOffset.y=1.0 / this._shadowMapTextureSize;
			this.setPCFType(PCFType);
			this._statesDirty=true;
		}

		__proto.setPCFType=function(PCFtype){
			this._PCFType=PCFtype;
			var defineData=this._scene._defineDatas;
			switch (this._PCFType){
				case 0:
					defineData.add(Scene.SHADERDEFINE_SHADOW_PCF_NO);
					defineData.remove(Scene.SHADERDEFINE_SHADOW_PCF1);
					defineData.remove(Scene.SHADERDEFINE_SHADOW_PCF2);
					defineData.remove(Scene.SHADERDEFINE_SHADOW_PCF3);
					break ;
				case 1:
					defineData.add(Scene.SHADERDEFINE_SHADOW_PCF1);
					defineData.remove(Scene.SHADERDEFINE_SHADOW_PCF_NO);
					defineData.remove(Scene.SHADERDEFINE_SHADOW_PCF2);
					defineData.remove(Scene.SHADERDEFINE_SHADOW_PCF3);
					break ;
				case 2:
					defineData.add(Scene.SHADERDEFINE_SHADOW_PCF2);
					defineData.remove(Scene.SHADERDEFINE_SHADOW_PCF_NO);
					defineData.remove(Scene.SHADERDEFINE_SHADOW_PCF1);
					defineData.remove(Scene.SHADERDEFINE_SHADOW_PCF3);
					break ;
				case 3:
					defineData.add(Scene.SHADERDEFINE_SHADOW_PCF3);
					defineData.remove(Scene.SHADERDEFINE_SHADOW_PCF_NO);
					defineData.remove(Scene.SHADERDEFINE_SHADOW_PCF1);
					defineData.remove(Scene.SHADERDEFINE_SHADOW_PCF2);
					break ;
				}
		}

		__proto.getPCFType=function(){
			return this._PCFType;
		}

		__proto.setFarDistance=function(value){
			if (this._maxDistance !=value){
				this._maxDistance=value;
				this._statesDirty=true;
			}
		}

		__proto.getFarDistance=function(){
			return this._maxDistance;
		}

		__proto._setGlobalParallelLightDir=function(dir){
			this._globalParallelLightDir=dir;
		}

		__proto.getGlobalParallelLightDir=function(){
			return this._globalParallelLightDir;
		}

		__proto.getCurrentPSSM=function(){
			return this._currentPSSM;
		}

		__proto.getLightCamera=function(index){
			return this._lightCameras[index];
		}

		/**
		*@private
		*/
		__proto._beginSampler=function(index,sceneCamera){
			if (index < 0 || index > this._numberOfPSSM)
				throw new Error("ParallelSplitShadowMap: beginSample invalid index");
			this._currentPSSM=index;
			this._update(sceneCamera);
		}

		/**
		*@private
		*/
		__proto.endSampler=function(sceneCamera){
			this._currentPSSM=-1;
		}

		/**
		*@private
		*/
		__proto._calcAllLightCameraInfo=function(sceneCamera){
			if (this._numberOfPSSM===1){
				this._beginSampler(0,sceneCamera);
				this.endSampler(sceneCamera);
				}else {
				for (var i=0,n=this._numberOfPSSM+1;i < n;i++){
					this._beginSampler(i,sceneCamera);
					this.endSampler(sceneCamera);
				}
			}
		}

		/**
		*@private
		*/
		__proto._recalculate=function(nearPlane,fieldOfView,aspectRatio){
			this._calcSplitDistance(nearPlane);
			this._calcBoundingBox(fieldOfView,aspectRatio);
			this._rebuildRenderInfo();
		}

		/**
		*@private
		*/
		__proto._update=function(sceneCamera){
			var nearPlane=sceneCamera.nearPlane;
			var fieldOfView=sceneCamera.fieldOfView;
			var aspectRatio=(sceneCamera).aspectRatio;
			if (this._statesDirty || this.lastNearPlane!==nearPlane || this.lastFieldOfView!==fieldOfView || this.lastAspectRatio!==aspectRatio){
				this._recalculate(nearPlane,fieldOfView,aspectRatio);
				this._uploadShaderValue();
				this._statesDirty=false;
				this.lastNearPlane=nearPlane;
				this.lastFieldOfView=fieldOfView;
				this.lastAspectRatio=aspectRatio;
			}
			this._calcLightViewProject(sceneCamera);
		}

		/**
		*@private
		*/
		__proto._uploadShaderValue=function(){
			var defDatas=this._scene._defineDatas;
			switch (this._numberOfPSSM){
				case 1:
					defDatas.add(Scene.SHADERDEFINE_SHADOW_PSSM1);
					defDatas.remove(Scene.SHADERDEFINE_SHADOW_PSSM2);
					defDatas.remove(Scene.SHADERDEFINE_SHADOW_PSSM3);
					break ;
				case 2:
					defDatas.add(Scene.SHADERDEFINE_SHADOW_PSSM2);
					defDatas.remove(Scene.SHADERDEFINE_SHADOW_PSSM1);
					defDatas.remove(Scene.SHADERDEFINE_SHADOW_PSSM3);
					break ;
				case 3:
					defDatas.add(Scene.SHADERDEFINE_SHADOW_PSSM3);
					defDatas.remove(Scene.SHADERDEFINE_SHADOW_PSSM1);
					defDatas.remove(Scene.SHADERDEFINE_SHADOW_PSSM2);
					break ;
				};
			var sceneSV=this._scene._shaderValues;
			sceneSV.setVector(15,this._shaderValueDistance);
			sceneSV.setBuffer(16,this._shaderValueLightVP);
			sceneSV.setVector(17,this._shadowPCFOffset);
			switch (this._numberOfPSSM){
				case 3:
					sceneSV.setTexture(18,this.getRenderTarget(1));
					sceneSV.setTexture(19,this.getRenderTarget(2));
					sceneSV.setTexture(20,this.getRenderTarget(3));
					break ;
				case 2:
					sceneSV.setTexture(18,this.getRenderTarget(1));
					sceneSV.setTexture(19,this.getRenderTarget(2));
					break ;
				case 1:
					sceneSV.setTexture(18,this.getRenderTarget(1));
					break ;
				}
		}

		/**
		*@private
		*/
		__proto._calcSplitDistance=function(nearPlane){
			var far=this._maxDistance;
			var invNumberOfPSSM=1.0 / this._numberOfPSSM;
			var i=0;
			for (i=0;i <=this._numberOfPSSM;i++){
				this._uniformDistance[i]=nearPlane+(far-nearPlane)*i *invNumberOfPSSM;
			};
			var farDivNear=far / nearPlane;
			for (i=0;i <=this._numberOfPSSM;i++){
				var n=Math.pow(farDivNear,i *invNumberOfPSSM);
				this._logDistance[i]=nearPlane *n;
			}
			for (i=0;i <=this._numberOfPSSM;i++){
				this._spiltDistance[i]=this._uniformDistance[i] *this._ratioOfDistance+this._logDistance[i] *(1.0-this._ratioOfDistance);
			}
			this._shaderValueDistance.x=this._spiltDistance[1];
			this._shaderValueDistance.y=this._spiltDistance[2];
			this._shaderValueDistance.z=this._spiltDistance[3];
			this._shaderValueDistance.w=this._spiltDistance[4];
		}

		/**
		*@private
		*/
		__proto._calcBoundingBox=function(fieldOfView,aspectRatio){
			var fov=3.1415926 *fieldOfView / 180.0;
			var halfTanValue=Math.tan(fov / 2.0);
			var height=NaN;
			var width=NaN;
			var distance=NaN;
			var i=0;
			for (i=0;i <=this._numberOfPSSM;i++){
				distance=this._spiltDistance[i];
				height=distance *halfTanValue;
				width=height *aspectRatio;
				var temp=this._frustumPos[i *4+0].elements;
				temp[0]=-width;
				temp[1]=-height;
				temp[2]=-distance;
				temp=this._frustumPos[i *4+1].elements;
				temp[0]=width;
				temp[1]=-height;
				temp[2]=-distance;
				temp=this._frustumPos[i *4+2].elements;
				temp[0]=-width;
				temp[1]=height;
				temp[2]=-distance;
				temp=this._frustumPos[i *4+3].elements;
				temp[0]=width;
				temp[1]=height;
				temp[2]=-distance;
				temp=this._dimension[i].elements;
				temp[0]=width;
				temp[1]=height;
			};
			var d;
			var min;
			var max;
			var center;
			for (i=1;i <=this._numberOfPSSM;i++){
				d=this._dimension[i].elements;
				min=this._boundingBox[i].min.elements;
				min[0]=-d[0];
				min[1]=-d[1];
				min[2]=-this._spiltDistance[i];
				max=this._boundingBox[i].max.elements;
				max[0]=d[0];
				max[1]=d[1];
				max[2]=-this._spiltDistance[i-1];
				center=this._boundingSphere[i].center.elements;
				center[0]=(min[0]+max[0])*0.5;
				center[1]=(min[1]+max[1])*0.5;
				center[2]=(min[2]+max[2])*0.5;
				this._boundingSphere[i].radius=Math.sqrt(Math.pow(max[0]-min[0],2)+Math.pow(max[1]-min[1],2)+Math.pow(max[2]-min[2],2))*0.5;
			}
			min=this._boundingBox[0].min.elements;
			d=this._dimension[this._numberOfPSSM].elements;
			min[0]=-d[0];
			min[1]=-d[1];
			min[2]=-this._spiltDistance[this._numberOfPSSM];
			max=this._boundingBox[0].max.elements;
			max[0]=d[0];
			max[1]=d[1];
			max[2]=-this._spiltDistance[0];
			center=this._boundingSphere[0].center.elements;
			center[0]=(min[0]+max[0])*0.5;
			center[1]=(min[1]+max[1])*0.5;
			center[2]=(min[2]+max[2])*0.5;
			this._boundingSphere[0].radius=Math.sqrt(Math.pow(max[0]-min[0],2)+Math.pow(max[1]-min[1],2)+Math.pow(max[2]-min[2],2))*0.5;
		}

		__proto.calcSplitFrustum=function(sceneCamera){
			if (this._currentPSSM > 0){
				Matrix4x4.createPerspective(3.1416 *sceneCamera.fieldOfView / 180.0,(sceneCamera).aspectRatio,this._spiltDistance[this._currentPSSM-1],this._spiltDistance[this._currentPSSM],this._tempMatrix44);
				}else {
				Matrix4x4.createPerspective(3.1416 *sceneCamera.fieldOfView / 180.0,(sceneCamera).aspectRatio,this._spiltDistance[0],this._spiltDistance[this._numberOfPSSM],this._tempMatrix44);
			}
			Matrix4x4.multiply(this._tempMatrix44,(sceneCamera).viewMatrix,this._tempMatrix44);
			this._splitFrustumCulling.matrix=this._tempMatrix44;
		}

		/**
		*@private
		*/
		__proto._rebuildRenderInfo=function(){
			var nNum=this._numberOfPSSM+1;
			var i=0;
			if (this._renderTarget==null){
				this._renderTarget=__newvec(nNum);
				this._renderTarget[0]=null;
				for (i=1;i < nNum;i++){
					this._renderTarget[i]=new laya.d3.resource.RenderTexture(this._shadowMapTextureSize,this._shadowMapTextureSize,0x1908,0x1401,0x81A5,false,false,0x2600,0x2600);
				}
				}else if (this._renderTarget.length !=nNum){
				this.disposeAllRenderTarget();
				this._renderTarget.length=nNum;
				this._renderTarget[0]=null;
				for (i=1;i < nNum;i++){
					this._renderTarget[i]=new laya.d3.resource.RenderTexture(this._shadowMapTextureSize,this._shadowMapTextureSize,0x1908,0x1401,0x81A5,false,false,0x2600,0x2600);
				}
				}else {
				for (i=1;i < nNum;i++){
					if (this._renderTarget[i]==null || this._renderTarget[i].width !=this._shadowMapTextureSize || this._renderTarget[i].height !=this._shadowMapTextureSize){
						if (this._renderTarget[i] !=null){
							this._renderTarget[i].destroy();
						}
						this._renderTarget[i]=new laya.d3.resource.RenderTexture(this._shadowMapTextureSize,this._shadowMapTextureSize,0x1908,0x1401,0x81A5,false,false,0x2600,0x2600);
					}
				}
			}
			if (this._lightCulling==null || this._lightCulling.length !=nNum){
				if (this._lightCulling){
					this._lightCulling.length=nNum;
					}else {
					this._lightCulling=__newvec(nNum);
				}
				for (i=0;i < this._lightCulling.length;i++){
					this._lightCulling[i]=new BoundFrustum(Matrix4x4.DEFAULT);
				}
			}
			if (this._lightVPMatrix==null || this._lightVPMatrix.length !=nNum){
				if (this._lightVPMatrix){
					this._lightVPMatrix.length=nNum;
					}else {
					this._lightVPMatrix=__newvec(nNum);
				}
				for (i=0;i < this._lightVPMatrix.length;i++){
					this._lightVPMatrix[i]=new Matrix4x4();
				}
			}
			if (this._lightCameras==null || this._lightCameras.length !=nNum){
				if (this._lightCameras){
					this._lightCameras.length=nNum;
					}else {
					this._lightCameras=__newvec(nNum);
				}
				for (i=0;i < this._lightCameras.length;i++){
					this._lightCameras[i]=new Camera();
					this._lightCameras[i].name="lightCamera"+i;
				}
			}
			if (this._shadowQuenes==null || this._shadowQuenes.length !=this._numberOfPSSM){
				if (this._shadowQuenes){
					this._shadowQuenes.length=this._numberOfPSSM;
					}else {
					this._shadowQuenes=__newvec(this._numberOfPSSM);
				}
				for (i=0;i < this._shadowQuenes.length;i++){
					this._shadowQuenes[i]=new RenderQueue(this._scene);
				}
			}
			if (this._shaderValueVPs==null || this._shaderValueVPs.length !=nNum){
				if (this._shaderValueVPs){
					this._shaderValueVPs.length=nNum;
					}else {
					this._shaderValueVPs=__newvec(nNum);
				}
				this._shaderValueLightVP=new Float32Array(nNum *16);
				for (i=0;i < nNum;i++){
					this._shaderValueVPs[i]=new Float32Array(this._shaderValueLightVP.buffer,i *64);
				}
			}
		}

		/**
		*@private
		*/
		__proto._calcLightViewProject=function(sceneCamera){
			var boundSphere=this._boundingSphere[this._currentPSSM];
			var cameraMatViewInv=sceneCamera.transform.worldMatrix;
			var radius=boundSphere.radius;
			boundSphere.center.cloneTo(this._tempLookAt3);
			Vector3.transformV3ToV4(this._tempLookAt3,cameraMatViewInv,this._tempLookAt4);
			var lookAt3Element=this._tempLookAt3.elements;
			var lookAt4Element=this._tempLookAt4.elements;
			lookAt3Element[0]=lookAt4Element[0];
			lookAt3Element[1]=lookAt4Element[1];
			lookAt3Element[2]=lookAt4Element[2];
			var lightUpElement=this._tempLightUp.elements;
			var sceneCameraDir=sceneCamera.forward.elements;
			lightUpElement[0]=sceneCameraDir[0];
			lightUpElement[1]=1.0;
			lightUpElement[2]=sceneCameraDir[2];
			Vector3.normalize(this._tempLightUp,this._tempLightUp);
			Vector3.scale(this._globalParallelLightDir,boundSphere.radius *4,this._tempPos);
			Vector3.subtract(this._tempLookAt3,this._tempPos,this._tempPos);
			var curLightCamera=this._lightCameras[this._currentPSSM];
			curLightCamera.transform.position=this._tempPos;
			curLightCamera.transform.lookAt(this._tempLookAt3,this._tempLightUp,false);
			var tempMaxElements=this._tempMax.elements;
			var tempMinElements=this._tempMin.elements;
			tempMaxElements[0]=tempMaxElements[1]=tempMaxElements[2]=-100000.0;
			tempMaxElements[3]=1.0;
			tempMinElements[0]=tempMinElements[1]=tempMinElements[2]=100000.0;
			tempMinElements[3]=1.0;
			Matrix4x4.multiply(curLightCamera.viewMatrix,cameraMatViewInv,this._tempMatrix44);
			var tempValueElement=this._tempValue.elements;
			var corners=[];
			corners.length=8;
			this._boundingBox[this._currentPSSM].getCorners(corners);
			for (var i=0;i < 8;i++){
				var frustumPosElements=corners[i].elements;
				tempValueElement[0]=frustumPosElements[0];
				tempValueElement[1]=frustumPosElements[1];
				tempValueElement[2]=frustumPosElements[2];
				tempValueElement[3]=1.0;
				Vector4.transformByM4x4(this._tempValue,this._tempMatrix44,this._tempValue);
				tempMinElements[0]=(tempValueElement[0] < tempMinElements[0])? tempValueElement[0] :tempMinElements[0];
				tempMinElements[1]=(tempValueElement[1] < tempMinElements[1])? tempValueElement[1] :tempMinElements[1];
				tempMinElements[2]=(tempValueElement[2] < tempMinElements[2])? tempValueElement[2] :tempMinElements[2];
				tempMaxElements[0]=(tempValueElement[0] > tempMaxElements[0])? tempValueElement[0] :tempMaxElements[0];
				tempMaxElements[1]=(tempValueElement[1] > tempMaxElements[1])? tempValueElement[1] :tempMaxElements[1];
				tempMaxElements[2]=(tempValueElement[2] > tempMaxElements[2])? tempValueElement[2] :tempMaxElements[2];
			}
			Vector4.add(this._tempMax,this._tempMin,this._tempValue);
			tempValueElement[0] *=0.5;
			tempValueElement[1] *=0.5;
			tempValueElement[2] *=0.5;
			tempValueElement[3]=1;
			Vector4.transformByM4x4(this._tempValue,curLightCamera.transform.worldMatrix,this._tempValue);
			var distance=Math.abs(-this._tempMax.z);
			var farPlane=distance > this._maxDistance ? distance :this._maxDistance;
			Vector3.scale(this._globalParallelLightDir,farPlane,this._tempPos);
			var tempPosElement=this._tempPos.elements;
			tempPosElement[0]=tempValueElement[0]-tempPosElement[0];
			tempPosElement[1]=tempValueElement[1]-tempPosElement[1];
			tempPosElement[2]=tempValueElement[2]-tempPosElement[2];
			curLightCamera.transform.position=this._tempPos;
			curLightCamera.transform.lookAt(this._tempLookAt3,this._tempLightUp,false);
			Matrix4x4.createOrthoOffCenterRH(tempMinElements[0],tempMaxElements[0],tempMinElements[1],tempMaxElements[1],1.0,farPlane+0.5 *(tempMaxElements[2]-tempMinElements[2]),curLightCamera.projectionMatrix);
			curLightCamera.projectionViewMatrix.cloneTo(this._lightVPMatrix[this._currentPSSM]);
			this._lightCulling[this._currentPSSM].matrix=this._lightVPMatrix[this._currentPSSM];
			ParallelSplitShadowMap.multiplyMatrixOutFloat32Array(this._tempScaleMatrix44,this._lightVPMatrix[this._currentPSSM],this._shaderValueVPs[this._currentPSSM]);
		}

		__proto.getLightFrustumCulling=function(currentPSSM){
			return this._lightCulling[currentPSSM];
		}

		__proto.getSplitFrustumCulling=function(){
			return this._splitFrustumCulling;
		}

		__proto.getSplitDistance=function(index){
			return this._spiltDistance[index];
		}

		__proto.setShadowMapTextureSize=function(size){
			if (size!==this._shadowMapTextureSize){
				this._shadowMapTextureSize=size;
				this._shadowPCFOffset.x=1 / this._shadowMapTextureSize;
				this._shadowPCFOffset.y=1 / this._shadowMapTextureSize;
				this._statesDirty=true;
			}
		}

		__proto.getShadowMapTextureSize=function(){
			return this._shadowMapTextureSize;
		}

		__proto.beginRenderTarget=function(index){
			this._renderTarget[index].start();
		}

		__proto.endRenderTarget=function(index){
			this._renderTarget[index].end();
		}

		__proto.getRenderTarget=function(index){
			return this._renderTarget[index];
		}

		__proto.disposeAllRenderTarget=function(){
			for (var i=0,n=this._numberOfPSSM+1;i < n;i++){
				if (this._renderTarget[i]){
					this._renderTarget[i].destroy();
					this._renderTarget[i]=null;
				}
			}
		}

		__getset(0,__proto,'PSSMNum',function(){
			return this._numberOfPSSM;
			},function(value){
			value=value > 0 ? value :1;
			value=value <=3 ? value :3;
			if (this._numberOfPSSM !=value){
				this._numberOfPSSM=value;
				this._ratioOfDistance=1.0 / this._numberOfPSSM;
				this._statesDirty=true;
			}
		});

		ParallelSplitShadowMap.multiplyMatrixOutFloat32Array=function(left,right,out){
			var i,a,b,ai0,ai1,ai2,ai3;
			a=left.elements;
			b=right.elements;
			for (i=0;i < 4;i++){
				ai0=a[i];
				ai1=a[i+4];
				ai2=a[i+8];
				ai3=a[i+12];
				out[i]=ai0 *b[0]+ai1 *b[1]+ai2 *b[2]+ai3 *b[3];
				out[i+4]=ai0 *b[4]+ai1 *b[5]+ai2 *b[6]+ai3 *b[7];
				out[i+8]=ai0 *b[8]+ai1 *b[9]+ai2 *b[10]+ai3 *b[11];
				out[i+12]=ai0 *b[12]+ai1 *b[13]+ai2 *b[14]+ai3 *b[15];
			}
		}

		ParallelSplitShadowMap.MAX_PSSM_COUNT=3;
		return ParallelSplitShadowMap;
	})()


	/**
	*<code>TerrainLeaf</code> Terrain的叶子节点
	*/
	//class laya.d3.terrain.TerrainLeaf
	var TerrainLeaf=(function(){
		function TerrainLeaf(){
			this._boundingSphere=null;
			this._boundingBox=null;
			this._sizeOfY=null;
			this._currentLODLevel=0;
			this._lastDistanceToEye=NaN;
			this._originalBoundingSphere=null;
			this._originalBoundingBox=null;
			this._originalBoundingBoxCorners=null;
			this._bUseStrip=false;
			this._gridSize=NaN;
			this._beginGridX=0;
			this._beginGridZ=0;
			this._LODError=null;
			TerrainLeaf.__init__();
			this._currentLODLevel=0;
		}

		__class(TerrainLeaf,'laya.d3.terrain.TerrainLeaf');
		var __proto=TerrainLeaf.prototype;
		__proto.calcVertextNorml=function(x,z,terrainHeightData,heighDataWidth,heightDataHeight,normal){
			var dZ=0,dX=0;
			dX=TerrainLeaf.getHeightFromTerrainHeightData(x-1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
			dX+=TerrainLeaf.getHeightFromTerrainHeightData(x-1,z,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
			dX+=TerrainLeaf.getHeightFromTerrainHeightData(x-1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
			dX+=TerrainLeaf.getHeightFromTerrainHeightData(x+1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
			dX+=TerrainLeaf.getHeightFromTerrainHeightData(x+1,z,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
			dX+=TerrainLeaf.getHeightFromTerrainHeightData(x+1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
			dZ=TerrainLeaf.getHeightFromTerrainHeightData(x-1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
			dZ+=TerrainLeaf.getHeightFromTerrainHeightData(x,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
			dZ+=TerrainLeaf.getHeightFromTerrainHeightData(x+1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
			dZ+=TerrainLeaf.getHeightFromTerrainHeightData(x-1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
			dZ+=TerrainLeaf.getHeightFromTerrainHeightData(x,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
			dZ+=TerrainLeaf.getHeightFromTerrainHeightData(x+1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
			normal.x=-dX;
			normal.y=6;
			normal.z=-dZ;
			Vector3.normalize(normal,normal);
		}

		__proto.calcVertextNormlUV=function(x,z,terrainWidth,terrainHeight,normal){
			normal.x=x / terrainWidth;
			normal.y=z / terrainHeight;
			normal.z=z / terrainHeight;
		}

		__proto.calcVertextBuffer=function(offsetChunkX,offsetChunkZ,beginX,beginZ,girdSize,vertextBuffer,offset,strideSize,terrainHeightData,heighDataWidth,heightDataHeight,cameraCoordinateInverse){
			if (cameraCoordinateInverse==true && !TerrainLeaf.__ADAPT_MATRIX__){
				TerrainLeaf.__ADAPT_MATRIX__=new Matrix4x4();
				var mat=new Matrix4x4();
				Matrix4x4.createRotationY(Math.PI,TerrainLeaf.__ADAPT_MATRIX__);
				Matrix4x4.createTranslate(new Vector3(0,0,(heightDataHeight-1)*girdSize),mat);
				Matrix4x4.multiply(mat,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__ADAPT_MATRIX__);
				TerrainLeaf.__ADAPT_MATRIX_INV__=new Matrix4x4();
				TerrainLeaf.__ADAPT_MATRIX__.invert(TerrainLeaf.__ADAPT_MATRIX_INV__);
			}
			this._gridSize=girdSize;
			this._beginGridX=offsetChunkX *TerrainLeaf.CHUNK_GRID_NUM+beginX;
			this._beginGridZ=offsetChunkZ *TerrainLeaf.CHUNK_GRID_NUM+beginZ;
			var nNum=offset *strideSize;
			var minY=2147483647;
			var maxY=-2147483648;
			var normal=new Vector3();
			for (var i=0,s=TerrainLeaf.LEAF_GRID_NUM+1;i < s;i++){
				for (var j=0,s1=TerrainLeaf.LEAF_GRID_NUM+1;j < s1;j++){
					TerrainLeaf.__VECTOR3__.x=(this._beginGridX+j)*this._gridSize;
					TerrainLeaf.__VECTOR3__.z=(this._beginGridZ+i)*this._gridSize;
					TerrainLeaf.__VECTOR3__.y=terrainHeightData[(this._beginGridZ+i)*(heighDataWidth)+(this._beginGridX+j)];
					minY=TerrainLeaf.__VECTOR3__.y < minY ? TerrainLeaf.__VECTOR3__.y :minY;
					maxY=TerrainLeaf.__VECTOR3__.y > maxY ? TerrainLeaf.__VECTOR3__.y :maxY;
					if (TerrainLeaf.__ADAPT_MATRIX__){
						Vector3.transformV3ToV3(TerrainLeaf.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__VECTOR3__);
					}
					vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.x;
					nNum++;
					vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.y;
					nNum++;
					vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.z;
					nNum++;
					this.calcVertextNormlUV(this._beginGridX+j,this._beginGridZ+i,heighDataWidth,heightDataHeight,normal);
					vertextBuffer[nNum]=normal.x;
					nNum++;
					vertextBuffer[nNum]=normal.y;
					nNum++;
					vertextBuffer[nNum]=normal.z;
					nNum++;
					vertextBuffer[nNum]=(beginX+j)/ TerrainLeaf.CHUNK_GRID_NUM;
					nNum++;
					vertextBuffer[nNum]=(beginZ+i)/ TerrainLeaf.CHUNK_GRID_NUM;
					nNum++;
					vertextBuffer[nNum]=this._beginGridX+j;
					nNum++;
					vertextBuffer[nNum]=this._beginGridZ+i;
					nNum++;
				}
			}
			this._sizeOfY=new Vector2(minY-1,maxY+1);
			this.calcLODErrors(terrainHeightData,heighDataWidth,heightDataHeight);
			this.calcOriginalBoudingBoxAndSphere();
		}

		__proto.calcSkirtVertextBuffer=function(offsetChunkX,offsetChunkZ,beginX,beginZ,girdSize,vertextBuffer,offset,strideSize,terrainHeightData,heighDataWidth,heightDataHeight){
			this._gridSize=girdSize;
			this._beginGridX=offsetChunkX *TerrainLeaf.CHUNK_GRID_NUM+beginX;
			this._beginGridZ=offsetChunkZ *TerrainLeaf.CHUNK_GRID_NUM+beginZ;
			var nNum=offset *strideSize;
			var i=0,j=0,s=TerrainLeaf.LEAF_GRID_NUM+1;
			var normal=new Vector3();
			var hZIndex=0;
			var hXIndex=0;
			var h=0;
			var zh=0;
			var xh=0;
			for (i=0;i < 2;i++){
				for (j=0;j < s;j++){
					TerrainLeaf.__VECTOR3__.x=(this._beginGridX+j)*this._gridSize;
					TerrainLeaf.__VECTOR3__.y=(i==1 ? terrainHeightData[this._beginGridZ *heighDataWidth+(this._beginGridX+j)] :-this._gridSize);
					TerrainLeaf.__VECTOR3__.z=(this._beginGridZ+0)*this._gridSize;
					if (TerrainLeaf.__ADAPT_MATRIX__){
						Vector3.transformV3ToV3(TerrainLeaf.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__VECTOR3__);
					}
					vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.x;
					nNum++;
					vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.y;
					nNum++;
					vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.z;
					nNum++;
					if (i==0){
						hZIndex=(this._beginGridZ-1);
						}else {
						hZIndex=this._beginGridZ;
					}
					this.calcVertextNormlUV(this._beginGridX+j,hZIndex,heighDataWidth,heightDataHeight,normal);
					vertextBuffer[nNum]=normal.x;
					nNum++;
					vertextBuffer[nNum]=normal.y;
					nNum++;
					vertextBuffer[nNum]=normal.z;
					nNum++;
					vertextBuffer[nNum]=(beginX+j)/ TerrainLeaf.CHUNK_GRID_NUM;
					nNum++;
					vertextBuffer[nNum]=(beginZ+0)/ TerrainLeaf.CHUNK_GRID_NUM;
					nNum++;
					vertextBuffer[nNum]=this._beginGridX+j;
					nNum++;
					vertextBuffer[nNum]=hZIndex;
					nNum++;
				}
			}
			for (i=0;i < 2;i++){
				for (j=0;j < s;j++){
					TerrainLeaf.__VECTOR3__.x=(this._beginGridX+j)*this._gridSize;
					TerrainLeaf.__VECTOR3__.y=(i==0 ? terrainHeightData[(this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM)*(heighDataWidth)+(this._beginGridX+j)] :-this._gridSize);
					TerrainLeaf.__VECTOR3__.z=(this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize;
					if (TerrainLeaf.__ADAPT_MATRIX__){
						Vector3.transformV3ToV3(TerrainLeaf.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__VECTOR3__);
					}
					vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.x;
					nNum++;
					vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.y;
					nNum++;
					vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.z;
					nNum++;
					if (i==0){
						hZIndex=this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM;
						}else {
						hZIndex=(this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM+1);
					}
					this.calcVertextNormlUV(this._beginGridX+j,hZIndex,heighDataWidth,heightDataHeight,normal);
					vertextBuffer[nNum]=normal.x;
					nNum++;
					vertextBuffer[nNum]=normal.y;
					nNum++;
					vertextBuffer[nNum]=normal.z;
					nNum++;
					vertextBuffer[nNum]=(beginX+j)/ TerrainLeaf.CHUNK_GRID_NUM;
					nNum++;
					vertextBuffer[nNum]=(beginZ+TerrainLeaf.LEAF_GRID_NUM)/ TerrainLeaf.CHUNK_GRID_NUM;
					nNum++;
					vertextBuffer[nNum]=this._beginGridX+j;
					nNum++;
					vertextBuffer[nNum]=hZIndex;
					nNum++;
				}
			}
			for (i=0;i < 2;i++){
				for (j=0;j < s;j++){
					TerrainLeaf.__VECTOR3__.x=(this._beginGridX+0)*this._gridSize;
					TerrainLeaf.__VECTOR3__.y=(i==0 ? terrainHeightData[(this._beginGridZ+j)*(heighDataWidth)+(this._beginGridX+0)] :-this._gridSize);
					TerrainLeaf.__VECTOR3__.z=(this._beginGridZ+j)*this._gridSize;
					if (TerrainLeaf.__ADAPT_MATRIX__){
						Vector3.transformV3ToV3(TerrainLeaf.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__VECTOR3__);
					}
					vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.x;
					nNum++;
					vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.y;
					nNum++;
					vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.z;
					nNum++;
					if (i==0){
						hXIndex=this._beginGridX;
						}else {
						hXIndex=(this._beginGridX-1);
					}
					this.calcVertextNormlUV(hXIndex,this._beginGridZ+j,heighDataWidth,heightDataHeight,normal);
					vertextBuffer[nNum]=normal.x;
					nNum++;
					vertextBuffer[nNum]=normal.y;
					nNum++;
					vertextBuffer[nNum]=normal.z;
					nNum++;
					vertextBuffer[nNum]=(beginX+0)/ TerrainLeaf.CHUNK_GRID_NUM;
					nNum++;
					vertextBuffer[nNum]=(beginZ+j)/ TerrainLeaf.CHUNK_GRID_NUM;
					nNum++;
					vertextBuffer[nNum]=hXIndex;
					nNum++;
					vertextBuffer[nNum]=this._beginGridZ+j;
					nNum++;
				}
			}
			for (i=0;i < 2;i++){
				for (j=0;j < s;j++){
					TerrainLeaf.__VECTOR3__.x=(this._beginGridX+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize;
					TerrainLeaf.__VECTOR3__.y=(i==1 ? terrainHeightData[(this._beginGridZ+j)*(heighDataWidth)+(this._beginGridX+TerrainLeaf.LEAF_GRID_NUM)] :-this._gridSize);
					TerrainLeaf.__VECTOR3__.z=(this._beginGridZ+j)*this._gridSize;
					if (TerrainLeaf.__ADAPT_MATRIX__){
						Vector3.transformV3ToV3(TerrainLeaf.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__VECTOR3__);
					}
					vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.x;
					nNum++;
					vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.y;
					nNum++;
					vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.z;
					nNum++;
					if (i==0){
						hXIndex=this._beginGridX+TerrainLeaf.LEAF_GRID_NUM+1;
						}else {
						hXIndex=this._beginGridX+TerrainLeaf.LEAF_GRID_NUM;
					}
					this.calcVertextNormlUV(hXIndex,this._beginGridZ+j,heighDataWidth,heightDataHeight,normal);
					vertextBuffer[nNum]=normal.x;
					nNum++;
					vertextBuffer[nNum]=normal.y;
					nNum++;
					vertextBuffer[nNum]=normal.z;
					nNum++;
					vertextBuffer[nNum]=(beginX+TerrainLeaf.LEAF_GRID_NUM)/ TerrainLeaf.CHUNK_GRID_NUM;
					nNum++;
					vertextBuffer[nNum]=(beginZ+j)/ TerrainLeaf.CHUNK_GRID_NUM;
					nNum++;
					vertextBuffer[nNum]=hXIndex;
					nNum++;
					vertextBuffer[nNum]=this._beginGridZ+j;
					nNum++;
				}
			}
		}

		__proto.calcOriginalBoudingBoxAndSphere=function(){
			var min=new Vector3(this._beginGridX *this._gridSize,this._sizeOfY.x,this._beginGridZ *this._gridSize);
			var max=new Vector3((this._beginGridX+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize,this._sizeOfY.y,(this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize);
			if (TerrainLeaf.__ADAPT_MATRIX__){
				Vector3.transformV3ToV3(min,TerrainLeaf.__ADAPT_MATRIX__,min);
				Vector3.transformV3ToV3(max,TerrainLeaf.__ADAPT_MATRIX__,max);
			}
			this._originalBoundingBox=new BoundBox(min,max);
			var size=new Vector3();
			Vector3.subtract(max,min,size);
			Vector3.scale(size,0.5,size);
			var center=new Vector3();
			Vector3.add(min,size,center);
			this._originalBoundingSphere=new BoundSphere(center,Vector3.scalarLength(size));
			this._originalBoundingBoxCorners=__newvec(8,null);
			this._originalBoundingBox.getCorners(this._originalBoundingBoxCorners);
			this._boundingBox=new BoundBox(new Vector3(-0.5,-0.5,-0.5),new Vector3(0.5,0.5,0.5));
			this._boundingSphere=new BoundSphere(new Vector3(0,0,0),1);
		}

		__proto.calcLeafBoudingBox=function(worldMatrix){
			for (var i=0;i < 8;i++){
				Vector3.transformCoordinate(this._originalBoundingBoxCorners[i],worldMatrix,BaseRender._tempBoundBoxCorners[i]);
			}
			BoundBox.createfromPoints(BaseRender._tempBoundBoxCorners,this._boundingBox);
		}

		__proto.calcLeafBoudingSphere=function(worldMatrix,maxScale){
			Vector3.transformCoordinate(this._originalBoundingSphere.center,worldMatrix,this._boundingSphere.center);
			this._boundingSphere.radius=this._originalBoundingSphere.radius *maxScale;
		}

		__proto.calcLODErrors=function(terrainHeightData,heighDataWidth,heightDataHeight){
			this._LODError=new Float32Array(TerrainLeaf._maxLODLevel+1);
			var step=1;
			for (var i=0,n=TerrainLeaf._maxLODLevel+1;i < n;i++){
				var maxError=0;
				for (var y=0,n1=TerrainLeaf.LEAF_GRID_NUM;y < n1;y+=step){
					for (var x=0,n2=TerrainLeaf.LEAF_GRID_NUM;x < n2;x+=step){
						var z00=terrainHeightData[(this._beginGridZ+y)*heighDataWidth+(this._beginGridX+x)];
						var z10=terrainHeightData[(this._beginGridZ+y)*heighDataWidth+(this._beginGridX+x)+step];
						var z01=terrainHeightData[(this._beginGridZ+y+step)*heighDataWidth+(this._beginGridX+x)];
						var z11=terrainHeightData[(this._beginGridZ+y+step)*heighDataWidth+(this._beginGridX+x)+step];
						for (var j=0;j < step;j++){
							var ys=j / step;
							for (var k=0;k < step;k++){
								var xs=k / step;
								var z=terrainHeightData[(this._beginGridZ+y+j)*heighDataWidth+(this._beginGridX+x)+k];
								var iz=(xs+ys <=1)? (z00+(z10-z00)*xs+(z01-z00)*ys):(z11+(z01-z11)*(1-xs)+(z10-z11)*(1-ys));
								var error=Math.abs(iz-z);
								maxError=Math.max(maxError,error);
							}
						}
					}
				}
				step *=2;
				this._LODError[i]=maxError;
			}
		}

		__proto.determineLod=function(eyePos,perspectiveFactor,tolerance,tolerAndPerspectiveChanged){
			var nDistanceToEye=Vector3.distance(eyePos,this._boundingSphere.center);
			var n=TerrainLeaf._maxLODLevel;
			if (!tolerAndPerspectiveChanged){
				if (this._lastDistanceToEye==nDistanceToEye){
					return this._currentLODLevel;
					}else if (this._lastDistanceToEye > nDistanceToEye){
					n=this._currentLODLevel;
				}
			}
			for (var i=n;i >=1;i--){
				if (Terrain.LOD_DISTANCE_FACTOR *this._LODError[i] / nDistanceToEye *perspectiveFactor < tolerance){
					this._currentLODLevel=i;
					break ;
				}
			}
			this._lastDistanceToEye=nDistanceToEye;
			return this._currentLODLevel;
		}

		TerrainLeaf.__init__=function(){
			if (!TerrainLeaf._bInit){
				var nLeafNum=(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM);
				TerrainLeaf._planeLODIndex=__newvec(nLeafNum);
				var i=0,j=0,k=0,n=0,n1=0,nOffset=0;
				var nOriginIndexArray=null,nTempIndex=null;
				for (i=0;i < nLeafNum;i++){
					TerrainLeaf._planeLODIndex[i]=new Array(TerrainLeaf._maxLODLevel+1);
				}
				for (i=0,n=TerrainLeaf._maxLODLevel+1;i < n;i++){
					TerrainLeaf._planeLODIndex[0][i]=TerrainLeaf.calcPlaneLODIndex(i);
				}
				for (i=1;i < nLeafNum;i++){
					nOffset=i *TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT;
					for (j=0,n1=TerrainLeaf._maxLODLevel+1;j < n1;j++){
						nOriginIndexArray=TerrainLeaf._planeLODIndex[0][j];
						nTempIndex=new Uint16Array(nOriginIndexArray.length);
						for (k=0;k < nOriginIndexArray.length;k++){
							nTempIndex[k]=nOriginIndexArray[k]+nOffset;
						}
						TerrainLeaf._planeLODIndex[i][j]=nTempIndex;
					}
				}
				TerrainLeaf._skirtLODIndex=__newvec(nLeafNum);
				for (i=0;i < nLeafNum;i++){
					TerrainLeaf._skirtLODIndex[i]=new Array(TerrainLeaf._maxLODLevel+1);
				}
				for (i=0,n=TerrainLeaf._maxLODLevel+1;i < n;i++){
					TerrainLeaf._skirtLODIndex[0][i]=TerrainLeaf.calcSkirtLODIndex(i);
				}
				for (i=1;i < nLeafNum;i++){
					nOffset=i *TerrainLeaf.LEAF_SKIRT_VERTEXT_COUNT;
					for (j=0,n1=TerrainLeaf._maxLODLevel+1;j < n1;j++){
						nOriginIndexArray=TerrainLeaf._skirtLODIndex[0][j];
						nTempIndex=new Uint16Array(nOriginIndexArray.length);
						for (k=0;k < nOriginIndexArray.length;k++){
							nTempIndex[k]=nOriginIndexArray[k]+nOffset;
						}
						TerrainLeaf._skirtLODIndex[i][j]=nTempIndex;
					}
				}
				TerrainLeaf._bInit=true;
			}
		}

		TerrainLeaf.getPlaneLODIndex=function(leafIndex,LODLevel){
			return TerrainLeaf._planeLODIndex[leafIndex][LODLevel];
		}

		TerrainLeaf.getSkirtLODIndex=function(leafIndex,LODLevel){
			return TerrainLeaf._skirtLODIndex[leafIndex][LODLevel];
		}

		TerrainLeaf.calcPlaneLODIndex=function(level){
			if (level > TerrainLeaf._maxLODLevel)level=TerrainLeaf._maxLODLevel;
			var nGridNumAddOne=TerrainLeaf.LEAF_GRID_NUM+1;
			var nNum=0;
			var indexBuffer=null;
			var nLODGridNum=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / Math.pow(2,level);
			indexBuffer=new Uint16Array(nLODGridNum *nLODGridNum *6);
			var nGridSpace=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / nLODGridNum;
			for (var i=0;i < TerrainLeaf.LEAF_GRID_NUM;i+=nGridSpace){
				for (var j=0;j < TerrainLeaf.LEAF_GRID_NUM;j+=nGridSpace){
					indexBuffer[nNum]=(i+nGridSpace)*nGridNumAddOne+j;
					nNum++;
					indexBuffer[nNum]=i *nGridNumAddOne+j;
					nNum++;
					indexBuffer[nNum]=i *nGridNumAddOne+j+nGridSpace;
					nNum++;
					indexBuffer[nNum]=i *nGridNumAddOne+j+nGridSpace;
					nNum++;
					indexBuffer[nNum]=(i+nGridSpace)*nGridNumAddOne+j+nGridSpace;
					nNum++;
					indexBuffer[nNum]=(i+nGridSpace)*nGridNumAddOne+j;
					nNum++;
				}
			}
			return indexBuffer;
		}

		TerrainLeaf.calcSkirtLODIndex=function(level){
			if (level > TerrainLeaf._maxLODLevel)level=TerrainLeaf._maxLODLevel;
			var nSkirtIndexOffset=(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT;
			var nGridNumAddOne=TerrainLeaf.LEAF_GRID_NUM+1;
			var nNum=0;
			var indexBuffer=null;
			var nLODGridNum=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / Math.pow(2,level);
			indexBuffer=new Uint16Array(nLODGridNum *4 *6);
			var nGridSpace=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / nLODGridNum;
			for (var j=0;j < 4;j++){
				for (var i=0;i < TerrainLeaf.LEAF_GRID_NUM;i+=nGridSpace){
					indexBuffer[nNum]=nSkirtIndexOffset+nGridNumAddOne+i;
					nNum++;
					indexBuffer[nNum]=nSkirtIndexOffset+i;
					nNum++;
					indexBuffer[nNum]=nSkirtIndexOffset+i+nGridSpace;
					nNum++;
					indexBuffer[nNum]=nSkirtIndexOffset+i+nGridSpace;
					nNum++;
					indexBuffer[nNum]=nSkirtIndexOffset+nGridNumAddOne+i+nGridSpace;
					nNum++;
					indexBuffer[nNum]=nSkirtIndexOffset+nGridNumAddOne+i;
					nNum++;
				}
				nSkirtIndexOffset+=nGridNumAddOne *2;
			}
			return indexBuffer;
		}

		TerrainLeaf.getHeightFromTerrainHeightData=function(x,z,terrainHeightData,heighDataWidth,heightDataHeight){
			x=x < 0 ? 0 :x;
			x=(x >=heighDataWidth)? heighDataWidth-1 :x;
			z=z < 0 ? 0 :z;
			z=(z >=heightDataHeight)? heightDataHeight-1 :z;
			return terrainHeightData[z *heighDataWidth+x];
		}

		TerrainLeaf.CHUNK_GRID_NUM=64;
		TerrainLeaf.LEAF_GRID_NUM=32;
		TerrainLeaf.__ADAPT_MATRIX__=null
		TerrainLeaf.__ADAPT_MATRIX_INV__=null
		TerrainLeaf._planeLODIndex=null
		TerrainLeaf._skirtLODIndex=null
		TerrainLeaf._bInit=false;
		__static(TerrainLeaf,
		['LEAF_PLANE_VERTEXT_COUNT',function(){return this.LEAF_PLANE_VERTEXT_COUNT=(TerrainLeaf.LEAF_GRID_NUM+1)*(TerrainLeaf.LEAF_GRID_NUM+1);},'LEAF_SKIRT_VERTEXT_COUNT',function(){return this.LEAF_SKIRT_VERTEXT_COUNT=(TerrainLeaf.LEAF_GRID_NUM+1)*2 *4;},'LEAF_VERTEXT_COUNT',function(){return this.LEAF_VERTEXT_COUNT=TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT+TerrainLeaf.LEAF_SKIRT_VERTEXT_COUNT;},'LEAF_PLANE_MAX_INDEX_COUNT',function(){return this.LEAF_PLANE_MAX_INDEX_COUNT=TerrainLeaf.LEAF_GRID_NUM *TerrainLeaf.LEAF_GRID_NUM *6;},'LEAF_SKIRT_MAX_INDEX_COUNT',function(){return this.LEAF_SKIRT_MAX_INDEX_COUNT=TerrainLeaf.LEAF_GRID_NUM *4 *6;},'LEAF_MAX_INDEX_COUNT',function(){return this.LEAF_MAX_INDEX_COUNT=TerrainLeaf.LEAF_PLANE_MAX_INDEX_COUNT+TerrainLeaf.LEAF_SKIRT_MAX_INDEX_COUNT;},'__VECTOR3__',function(){return this.__VECTOR3__=new Vector3();},'_maxLODLevel',function(){return this._maxLODLevel=Math.log2(TerrainLeaf.LEAF_GRID_NUM);}
		]);
		return TerrainLeaf;
	})()


	/**
	*<code>DetailTextureInfo</code> 类用于描述地形细节纹理。
	*/
	//class laya.d3.terrain.unit.ChunkInfo
	var ChunkInfo=(function(){
		function ChunkInfo(){
			this.alphaMap=null;
			this.detailID=null;
			this.normalMap=null;
			;
		}

		__class(ChunkInfo,'laya.d3.terrain.unit.ChunkInfo');
		return ChunkInfo;
	})()


	/**
	*<code>DetailTextureInfo</code> 类用于描述地形细节纹理。
	*/
	//class laya.d3.terrain.unit.DetailTextureInfo
	var DetailTextureInfo=(function(){
		function DetailTextureInfo(){
			this.diffuseTexture=null;
			this.normalTexture=null;
			this.scale=null;
			this.offset=null;
			;
		}

		__class(DetailTextureInfo,'laya.d3.terrain.unit.DetailTextureInfo');
		return DetailTextureInfo;
	})()


	/**
	*<code>MaterialInfo</code> 类用于描述地形材质信息。
	*/
	//class laya.d3.terrain.unit.MaterialInfo
	var MaterialInfo=(function(){
		function MaterialInfo(){
			this.ambientColor=null;
			this.diffuseColor=null;
			this.specularColor=null;
			;
		}

		__class(MaterialInfo,'laya.d3.terrain.unit.MaterialInfo');
		return MaterialInfo;
	})()


	/**
	*<code>Physics</code> 类用于简单物理检测。
	*/
	//class laya.d3.utils.Physics
	var Physics=(function(){
		/**
		*创建一个 <code>Physics</code> 实例。
		*/
		function Physics(){}
		__class(Physics,'laya.d3.utils.Physics');
		Physics.__init__=function(){
			var maxCount=31;
			Physics._layerCollsionMatrix.length=maxCount;
			for (var i=0;i < maxCount;i++){
				var collArray=[];
				var count=maxCount-i;
				collArray.length=count;
				for (var j=0;j < count;j++)
				if (j===count-1)
					collArray[j]=true;
				else
				collArray[j]=false;
				Physics._layerCollsionMatrix[i]=collArray;
			}
		}

		Physics.setLayerCollision=function(layer1,layer2,collison){
			Physics._layerCollsionMatrix[layer1.number][(31-1)-layer2.number]=collison;
		}

		Physics.getLayerCollision=function(layer1,layer2){
			return Physics._layerCollsionMatrix[layer1.number][(31-1)-layer2.number];
		}

		Physics.setColliderCollision=function(collider1,collider2,collsion){
			if (collsion){
				delete collider1._ignoreCollisonMap[collider2.id];
				delete collider2._ignoreCollisonMap[collider1.id];
				}else {
				collider1._ignoreCollisonMap[collider2.id]=collider2;
				collider2._ignoreCollisonMap[collider1.id]=collider1;
			}
		}

		Physics.getIColliderCollision=function(collider1,collider2){
			return collider1._ignoreCollisonMap[collider2.id] ? true :false;
		}

		Physics.rayCast=function(ray,outHitInfo,distance,layer){
			(distance===void 0)&& (distance=1.79e+308);
			(layer===void 0)&& (layer=0);
			Physics._outHitAllInfo.length=0;
			var colliders=Layer.getLayerByNumber(layer)._colliders;
			for (var i=0,n=colliders.length;i < n;i++){
				var collider=colliders[i];
				if (collider.enable){
					collider.raycast(ray,Physics._outHitInfo,distance);
					if (Physics._outHitInfo.distance!==-1 && Physics._outHitInfo.distance <=distance){
						var outHit=new RaycastHit();
						Physics._outHitInfo.cloneTo(outHit);
						Physics._outHitAllInfo.push(outHit);
					}
				}
			}
			if (Physics._outHitAllInfo.length==0){
				outHitInfo.sprite3D=null;
				outHitInfo.distance=-1;
				return;
			};
			var minDistance=Number.MAX_VALUE;
			var minIndex=0;
			for (var j=0;j < Physics._outHitAllInfo.length;j++){
				if (Physics._outHitAllInfo[j].distance < minDistance){
					minDistance=Physics._outHitAllInfo[j].distance;
					minIndex=j;
				}
			}
			Physics._outHitAllInfo[minIndex].cloneTo(outHitInfo);
		}

		Physics.rayCastAll=function(ray,outHitAllInfo,distance,layer){
			(distance===void 0)&& (distance=1.79e+308);
			(layer===void 0)&& (layer=0);
			outHitAllInfo.length=0;
			var colliders=Layer.getLayerByNumber(layer)._colliders;
			for (var i=0,n=colliders.length;i < n;i++){
				var collider=colliders[i];
				if (collider.enable){
					Physics._outHitInfo.distance=-1;
					Physics._outHitInfo.sprite3D=null;
					collider.raycast(ray,Physics._outHitInfo,distance);
					if (Physics._outHitInfo.distance!==-1 && Physics._outHitInfo.distance <=distance){
						var outHit=new RaycastHit();
						Physics._outHitInfo.cloneTo(outHit);
						outHitAllInfo.push(outHit);
					}
				}
			}
		}

		Physics._outHitAllInfo=[];
		Physics._layerCollsionMatrix=[];
		__static(Physics,
		['_outHitInfo',function(){return this._outHitInfo=new RaycastHit();},'collisionManager',function(){return this.collisionManager=new CollisionManager();},'gravity',function(){return this.gravity=new Vector3(0,-9.81,0);}
		]);
		return Physics;
	})()


	/**
	*<code>Picker</code> 类用于创建拾取。
	*/
	//class laya.d3.utils.Picker
	var Picker=(function(){
		/**
		*创建一个 <code>Picker</code> 实例。
		*/
		function Picker(){}
		__class(Picker,'laya.d3.utils.Picker');
		Picker.calculateCursorRay=function(point,viewPort,projectionMatrix,viewMatrix,world,out){
			var x=point.elements[0];
			var y=point.elements[1];
			var nearSource=Picker._tempVector30;
			var nerSourceE=nearSource.elements;
			nerSourceE[0]=x;
			nerSourceE[1]=y;
			nerSourceE[2]=viewPort.minDepth;
			var farSource=Picker._tempVector31;
			var farSourceE=farSource.elements;
			farSourceE[0]=x;
			farSourceE[1]=y;
			farSourceE[2]=viewPort.maxDepth;
			var nearPoint=out.origin;
			var farPoint=Picker._tempVector32;
			viewPort.unprojectFromWVP(nearSource,projectionMatrix,viewMatrix,world,nearPoint);
			viewPort.unprojectFromWVP(farSource,projectionMatrix,viewMatrix,world,farPoint);
			var outDire=out.direction.elements;
			outDire[0]=farPoint.x-nearPoint.x;
			outDire[1]=farPoint.y-nearPoint.y;
			outDire[2]=farPoint.z-nearPoint.z;
			Vector3.normalize(out.direction,out.direction);
		}

		Picker.rayIntersectsPositionsAndIndices=function(ray,vertexDatas,vertexDeclaration,indices,outHitInfo){
			var vertexStrideFloatCount=vertexDeclaration.vertexStride / 4;
			var positionVertexElementOffset=vertexDeclaration.getVertexElementByUsage(0).offset / 4;
			var closestIntersection=Number.MAX_VALUE;
			var closestTriangleVertexIndex1=-1;
			var closestTriangleVertexIndex2=-1;
			var closestTriangleVertexIndex3=-1;
			for (var j=0;j < indices.length;j+=3){
				var vertex1=Picker._tempVector35;
				var vertex1E=vertex1.elements;
				var vertex1Index=indices[j] *vertexStrideFloatCount;
				var vertex1PositionIndex=vertex1Index+positionVertexElementOffset;
				vertex1E[0]=vertexDatas[vertex1PositionIndex];
				vertex1E[1]=vertexDatas[vertex1PositionIndex+1];
				vertex1E[2]=vertexDatas[vertex1PositionIndex+2];
				var vertex2=Picker._tempVector36;
				var vertex2E=vertex2.elements;
				var vertex2Index=indices[j+1] *vertexStrideFloatCount;
				var vertex2PositionIndex=vertex2Index+positionVertexElementOffset;
				vertex2E[0]=vertexDatas[vertex2PositionIndex];
				vertex2E[1]=vertexDatas[vertex2PositionIndex+1];
				vertex2E[2]=vertexDatas[vertex2PositionIndex+2];
				var vertex3=Picker._tempVector37;
				var vertex3E=vertex3.elements;
				var vertex3Index=indices[j+2] *vertexStrideFloatCount;
				var vertex3PositionIndex=vertex3Index+positionVertexElementOffset;
				vertex3E[0]=vertexDatas[vertex3PositionIndex];
				vertex3E[1]=vertexDatas[vertex3PositionIndex+1];
				vertex3E[2]=vertexDatas[vertex3PositionIndex+2];
				var intersection=laya.d3.utils.Picker.rayIntersectsTriangle(ray,vertex1,vertex2,vertex3);
				if (!isNaN(intersection)&& intersection < closestIntersection){
					closestIntersection=intersection;
					closestTriangleVertexIndex1=vertex1Index;
					closestTriangleVertexIndex2=vertex2Index;
					closestTriangleVertexIndex3=vertex3Index;
				}
			}
			if (closestIntersection!==Number.MAX_VALUE){
				outHitInfo.distance=closestIntersection;
				Vector3.scale(ray.direction,closestIntersection,outHitInfo.position);
				Vector3.add(ray.origin,outHitInfo.position,outHitInfo.position);
				var trianglePositions=outHitInfo.trianglePositions;
				var position0=trianglePositions[0];
				var position1=trianglePositions[1];
				var position2=trianglePositions[2];
				var position0E=position0.elements;
				var position1E=position1.elements;
				var position2E=position2.elements;
				var closestVertex1PositionIndex=closestTriangleVertexIndex1+positionVertexElementOffset;
				position0E[0]=vertexDatas[closestVertex1PositionIndex];
				position0E[1]=vertexDatas[closestVertex1PositionIndex+1];
				position0E[2]=vertexDatas[closestVertex1PositionIndex+2];
				var closestVertex2PositionIndex=closestTriangleVertexIndex2+positionVertexElementOffset;
				position1E[0]=vertexDatas[closestVertex2PositionIndex];
				position1E[1]=vertexDatas[closestVertex2PositionIndex+1];
				position1E[2]=vertexDatas[closestVertex2PositionIndex+2];
				var closestVertex3PositionIndex=closestTriangleVertexIndex3+positionVertexElementOffset;
				position2E[0]=vertexDatas[closestVertex3PositionIndex];
				position2E[1]=vertexDatas[closestVertex3PositionIndex+1];
				position2E[2]=vertexDatas[closestVertex3PositionIndex+2];
				var normalVertexElement=vertexDeclaration.getVertexElementByUsage(3);
				if (normalVertexElement){
					var normalVertexElementOffset=normalVertexElement.offset / 4;
					var triangleNormals=outHitInfo.triangleNormals;
					var normal0=triangleNormals[0];
					var normal1=triangleNormals[1];
					var normal2=triangleNormals[2];
					var normal0E=normal0.elements;
					var normal1E=normal1.elements;
					var normal2E=normal2.elements;
					var closestVertex1NormalIndex=closestTriangleVertexIndex1+normalVertexElementOffset;
					normal0E[0]=vertexDatas[closestVertex1NormalIndex];
					normal0E[1]=vertexDatas[closestVertex1NormalIndex+1];
					normal0E[2]=vertexDatas[closestVertex1NormalIndex+2];
					var closestVertex2NormalIndex=closestTriangleVertexIndex2+normalVertexElementOffset;
					normal1E[0]=vertexDatas[closestVertex2NormalIndex];
					normal1E[1]=vertexDatas[closestVertex2NormalIndex+1];
					normal1E[2]=vertexDatas[closestVertex2NormalIndex+2];
					var closestVertex3NormalIndex=closestTriangleVertexIndex3+normalVertexElementOffset;
					normal2E[0]=vertexDatas[closestVertex3NormalIndex];
					normal2E[1]=vertexDatas[closestVertex3NormalIndex+1];
					normal2E[2]=vertexDatas[closestVertex3NormalIndex+2];
				}
				return true;
				}else {
				outHitInfo.position.toDefault();
				outHitInfo.distance=Number.MAX_VALUE;
				outHitInfo.trianglePositions[0].toDefault();
				outHitInfo.trianglePositions[1].toDefault();
				outHitInfo.trianglePositions[2].toDefault();
				outHitInfo.triangleNormals[0].toDefault();
				outHitInfo.triangleNormals[1].toDefault();
				outHitInfo.triangleNormals[2].toDefault();
				return false;
			}
		}

		Picker.rayIntersectsTriangle=function(ray,vertex1,vertex2,vertex3){
			var result;
			var edge1=Picker._tempVector30,edge2=Picker._tempVector31;
			Vector3.subtract(vertex2,vertex1,edge1);
			Vector3.subtract(vertex3,vertex1,edge2);
			var directionCrossEdge2=Picker._tempVector32;
			Vector3.cross(ray.direction,edge2,directionCrossEdge2);
			var determinant;
			determinant=Vector3.dot(edge1,directionCrossEdge2);
			if (determinant >-Number.MIN_VALUE && determinant < Number.MIN_VALUE){
				result=Number.NaN;
				return result;
			};
			var inverseDeterminant=1.0 / determinant;
			var distanceVector=Picker._tempVector33;
			Vector3.subtract(ray.origin,vertex1,distanceVector);
			var triangleU;
			triangleU=Vector3.dot(distanceVector,directionCrossEdge2);
			triangleU *=inverseDeterminant;
			if (triangleU < 0 || triangleU > 1){
				result=Number.NaN;
				return result;
			};
			var distanceCrossEdge1=Picker._tempVector34;
			Vector3.cross(distanceVector,edge1,distanceCrossEdge1);
			var triangleV;
			triangleV=Vector3.dot(ray.direction,distanceCrossEdge1);
			triangleV *=inverseDeterminant;
			if (triangleV < 0 || triangleU+triangleV > 1){
				result=Number.NaN;
				return result;
			};
			var rayDistance;
			rayDistance=Vector3.dot(edge2,distanceCrossEdge1);
			rayDistance *=inverseDeterminant;
			if (rayDistance < 0){
				result=Number.NaN;
				return result;
			}
			result=rayDistance;
			return result;
		}

		__static(Picker,
		['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempVector32',function(){return this._tempVector32=new Vector3();},'_tempVector33',function(){return this._tempVector33=new Vector3();},'_tempVector34',function(){return this._tempVector34=new Vector3();},'_tempVector35',function(){return this._tempVector35=new Vector3();},'_tempVector36',function(){return this._tempVector36=new Vector3();},'_tempVector37',function(){return this._tempVector37=new Vector3();}
		]);
		return Picker;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.utils.RaycastHit
	var RaycastHit=(function(){
		function RaycastHit(){
			this.distance=NaN;
			this.trianglePositions=null;
			this.triangleNormals=null;
			this.position=null;
			this.sprite3D=null;
			this.distance=-1;
			this.trianglePositions=[new Vector3(),new Vector3(),new Vector3()];
			this.trianglePositions.length=3;
			this.triangleNormals=[new Vector3(),new Vector3(),new Vector3()];
			this.triangleNormals.length=3;
			this.position=new Vector3();
		}

		__class(RaycastHit,'laya.d3.utils.RaycastHit');
		var __proto=RaycastHit.prototype;
		__proto.cloneTo=function(dec){
			dec.distance=this.distance;
			this.trianglePositions[0].cloneTo(dec.trianglePositions[0]);
			this.trianglePositions[1].cloneTo(dec.trianglePositions[1]);
			this.trianglePositions[2].cloneTo(dec.trianglePositions[2]);
			this.triangleNormals[0].cloneTo(dec.triangleNormals[0]);
			this.triangleNormals[1].cloneTo(dec.triangleNormals[1]);
			this.triangleNormals[2].cloneTo(dec.triangleNormals[2]);
			this.position.cloneTo(dec.position);
			dec.sprite3D=this.sprite3D;
		}

		return RaycastHit;
	})()


	//class laya.d3.utils.Size
	var Size=(function(){
		function Size(width,height){
			this._width=0;
			this._height=0;
			this._width=width;
			this._height=height;
		}

		__class(Size,'laya.d3.utils.Size');
		var __proto=Size.prototype;
		__getset(0,__proto,'width',function(){
			if (this._width===-1)
				return RenderContext3D.clientWidth;
			return this._width;
		});

		__getset(0,__proto,'height',function(){
			if (this._height===-1)
				return RenderContext3D.clientHeight;
			return this._height;
		});

		__getset(1,Size,'fullScreen',function(){
			return new Size(-1,-1);
		});

		return Size;
	})()


	/**
	*<code>Utils3D</code> 类用于创建3D工具。
	*/
	//class laya.d3.utils.Utils3D
	var Utils3D=(function(){
		function Utils3D(){};
		__class(Utils3D,'laya.d3.utils.Utils3D');
		Utils3D._rotationTransformScaleSkinAnimation=function(tx,ty,tz,qx,qy,qz,qw,sx,sy,sz,outArray,outOffset){
			var re=Utils3D._tempArray16_0;
			var se=Utils3D._tempArray16_1;
			var tse=Utils3D._tempArray16_2;
			var x2=qx+qx;
			var y2=qy+qy;
			var z2=qz+qz;
			var xx=qx *x2;
			var yx=qy *x2;
			var yy=qy *y2;
			var zx=qz *x2;
			var zy=qz *y2;
			var zz=qz *z2;
			var wx=qw *x2;
			var wy=qw *y2;
			var wz=qw *z2;
			re[15]=1;
			re[0]=1-yy-zz;
			re[1]=yx+wz;
			re[2]=zx-wy;
			re[4]=yx-wz;
			re[5]=1-xx-zz;
			re[6]=zy+wx;
			re[8]=zx+wy;
			re[9]=zy-wx;
			re[10]=1-xx-yy;
			se[15]=1;
			se[0]=sx;
			se[5]=sy;
			se[10]=sz;
			var i,a,b,e,ai0,ai1,ai2,ai3;
			for (i=0;i < 4;i++){
				ai0=re[i];
				ai1=re[i+4];
				ai2=re[i+8];
				ai3=re[i+12];
				tse[i]=ai0;
				tse[i+4]=ai1;
				tse[i+8]=ai2;
				tse[i+12]=ai0 *tx+ai1 *ty+ai2 *tz+ai3;
			}
			for (i=0;i < 4;i++){
				ai0=tse[i];
				ai1=tse[i+4];
				ai2=tse[i+8];
				ai3=tse[i+12];
				outArray[i+outOffset]=ai0 *se[0]+ai1 *se[1]+ai2 *se[2]+ai3 *se[3];
				outArray[i+outOffset+4]=ai0 *se[4]+ai1 *se[5]+ai2 *se[6]+ai3 *se[7];
				outArray[i+outOffset+8]=ai0 *se[8]+ai1 *se[9]+ai2 *se[10]+ai3 *se[11];
				outArray[i+outOffset+12]=ai0 *se[12]+ai1 *se[13]+ai2 *se[14]+ai3 *se[15];
			}
		}

		Utils3D._createNodeByJson=function(rootNode,nodeData,node,innerResouMap,outBatchSprites){
			if (!node){
				switch (nodeData.type){
					case "Sprite3D":
						node=new Sprite3D();
						break ;
					case "MeshSprite3D":
						node=new MeshSprite3D();
						(outBatchSprites)&& (outBatchSprites.push(node));
						break ;
					case "SkinnedMeshSprite3D":
						node=new SkinnedMeshSprite3D();
						break ;
					case "ShuriKenParticle3D":
						node=new ShuriKenParticle3D();
						break ;
					case "Terrain":
						node=new Terrain();
						break ;
					case "Camera":
						node=new Camera();
						break ;
					case "DirectionLight":
						node=new DirectionLight();
						break ;
					default :
						throw new Error("Utils3D:unidentified class type in (.lh) file.");
					}
			};
			var props=nodeData.props;
			if (props)
				for (var key in props)
			node[key]=props[key];
			var customProps=nodeData.customProps;
			if (customProps){
				if ((node instanceof laya.d3.core.Sprite3D ))
					node._parseBaseCustomProps(customProps);
				node._parseCustomProps(rootNode,innerResouMap,customProps);
				node._parseCustomComponent(rootNode,innerResouMap,nodeData.components);
			};
			var childData=nodeData.child;
			if (childData){
				for (var i=0,n=childData.length;i < n;i++){
					var child=Utils3D._createNodeByJson(rootNode,childData[i],null,innerResouMap,outBatchSprites)
					node.addChild(child);
				}
			}
			return node;
		}

		Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxix=function(bones,curData,inverGlobalBindPose,outBonesDatas,outAnimationDatas,boneIndexToMesh){
			var offset=0;
			var matOffset=0;
			var i;
			var parentOffset;
			var boneLength=bones.length;
			for (i=0;i < boneLength;offset+=bones[i].keyframeWidth,matOffset+=16,i++){
				laya.d3.utils.Utils3D._rotationTransformScaleSkinAnimation(curData[offset+0],curData[offset+1],curData[offset+2],curData[offset+3],curData[offset+4],curData[offset+5],curData[offset+6],curData[offset+7],curData[offset+8],curData[offset+9],outBonesDatas,matOffset);
				if (i !=0){
					parentOffset=bones[i].parentIndex *16;
					laya.d3.utils.Utils3D.mulMatrixByArray(outBonesDatas,parentOffset,outBonesDatas,matOffset,outBonesDatas,matOffset);
				}
			};
			var n=inverGlobalBindPose.length;
			for (i=0;i < n;i++){
				laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas,boneIndexToMesh[i] *16,inverGlobalBindPose[i],outAnimationDatas,i *16);
			}
		}

		Utils3D._computeAnimationDatasByArrayAndMatrixFast=function(inverGlobalBindPose,bonesDatas,outAnimationDatas,boneIndexToMesh){
			for (var i=0,n=inverGlobalBindPose.length;i < n;i++)
			laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas,boneIndexToMesh[i] *16,inverGlobalBindPose[i],outAnimationDatas,i *16);
		}

		Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxixOld=function(bones,curData,inverGlobalBindPose,outBonesDatas,outAnimationDatas){
			var offset=0;
			var matOffset=0;
			var i;
			var parentOffset;
			var boneLength=bones.length;
			for (i=0;i < boneLength;offset+=bones[i].keyframeWidth,matOffset+=16,i++){
				laya.d3.utils.Utils3D._rotationTransformScaleSkinAnimation(curData[offset+7],curData[offset+8],curData[offset+9],curData[offset+3],curData[offset+4],curData[offset+5],curData[offset+6],curData[offset+0],curData[offset+1],curData[offset+2],outBonesDatas,matOffset);
				if (i !=0){
					parentOffset=bones[i].parentIndex *16;
					laya.d3.utils.Utils3D.mulMatrixByArray(outBonesDatas,parentOffset,outBonesDatas,matOffset,outBonesDatas,matOffset);
				}
			};
			var n=inverGlobalBindPose.length;
			for (i=0;i < n;i++){
				var arrayOffset=i *16;
				laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas,arrayOffset,inverGlobalBindPose[i],outAnimationDatas,arrayOffset);
			}
		}

		Utils3D._computeAnimationDatasByArrayAndMatrixFastOld=function(inverGlobalBindPose,bonesDatas,outAnimationDatas){
			var n=inverGlobalBindPose.length;
			for (var i=0;i < n;i++){
				var arrayOffset=i *16;
				laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas,arrayOffset,inverGlobalBindPose[i],outAnimationDatas,arrayOffset);
			}
		}

		Utils3D._computeRootAnimationData=function(bones,curData,animationDatas){
			for (var i=0,offset=0,matOffset=0,boneLength=bones.length;i < boneLength;offset+=bones[i].keyframeWidth,matOffset+=16,i++)
			laya.d3.utils.Utils3D.createAffineTransformationArray(curData[offset+0],curData[offset+1],curData[offset+2],curData[offset+3],curData[offset+4],curData[offset+5],curData[offset+6],curData[offset+7],curData[offset+8],curData[offset+9],animationDatas,matOffset);
		}

		Utils3D.transformVector3ArrayByQuat=function(sourceArray,sourceOffset,rotation,outArray,outOffset){
			var re=rotation.elements;
			var x=sourceArray[sourceOffset],y=sourceArray[sourceOffset+1],z=sourceArray[sourceOffset+2],qx=re[0],qy=re[1],qz=re[2],qw=re[3],ix=qw *x+qy *z-qz *y,iy=qw *y+qz *x-qx *z,iz=qw *z+qx *y-qy *x,iw=-qx *x-qy *y-qz *z;
			outArray[outOffset]=ix *qw+iw *-qx+iy *-qz-iz *-qy;
			outArray[outOffset+1]=iy *qw+iw *-qy+iz *-qx-ix *-qz;
			outArray[outOffset+2]=iz *qw+iw *-qz+ix *-qy-iy *-qx;
		}

		Utils3D.mulMatrixByArray=function(leftArray,leftOffset,rightArray,rightOffset,outArray,outOffset){
			var i,ai0,ai1,ai2,ai3;
			if (outArray===rightArray){
				rightArray=Utils3D._tempArray16_3;
				for (i=0;i < 16;++i){
					rightArray[i]=outArray[outOffset+i];
				}
				rightOffset=0;
			}
			for (i=0;i < 4;i++){
				ai0=leftArray[leftOffset+i];
				ai1=leftArray[leftOffset+i+4];
				ai2=leftArray[leftOffset+i+8];
				ai3=leftArray[leftOffset+i+12];
				outArray[outOffset+i]=ai0 *rightArray[rightOffset+0]+ai1 *rightArray[rightOffset+1]+ai2 *rightArray[rightOffset+2]+ai3 *rightArray[rightOffset+3];
				outArray[outOffset+i+4]=ai0 *rightArray[rightOffset+4]+ai1 *rightArray[rightOffset+5]+ai2 *rightArray[rightOffset+6]+ai3 *rightArray[rightOffset+7];
				outArray[outOffset+i+8]=ai0 *rightArray[rightOffset+8]+ai1 *rightArray[rightOffset+9]+ai2 *rightArray[rightOffset+10]+ai3 *rightArray[rightOffset+11];
				outArray[outOffset+i+12]=ai0 *rightArray[rightOffset+12]+ai1 *rightArray[rightOffset+13]+ai2 *rightArray[rightOffset+14]+ai3 *rightArray[rightOffset+15];
			}
		}

		Utils3D.mulMatrixByArrayFast=function(leftArray,leftOffset,rightArray,rightOffset,outArray,outOffset){
			var i,ai0,ai1,ai2,ai3;
			for (i=0;i < 4;i++){
				ai0=leftArray[leftOffset+i];
				ai1=leftArray[leftOffset+i+4];
				ai2=leftArray[leftOffset+i+8];
				ai3=leftArray[leftOffset+i+12];
				outArray[outOffset+i]=ai0 *rightArray[rightOffset+0]+ai1 *rightArray[rightOffset+1]+ai2 *rightArray[rightOffset+2]+ai3 *rightArray[rightOffset+3];
				outArray[outOffset+i+4]=ai0 *rightArray[rightOffset+4]+ai1 *rightArray[rightOffset+5]+ai2 *rightArray[rightOffset+6]+ai3 *rightArray[rightOffset+7];
				outArray[outOffset+i+8]=ai0 *rightArray[rightOffset+8]+ai1 *rightArray[rightOffset+9]+ai2 *rightArray[rightOffset+10]+ai3 *rightArray[rightOffset+11];
				outArray[outOffset+i+12]=ai0 *rightArray[rightOffset+12]+ai1 *rightArray[rightOffset+13]+ai2 *rightArray[rightOffset+14]+ai3 *rightArray[rightOffset+15];
			}
		}

		Utils3D.mulMatrixByArrayAndMatrixFast=function(leftArray,leftOffset,rightMatrix,outArray,outOffset){
			var i,ai0,ai1,ai2,ai3;
			var rightMatrixE=rightMatrix.elements;
			var m11=rightMatrixE[0],m12=rightMatrixE[1],m13=rightMatrixE[2],m14=rightMatrixE[3];
			var m21=rightMatrixE[4],m22=rightMatrixE[5],m23=rightMatrixE[6],m24=rightMatrixE[7];
			var m31=rightMatrixE[8],m32=rightMatrixE[9],m33=rightMatrixE[10],m34=rightMatrixE[11];
			var m41=rightMatrixE[12],m42=rightMatrixE[13],m43=rightMatrixE[14],m44=rightMatrixE[15];
			var ai0LeftOffset=leftOffset;
			var ai1LeftOffset=leftOffset+4;
			var ai2LeftOffset=leftOffset+8;
			var ai3LeftOffset=leftOffset+12;
			var ai0OutOffset=outOffset;
			var ai1OutOffset=outOffset+4;
			var ai2OutOffset=outOffset+8;
			var ai3OutOffset=outOffset+12;
			for (i=0;i < 4;i++){
				ai0=leftArray[ai0LeftOffset+i];
				ai1=leftArray[ai1LeftOffset+i];
				ai2=leftArray[ai2LeftOffset+i];
				ai3=leftArray[ai3LeftOffset+i];
				outArray[ai0OutOffset+i]=ai0 *m11+ai1 *m12+ai2 *m13+ai3 *m14;
				outArray[ai1OutOffset+i]=ai0 *m21+ai1 *m22+ai2 *m23+ai3 *m24;
				outArray[ai2OutOffset+i]=ai0 *m31+ai1 *m32+ai2 *m33+ai3 *m34;
				outArray[ai3OutOffset+i]=ai0 *m41+ai1 *m42+ai2 *m43+ai3 *m44;
			}
		}

		Utils3D.createAffineTransformationArray=function(tX,tY,tZ,rX,rY,rZ,rW,sX,sY,sZ,outArray,outOffset){
			var x2=rX+rX,y2=rY+rY,z2=rZ+rZ;
			var xx=rX *x2,xy=rX *y2,xz=rX *z2,yy=rY *y2,yz=rY *z2,zz=rZ *z2;
			var wx=rW *x2,wy=rW *y2,wz=rW *z2;
			outArray[outOffset+0]=(1-(yy+zz))*sX;
			outArray[outOffset+1]=(xy+wz)*sX;
			outArray[outOffset+2]=(xz-wy)*sX;
			outArray[outOffset+3]=0;
			outArray[outOffset+4]=(xy-wz)*sY;
			outArray[outOffset+5]=(1-(xx+zz))*sY;
			outArray[outOffset+6]=(yz+wx)*sY;
			outArray[outOffset+7]=0;
			outArray[outOffset+8]=(xz+wy)*sZ;
			outArray[outOffset+9]=(yz-wx)*sZ;
			outArray[outOffset+10]=(1-(xx+yy))*sZ;
			outArray[outOffset+11]=0;
			outArray[outOffset+12]=tX;
			outArray[outOffset+13]=tY;
			outArray[outOffset+14]=tZ;
			outArray[outOffset+15]=1;
		}

		Utils3D.transformVector3ArrayToVector3ArrayCoordinate=function(source,sourceOffset,transform,result,resultOffset){
			var coordinateX=source[sourceOffset+0];
			var coordinateY=source[sourceOffset+1];
			var coordinateZ=source[sourceOffset+2];
			var transformElem=transform.elements;
			var w=((coordinateX *transformElem[3])+(coordinateY *transformElem[7])+(coordinateZ *transformElem[11])+transformElem[15]);
			result[resultOffset]=(coordinateX *transformElem[0])+(coordinateY *transformElem[4])+(coordinateZ *transformElem[8])+transformElem[12] / w;
			result[resultOffset+1]=(coordinateX *transformElem[1])+(coordinateY *transformElem[5])+(coordinateZ *transformElem[9])+transformElem[13] / w;
			result[resultOffset+2]=(coordinateX *transformElem[2])+(coordinateY *transformElem[6])+(coordinateZ *transformElem[10])+transformElem[14] / w;
		}

		Utils3D.transformLightingMapTexcoordByUV0Array=function(source,sourceOffset,lightingMapScaleOffset,result,resultOffset){
			var lightingMapScaleOffsetE=lightingMapScaleOffset.elements;
			result[resultOffset+0]=source[sourceOffset+0] *lightingMapScaleOffsetE[0]+lightingMapScaleOffsetE[2];
			result[resultOffset+1]=(source[sourceOffset+1]-1.0)*lightingMapScaleOffsetE[1]+lightingMapScaleOffsetE[3];
		}

		Utils3D.transformLightingMapTexcoordByUV1Array=function(source,sourceOffset,lightingMapScaleOffset,result,resultOffset){
			var lightingMapScaleOffsetE=lightingMapScaleOffset.elements;
			result[resultOffset+0]=source[sourceOffset+0] *lightingMapScaleOffsetE[0]+lightingMapScaleOffsetE[2];
			result[resultOffset+1]=1.0+source[sourceOffset+1] *lightingMapScaleOffsetE[1]+lightingMapScaleOffsetE[3];
		}

		Utils3D.getURLVerion=function(url){
			var index=url.indexOf("?");
			return index >=0 ? url.substr(index):null;
		}

		Utils3D._quaternionCreateFromYawPitchRollArray=function(yaw,pitch,roll,out){
			var halfRoll=roll *0.5;
			var halfPitch=pitch *0.5;
			var halfYaw=yaw *0.5;
			var sinRoll=Math.sin(halfRoll);
			var cosRoll=Math.cos(halfRoll);
			var sinPitch=Math.sin(halfPitch);
			var cosPitch=Math.cos(halfPitch);
			var sinYaw=Math.sin(halfYaw);
			var cosYaw=Math.cos(halfYaw);
			out[0]=(cosYaw *sinPitch *cosRoll)+(sinYaw *cosPitch *sinRoll);
			out[1]=(sinYaw *cosPitch *cosRoll)-(cosYaw *sinPitch *sinRoll);
			out[2]=(cosYaw *cosPitch *sinRoll)-(sinYaw *sinPitch *cosRoll);
			out[3]=(cosYaw *cosPitch *cosRoll)+(sinYaw *sinPitch *sinRoll);
		}

		Utils3D._createAffineTransformationArray=function(trans,rot,scale,outE){
			var x=rot[0],y=rot[1],z=rot[2],w=rot[3],x2=x+x,y2=y+y,z2=z+z;
			var xx=x *x2,xy=x *y2,xz=x *z2,yy=y *y2,yz=y *z2,zz=z *z2;
			var wx=w *x2,wy=w *y2,wz=w *z2,sx=scale[0],sy=scale[1],sz=scale[2];
			outE[0]=(1-(yy+zz))*sx;
			outE[1]=(xy+wz)*sx;
			outE[2]=(xz-wy)*sx;
			outE[3]=0;
			outE[4]=(xy-wz)*sy;
			outE[5]=(1-(xx+zz))*sy;
			outE[6]=(yz+wx)*sy;
			outE[7]=0;
			outE[8]=(xz+wy)*sz;
			outE[9]=(yz-wx)*sz;
			outE[10]=(1-(xx+yy))*sz;
			outE[11]=0;
			outE[12]=trans[0];
			outE[13]=trans[1];
			outE[14]=trans[2];
			outE[15]=1;
		}

		Utils3D._mulMatrixArray=function(leftMatrixE,rightMatrix,outArray,outOffset){
			var i,ai0,ai1,ai2,ai3;
			var rightMatrixE=rightMatrix.elements;
			var m11=rightMatrixE[0],m12=rightMatrixE[1],m13=rightMatrixE[2],m14=rightMatrixE[3];
			var m21=rightMatrixE[4],m22=rightMatrixE[5],m23=rightMatrixE[6],m24=rightMatrixE[7];
			var m31=rightMatrixE[8],m32=rightMatrixE[9],m33=rightMatrixE[10],m34=rightMatrixE[11];
			var m41=rightMatrixE[12],m42=rightMatrixE[13],m43=rightMatrixE[14],m44=rightMatrixE[15];
			var ai0OutOffset=outOffset;
			var ai1OutOffset=outOffset+4;
			var ai2OutOffset=outOffset+8;
			var ai3OutOffset=outOffset+12;
			for (i=0;i < 4;i++){
				ai0=leftMatrixE[i];
				ai1=leftMatrixE[i+4];
				ai2=leftMatrixE[i+8];
				ai3=leftMatrixE[i+12];
				outArray[ai0OutOffset+i]=ai0 *m11+ai1 *m12+ai2 *m13+ai3 *m14;
				outArray[ai1OutOffset+i]=ai0 *m21+ai1 *m22+ai2 *m23+ai3 *m24;
				outArray[ai2OutOffset+i]=ai0 *m31+ai1 *m32+ai2 *m33+ai3 *m34;
				outArray[ai3OutOffset+i]=ai0 *m41+ai1 *m42+ai2 *m43+ai3 *m44;
			}
		}

		Utils3D.getYawPitchRoll=function(quaternion,out){
			Utils3D.transformQuat(Vector3.ForwardRH,quaternion,Quaternion.TEMPVector31);
			Utils3D.transformQuat(Vector3.Up,quaternion,Quaternion.TEMPVector32);
			var upe=Quaternion.TEMPVector32.elements;
			Utils3D.angleTo(Vector3.ZERO,Quaternion.TEMPVector31,Quaternion.TEMPVector33);
			var anglee=Quaternion.TEMPVector33.elements;
			if (anglee[0]==Math.PI / 2){
				anglee[1]=Utils3D.arcTanAngle(upe[2],upe[0]);
				anglee[2]=0;
				}else if (anglee[0]==-Math.PI / 2){
				anglee[1]=Utils3D.arcTanAngle(-upe[2],-upe[0]);
				anglee[2]=0;
				}else {
				Matrix4x4.createRotationY(-anglee[1],Quaternion.TEMPMatrix0);
				Matrix4x4.createRotationX(-anglee[0],Quaternion.TEMPMatrix1);
				Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix0,Quaternion.TEMPVector32);
				Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix1,Quaternion.TEMPVector32);
				anglee[2]=Utils3D.arcTanAngle(upe[1],-upe[0]);
			}
			if (anglee[1] <=-Math.PI)
				anglee[1]=Math.PI;
			if (anglee[2] <=-Math.PI)
				anglee[2]=Math.PI;
			if (anglee[1] >=Math.PI && anglee[2] >=Math.PI){
				anglee[1]=0;
				anglee[2]=0;
				anglee[0]=Math.PI-anglee[0];
			}
			out[0]=anglee[1];
			out[1]=anglee[0];
			out[2]=anglee[2];
		}

		Utils3D.arcTanAngle=function(x,y){
			if (x==0){
				if (y==1)
					return Math.PI / 2;
				return-Math.PI / 2;
			}
			if (x > 0)
				return Math.atan(y / x);
			if (x < 0){
				if (y > 0)
					return Math.atan(y / x)+Math.PI;
				return Math.atan(y / x)-Math.PI;
			}
			return 0;
		}

		Utils3D.angleTo=function(from,location,angle){
			Vector3.subtract(location,from,Quaternion.TEMPVector30);
			Vector3.normalize(Quaternion.TEMPVector30,Quaternion.TEMPVector30);
			angle.elements[0]=Math.asin(Quaternion.TEMPVector30.y);
			angle.elements[1]=Utils3D.arcTanAngle(-Quaternion.TEMPVector30.z,-Quaternion.TEMPVector30.x);
		}

		Utils3D.transformQuat=function(source,rotation,out){
			var destination=out.elements;
			var se=source.elements;
			var re=rotation;
			var x=se[0],y=se[1],z=se[2],qx=re[0],qy=re[1],qz=re[2],qw=re[3],
			ix=qw *x+qy *z-qz *y,iy=qw *y+qz *x-qx *z,iz=qw *z+qx *y-qy *x,iw=-qx *x-qy *y-qz *z;
			destination[0]=ix *qw+iw *-qx+iy *-qz-iz *-qy;
			destination[1]=iy *qw+iw *-qy+iz *-qx-ix *-qz;
			destination[2]=iz *qw+iw *-qz+ix *-qy-iy *-qx;
		}

		Utils3D.quaterionNormalize=function(f,e){
			var x=f[0],y=f[1],z=f[2],w=f[3];
			var len=x *x+y *y+z *z+w *w;
			if (len > 0){
				len=1 / Math.sqrt(len);
				e[0]=x *len;
				e[1]=y *len;
				e[2]=z *len;
				e[3]=w *len;
			}
		}

		Utils3D.matrix4x4MultiplyFFF=function(a,b,e){
			var i,e,a,b,ai0,ai1,ai2,ai3;
			if (e===b){
				b=new Float32Array(16);
				for (i=0;i < 16;++i){
					b[i]=e[i];
				}
			};
			var b0=b[0],b1=b[1],b2=b[2],b3=b[3];
			var b4=b[4],b5=b[5],b6=b[6],b7=b[7];
			var b8=b[8],b9=b[9],b10=b[10],b11=b[11];
			var b12=b[12],b13=b[13],b14=b[14],b15=b[15];
			for (i=0;i < 4;i++){
				ai0=a[i];
				ai1=a[i+4];
				ai2=a[i+8];
				ai3=a[i+12];
				e[i]=ai0 *b0+ai1 *b1+ai2 *b2+ai3 *b3;
				e[i+4]=ai0 *b4+ai1 *b5+ai2 *b6+ai3 *b7;
				e[i+8]=ai0 *b8+ai1 *b9+ai2 *b10+ai3 *b11;
				e[i+12]=ai0 *b12+ai1 *b13+ai2 *b14+ai3 *b15;
			}
		}

		Utils3D.matrix4x4MultiplyFFFForNative=function(a,b,e){
			window.conch.matrix4x4Multiply(a,b,e);
		}

		Utils3D.matrix4x4MultiplyMFM=function(left,right,out){
			Utils3D.matrix4x4MultiplyFFF(left.elements,right,out.elements);
		}

		Utils3D._tempArray4_0=new Float32Array(4);
		Utils3D._tempArray16_0=new Float32Array(16);
		Utils3D._tempArray16_1=new Float32Array(16);
		Utils3D._tempArray16_2=new Float32Array(16);
		Utils3D._tempArray16_3=new Float32Array(16);
		__static(Utils3D,
		['_typeToFunO',function(){return this._typeToFunO={"INT16":"writeInt16","SHORT":"writeInt16","UINT16":"writeUint16","UINT32":"writeUint32","FLOAT32":"writeFloat32","INT":"writeInt32","UINT":"writeUint32","BYTE":"writeByte","STRING":"writeUTFString"};},'_tempVector3_0',function(){return this._tempVector3_0=new Vector3();},'_tempVector3_1',function(){return this._tempVector3_1=new Vector3();},'_tempVector3_2',function(){return this._tempVector3_2=new Vector3();},'_tempVector3_3',function(){return this._tempVector3_3=new Vector3();},'_tempVector3_4',function(){return this._tempVector3_4=new Vector3();},'_tempVector3_5',function(){return this._tempVector3_5=new Vector3();},'_tempVector3_6',function(){return this._tempVector3_6=new Vector3();}
		]);
		return Utils3D;
	})()


	/**
	*<code>Laya3D</code> 类用于初始化3D设置。
	*/
	//class Laya3D
	var Laya3D=(function(){
		/**
		*创建一个 <code>Laya3D</code> 实例。
		*/
		function Laya3D(){}
		__class(Laya3D,'Laya3D');
		Laya3D._cancelLoadByUrl=function(url){
			Laya.loader.cancelLoadByUrl(url);
			Laya3D._innerFirstLevelLoaderManager.cancelLoadByUrl(url);
			Laya3D._innerSecondLevelLoaderManager.cancelLoadByUrl(url);
			Laya3D._innerThirdLevelLoaderManager.cancelLoadByUrl(url);
			Laya3D._innerFourthLevelLoaderManager.cancelLoadByUrl(url);
		}

		Laya3D._changeWebGLSize=function(width,height){
			WebGL.onStageResize(width,height);
			RenderContext3D.clientWidth=width;
			RenderContext3D.clientHeight=height;
		}

		Laya3D.__init__=function(){
			var createMap=LoaderManager.createMap;
			createMap["lh"]=[Sprite3D,"SPRITE3DHIERARCHY"];
			createMap["ls"]=[Scene,"SPRITE3DHIERARCHY"];
			createMap["lm"]=[Mesh,"MESH"];
			createMap["lmat"]=[StandardMaterial,"MATERIAL"];
			createMap["lpbr"]=[PBRMaterial,"MATERIAL"];
			createMap["ltc"]=[TextureCube,"TEXTURECUBE"];
			createMap["jpg"]=[Texture2D,"nativeimage"];
			createMap["jpeg"]=[Texture2D,"nativeimage"];
			createMap["png"]=[Texture2D,"nativeimage"];
			createMap["pkm"]=[Texture2D,"arraybuffer"];
			createMap["lsani"]=[AnimationTemplet,"arraybuffer"];
			createMap["lrani"]=[AnimationTemplet,"arraybuffer"];
			createMap["raw"]=[DataTexture2D,"arraybuffer"];
			createMap["mipmaps"]=[DataTexture2D,"arraybuffer"];
			createMap["thdata"]=[TerrainHeightData,"arraybuffer"];
			createMap["lt"]=[TerrainRes,"TERRAIN"];
			createMap["lani"]=[AnimationClip,"arraybuffer"];
			createMap["lav"]=[Avatar,"json"];
			createMap["ani"]=[AnimationTemplet,"arraybuffer"];
			Loader.parserMap[ "SPRITE3DHIERARCHY"]=Laya3D._loadHierarchy;
			Loader.parserMap[ "MESH"]=Laya3D._loadMesh;
			Loader.parserMap[ "MATERIAL"]=Laya3D._loadMaterial;
			Loader.parserMap[ "TEXTURECUBE"]=Laya3D._loadTextureCube;
			Loader.parserMap[ "TERRAIN"]=Laya3D._loadTerrain;
			Laya3D._innerFirstLevelLoaderManager.on("error",null,Laya3D._eventLoadManagerError);
			Laya3D._innerSecondLevelLoaderManager.on("error",null,Laya3D._eventLoadManagerError);
			Laya3D._innerThirdLevelLoaderManager.on("error",null,Laya3D._eventLoadManagerError);
			Laya3D._innerFourthLevelLoaderManager.on("error",null,Laya3D._eventLoadManagerError);
		}

		Laya3D._eventLoadManagerError=function(msg){
			Laya.loader.event("error",msg);
		}

		Laya3D._addHierarchyInnerUrls=function(urls,urlMap,urlVersion,hierarchyBasePath,path,clas){
			var formatSubUrl=URL.formatURL(hierarchyBasePath+path);
			(urlVersion)&& (formatSubUrl=formatSubUrl+urlVersion);
			urls.push({url:formatSubUrl,clas:clas});
			urlMap[path]=formatSubUrl;
		}

		Laya3D._parseMaterial=function(mat,secondLevelUrls,urlMap,urlVersion,hierarchyBasePath){
			var clasPaths=mat.type.split('.');
			var clas=Browser.window;
			clasPaths.forEach(function(cls){
				clas=clas[cls];
			});
			if (typeof(clas)=='function')
				Laya3D._addHierarchyInnerUrls(secondLevelUrls,urlMap,urlVersion,hierarchyBasePath,mat.path,clas);
			else {
				throw('_getSprite3DHierarchyInnerUrls 错误: '+mat.type+' 不是类');
			}
		}

		Laya3D._getSprite3DHierarchyInnerUrls=function(node,firstLevelUrls,secondLevelUrls,fourthLelUrls,urlMap,urlVersion,hierarchyBasePath){
			var i=0,n=0;
			var customProps=node.customProps;
			switch (node.type){
				case "Scene":;
					var lightmaps=customProps.lightmaps;
					for (i=0,n=lightmaps.length;i < n;i++){
						var lightMap=lightmaps[i].replace("exr","png");
						Laya3D._addHierarchyInnerUrls(fourthLelUrls,urlMap,urlVersion,hierarchyBasePath,lightMap,Texture2D);
					}
					break ;
				case "Camera":;
					var skyBoxData=customProps.skyBox;
					if (skyBoxData){
						var sharedMaterial=skyBoxData.sharedMaterial;
						(sharedMaterial)&& (Laya3D._parseMaterial(sharedMaterial,secondLevelUrls,urlMap,urlVersion,hierarchyBasePath));
					}
					break ;
				case "MeshSprite3D":
				case "SkinnedMeshSprite3D":;
					var meshPath=customProps.meshPath;
					(meshPath)&& (Laya3D._addHierarchyInnerUrls(firstLevelUrls,urlMap,urlVersion,hierarchyBasePath,meshPath,Mesh));
					var materials=customProps.materials;
					if (materials)
						for (i=0,n=materials.length;i < n;i++)
					Laya3D._parseMaterial(materials[i],secondLevelUrls,urlMap,urlVersion,hierarchyBasePath);
					break ;
				case "ShuriKenParticle3D":;
					var parMeshPath=customProps.meshPath;
					(parMeshPath)&& (Laya3D._addHierarchyInnerUrls(firstLevelUrls,urlMap,urlVersion,hierarchyBasePath,parMeshPath,Mesh));
					var materialData=customProps.material;
					Laya3D._addHierarchyInnerUrls(secondLevelUrls,urlMap,urlVersion,hierarchyBasePath,materialData.path,ShurikenParticleMaterial);
					break ;
				case "Terrain":
					Laya3D._addHierarchyInnerUrls(fourthLelUrls,urlMap,urlVersion,hierarchyBasePath,customProps.dataPath,TerrainRes);
					break ;
				};
			var components=node.components;
			for (var k in components){
				var component=components[k];
				switch (k){
					case "Animator":;
						var avatarPath=component.avatarPath;
						var avatarData=component.avatar;
						(avatarData)&& (Laya3D._addHierarchyInnerUrls(fourthLelUrls,urlMap,urlVersion,hierarchyBasePath,avatarData.path,Avatar));
						var clipPaths=component.clipPaths;
						for (i=0,n=clipPaths.length;i < n;i++)
						Laya3D._addHierarchyInnerUrls(fourthLelUrls,urlMap,urlVersion,hierarchyBasePath,clipPaths[i],AnimationClip);
						break ;
					}
			};
			var children=node.child;
			for (i=0,n=children.length;i < n;i++)
			Laya3D._getSprite3DHierarchyInnerUrls(children[i],firstLevelUrls,secondLevelUrls,fourthLelUrls,urlMap,urlVersion,hierarchyBasePath);
		}

		Laya3D._loadHierarchy=function(loader){
			loader.on("loaded",null,Laya3D._onHierarchylhLoaded,[loader,loader._class._getGroup()]);
			loader.load(loader.url,"json",false,null,true);
		}

		Laya3D._onHierarchylhLoaded=function(loader,group,lhData){
			if (loader._class.destroyed){
				loader.endLoad();
				}else {
				var url=loader.url;
				var urlVersion=Utils3D.getURLVerion(url);
				var hierarchyBasePath=URL.getPath(url);
				var firstLevUrls=[];
				var secondLevUrls=[];
				var forthLevUrls=[];
				var urlMap={};
				Laya3D._getSprite3DHierarchyInnerUrls(lhData,firstLevUrls,secondLevUrls,forthLevUrls,urlMap,urlVersion,hierarchyBasePath);
				var urlCount=firstLevUrls.length+secondLevUrls.length+forthLevUrls.length;
				var totalProcessCount=urlCount+1;
				var weight=1 / totalProcessCount;
				Laya3D._onProcessChange(loader,0,weight,1.0);
				if (forthLevUrls.length > 0){
					var processCeil=urlCount / totalProcessCount;
					var processHandler=Handler.create(null,Laya3D._onProcessChange,[loader,weight,processCeil],false);
					Laya3D._innerFourthLevelLoaderManager.create(forthLevUrls,Handler.create(null,Laya3D._onHierarchyInnerForthLevResouLoaded,[loader,group,processHandler,lhData,urlMap,firstLevUrls,secondLevUrls,weight+processCeil *forthLevUrls.length,processCeil]),processHandler,null,null,1,true,group);
					}else {
					Laya3D._onHierarchyInnerForthLevResouLoaded(loader,group,null,lhData,urlMap,firstLevUrls,secondLevUrls,weight,processCeil);
				}
			}
		}

		Laya3D._onHierarchyInnerForthLevResouLoaded=function(loader,group,processHandler,lhData,urlMap,firstLevUrls,secondLevUrls,processOffset,processCeil){
			if (loader._class.destroyed){
				loader.endLoad();
				}else {
				(processHandler)&& (processHandler.recover());
				if (secondLevUrls.length > 0){
					var process=Handler.create(null,Laya3D._onProcessChange,[loader,processOffset,processCeil],false);
					Laya3D._innerSecondLevelLoaderManager.create(secondLevUrls,Handler.create(null,Laya3D._onHierarchyInnerSecondLevResouLoaded,[loader,group,process,lhData,urlMap,firstLevUrls,processOffset+processCeil *secondLevUrls.length,processCeil]),processHandler,null,null,1,true,group);
					}else {
					Laya3D._onHierarchyInnerSecondLevResouLoaded(loader,group,null,lhData,urlMap,firstLevUrls,processOffset,processCeil);
				}
			}
		}

		Laya3D._onHierarchyInnerSecondLevResouLoaded=function(loader,group,processHandler,lhData,urlMap,firstLevUrls,processOffset,processCeil){
			if (loader._class.destroyed){
				loader.endLoad();
				}else {
				(processHandler)&& (processHandler.recover());
				if (firstLevUrls.length > 0){
					var process=Handler.create(null,Laya3D._onProcessChange,[loader,processOffset,processCeil],false);
					Laya3D._innerFirstLevelLoaderManager.create(firstLevUrls,Handler.create(null,Laya3D._onHierarchyInnerFirstLevResouLoaded,[loader,process,lhData,urlMap,]),processHandler,null,null,1,true,group);
					}else {
					Laya3D._onHierarchyInnerFirstLevResouLoaded(loader,null,lhData,urlMap);
				}
			}
		}

		Laya3D._onHierarchyInnerFirstLevResouLoaded=function(loader,processHandler,lhData,urlMap){
			(processHandler)&& (processHandler.recover());
			loader.endLoad([lhData,urlMap]);
		}

		Laya3D._loadTerrain=function(loader){
			loader.on("loaded",null,Laya3D._onTerrainLtLoaded,[loader,loader._class._getGroup()]);
			loader.load(loader.url,"json",false,null,true);
		}

		Laya3D._onTerrainLtLoaded=function(loader,group,ltData){
			if (loader._class.destroyed){
				loader.endLoad();
				}else {
				var url=loader.url;
				var urlVersion=Utils3D.getURLVerion(url);
				var terrainBasePath=URL.getPath(url);
				var heightMapURL,textureURLs=[];
				var urlMap={};
				var formatUrl;
				var i=0,n=0,count=0;
				var heightData=ltData.heightData;
				heightMapURL=heightData.url;
				formatUrl=URL.formatURL(terrainBasePath+heightMapURL);
				(urlVersion)&& (formatUrl=formatUrl+urlVersion);
				urlMap[heightMapURL]=formatUrl;
				heightMapURL=formatUrl;
				var detailTextures=ltData.detailTexture;
				for (i=0,n=detailTextures.length;i < n;i++)
				textureURLs.push({url:detailTextures[i].diffuse});
				var normalMaps=ltData.normalMap;
				for (i=0,n=normalMaps.length;i < n;i++)
				textureURLs.push({url:normalMaps[i]});
				var alphaMaps=ltData.alphaMap;
				for (i=0,n=alphaMaps.length;i < n;i++)
				textureURLs.push({url:alphaMaps[i],params:[false,false,0x1908,true]});
				for (i=0,n=textureURLs.length;i < n;i++){
					var subUrl=textureURLs[i].url;
					formatUrl=URL.formatURL(terrainBasePath+subUrl);
					(urlVersion)&& (formatUrl=formatUrl+urlVersion);
					textureURLs[i].url=formatUrl;
					urlMap[subUrl]=formatUrl;
				};
				var texsUrlCount=textureURLs.length;
				var totalProcessCount=texsUrlCount+2;
				var weight=1 / totalProcessCount;
				Laya3D._onProcessChange(loader,0,weight,1.0);
				var loadInfo={heightMapLoaded:false,texturesLoaded:false};
				var hmProcessHandler=Handler.create(null,Laya3D._onProcessChange,[loader,weight,weight],false);
				Laya3D._innerFourthLevelLoaderManager.create(heightMapURL,Handler.create(null,Laya3D._onTerrainHeightMapLoaded,[loader,hmProcessHandler,ltData,urlMap,loadInfo]),hmProcessHandler,null,[heightData.numX,heightData.numZ,heightData.bitType,heightData.value],1,true,group);
				var texsProcessHandler=Handler.create(null,Laya3D._onProcessChange,[loader,weight *2,texsUrlCount / totalProcessCount],false);
				Laya3D._innerFourthLevelLoaderManager.create(textureURLs,Handler.create(null,Laya3D._onTerrainTexturesLoaded,[loader,texsProcessHandler,ltData,urlMap,loadInfo]),texsProcessHandler,null,null,1,true,group);
			}
		}

		Laya3D._onTerrainHeightMapLoaded=function(loader,processHandler,ltData,urlMap,loadInfo){
			loadInfo.heightMapLoaded=true;
			if (loadInfo.texturesLoaded){
				loader.endLoad([ltData,urlMap]);
				processHandler.recover();
			}
		}

		Laya3D._onTerrainTexturesLoaded=function(loader,processHandler,ltData,urlMap,loadInfo){
			loadInfo.texturesLoaded=true;
			if (loadInfo.heightMapLoaded){
				loader.endLoad([ltData,urlMap]);
				processHandler.recover();
			}
		}

		Laya3D._loadMesh=function(loader){
			loader.on("loaded",null,Laya3D._onMeshLmLoaded,[loader,loader._class._getGroup()]);
			loader.load(loader.url,"arraybuffer",false,null,true);
		}

		Laya3D._onMeshLmLoaded=function(loader,group,lmData){
			if (loader._class.destroyed){
				loader.endLoad();
				}else {
				var url=loader.url;
				var urlVersion=Utils3D.getURLVerion(url);
				var meshBasePath=URL.getPath(url);
				var urls;
				var urlMap={};
				var formatSubUrl;
				var i=0,n=0,count=0;
				var readData=new Byte(lmData);
				readData.pos=0;
				var version=readData.readUTFString();
				switch (version){
					case "LAYAMODEL:03":
					case "LAYAMODEL:0301":;
						var dataOffset=readData.getUint32();
						readData.pos=readData.pos+4;
						count=readData.getUint16();
						readData.pos=readData.pos+count *8;
						var offset=readData.getUint32();
						count=readData.getUint16();
						readData.pos=dataOffset+offset;
						urls=[];
						for (i=0;i < count;i++){
							var string=readData.readUTFString();
							if (string.lastIndexOf(".lmat")!==-1)
								urls.push(string);
						}
						break ;
					default :
						throw new Error("Laya3D:unknown mesh version.");
					}
				for (i=0,n=urls.length;i < n;i++){
					var subUrl=urls[i];
					formatSubUrl=URL.formatURL(meshBasePath+subUrl);
					(urlVersion)&& (formatSubUrl=formatSubUrl+urlVersion);
					urls[i]=formatSubUrl;
					urlMap[subUrl]=formatSubUrl;
				}
				if (urls.length > 0){
					var urlCount=1;
					var totalProcessCount=urlCount+1;
					var lmatWeight=1 / totalProcessCount;
					Laya3D._onProcessChange(loader,0,lmatWeight,1.0);
					var processHandler=Handler.create(null,Laya3D._onProcessChange,[loader,lmatWeight,urlCount / totalProcessCount],false);
					Laya3D._innerSecondLevelLoaderManager.create(urls,Handler.create(null,Laya3D._onMeshMateialLoaded,[loader,processHandler,lmData,urlMap]),processHandler,null,null,1,true,group);
					}else {
					loader.endLoad([lmData,urlMap]);
				}
			}
		}

		Laya3D._onMeshMateialLoaded=function(loader,processHandler,lmData,urlMap){
			loader.endLoad([lmData,urlMap]);
			processHandler.recover();
		}

		Laya3D._getMaterialTexturePath=function(path,urlVersion,materialBath){
			var extenIndex=path.length-4;
			if (path.indexOf(".dds")==extenIndex || path.indexOf(".tga")==extenIndex || path.indexOf(".exr")==extenIndex || path.indexOf(".DDS")==extenIndex || path.indexOf(".TGA")==extenIndex || path.indexOf(".EXR")==extenIndex)
				path=path.substr(0,extenIndex)+".png";
			path=URL.formatURL(materialBath+path);
			(urlVersion)&& (path=path+urlVersion);
			return path;
		}

		Laya3D._loadMaterial=function(loader){
			loader.on("loaded",null,Laya3D._onMaterilLmatLoaded,[loader,loader._class._getGroup()]);
			loader.load(loader.url,"json",false,null,true);
		}

		Laya3D._onMaterilLmatLoaded=function(loader,group,lmatData){
			if (loader._class.destroyed){
				loader.endLoad();
				}else {
				var url=loader.url;
				var urlVersion=Utils3D.getURLVerion(url);
				var materialBasePath=URL.getPath(url);
				var urls=[];
				var urlMap={};
				var customProps=lmatData.customProps;
				var formatSubUrl;
				var version=lmatData.version;
				switch (version){
					case "LAYAMATERIAL:01":;
						var i=0,n=0;
						var textures=lmatData.props.textures;
						if (textures){
							for (i=0,n=textures.length;i < n;i++){
								var tex2D=textures[i];
								var tex2DPath=tex2D.path;
								if (tex2DPath){
									var extenIndex=tex2DPath.length-4;
									if (tex2DPath.indexOf(".exr")==extenIndex || tex2DPath.indexOf(".EXR")==extenIndex)
										tex2DPath=tex2DPath.substr(0,extenIndex)+".png";
									formatSubUrl=URL.formatURL(materialBasePath+tex2DPath);
									(urlVersion)&& (formatSubUrl=formatSubUrl+urlVersion);
									urls.push({url:formatSubUrl,params:tex2D.params});
									urlMap[tex2DPath]=formatSubUrl;
								}
							}
						}
						break ;
					default :
						throw new Error("Laya3D:unkonwn version.");
					};
				var urlCount=urls.length;
				var totalProcessCount=urlCount+1;
				var lmatWeight=1 / totalProcessCount;
				Laya3D._onProcessChange(loader,0,lmatWeight,1.0);
				if (urlCount > 0){
					var processHandler=Handler.create(null,Laya3D._onProcessChange,[loader,lmatWeight,urlCount / totalProcessCount],false);
					Laya3D._innerFourthLevelLoaderManager.create(urls,Handler.create(null,Laya3D._onMateialTexturesLoaded,[loader,processHandler,lmatData,urlMap]),processHandler,null,null,1,true,group);
					}else {
					Laya3D._onMateialTexturesLoaded(loader,null,lmatData,null);
				}
			}
		}

		Laya3D._onMateialTexturesLoaded=function(loader,processHandler,lmatData,urlMap){
			loader.endLoad([lmatData,urlMap]);
			(processHandler)&& (processHandler.recover());
		}

		Laya3D._loadTextureCube=function(loader){
			loader.on("loaded",null,Laya3D._onTextureCubeLtcLoaded,[loader]);
			loader.load(loader.url,"json",false,null,true);
		}

		Laya3D._onTextureCubeLtcLoaded=function(loader,ltcData){
			if (loader._class.destroyed){
				loader.endLoad();
				}else {
				var ltcBasePath=URL.getPath(loader.url);
				var urls=[URL.formatURL(ltcBasePath+ltcData.front),URL.formatURL(ltcBasePath+ltcData.back),URL.formatURL(ltcBasePath+ltcData.left),URL.formatURL(ltcBasePath+ltcData.right),URL.formatURL(ltcBasePath+ltcData.up),URL.formatURL(ltcBasePath+ltcData.down)];
				var ltcWeight=1.0 / 7.0;
				Laya3D._onProcessChange(loader,0,ltcWeight,1.0);
				var processHandler=Handler.create(null,Laya3D._onProcessChange,[loader,ltcWeight,6 / 7],false);
				Laya3D._innerFourthLevelLoaderManager.load(urls,Handler.create(null,Laya3D._onTextureCubeImagesLoaded,[loader,urls,processHandler]),processHandler,"nativeimage");
			}
		}

		Laya3D._onTextureCubeImagesLoaded=function(loader,urls,processHandler){
			var images=new Array(6);
			for (var i=0;i < 6;i++)
			images[i]=Loader.getRes(urls[i]);
			loader.endLoad(images);
			processHandler.recover();
			for (var i=0;i < 6;i++)
			Loader.clearRes(urls[i]);
		}

		Laya3D._onProcessChange=function(loader,offset,weight,process){
			process=offset+process *weight;
			(process < 1.0)&& (loader.event("progress",process));
		}

		Laya3D._update3DLoop=function(){
			Script._update();
			CollisionManager._triggerCollision();
			Animator._update();
			SkinAnimations._update();
			Script._lateUpdate();
		}

		Laya3D.init=function(width,height,antialias,alpha,premultipliedAlpha,stencil){
			(antialias===void 0)&& (antialias=false);
			(alpha===void 0)&& (alpha=false);
			(premultipliedAlpha===void 0)&& (premultipliedAlpha=true);
			(stencil===void 0)&& (stencil=true);
			RunDriver.update3DLoop=Laya3D._update3DLoop;
			RunDriver.cancelLoadByUrl=function (url){
				Laya3D._cancelLoadByUrl(url);
			}
			Config.isAntialias=antialias;
			Config.isAlpha=alpha;
			Config.premultipliedAlpha=premultipliedAlpha;
			Config.isStencil=stencil;
			if (!Render.isConchApp && !WebGL.enable()){
				alert("Laya3D init error,must support webGL!");
				return;
			}
			if (Render.isConchApp)
				ShaderCompile.customCompile=true;
			RunDriver.changeWebGLSize=Laya3D._changeWebGLSize;
			Render.is3DMode=true;
			Laya.init(width,height);
			Layer.__init__();
			Physics.__init__();
			RenderableSprite3D.__init__();
			SkinnedMeshSprite3D.__init__();
			ShuriKenParticle3D.__init__();
			BaseMaterial.__init__();
			BlinnPhongMaterial.__init__();
			StandardMaterial.__init__();
			PBRMaterial.__init__();
			PBRStandardMaterial.__init__();
			PBRSpecularMaterial.__init__();
			WaterMaterial.__init__();
			ShurikenParticleMaterial.__init__();
			TerrainMaterial.__init__();
			ShaderInit3D.__init__();
			SkyBox.__init__();
			MeshSprite3D.__init__();
			AnimationNode.__init__();
			Texture2D.__init__();
			TextureCube.__init__();
			Laya3D.__init__();
			if (Laya3D.debugMode || OctreeNode.debugMode)
				Laya3D._debugPhasorSprite=new PhasorSpriter3D();
		}

		Laya3D.HIERARCHY="SPRITE3DHIERARCHY";
		Laya3D.MESH="MESH";
		Laya3D.MATERIAL="MATERIAL";
		Laya3D.PBRMATERIAL="PBRMTL";
		Laya3D.TEXTURECUBE="TEXTURECUBE";
		Laya3D.TERRAIN="TERRAIN";
		Laya3D._debugPhasorSprite=null
		Laya3D.debugMode=false;
		__static(Laya3D,
		['_innerFirstLevelLoaderManager',function(){return this._innerFirstLevelLoaderManager=new LoaderManager();},'_innerSecondLevelLoaderManager',function(){return this._innerSecondLevelLoaderManager=new LoaderManager();},'_innerThirdLevelLoaderManager',function(){return this._innerThirdLevelLoaderManager=new LoaderManager();},'_innerFourthLevelLoaderManager',function(){return this._innerFourthLevelLoaderManager=new LoaderManager();}
		]);
		return Laya3D;
	})()


	/**
	*<code>Component3D</code> 类用于创建组件的父类。
	*/
	//class laya.d3.component.Component3D extends laya.events.EventDispatcher
	var Component3D=(function(_super){
		function Component3D(){
			this._id=0;
			this._enable=false;
			this._owner=null;
			Component3D.__super.call(this);
			this._id=Component3D._uniqueIDCounter;
			Component3D._uniqueIDCounter++;
		}

		__class(Component3D,'laya.d3.component.Component3D',_super);
		var __proto=Component3D.prototype;
		/**
		*@private
		*/
		__proto._onActive=function(){
			throw new Error("Component3D: must override it.");
		}

		/**
		*@private
		*/
		__proto._onInActive=function(){
			throw new Error("Component3D: must override it.");
		}

		/**
		*@private
		*/
		__proto._parse=function(rootNode,innerResouMap,data){}
		/**
		*@private
		*/
		__proto._initialize=function(owner){
			this._owner=owner;
			this._enable=true;
			(owner.activeInHierarchy)&& (this._onActive());
		}

		/**
		*@private
		*/
		__proto._uninitialize=function(){
			this._owner=null;
			(this.owner.activeInHierarchy)&& (this._onInActive());
		}

		/**
		*@private
		*/
		__proto._onOwnerActiveChange=function(active){
			if (active)
				this._onActive();
			else
			this._onInActive();
		}

		/**
		*@private
		*/
		__proto._cloneTo=function(dest){}
		/**
		*获取唯一标识ID。
		*@return 唯一标识ID。
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		/**
		*设置是否启用。
		*@param value 是否启动
		*/
		/**
		*获取是否启用。
		*@return 是否启动。
		*/
		__getset(0,__proto,'enable',function(){
			return this._enable;
			},function(value){
			if (this._enable!==value){
				this._enable=value;
				this.event("enablechanged",this._enable);
			}
		});

		/**
		*获取所属Sprite3D节点。
		*@return 所属Sprite3D节点。
		*/
		__getset(0,__proto,'owner',function(){
			return this._owner;
		});

		/**
		*获取是否为单实例组件。
		*@return 是否为单实例组件。
		*/
		__getset(0,__proto,'isSingleton',function(){
			return Component3D._isSingleton;
		});

		Component3D._isSingleton=true;
		Component3D._uniqueIDCounter=1;
		return Component3D;
	})(EventDispatcher)


	/**
	*@private
	*<code>Resource</code> 资源存取类。
	*/
	//class laya.resource.Resource extends laya.events.EventDispatcher
	var Resource=(function(_super){
		function Resource(){
			//this.__loaded=false;
			//this._id=0;
			//this._url=null;
			//this._memorySize=0;
			//this._released=false;
			//this._destroyed=false;
			//this._referenceCount=0;
			//this._group=null;
			//this._resourceManager=null;
			//this.lock=false;
			//this.name=null;
			Resource.__super.call(this);
			this._$1__id=++Resource._uniqueIDCounter;
			this.__loaded=true;
			this._destroyed=false;
			this._referenceCount=0;
			Resource._idResourcesMap[this.id]=this;
			this._released=true;
			this.lock=false;
			this._memorySize=0;
			(ResourceManager.currentResourceManager)&& (ResourceManager.currentResourceManager.addResource(this));
		}

		__class(Resource,'laya.resource.Resource',_super);
		var __proto=Resource.prototype;
		Laya.imps(__proto,{"laya.resource.ICreateResource":true,"laya.resource.IDestroy":true})
		/**
		*@private
		*/
		__proto._setUrl=function(url){
			if (this._url!==url){
				var resList;
				if (this._url){
					resList=Resource._urlResourcesMap[this._url];
					resList.splice(resList.indexOf(this),1);
					(resList.length===0)&& (delete Resource._urlResourcesMap[this._url]);
				}
				if (url){
					resList=Resource._urlResourcesMap[url];
					(resList)|| (Resource._urlResourcesMap[url]=resList=[]);
					resList.push(this);
				}
				this._url=url;
			}
		}

		/**
		*@private
		*/
		__proto._getGroup=function(){
			return this._group;
		}

		/**
		*@private
		*/
		__proto._setGroup=function(value){
			if (this._group!==value){
				var groupList;
				if (this._group){
					groupList=Resource._groupResourcesMap[this._group];
					groupList.splice(groupList.indexOf(this),1);
					(groupList.length===0)&& (delete Resource._groupResourcesMap[this._group]);
				}
				if (value){
					groupList=Resource._groupResourcesMap[value];
					(groupList)|| (Resource._groupResourcesMap[value]=groupList=[]);
					groupList.push(this);
				}
				this._group=value;
			}
		}

		/**
		*@private
		*/
		__proto._addReference=function(){
			this._referenceCount++;
		}

		/**
		*@private
		*/
		__proto._removeReference=function(){
			this._referenceCount--;
		}

		/**
		*@private
		*/
		__proto._clearReference=function(){
			this._referenceCount=0;
		}

		/**
		*@private
		*/
		__proto._completeLoad=function(){
			this.__loaded=true;
			this._released=false;
			this.event("loaded",this);
		}

		/**
		*@private
		*/
		__proto.recoverResource=function(){}
		/**
		*@private
		*/
		__proto.disposeResource=function(){}
		/**
		*@private
		*/
		__proto._activeResource=function(){
			this._released=false;
		}

		/**
		*释放资源。
		*@param force 是否强制释放。
		*@return 是否成功释放。
		*/
		__proto.releaseResource=function(force){
			(force===void 0)&& (force=false);
			if (!force && this.lock)
				return false;
			if (!this._released || force){
				this.disposeResource();
				this._released=true;
				return true;
				}else {
				return false;
			}
		}

		/**
		*@private
		*/
		__proto.onAsynLoaded=function(data,params){
			throw new Error("Resource: must override this function!");
		}

		/**
		*<p>彻底处理资源，处理后不能恢复。</p>
		*<p><b>注意：</b>会强制解锁清理。</p>
		*/
		__proto.destroy=function(){
			if (this._destroyed)
				return;
			if (this._resourceManager!==null)
				this._resourceManager.removeResource(this);
			this._destroyed=true;
			this.lock=false;
			this.releaseResource();
			delete Resource._idResourcesMap[this.id];
			var resList;
			if (this._url){
				resList=Resource._urlResourcesMap[this._url];
				if (resList){
					resList.splice(resList.indexOf(this),1);
					(resList.length===0)&& (delete Resource._urlResourcesMap[this.url]);
				}
				Loader.clearRes(this._url);
				(this.__loaded)||(RunDriver.cancelLoadByUrl(this._url));
			}
			if (this._group){
				resList=Resource._groupResourcesMap[this._group];
				resList.splice(resList.indexOf(this),1);
				(resList.length===0)&& (delete Resource._groupResourcesMap[this.url]);
			}
		}

		/**
		*@private
		*/
		/**
		*占用内存尺寸。
		*/
		__getset(0,__proto,'memorySize',function(){
			return this._memorySize;
			},function(value){
			var offsetValue=value-this._memorySize;
			this._memorySize=value;
			this.resourceManager && this.resourceManager.addSize(offsetValue);
		});

		/**
		*@private
		*/
		__getset(0,__proto,'_loaded',null,function(value){
			this.__loaded=value;
		});

		/**
		*获取是否已加载完成。
		*/
		__getset(0,__proto,'loaded',function(){
			return this.__loaded;
		});

		/**
		*获取唯一标识ID,通常用于识别。
		*/
		__getset(0,__proto,'id',function(){
			return this._$1__id;
		});

		/**
		*是否已释放。
		*/
		__getset(0,__proto,'released',function(){
			return this._released;
		});

		/**
		*获取资源的URL地址。
		*@return URL地址。
		*/
		__getset(0,__proto,'url',function(){
			return this._url;
		});

		/**
		*设置资源组名。
		*/
		/**
		*获取资源组名。
		*/
		__getset(0,__proto,'group',function(){
			return this._getGroup();
			},function(value){
			this._setGroup(value);
		});

		/**
		*是否已处理。
		*/
		__getset(0,__proto,'destroyed',function(){
			return this._destroyed;
		});

		/**
		*资源管理员。
		*/
		__getset(0,__proto,'resourceManager',function(){
			return this._resourceManager;
		});

		/**
		*获取资源的引用计数。
		*/
		__getset(0,__proto,'referenceCount',function(){
			return this._referenceCount;
		});

		Resource.getResourceByID=function(id){
			return Resource._idResourcesMap[id];
		}

		Resource.getResourceByURL=function(url,index){
			(index===void 0)&& (index=0);
			return Resource._urlResourcesMap[url][index];
		}

		Resource.destroyUnusedResources=function(group){
			var res;
			if (group){
				var resouList=Resource._groupResourcesMap[group];
				if (resouList){
					var tempResouList=resouList.slice();
					for (var i=0,n=tempResouList.length;i < n;i++){
						res=tempResouList[i];
						if (!res.lock && res._referenceCount===0)
							res.destroy();
					}
				}
				}else {
				for (var k in Resource._idResourcesMap){
					res=Resource._idResourcesMap[k];
					if (!res.lock && res._referenceCount===0)
						res.destroy();
				}
			}
		}

		Resource._uniqueIDCounter=0;
		Resource._idResourcesMap={};
		Resource._urlResourcesMap={};
		Resource._groupResourcesMap={};
		return Resource;
	})(EventDispatcher)


	/**
	*<code>Node</code> 类是可放在显示列表中的所有对象的基类。该显示列表管理 Laya 运行时中显示的所有对象。使用 Node 类排列显示列表中的显示对象。Node 对象可以有子显示对象。
	*/
	//class laya.display.Node extends laya.events.EventDispatcher
	var Node=(function(_super){
		function Node(){
			this._bits=0;
			this._parent=null;
			this.name="";
			this.destroyed=false;
			this.data=null;
			Node.__super.call(this);
			this._children=Node.ARRAY_EMPTY;
			this._$P=Node.PROP_EMPTY;
			this.timer=Laya.timer;
			this.createGLBuffer();
		}

		__class(Node,'laya.display.Node',_super);
		var __proto=Node.prototype;
		__proto.createGLBuffer=function(){}
		/**@private */
		__proto._setBit=function(type,value){
			if (type===0x01){
				var preValue=this._getBit(type);
				if (preValue !=value)this._updateDisplayedInstage();
			}
			if (value)this._bits |=type;
			else this._bits &=~type;
		}

		/**@private */
		__proto._getBit=function(type){
			return (this._bits & type)!=0;
		}

		/**@private */
		__proto._setUpNoticeChain=function(){
			if (this._getBit(0x01))this._setBitUp(0x01);
		}

		/**@private */
		__proto._setBitUp=function(type){
			var ele=this;
			ele._setBit(type,true);
			ele=ele._parent;
			while (ele){
				if (ele._getBit(type))return;
				ele._setBit(type,true);
				ele=ele._parent;
			}
		}

		/**@private */
		__proto._set$P=function(key,value){
			if (!this.destroyed){
				this._$P===Node.PROP_EMPTY && (this._$P={});
				this._$P[key]=value;
			}
			return value;
		}

		/**
		*<p>增加事件侦听器，以使侦听器能够接收事件通知。</p>
		*<p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args （可选）事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.on=function(type,caller,listener,args){
			if (type==="display" || type==="undisplay"){
				if (!this._getBit(0x01))this._setBitUp(0x01);
			}
			return this._createListener(type,caller,listener,args,false);
		}

		/**
		*<p>增加事件侦听器，以使侦听器能够接收事件通知，此侦听事件响应一次后则自动移除侦听。</p>
		*<p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args （可选）事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.once=function(type,caller,listener,args){
			if (type==="display" || type==="undisplay"){
				if (!this._getBit(0x01))this._setBitUp(0x01);
			}
			return this._createListener(type,caller,listener,args,true);
		}

		/**
		*<p>销毁此对象。destroy对象默认会把自己从父节点移除，并且清理自身引用关系，等待js自动垃圾回收机制回收。destroy后不能再使用。</p>
		*<p>destroy时会移除自身的事情监听，自身的timer监听，移除子对象及从父节点移除自己。</p>
		*@param destroyChild （可选）是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
		*/
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			this.destroyed=true;
			this._parent && this._parent.removeChild(this);
			if (this._children){
				if (destroyChild)this.destroyChildren();
				else this.removeChildren();
			}
			this._children=null;
			this.offAll();
			this.timer.clearAll(this);
		}

		/**
		*销毁所有子对象，不销毁自己本身。
		*/
		__proto.destroyChildren=function(){
			if (this._children){
				for (var i=this._children.length-1;i >-1;i--){
					this._children[i].destroy(true);
				}
			}
		}

		/**
		*添加子节点。
		*@param node 节点对象
		*@return 返回添加的节点
		*/
		__proto.addChild=function(node){
			if (!node || this.destroyed || node===this)return node;
			if ((node)._zOrder)this._setBit(0x02,true);
			if (node._parent===this){
				var index=this.getChildIndex(node);
				if (index!==this._children.length-1){
					this._children.splice(index,1);
					this._children.push(node);
					this._childChanged();
				}
				}else {
				node._parent && node._parent.removeChild(node);
				this._children===Node.ARRAY_EMPTY && (this._children=[]);
				this._children.push(node);
				node._setParent(this);
				this._childChanged();
			}
			return node;
		}

		/**
		*批量增加子节点
		*@param ...args 无数子节点。
		*/
		__proto.addChildren=function(__args){
			var args=arguments;
			var i=0,n=args.length;
			while (i < n){
				this.addChild(args[i++]);
			}
		}

		/**
		*添加子节点到指定的索引位置。
		*@param node 节点对象。
		*@param index 索引位置。
		*@return 返回添加的节点。
		*/
		__proto.addChildAt=function(node,index){
			if (!node || this.destroyed || node===this)return node;
			if ((node)._zOrder)this._setBit(0x02,true);
			if (index >=0 && index <=this._children.length){
				if (node._parent===this){
					var oldIndex=this.getChildIndex(node);
					this._children.splice(oldIndex,1);
					this._children.splice(index,0,node);
					this._childChanged();
					}else {
					node._parent && node._parent.removeChild(node);
					this._children===Node.ARRAY_EMPTY && (this._children=[]);
					this._children.splice(index,0,node);
					node._setParent(this);
				}
				return node;
				}else {
				throw new Error("appendChildAt:The index is out of bounds");
			}
		}

		/**
		*根据子节点对象，获取子节点的索引位置。
		*@param node 子节点。
		*@return 子节点所在的索引位置。
		*/
		__proto.getChildIndex=function(node){
			return this._children.indexOf(node);
		}

		/**
		*根据子节点的名字，获取子节点对象。
		*@param name 子节点的名字。
		*@return 节点对象。
		*/
		__proto.getChildByName=function(name){
			var nodes=this._children;
			if (nodes){
				for (var i=0,n=nodes.length;i < n;i++){
					var node=nodes[i];
					if (node.name===name)return node;
				}
			}
			return null;
		}

		/**
		*根据子节点的索引位置，获取子节点对象。
		*@param index 索引位置
		*@return 子节点
		*/
		__proto.getChildAt=function(index){
			return this._children[index] || null;
		}

		/**
		*设置子节点的索引位置。
		*@param node 子节点。
		*@param index 新的索引。
		*@return 返回子节点本身。
		*/
		__proto.setChildIndex=function(node,index){
			var childs=this._children;
			if (index < 0 || index >=childs.length){
				throw new Error("setChildIndex:The index is out of bounds.");
			};
			var oldIndex=this.getChildIndex(node);
			if (oldIndex < 0)throw new Error("setChildIndex:node is must child of this object.");
			childs.splice(oldIndex,1);
			childs.splice(index,0,node);
			this._childChanged();
			return node;
		}

		/**
		*@private
		*子节点发生改变。
		*@param child 子节点。
		*/
		__proto._childChanged=function(child){}
		/**
		*删除子节点。
		*@param node 子节点
		*@return 被删除的节点
		*/
		__proto.removeChild=function(node){
			if (!this._children)return node;
			var index=this._children.indexOf(node);
			return this.removeChildAt(index);
		}

		/**
		*从父容器删除自己，如已经被删除不会抛出异常。
		*@return 当前节点（ Node ）对象。
		*/
		__proto.removeSelf=function(){
			this._parent && this._parent.removeChild(this);
			return this;
		}

		/**
		*根据子节点名字删除对应的子节点对象，如果找不到不会抛出异常。
		*@param name 对象名字。
		*@return 查找到的节点（ Node ）对象。
		*/
		__proto.removeChildByName=function(name){
			var node=this.getChildByName(name);
			node && this.removeChild(node);
			return node;
		}

		/**
		*根据子节点索引位置，删除对应的子节点对象。
		*@param index 节点索引位置。
		*@return 被删除的节点。
		*/
		__proto.removeChildAt=function(index){
			var node=this.getChildAt(index);
			if (node){
				this._children.splice(index,1);
				node._setParent(null);
			}
			return node;
		}

		/**
		*删除指定索引区间的所有子对象。
		*@param beginIndex 开始索引。
		*@param endIndex 结束索引。
		*@return 当前节点对象。
		*/
		__proto.removeChildren=function(beginIndex,endIndex){
			(beginIndex===void 0)&& (beginIndex=0);
			(endIndex===void 0)&& (endIndex=0x7fffffff);
			if (this._children && this._children.length > 0){
				var childs=this._children;
				if (beginIndex===0 && endIndex >=childs.length-1){
					var arr=childs;
					this._children=Node.ARRAY_EMPTY;
					}else {
					arr=childs.splice(beginIndex,endIndex-beginIndex);
				}
				for (var i=0,n=arr.length;i < n;i++){
					arr[i]._setParent(null);
				}
			}
			return this;
		}

		/**
		*替换子节点。
		*@internal 将传入的新节点对象替换到已有子节点索引位置处。
		*@param newNode 新节点。
		*@param oldNode 老节点。
		*@return 返回新节点。
		*/
		__proto.replaceChild=function(newNode,oldNode){
			var index=this._children.indexOf(oldNode);
			if (index >-1){
				this._children.splice(index,1,newNode);
				oldNode._setParent(null);
				newNode._setParent(this);
				return newNode;
			}
			return null;
		}

		__proto._setParent=function(value){
			if (this._parent!==value){
				if (value){
					this._parent=value;
					this.event("added");
					if (this._getBit(0x01)){
						this._setUpNoticeChain();
						value.displayedInStage && this._displayChild(this,true);
					}
					value._childChanged(this);
					}else {
					this.event("removed");
					this._parent._childChanged();
					if (this._getBit(0x01))this._displayChild(this,false);
					this._parent=value;
				}
			}
		}

		/**@private */
		__proto._updateDisplayedInstage=function(){
			var ele;
			ele=this;
			var stage=Laya.stage;
			var displayedInStage=false;
			while (ele){
				if (ele._getBit(0x01)){
					displayedInStage=ele._getBit(0x08);
					break ;
				}
				if (ele===stage || ele._getBit(0x08)){
					displayedInStage=true;
					break ;
				}
				ele=ele._parent;
			}
			this._setBit(0x08,displayedInStage);
		}

		/**@private */
		__proto._setDisplay=function(value){
			if (this._getBit(0x08)!==value){
				this._setBit(0x08,value);
				if (value)this.event("display");
				else this.event("undisplay");
			}
		}

		/**
		*@private
		*设置指定节点对象是否可见(是否在渲染列表中)。
		*@param node 节点。
		*@param display 是否可见。
		*/
		__proto._displayChild=function(node,display){
			var childs=node._children;
			if (childs){
				for (var i=0,n=childs.length;i < n;i++){
					var child=childs[i];
					if (!child._getBit(0x01))continue ;
					if (child._children.length > 0){
						this._displayChild(child,display);
						}else {
						child._setDisplay(display);
					}
				}
			}
			node._setDisplay(display);
		}

		/**
		*当前容器是否包含指定的 <code>Node</code> 节点对象 。
		*@param node 指定的 <code>Node</code> 节点对象 。
		*@return 一个布尔值表示是否包含指定的 <code>Node</code> 节点对象 。
		*/
		__proto.contains=function(node){
			if (node===this)return true;
			while (node){
				if (node._parent===this)return true;
				node=node._parent;
			}
			return false;
		}

		/**
		*定时重复执行某函数。功能同Laya.timer.timerLoop()。
		*@param delay 间隔时间(单位毫秒)。
		*@param caller 执行域(this)。
		*@param method 结束时的回调方法。
		*@param args （可选）回调参数。
		*@param coverBefore （可选）是否覆盖之前的延迟执行，默认为true。
		*@param jumpFrame 时钟是否跳帧。基于时间的循环回调，单位时间间隔内，如能执行多次回调，出于性能考虑，引擎默认只执行一次，设置jumpFrame=true后，则回调会连续执行多次
		*/
		__proto.timerLoop=function(delay,caller,method,args,coverBefore,jumpFrame){
			(coverBefore===void 0)&& (coverBefore=true);
			(jumpFrame===void 0)&& (jumpFrame=false);
			this.timer.loop(delay,caller,method,args,coverBefore,jumpFrame);
		}

		/**
		*定时执行某函数一次。功能同Laya.timer.timerOnce()。
		*@param delay 延迟时间(单位毫秒)。
		*@param caller 执行域(this)。
		*@param method 结束时的回调方法。
		*@param args （可选）回调参数。
		*@param coverBefore （可选）是否覆盖之前的延迟执行，默认为true。
		*/
		__proto.timerOnce=function(delay,caller,method,args,coverBefore){
			(coverBefore===void 0)&& (coverBefore=true);
			this.timer._create(false,false,delay,caller,method,args,coverBefore);
		}

		/**
		*定时重复执行某函数(基于帧率)。功能同Laya.timer.frameLoop()。
		*@param delay 间隔几帧(单位为帧)。
		*@param caller 执行域(this)。
		*@param method 结束时的回调方法。
		*@param args （可选）回调参数。
		*@param coverBefore （可选）是否覆盖之前的延迟执行，默认为true。
		*/
		__proto.frameLoop=function(delay,caller,method,args,coverBefore){
			(coverBefore===void 0)&& (coverBefore=true);
			this.timer._create(true,true,delay,caller,method,args,coverBefore);
		}

		/**
		*定时执行一次某函数(基于帧率)。功能同Laya.timer.frameOnce()。
		*@param delay 延迟几帧(单位为帧)。
		*@param caller 执行域(this)
		*@param method 结束时的回调方法
		*@param args （可选）回调参数
		*@param coverBefore （可选）是否覆盖之前的延迟执行，默认为true
		*/
		__proto.frameOnce=function(delay,caller,method,args,coverBefore){
			(coverBefore===void 0)&& (coverBefore=true);
			this.timer._create(true,false,delay,caller,method,args,coverBefore);
		}

		/**
		*清理定时器。功能同Laya.timer.clearTimer()。
		*@param caller 执行域(this)。
		*@param method 结束时的回调方法。
		*/
		__proto.clearTimer=function(caller,method){
			this.timer.clear(caller,method);
		}

		/**
		*子对象数量。
		*/
		__getset(0,__proto,'numChildren',function(){
			return this._children.length;
		});

		/**父节点。*/
		__getset(0,__proto,'parent',function(){
			return this._parent;
		});

		/**表示是否在显示列表中显示。*/
		__getset(0,__proto,'displayedInStage',function(){
			if (this._getBit(0x01))return this._getBit(0x08);
			this._setBitUp(0x01);
			return this._getBit(0x08);
		});

		Node.ARRAY_EMPTY=[];
		Node.PROP_EMPTY={};
		return Node;
	})(EventDispatcher)


	/**
	*@private
	*使用Audio标签播放声音
	*/
	//class laya.media.h5audio.AudioSound extends laya.events.EventDispatcher
	var AudioSound=(function(_super){
		function AudioSound(){
			this.url=null;
			this.audio=null;
			this.loaded=false;
			AudioSound.__super.call(this);
		}

		__class(AudioSound,'laya.media.h5audio.AudioSound',_super);
		var __proto=AudioSound.prototype;
		/**
		*释放声音
		*/
		__proto.dispose=function(){
			var ad=AudioSound._audioCache[this.url];
			if (ad){
				ad.src="";
				delete AudioSound._audioCache[this.url];
			}
		}

		/**
		*加载声音
		*@param url
		*
		*/
		__proto.load=function(url){
			url=URL.formatURL(url);
			this.url=url;
			var ad=AudioSound._audioCache[url];
			if (ad && ad.readyState >=2){
				this.event("complete");
				return;
			}
			if (!ad){
				ad=Browser.createElement("audio");
				ad.src=url;
				AudioSound._audioCache[url]=ad;
			}
			ad.addEventListener("canplaythrough",onLoaded);
			ad.addEventListener("error",onErr);
			var me=this;
			function onLoaded (){
				offs();
				me.loaded=true;
				me.event("complete");
			}
			function onErr (){
				ad.load=null;
				offs();
				me.event("error");
			}
			function offs (){
				ad.removeEventListener("canplaythrough",onLoaded);
				ad.removeEventListener("error",onErr);
			}
			this.audio=ad;
			if (ad.load)ad.load();
			else onErr();
		}

		/**
		*播放声音
		*@param startTime 起始时间
		*@param loops 循环次数
		*/
		__proto.play=function(startTime,loops){
			(startTime===void 0)&& (startTime=0);
			(loops===void 0)&& (loops=0);
			if (!this.url)return null;
			var ad;
			ad=AudioSound._audioCache[this.url];
			if (!ad)return null;
			var tAd;
			tAd=Pool.getItem("audio:"+this.url);
			if (Render.isConchApp){
				if (!tAd){
					tAd=Browser.createElement("audio");
					tAd.src=ad.src;
				}
				}else {
				tAd=tAd ? tAd :ad.cloneNode(true);
			};
			var channel=new AudioSoundChannel(tAd);
			channel.url=this.url;
			channel.loops=loops;
			channel.startTime=startTime;
			channel.play();
			SoundManager.addChannel(channel);
			return channel;
		}

		/**
		*获取总时间。
		*/
		__getset(0,__proto,'duration',function(){
			var ad=AudioSound._audioCache[this.url];
			if (!ad)return 0;
			return ad.duration;
		});

		AudioSound._audioCache={};
		return AudioSound;
	})(EventDispatcher)


	/**
	*<p> <code>SoundChannel</code> 用来控制程序中的声音。每个声音均分配给一个声道，而且应用程序可以具有混合在一起的多个声道。</p>
	*<p> <code>SoundChannel</code> 类包含控制声音的播放、暂停、停止、音量的方法，以及获取声音的播放状态、总时间、当前播放时间、总循环次数、播放地址等信息的方法。</p>
	*/
	//class laya.media.SoundChannel extends laya.events.EventDispatcher
	var SoundChannel=(function(_super){
		function SoundChannel(){
			this.url=null;
			this.loops=0;
			this.startTime=NaN;
			this.isStopped=false;
			this.completeHandler=null;
			SoundChannel.__super.call(this);
		}

		__class(SoundChannel,'laya.media.SoundChannel',_super);
		var __proto=SoundChannel.prototype;
		/**
		*播放声音。
		*/
		__proto.play=function(){}
		/**
		*停止播放。
		*/
		__proto.stop=function(){}
		/**
		*暂停播放。
		*/
		__proto.pause=function(){}
		/**
		*继续播放。
		*/
		__proto.resume=function(){}
		/**
		*private
		*/
		__proto.__runComplete=function(handler){
			if (handler){
				handler.run();
			}
		}

		/**
		*音量范围从 0（静音）至 1（最大音量）。
		*/
		__getset(0,__proto,'volume',function(){
			return 1;
			},function(v){
		});

		/**
		*获取当前播放时间，单位是秒。
		*/
		__getset(0,__proto,'position',function(){
			return 0;
		});

		/**
		*获取总时间，单位是秒。
		*/
		__getset(0,__proto,'duration',function(){
			return 0;
		});

		return SoundChannel;
	})(EventDispatcher)


	/**
	*<code>Sound</code> 类是用来播放控制声音的类。
	*引擎默认有两套声音方案，优先使用WebAudio播放声音，如果WebAudio不可用，则用H5Audio播放，H5Audio在部分机器上有兼容问题（比如不能混音，播放有延迟等）。
	*/
	//class laya.media.Sound extends laya.events.EventDispatcher
	var Sound=(function(_super){
		function Sound(){Sound.__super.call(this);;
		};

		__class(Sound,'laya.media.Sound',_super);
		var __proto=Sound.prototype;
		/**
		*加载声音。
		*@param url 地址。
		*/
		__proto.load=function(url){}
		/**
		*播放声音。
		*@param startTime 开始时间,单位秒
		*@param loops 循环次数,0表示一直循环
		*@return 声道 SoundChannel 对象。
		*/
		__proto.play=function(startTime,loops){
			(startTime===void 0)&& (startTime=0);
			(loops===void 0)&& (loops=0);
			return null;
		}

		/**
		*释放声音资源。
		*/
		__proto.dispose=function(){}
		/**
		*获取总时间。
		*/
		__getset(0,__proto,'duration',function(){
			return 0;
		});

		return Sound;
	})(EventDispatcher)


	/**
	*@private
	*web audio api方式播放声音
	*/
	//class laya.media.webaudio.WebAudioSound extends laya.events.EventDispatcher
	var WebAudioSound=(function(_super){
		function WebAudioSound(){
			this.url=null;
			this.loaded=false;
			this.data=null;
			this.audioBuffer=null;
			this.__toPlays=null;
			WebAudioSound.__super.call(this);
		}

		__class(WebAudioSound,'laya.media.webaudio.WebAudioSound',_super);
		var __proto=WebAudioSound.prototype;
		/**
		*加载声音
		*/
		__proto.load=function(url){
			var me=this;
			url=URL.formatURL(url);
			this.url=url;
			this.audioBuffer=WebAudioSound._dataCache[url];
			if (this.audioBuffer){
				this._loaded(this.audioBuffer);
				return;
			}
			WebAudioSound.e.on("loaded:"+url,this,this._loaded);
			WebAudioSound.e.on("err:"+url,this,this._err);
			if (WebAudioSound.__loadingSound[url])return;
			WebAudioSound.__loadingSound[url]=true;
			var request=new Browser.window.XMLHttpRequest();
			request.open("GET",url,true);
			request.responseType="arraybuffer";
			request.onload=function (){
				me.data=request.response;
				WebAudioSound.buffs.push({"buffer":me.data,"url":me.url});
				WebAudioSound.decode();
			}
			request.onerror=function (e){
				me._err();
			}
			request.send();
		}

		__proto._err=function(){
			this._removeLoadEvents();
			WebAudioSound.__loadingSound[this.url]=false;
			this.event("error");
		}

		__proto._loaded=function(audioBuffer){
			this._removeLoadEvents();
			this.audioBuffer=audioBuffer;
			WebAudioSound._dataCache[this.url]=this.audioBuffer;
			this.loaded=true;
			this.event("complete");
		}

		__proto._removeLoadEvents=function(){
			WebAudioSound.e.off("loaded:"+this.url,this,this._loaded);
			WebAudioSound.e.off("err:"+this.url,this,this._err);
		}

		__proto.__playAfterLoaded=function(){
			if (!this.__toPlays)return;
			var i=0,len=0;
			var toPlays;
			toPlays=this.__toPlays;
			len=toPlays.length;
			var tParams;
			for (i=0;i < len;i++){
				tParams=toPlays[i];
				if (tParams[2] && !(tParams [2]).isStopped){
					this.play(tParams[0],tParams[1],tParams[2]);
				}
			}
			this.__toPlays.length=0;
		}

		/**
		*播放声音
		*@param startTime 起始时间
		*@param loops 循环次数
		*/
		__proto.play=function(startTime,loops,channel){
			(startTime===void 0)&& (startTime=0);
			(loops===void 0)&& (loops=0);
			channel=channel ? channel :new WebAudioSoundChannel();
			if (!this.audioBuffer){
				if (this.url){
					if (!this.__toPlays)this.__toPlays=[];
					this.__toPlays.push([startTime,loops,channel]);
					this.once("complete",this,this.__playAfterLoaded);
					this.load(this.url);
				}
			}
			channel.url=this.url;
			channel.loops=loops;
			channel["audioBuffer"]=this.audioBuffer;
			channel.startTime=startTime;
			channel.play();
			SoundManager.addChannel(channel);
			return channel;
		}

		__proto.dispose=function(){
			delete WebAudioSound._dataCache[this.url];
			delete WebAudioSound.__loadingSound[this.url];
		}

		__getset(0,__proto,'duration',function(){
			if (this.audioBuffer){
				return this.audioBuffer.duration;
			}
			return 0;
		});

		WebAudioSound.decode=function(){
			if (WebAudioSound.buffs.length <=0 || WebAudioSound.isDecoding){
				return;
			}
			WebAudioSound.isDecoding=true;
			WebAudioSound.tInfo=WebAudioSound.buffs.shift();
			WebAudioSound.ctx.decodeAudioData(WebAudioSound.tInfo["buffer"],WebAudioSound._done,WebAudioSound._fail);
		}

		WebAudioSound._done=function(audioBuffer){
			WebAudioSound.e.event("loaded:"+WebAudioSound.tInfo.url,audioBuffer);
			WebAudioSound.isDecoding=false;
			WebAudioSound.decode();
		}

		WebAudioSound._fail=function(){
			WebAudioSound.e.event("err:"+WebAudioSound.tInfo.url,null);
			WebAudioSound.isDecoding=false;
			WebAudioSound.decode();
		}

		WebAudioSound._playEmptySound=function(){
			if (WebAudioSound.ctx==null)return;
			var source=WebAudioSound.ctx.createBufferSource();
			source.buffer=WebAudioSound._miniBuffer;
			source.connect(WebAudioSound.ctx.destination);
			source.start(0,0,0);
		}

		WebAudioSound._unlock=function(){
			if (WebAudioSound._unlocked)return;
			WebAudioSound._playEmptySound();
			if (WebAudioSound.ctx.state==="running"){
				Browser.document.removeEventListener("mousedown",WebAudioSound._unlock,true);
				Browser.document.removeEventListener("touchend",WebAudioSound._unlock,true);
				WebAudioSound._unlocked=true;
			}
		}

		WebAudioSound.initWebAudio=function(){
			if (WebAudioSound.ctx.state!=="running"){
				WebAudioSound._unlock();
				Browser.document.addEventListener("mousedown",WebAudioSound._unlock,true);
				Browser.document.addEventListener("touchend",WebAudioSound._unlock,true);
			}
		}

		WebAudioSound._dataCache={};
		WebAudioSound.buffs=[];
		WebAudioSound.isDecoding=false;
		WebAudioSound._unlocked=false;
		WebAudioSound.tInfo=null
		WebAudioSound.__loadingSound={};
		__static(WebAudioSound,
		['window',function(){return this.window=Browser.window;},'webAudioEnabled',function(){return this.webAudioEnabled=WebAudioSound.window["AudioContext"] || WebAudioSound.window["webkitAudioContext"] || WebAudioSound.window["mozAudioContext"];},'ctx',function(){return this.ctx=WebAudioSound.webAudioEnabled ? new (WebAudioSound.window["AudioContext"] || WebAudioSound.window["webkitAudioContext"] || WebAudioSound.window["mozAudioContext"])():undefined;},'_miniBuffer',function(){return this._miniBuffer=WebAudioSound.ctx.createBuffer(1,1,22050);},'e',function(){return this.e=new EventDispatcher();}
		]);
		return WebAudioSound;
	})(EventDispatcher)


	/**
	*<p> <code>HttpRequest</code> 通过封装 HTML <code>XMLHttpRequest</code> 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。 <code>HttpRequest</code> 只提供以异步的形式返回 Web 服务器的响应，并且能够以文本或者二进制的形式返回内容。</p>
	*<p><b>注意：</b>建议每次请求都使用新的 <code>HttpRequest</code> 对象，因为每次调用该对象的send方法时，都会清空之前设置的数据，并重置 HTTP 请求的状态，这会导致之前还未返回响应的请求被重置，从而得不到之前请求的响应结果。
	*/
	//class laya.net.HttpRequest extends laya.events.EventDispatcher
	var HttpRequest=(function(_super){
		function HttpRequest(){
			this._responseType=null;
			this._data=null;
			HttpRequest.__super.call(this);
			this._http=new Browser.window.XMLHttpRequest();
		}

		__class(HttpRequest,'laya.net.HttpRequest',_super);
		var __proto=HttpRequest.prototype;
		/**
		*发送 HTTP 请求。
		*@param url 请求的地址。大多数浏览器实施了一个同源安全策略，并且要求这个 URL 与包含脚本的文本具有相同的主机名和端口。
		*@param data (default=null)发送的数据。
		*@param method (default="get")用于请求的 HTTP 方法。值包括 "get"、"post"、"head"。
		*@param responseType (default="text")Web 服务器的响应类型，可设置为 "text"、"json"、"xml"、"arraybuffer"。
		*@param headers (default=null)HTTP 请求的头部信息。参数形如key-value数组：key是头部的名称，不应该包括空白、冒号或换行；value是头部的值，不应该包括换行。比如["Content-Type","application/json"]。
		*/
		__proto.send=function(url,data,method,responseType,headers){
			(method===void 0)&& (method="get");
			(responseType===void 0)&& (responseType="text");
			this._responseType=responseType;
			this._data=null;
			var _this=this;
			var http=this._http;
			http.open(method,url,true);
			if (headers){
				for (var i=0;i < headers.length;i++){
					http.setRequestHeader(headers[i++],headers[i]);
				}
				}else if (!Render.isConchApp){
				if (!data || (typeof data=='string'))http.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
				else http.setRequestHeader("Content-Type","application/json");
			}
			http.responseType=responseType!=="arraybuffer" ? "text" :"arraybuffer";
			http.onerror=function (e){
				_this._onError(e);
			}
			http.onabort=function (e){
				_this._onAbort(e);
			}
			http.onprogress=function (e){
				_this._onProgress(e);
			}
			http.onload=function (e){
				_this._onLoad(e);
			}
			http.send(data);
		}

		/**
		*@private
		*请求进度的侦听处理函数。
		*@param e 事件对象。
		*/
		__proto._onProgress=function(e){
			if (e && e.lengthComputable)this.event("progress",e.loaded / e.total);
		}

		/**
		*@private
		*请求中断的侦听处理函数。
		*@param e 事件对象。
		*/
		__proto._onAbort=function(e){
			this.error("Request was aborted by user");
		}

		/**
		*@private
		*请求出错侦的听处理函数。
		*@param e 事件对象。
		*/
		__proto._onError=function(e){
			this.error("Request failed Status:"+this._http.status+" text:"+this._http.statusText);
		}

		/**
		*@private
		*请求消息返回的侦听处理函数。
		*@param e 事件对象。
		*/
		__proto._onLoad=function(e){
			var http=this._http;
			var status=http.status!==undefined ? http.status :200;
			if (status===200 || status===204 || status===0){
				this.complete();
				}else {
				this.error("["+http.status+"]"+http.statusText+":"+http.responseURL);
			}
		}

		/**
		*@private
		*请求错误的处理函数。
		*@param message 错误信息。
		*/
		__proto.error=function(message){
			this.clear();
			this.event("error",message);
		}

		/**
		*@private
		*请求成功完成的处理函数。
		*/
		__proto.complete=function(){
			this.clear();
			var flag=true;
			try {
				if (this._responseType==="json"){
					this._data=JSON.parse(this._http.responseText);
					}else if (this._responseType==="xml"){
					this._data=Utils.parseXMLFromString(this._http.responseText);
					}else {
					this._data=this._http.response || this._http.responseText;
				}
				}catch (e){
				flag=false;
				this.error(e.message);
			}
			flag && this.event("complete",(this._data instanceof Array)? [this._data] :this._data);
		}

		/**
		*@private
		*清除当前请求。
		*/
		__proto.clear=function(){
			var http=this._http;
			http.onerror=http.onabort=http.onprogress=http.onload=null;
		}

		/**请求的地址。*/
		__getset(0,__proto,'url',function(){
			return this._http.responseURL;
		});

		/**
		*本对象所封装的原生 XMLHttpRequest 引用。
		*/
		__getset(0,__proto,'http',function(){
			return this._http;
		});

		/**返回的数据。*/
		__getset(0,__proto,'data',function(){
			return this._data;
		});

		return HttpRequest;
	})(EventDispatcher)


	/**
	*<code>Loader</code> 类可用来加载文本、JSON、XML、二进制、图像等资源。
	*/
	//class laya.net.Loader extends laya.events.EventDispatcher
	var Loader=(function(_super){
		function Loader(){
			this._data=null;
			this._class=null;
			this._url=null;
			this._type=null;
			this._cache=false;
			this._http=null;
			this._useWorkerLoader=false;
			this._customParse=false;
			Loader.__super.call(this);
		}

		__class(Loader,'laya.net.Loader',_super);
		var __proto=Loader.prototype;
		/**
		*加载资源。加载错误会派发 Event.ERROR 事件，参数为错误信息。
		*@param url 资源地址。
		*@param type (default=null)资源类型。可选值为：Loader.TEXT、Loader.JSON、Loader.XML、Loader.BUFFER、Loader.IMAGE、Loader.SOUND、Loader.ATLAS、Loader.FONT。如果为null，则根据文件后缀分析类型。
		*@param cache (default=true)是否缓存数据。
		*@param group (default=null)分组名称。
		*@param ignoreCache (default=false)是否忽略缓存，强制重新加载。
		*@param useWorkerLoader(default=false)是否使用worker加载（只针对IMAGE类型和ATLAS类型，并且浏览器支持的情况下生效）
		*/
		__proto.load=function(url,type,cache,group,ignoreCache,useWorkerLoader){
			(cache===void 0)&& (cache=true);
			(ignoreCache===void 0)&& (ignoreCache=false);
			(useWorkerLoader===void 0)&& (useWorkerLoader=false);
			this._url=url;
			if (url.indexOf("data:image")===0)type="image";
			else url=URL.formatURL(url);
			this._type=type || (type=this.getTypeFromUrl(url));
			this._cache=cache;
			this._useWorkerLoader=useWorkerLoader;
			this._data=null;
			if (useWorkerLoader)WorkerLoader.enableWorkerLoader();
			if (!ignoreCache && Loader.loadedMap[url]){
				this._data=Loader.loadedMap[url];
				this.event("progress",1);
				this.event("complete",this._data);
				return;
			}
			if (group)Loader.setGroup(url,group);
			if (Loader.parserMap[type] !=null){
				this._customParse=true;
				if (((Loader.parserMap[type])instanceof laya.utils.Handler ))Loader.parserMap[type].runWith(this);
				else Loader.parserMap[type].call(null,this);
				return;
			}
			if (type==="image" || type==="htmlimage" || type==="nativeimage")return this._loadImage(url);
			if (type==="sound")return this._loadSound(url);
			if (type==="atlas"){
				if (Loader._preLoadedAtlasMap[url]){
					this.onLoaded(Loader._preLoadedAtlasMap[url]);
					delete Loader._preLoadedAtlasMap[url];
					return;
				}
			}
			if (!this._http){
				this._http=new HttpRequest();
				this._http.on("progress",this,this.onProgress);
				this._http.on("error",this,this.onError);
				this._http.on("complete",this,this.onLoaded);
			};
			var contentType;
			switch (type){
				case "atlas":
					contentType="json";
					break ;
				case "font":
					contentType="xml";
					break ;
				case "pkm":
					contentType="arraybuffer";
					break
				default :
					contentType=type;
				}
			this._http.send(url,null,"get",contentType);
		}

		/**
		*获取指定资源地址的数据类型。
		*@param url 资源地址。
		*@return 数据类型。
		*/
		__proto.getTypeFromUrl=function(url){
			var type=Utils.getFileExtension(url);
			if (type)return Loader.typeMap[type];
			console.warn("Not recognize the resources suffix",url);
			return "text";
		}

		/**
		*@private
		*加载图片资源。
		*@param url 资源地址。
		*/
		__proto._loadImage=function(url){
			var _$this=this;
			url=URL.formatURL(url);
			var _this=this;
			var image;
			function clear (){
				image.onload=null;
				image.onerror=null;
				delete Loader._imgCache[url]
			};
			var onload=function (){
				(_$this._type==="nativeimage")||(image.setImageSource(imageSource,true));
				clear();
				_this.onLoaded(image);
			};
			var onerror=function (){
				clear();
				_this.event("error","Load image failed");
			}
			if (this._type==="nativeimage"){
				image=new Browser.window.Image();
				image.crossOrigin="";
				image.onload=onload;
				image.onerror=onerror;
				image.src=url;
				Loader._imgCache[url]=image;
				}else {
				image=HTMLImage.create(url);
				var imageSource=new Browser.window.Image();
				imageSource.crossOrigin="";
				imageSource.onload=onload;
				imageSource.onerror=onerror;
				imageSource.src=url;
				image._setUrl(url);
				Loader._imgCache[url]=image;
			}
		}

		/**
		*@private
		*加载声音资源。
		*@param url 资源地址。
		*/
		__proto._loadSound=function(url){
			var sound=(new SoundManager._soundClass());
			var _this=this;
			sound.on("complete",this,soundOnload);
			sound.on("error",this,soundOnErr);
			sound.load(url);
			function soundOnload (){
				clear();
				_this.onLoaded(sound);
			}
			function soundOnErr (){
				clear();
				sound.dispose();
				_this.event("error","Load sound failed");
			}
			function clear (){
				sound.offAll();
			}
		}

		/**@private */
		__proto.onProgress=function(value){
			if (this._type==="atlas")this.event("progress",value *0.3);
			else this.event("progress",value);
		}

		/**@private */
		__proto.onError=function(message){
			this.event("error",message);
		}

		/**
		*资源加载完成的处理函数。
		*@param data 数据。
		*/
		__proto.onLoaded=function(data){
			var type=this._type;
			if (type==="image"){
				var tex=new Texture(data);
				tex.url=this._url;
				this.complete(tex);
				}else if (type==="sound" || type==="htmlimage" || type==="nativeimage"){
				this.complete(data);
				}else if (type==="atlas"){
				if (!data.url && !data._setContext){
					if (!this._data){
						this._data=data;
						if (data.meta && data.meta.image){
							var toloadPics=data.meta.image.split(",");
							var split=this._url.indexOf("/")>=0 ? "/" :"\\";
							var idx=this._url.lastIndexOf(split);
							var folderPath=idx >=0 ? this._url.substr(0,idx+1):"";
							for (var i=0,len=toloadPics.length;i < len;i++){
								toloadPics[i]=folderPath+toloadPics[i];
							}
							}else {
							toloadPics=[this._url.replace(".json",".png")];
						}
						toloadPics.reverse();
						data.toLoads=toloadPics;
						data.pics=[];
					}
					this.event("progress",0.3+1 / toloadPics.length *0.6);
					return this._loadImage(toloadPics.pop());
					}else {
					this._data.pics.push(data);
					if (this._data.toLoads.length > 0){
						this.event("progress",0.3+1 / this._data.toLoads.length *0.6);
						return this._loadImage(this._data.toLoads.pop());
					};
					var frames=this._data.frames;
					var cleanUrl=this._url.split("?")[0];
					var directory=(this._data.meta && this._data.meta.prefix)? this._data.meta.prefix :cleanUrl.substring(0,cleanUrl.lastIndexOf("."))+"/";
					var pics=this._data.pics;
					var atlasURL=URL.formatURL(this._url);
					var map=Loader.atlasMap[atlasURL] || (Loader.atlasMap[atlasURL]=[]);
					map.dir=directory;
					for (var name in frames){
						var obj=frames[name];
						var tPic=pics[obj.frame.idx ? obj.frame.idx :0];
						var url=URL.formatURL(directory+name);
						Loader.cacheRes(url,Texture.create(tPic,obj.frame.x,obj.frame.y,obj.frame.w,obj.frame.h,obj.spriteSourceSize.x,obj.spriteSourceSize.y,obj.sourceSize.w,obj.sourceSize.h));
						Loader.loadedMap[url].url=url;
						map.push(url);
					}
					delete this._data.pics;
					this.complete(this._data);
				}
				}else if (type==="font"){
				if (!data.src){
					this._data=data;
					this.event("progress",0.5);
					return this._loadImage(this._url.replace(".fnt",".png"));
					}else {
					var bFont=new BitmapFont();
					bFont.parseFont(this._data,data);
					var tArr=this._url.split(".fnt")[0].split("/");
					var fontName=tArr[tArr.length-1];
					Text.registerBitmapFont(fontName,bFont);
					this._data=bFont;
					this.complete(this._data);
				}
				}else if (type=="pkm"){
				var image=HTMLImage.create(data,this._url);
				var tex1=new Texture(image);
				tex1.url=this._url;
				this.complete(tex1);
				}else {
				this.complete(data);
			}
		}

		/**
		*加载完成。
		*@param data 加载的数据。
		*/
		__proto.complete=function(data){
			this._data=data;
			if (this._customParse){
				this.event("loaded",(data instanceof Array)? [data] :data);
				}else {
				Loader._loaders.push(this);
				if (!Loader._isWorking)Loader.checkNext();
			}
		}

		/**
		*结束加载，处理是否缓存及派发完成事件 <code>Event.COMPLETE</code> 。
		*@param content 加载后的数据
		*/
		__proto.endLoad=function(content){
			content && (this._data=content);
			if (this._cache)Loader.cacheRes(this._url,this._data);
			this._customParse=false;
			this.event("progress",1);
			this.event("complete",(this.data instanceof Array)? [this.data] :this.data);
		}

		/**加载地址。*/
		__getset(0,__proto,'url',function(){
			return this._url;
		});

		/**返回的数据。*/
		__getset(0,__proto,'data',function(){
			return this._data;
		});

		/**是否缓存。*/
		__getset(0,__proto,'cache',function(){
			return this._cache;
		});

		/**加载类型。*/
		__getset(0,__proto,'type',function(){
			return this._type;
		});

		Loader.checkNext=function(){
			Loader._isWorking=true;
			var startTimer=Browser.now();
			var thisTimer=startTimer;
			while (Loader._startIndex < Loader._loaders.length){
				thisTimer=Browser.now();
				Loader._loaders[Loader._startIndex].endLoad();
				Loader._startIndex++;
				if (Browser.now()-startTimer > Loader.maxTimeOut){
					console.warn("loader callback cost a long time:"+(Browser.now()-startTimer)+" url="+Loader._loaders[Loader._startIndex-1].url);
					Laya.timer.frameOnce(1,null,Loader.checkNext);
					return;
				}
			}
			Loader._loaders.length=0;
			Loader._startIndex=0;
			Loader._isWorking=false;
		}

		Loader.clearRes=function(url,forceDispose){
			(forceDispose===void 0)&& (forceDispose=false);
			url=URL.formatURL(url);
			var arr=Loader.getAtlas(url);
			if (arr){
				for (var i=0,n=arr.length;i < n;i++){
					var resUrl=arr[i];
					var tex=Loader.getRes(resUrl);
					if (tex)tex.destroy(forceDispose);
					delete Loader.loadedMap[resUrl];
				}
				arr.length=0;
				delete Loader.atlasMap[url];
				delete Loader.loadedMap[url];
				}else {
				var res=Loader.loadedMap[url];
				if (res){
					if ((res instanceof laya.resource.Texture )&& res.bitmap)(res).destroy(forceDispose);
					delete Loader.loadedMap[url];
				}
			}
		}

		Loader.setAtlasConfigs=function(url,config){
			Loader._preLoadedAtlasMap[URL.formatURL(url)]=config;
		}

		Loader.getRes=function(url){
			return Loader.loadedMap[URL.formatURL(url)];
		}

		Loader.getAtlas=function(url){
			return Loader.atlasMap[URL.formatURL(url)];
		}

		Loader.cacheRes=function(url,data){
			url=URL.formatURL(url);
			if (Loader.loadedMap[url] !=null){
				console.warn("Resources already exist,is repeated loading:",url);
				}else {
				Loader.loadedMap[url]=data;
			}
		}

		Loader.setGroup=function(url,group){
			if (!Loader.groupMap[group])Loader.groupMap[group]=[];
			Loader.groupMap[group].push(url);
		}

		Loader.clearResByGroup=function(group){
			if (!Loader.groupMap[group])return;
			var arr=Loader.groupMap[group],i=0,len=arr.length;
			for (i=0;i < len;i++){
				Loader.clearRes(arr[i]);
			}
			arr.length=0;
		}

		Loader.TEXT="text";
		Loader.JSON="json";
		Loader.XML="xml";
		Loader.BUFFER="arraybuffer";
		Loader.IMAGE="image";
		Loader.SOUND="sound";
		Loader.ATLAS="atlas";
		Loader.FONT="font";
		Loader.PKM="pkm";
		Loader.typeMap={"png":"image","jpg":"image","jpeg":"image","txt":"text","json":"json","xml":"xml","als":"atlas","atlas":"atlas","mp3":"sound","ogg":"sound","wav":"sound","part":"json","fnt":"font","pkm":"pkm"};
		Loader.parserMap={};
		Loader.maxTimeOut=100;
		Loader.groupMap={};
		Loader.loadedMap={};
		Loader.atlasMap={};
		Loader._preLoadedAtlasMap={};
		Loader._imgCache={};
		Loader._loaders=[];
		Loader._isWorking=false;
		Loader._startIndex=0;
		return Loader;
	})(EventDispatcher)


	/**
	*<p> <code>LoaderManager</code> 类用于用于批量加载资源。此类是单例，不要手动实例化此类，请通过Laya.loader访问。</p>
	*<p>全部队列加载完成，会派发 Event.COMPLETE 事件；如果队列中任意一个加载失败，会派发 Event.ERROR 事件，事件回调参数值为加载出错的资源地址。</p>
	*<p> <code>LoaderManager</code> 类提供了以下几种功能：<br/>
	*多线程：默认5个加载线程，可以通过maxLoader属性修改线程数量；<br/>
	*多优先级：有0-4共5个优先级，优先级高的优先加载。0最高，4最低；<br/>
	*重复过滤：自动过滤重复加载（不会有多个相同地址的资源同时加载）以及复用缓存资源，防止重复加载；<br/>
	*错误重试：资源加载失败后，会重试加载（以最低优先级插入加载队列），retryNum设定加载失败后重试次数，retryDelay设定加载重试的时间间隔。</p>
	*@see laya.net.Loader
	*/
	//class laya.net.LoaderManager extends laya.events.EventDispatcher
	var LoaderManager=(function(_super){
		var ResInfo;
		function LoaderManager(){
			this.retryNum=1;
			this.retryDelay=0;
			this.maxLoader=5;
			this._loaders=[];
			this._loaderCount=0;
			this._resInfos=[];
			this._infoPool=[];
			this._maxPriority=5;
			this._failRes={};
			LoaderManager.__super.call(this);
			for (var i=0;i < this._maxPriority;i++)this._resInfos[i]=[];
		}

		__class(LoaderManager,'laya.net.LoaderManager',_super);
		var __proto=LoaderManager.prototype;
		/**
		*<p>根据clas类型创建一个未初始化资源的对象，随后进行异步加载，资源加载完成后，初始化对象的资源，并通过此对象派发 Event.LOADED 事件，事件回调参数值为此对象本身。套嵌资源的子资源会保留资源路径"?"后的部分。</p>
		*<p>如果url为数组，返回true；否则返回指定的资源类对象，可以通过侦听此对象的 Event.LOADED 事件来判断资源是否已经加载完毕。</p>
		*<p><b>注意：</b>cache参数只能对文件后缀为atlas的资源进行缓存控制，其他资源会忽略缓存，强制重新加载。</p>
		*@param url 资源地址或者数组。如果url和clas同时指定了资源类型，优先使用url指定的资源类型。参数形如：[{url:xx,clas:xx,priority:xx,params:xx},{url:xx,clas:xx,priority:xx,params:xx}]。
		*@param complete 加载结束回调。根据url类型不同分为2种情况：1. url为String类型，也就是单个资源地址，如果加载成功，则回调参数值为加载完成的资源，否则为null；2. url为数组类型，指定了一组要加载的资源，如果全部加载成功，则回调参数值为true，否则为false。
		*@param progress 资源加载进度回调，回调参数值为当前资源加载的进度信息(0-1)。
		*@param clas 资源类名。如果url和clas同时指定了资源类型，优先使用url指定的资源类型。参数形如：Texture。
		*@param params 资源构造参数。
		*@param priority (default=1)加载的优先级，优先级高的优先加载。有0-4共5个优先级，0最高，4最低。
		*@param cache 是否缓存加载的资源。
		*@return 如果url为数组，返回true；否则返回指定的资源类对象。
		*/
		__proto.create=function(url,complete,progress,clas,params,priority,cache,group){
			(priority===void 0)&& (priority=1);
			(cache===void 0)&& (cache=true);
			if ((url instanceof Array)){
				var items=url;
				var itemCount=items.length;
				var loadedCount=0;
				if (progress){
					var progress2=Handler.create(progress.caller,progress.method,progress.args,false);
				}
				for (var i=0;i < itemCount;i++){
					var item=items[i];
					if ((typeof item=='string'))item=items[i]={url:item};
					item.progress=0;
					var progressHandler=progress ? Handler.create(null,onProgress,[item],false):null;
					var completeHandler=(progress || complete)? Handler.create(null,onComplete,[item]):null;
					this._create(item.url,completeHandler,progressHandler,item.clas || clas,item.params || params,item.priority || priority,cache,item.group || group);
				}
				function onComplete (item,content){
					loadedCount++;
					item.progress=1;
					if (loadedCount===itemCount && complete){
						complete.run();
					}
				}
				function onProgress (item,value){
					item.progress=value;
					var num=0;
					for (var j=0;j < itemCount;j++){
						var item1=items[j];
						num+=item1.progress;
					};
					var v=num / itemCount;
					progress2.runWith(v);
				}
				return true;
			}else return this._create(url,complete,progress,clas,params,priority,cache,group);
		}

		__proto._create=function(url,complete,progress,clas,params,priority,cache,group){
			(priority===void 0)&& (priority=1);
			(cache===void 0)&& (cache=true);
			var formarUrl=URL.formatURL(url);
			var item=this.getRes(formarUrl);
			if (!item){
				var extension=Utils.getFileExtension(url);
				var creatItem=LoaderManager.createMap[extension];
				if (!creatItem)
					throw new Error("LoaderManager:unknown file("+url+") extension with: "+extension+".");
				if (!clas)clas=creatItem[0];
				var type=creatItem[1];
				if (extension=="atlas"){
					this.load(url,complete,progress,type,priority,cache);
					}else {
					if (clas===Texture)type="htmlimage";
					item=clas ? new clas():null;
					if (item.hasOwnProperty("_loaded"))
						item._loaded=false;
					item._setUrl(url);
					(group)&& (item._setGroup(group));
					this._createLoad(item,url,Handler.create(null,onLoaded),progress,type,priority,false,group,true);
					function onLoaded (data){
						if (item && !item.destroyed && data){
							item.onAsynLoaded.call(item,data,params);
							item._completeLoad();
						}
						if (complete)complete.run();
						Laya.loader.event(url);
					}
					(cache)&& (this.cacheRes(formarUrl,item));
				}
				}else {
				if (!item.hasOwnProperty("loaded")|| item.loaded){
					progress && progress.runWith(1);
					complete && complete.run();
					}else if (complete){
					Laya.loader._createListener(url,complete.caller,complete.method,complete.args,true,false);
				}
			}
			return item;
		}

		/**
		*<p>加载资源。资源加载错误时，本对象会派发 Event.ERROR 事件，事件回调参数值为加载出错的资源地址。</p>
		*<p>因为返回值为 LoaderManager 对象本身，所以可以使用如下语法：loaderManager.load(...).load(...);</p>
		*@param url 要加载的单个资源地址或资源信息数组。比如：简单数组：["a.png","b.png"]；复杂数组[{url:"a.png",type:Loader.IMAGE,size:100,priority:1},{url:"b.json",type:Loader.JSON,size:50,priority:1}]。
		*@param complete 加载结束回调。根据url类型不同分为2种情况：1. url为String类型，也就是单个资源地址，如果加载成功，则回调参数值为加载完成的资源，否则为null；2. url为数组类型，指定了一组要加载的资源，如果全部加载成功，则回调参数值为true，否则为false。
		*@param progress 加载进度回调。回调参数值为当前资源的加载进度信息(0-1)。
		*@param type 资源类型。比如：Loader.IMAGE。
		*@param priority (default=1)加载的优先级，优先级高的优先加载。有0-4共5个优先级，0最高，4最低。
		*@param cache 是否缓存加载结果。
		*@param group 分组，方便对资源进行管理。
		*@param ignoreCache 是否忽略缓存，强制重新加载。
		*@param useWorkerLoader(default=false)是否使用worker加载（只针对IMAGE类型和ATLAS类型，并且浏览器支持的情况下生效）
		*@return 此 LoaderManager 对象本身。
		*/
		__proto.load=function(url,complete,progress,type,priority,cache,group,ignoreCache,useWorkerLoader){
			var _$this=this;
			(priority===void 0)&& (priority=1);
			(cache===void 0)&& (cache=true);
			(ignoreCache===void 0)&& (ignoreCache=false);
			(useWorkerLoader===void 0)&& (useWorkerLoader=false);
			if ((url instanceof Array))return this._loadAssets(url,complete,progress,type,priority,cache,group);
			var content=Loader.getRes(url);
			if (!ignoreCache && content !=null){
				Laya.timer.frameOnce(1,null,function(){
					progress && progress.runWith(1);
					complete && complete.runWith(content);
					_$this._loaderCount || _$this.event("complete");
				});
				}else {
				var info=LoaderManager._resMap[url];
				if (!info){
					info=this._infoPool.length ? this._infoPool.pop():new ResInfo();
					info.url=url;
					info.type=type;
					info.cache=cache;
					info.group=group;
					info.ignoreCache=ignoreCache;
					info.useWorkerLoader=useWorkerLoader;
					complete && info.on("complete",complete.caller,complete.method,complete.args);
					progress && info.on("progress",progress.caller,progress.method,progress.args);
					LoaderManager._resMap[url]=info;
					priority=priority < this._maxPriority ? priority :this._maxPriority-1;
					this._resInfos[priority].push(info);
					this._next();
					}else {
					complete && info._createListener("complete",complete.caller,complete.method,complete.args,false,false);
					progress && info._createListener("progress",progress.caller,progress.method,progress.args,false,false);
				}
			}
			return this;
		}

		/**
		*@private
		*/
		__proto._createLoad=function(item,url,complete,progress,type,priority,cache,group,ignoreCache){
			var _$this=this;
			(priority===void 0)&& (priority=1);
			(cache===void 0)&& (cache=true);
			(ignoreCache===void 0)&& (ignoreCache=false);
			if ((url instanceof Array))return this._loadAssets(url,complete,progress,type,priority,cache,group);
			var content=Loader.getRes(url);
			if (content !=null){
				Laya.timer.frameOnce(1,null,function(){
					progress && progress.runWith(1);
					complete && complete.runWith(content);
					_$this._loaderCount || _$this.event("complete");
				});
				}else {
				var info=LoaderManager._resMap[url];
				if (!info){
					info=this._infoPool.length ? this._infoPool.pop():new ResInfo();
					info.url=url;
					info.clas=item;
					info.type=type;
					info.cache=cache;
					info.group=group;
					info.ignoreCache=ignoreCache;
					complete && info.on("complete",complete.caller,complete.method,complete.args);
					progress && info.on("progress",progress.caller,progress.method,progress.args);
					LoaderManager._resMap[url]=info;
					priority=priority < this._maxPriority ? priority :this._maxPriority-1;
					this._resInfos[priority].push(info);
					this._next();
					}else {
					complete && info._createListener("complete",complete.caller,complete.method,complete.args,false,false);
					progress && info._createListener("progress",progress.caller,progress.method,progress.args,false,false);
				}
			}
			return this;
		}

		__proto._next=function(){
			if (this._loaderCount >=this.maxLoader)return;
			for (var i=0;i < this._maxPriority;i++){
				var infos=this._resInfos[i];
				if (infos.length > 0){
					var info=infos.shift();
					if (info)return this._doLoad(info);
				}
			}
			this._loaderCount || this.event("complete");
		}

		__proto._doLoad=function(resInfo){
			this._loaderCount++;
			var loader=this._loaders.length ? this._loaders.pop():new Loader();
			loader.on("complete",null,onLoaded);
			loader.on("progress",null,function(num){
				resInfo.event("progress",num);
			});
			loader.on("error",null,function(msg){
				onLoaded(null);
			});
			var _this=this;
			function onLoaded (data){
				loader.offAll();
				loader._data=null;
				_this._loaders.push(loader);
				_this._endLoad(resInfo,(data instanceof Array)? [data] :data);
				_this._loaderCount--;
				_this._next();
			}
			loader._class=resInfo.clas;
			loader.load(resInfo.url,resInfo.type,resInfo.cache,resInfo.group,resInfo.ignoreCache,resInfo.useWorkerLoader);
		}

		__proto._endLoad=function(resInfo,content){
			var url=resInfo.url;
			if (content==null){
				var errorCount=this._failRes[url] || 0;
				if (errorCount < this.retryNum){
					console.warn("[warn]Retry to load:",url);
					this._failRes[url]=errorCount+1;
					Laya.timer.once(this.retryDelay,this,this._addReTry,[resInfo],false);
					return;
					}else {
					console.warn("[error]Failed to load:",url);
					this.event("error",url);
				}
			}
			if (this._failRes[url])this._failRes[url]=0;
			delete LoaderManager._resMap[url];
			resInfo.event("complete",content);
			resInfo.offAll();
			this._infoPool.push(resInfo);
		}

		__proto._addReTry=function(resInfo){
			this._resInfos[this._maxPriority-1].push(resInfo);
			this._next();
		}

		/**
		*清理指定资源地址缓存。
		*@param url 资源地址。
		*@param forceDispose 是否强制销毁，有些资源是采用引用计数方式销毁，如果forceDispose=true，则忽略引用计数，直接销毁，比如Texture，默认为false
		*/
		__proto.clearRes=function(url,forceDispose){
			(forceDispose===void 0)&& (forceDispose=false);
			Loader.clearRes(url,forceDispose);
		}

		/**
		*获取指定资源地址的资源。
		*@param url 资源地址。
		*@return 返回资源。
		*/
		__proto.getRes=function(url){
			return Loader.getRes(url);
		}

		/**
		*缓存资源。
		*@param url 资源地址。
		*@param data 要缓存的内容。
		*/
		__proto.cacheRes=function(url,data){
			Loader.cacheRes(url,data);
		}

		/**
		*设置资源分组。
		*@param url 资源地址。
		*@param group 分组名
		*/
		__proto.setGroup=function(url,group){
			Loader.setGroup(url,group);
		}

		/**
		*根据分组清理资源。
		*@param group 分组名
		*/
		__proto.clearResByGroup=function(group){
			Loader.clearResByGroup(group);
		}

		/**清理当前未完成的加载，所有未加载的内容全部停止加载。*/
		__proto.clearUnLoaded=function(){
			for (var i=0;i < this._maxPriority;i++){
				var infos=this._resInfos[i];
				for (var j=infos.length-1;j >-1;j--){
					var info=infos[j];
					if (info){
						info.offAll();
						this._infoPool.push(info);
					}
				}
				infos.length=0;
			}
			this._loaderCount=0;
			LoaderManager._resMap={};
		}

		/**
		*根据地址集合清理掉未加载的内容
		*@param urls 资源地址集合
		*/
		__proto.cancelLoadByUrls=function(urls){
			if (!urls)return;
			for (var i=0,n=urls.length;i < n;i++){
				this.cancelLoadByUrl(urls[i]);
			}
		}

		/**
		*根据地址清理掉未加载的内容
		*@param url 资源地址
		*/
		__proto.cancelLoadByUrl=function(url){
			for (var i=0;i < this._maxPriority;i++){
				var infos=this._resInfos[i];
				for (var j=infos.length-1;j >-1;j--){
					var info=infos[j];
					if (info && info.url===url){
						infos[j]=null;
						info.offAll();
						this._infoPool.push(info);
					}
				}
			}
			if (LoaderManager._resMap[url])delete LoaderManager._resMap[url];
		}

		/**
		*@private
		*加载数组里面的资源。
		*@param arr 简单：["a.png","b.png"]，复杂[{url:"a.png",type:Loader.IMAGE,size:100,priority:1,useWorkerLoader:true},{url:"b.json",type:Loader.JSON,size:50,priority:1}]*/
		__proto._loadAssets=function(arr,complete,progress,type,priority,cache,group){
			(priority===void 0)&& (priority=1);
			(cache===void 0)&& (cache=true);
			var itemCount=arr.length;
			var loadedCount=0;
			var totalSize=0;
			var items=[];
			var success=true;
			for (var i=0;i < itemCount;i++){
				var item=arr[i];
				if ((typeof item=='string'))item={url:item,type:type,size:1,priority:priority};
				if (!item.size)item.size=1;
				item.progress=0;
				totalSize+=item.size;
				items.push(item);
				var progressHandler=progress ? Handler.create(null,loadProgress,[item],false):null;
				var completeHandler=(complete || progress)? Handler.create(null,loadComplete,[item]):null;
				this.load(item.url,completeHandler,progressHandler,item.type,item.priority || 1,cache,item.group || group,false,item.useWorkerLoader);
			}
			function loadComplete (item,content){
				loadedCount++;
				item.progress=1;
				if (!content)success=false;
				if (loadedCount===itemCount && complete){
					complete.runWith(success);
				}
			}
			function loadProgress (item,value){
				if (progress !=null){
					item.progress=value;
					var num=0;
					for (var j=0;j < items.length;j++){
						var item1=items[j];
						num+=item1.size *item1.progress;
					};
					var v=num / totalSize;
					progress.runWith(v);
				}
			}
			return this;
		}

		//TODO:TESTs
		__proto.decodeBitmaps=function(urls){
			var i=0,len=urls.length;
			var ctx;
			ctx=Render._context.ctx;
			for (i=0;i < len;i++){
				var atlas;
				atlas=Loader.getAtlas(urls[i]);
				if (atlas){
					this._decodeTexture(atlas[0],ctx);
					}else {
					var tex;
					tex=this.getRes(urls[i]);
					if (tex && (tex instanceof laya.resource.Texture )){
						this._decodeTexture(tex,ctx);
					}
				}
			}
		}

		__proto._decodeTexture=function(tex,ctx){
			var bitmap=tex.bitmap;
			if (!tex || !bitmap)return;
			var tImg=bitmap.source || bitmap.image;
			if (!tImg)return;
			if (Laya.__typeof(tImg,Browser.window.HTMLImageElement)){
				ctx.drawImage(tImg,0,0,1,1);
				var info=ctx.getImageData(0,0,1,1);
			}
		}

		LoaderManager.cacheRes=function(url,data){
			Loader.cacheRes(url,data);
		}

		LoaderManager._resMap={};
		__static(LoaderManager,
		['createMap',function(){return this.createMap={atlas:[null,"atlas"]};}
		]);
		LoaderManager.__init$=function(){
			//class ResInfo extends laya.events.EventDispatcher
			ResInfo=(function(_super){
				function ResInfo(){
					this.url=null;
					this.type=null;
					this.cache=false;
					this.group=null;
					this.ignoreCache=false;
					this.useWorkerLoader=false;
					this.clas=null;
					ResInfo.__super.call(this);
				}
				__class(ResInfo,'',_super);
				return ResInfo;
			})(EventDispatcher)
		}

		return LoaderManager;
	})(EventDispatcher)


	/**
	*<p> <code>Socket</code> 封装了 HTML5 WebSocket ，允许服务器端与客户端进行全双工（full-duplex）的实时通信，并且允许跨域通信。在建立连接后，服务器和 Browser/Client Agent 都能主动的向对方发送或接收文本和二进制数据。</p>
	*<p>要使用 <code>Socket</code> 类的方法，请先使用构造函数 <code>new Socket</code> 创建一个 <code>Socket</code> 对象。 <code>Socket</code> 以异步方式传输和接收数据。</p>
	*/
	//class laya.net.Socket extends laya.events.EventDispatcher
	var Socket=(function(_super){
		function Socket(host,port,byteClass,protocols){
			this._endian=null;
			this._socket=null;
			this._connected=false;
			this._addInputPosition=0;
			this._input=null;
			this._output=null;
			this.disableInput=false;
			this._byteClass=null;
			this.protocols=[];
			Socket.__super.call(this);
			(port===void 0)&& (port=0);
			this._byteClass=byteClass ? byteClass :Byte;
			this.protocols=protocols;
			this.endian="bigEndian";
			if (host && port > 0 && port < 65535)this.connect(host,port);
		}

		__class(Socket,'laya.net.Socket',_super);
		var __proto=Socket.prototype;
		/**
		*<p>连接到指定的主机和端口。</p>
		*<p>连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。</p>
		*@param host 服务器地址。
		*@param port 服务器端口。
		*/
		__proto.connect=function(host,port){
			var url="ws://"+host+":"+port;
			this.connectByUrl(url);
		}

		/**
		*<p>连接到指定的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。</p>
		*<p>连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。</p>
		*@param url 要连接的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。
		*/
		__proto.connectByUrl=function(url){
			var _$this=this;
			if (this._socket !=null)this.close();
			this._socket && this.cleanSocket();
			if (!this.protocols || this.protocols.length==0){
				this._socket=new Browser.window.WebSocket(url);
				}else {
				this._socket=new Browser.window.WebSocket(url,this.protocols);
			}
			this._socket.binaryType="arraybuffer";
			this._output=new this._byteClass();
			this._output.endian=this.endian;
			this._input=new this._byteClass();
			this._input.endian=this.endian;
			this._addInputPosition=0;
			this._socket.onopen=function (e){
				_$this._onOpen(e);
			};
			this._socket.onmessage=function (msg){
				_$this._onMessage(msg);
			};
			this._socket.onclose=function (e){
				_$this._onClose(e);
			};
			this._socket.onerror=function (e){
				_$this._onError(e);
			};
		}

		/**
		*清理Socket：关闭Socket链接，关闭事件监听，重置Socket
		*/
		__proto.cleanSocket=function(){
			this.close();
			this._connected=false;
			this._socket.onopen=null;
			this._socket.onmessage=null;
			this._socket.onclose=null;
			this._socket.onerror=null;
			this._socket=null;
		}

		/**
		*关闭连接。
		*/
		__proto.close=function(){
			if (this._socket !=null){
				try {
					this._socket.close();
				}catch (e){}
			}
		}

		/**
		*@private
		*连接建立成功 。
		*/
		__proto._onOpen=function(e){
			this._connected=true;
			this.event("open",e);
		}

		/**
		*@private
		*接收到数据处理方法。
		*@param msg 数据。
		*/
		__proto._onMessage=function(msg){
			if (!msg || !msg.data)return;
			var data=msg.data;
			if (this.disableInput && data){
				this.event("message",data);
				return;
			}
			if (this._input.length > 0 && this._input.bytesAvailable < 1){
				this._input.clear();
				this._addInputPosition=0;
			};
			var pre=this._input.pos;
			!this._addInputPosition && (this._addInputPosition=0);
			this._input.pos=this._addInputPosition;
			if (data){
				if ((typeof data=='string')){
					this._input.writeUTFBytes(data);
					}else {
					this._input.writeArrayBuffer(data);
				}
				this._addInputPosition=this._input.pos;
				this._input.pos=pre;
			}
			this.event("message",data);
		}

		/**
		*@private
		*连接被关闭处理方法。
		*/
		__proto._onClose=function(e){
			this._connected=false;
			this.event("close",e)
		}

		/**
		*@private
		*出现异常处理方法。
		*/
		__proto._onError=function(e){
			this.event("error",e)
		}

		/**
		*发送数据到服务器。
		*@param data 需要发送的数据，可以是String或者ArrayBuffer。
		*/
		__proto.send=function(data){
			this._socket.send(data);
		}

		/**
		*发送缓冲区中的数据到服务器。
		*/
		__proto.flush=function(){
			if (this._output && this._output.length > 0){
				var evt;
				try {
					this._socket && this._socket.send(this._output.__getBuffer().slice(0,this._output.length));
					}catch (e){
					evt=e;
				}
				this._output.endian=this.endian;
				this._output.clear();
				if (evt)this.event("error",evt);
			}
		}

		/**
		*缓存的服务端发来的数据。
		*/
		__getset(0,__proto,'input',function(){
			return this._input;
		});

		/**
		*表示需要发送至服务端的缓冲区中的数据。
		*/
		__getset(0,__proto,'output',function(){
			return this._output;
		});

		/**
		*表示此 Socket 对象目前是否已连接。
		*/
		__getset(0,__proto,'connected',function(){
			return this._connected;
		});

		/**
		*<p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。</p>
		*<p> LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
		*<p> BIG_ENDIAN ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。</p>
		*/
		__getset(0,__proto,'endian',function(){
			return this._endian;
			},function(value){
			this._endian=value;
			if (this._input !=null)this._input.endian=value;
			if (this._output !=null)this._output.endian=value;
		});

		Socket.LITTLE_ENDIAN="littleEndian";
		Socket.BIG_ENDIAN="bigEndian";
		return Socket;
	})(EventDispatcher)


	/**
	*@private
	*Worker Image加载器
	*/
	//class laya.net.WorkerLoader extends laya.events.EventDispatcher
	var WorkerLoader=(function(_super){
		function WorkerLoader(){
			this.worker=null;
			this._useWorkerLoader=false;
			WorkerLoader.__super.call(this);
			var _$this=this;
			this.worker=new Browser.window.Worker(WorkerLoader.workerPath);
			this.worker.onmessage=function (evt){
				_$this.workerMessage(evt.data);
			}
		}

		__class(WorkerLoader,'laya.net.WorkerLoader',_super);
		var __proto=WorkerLoader.prototype;
		/**
		*@private
		*/
		__proto.workerMessage=function(data){
			if (data){
				switch (data.type){
					case "Image":
						this.imageLoaded(data);
						break ;
					case "Disable":
						WorkerLoader.enable=false;
						break ;
					}
			}
		}

		/**
		*@private
		*/
		__proto.imageLoaded=function(data){
			if (!data.dataType || data.dataType !="imageBitmap"){
				this.event(data.url,null);
				return;
			};
			var canvas=new HTMLCanvas("2D");
			var ctx=canvas.source.getContext("2d");
			switch (data.dataType){
				case "imageBitmap":;
					var imageData=data.imageBitmap;
					canvas.size(imageData.width,imageData.height);
					ctx.drawImage(imageData,0,0);
					break ;
				}
			console.log("load:",data.url);
			if (Render.isWebGL){
				canvas.memorySize=0;
				canvas=new laya.webgl.resource.WebGLImage(canvas,data.url);;
			}
			this.event(data.url,canvas);
		}

		/**
		*加载图片
		*@param url 图片地址
		*/
		__proto.loadImage=function(url){
			this.worker.postMessage(url);
		}

		/**
		*@private
		*加载图片资源。
		*@param url 资源地址。
		*/
		__proto._loadImage=function(url){
			var _this=this;
			if (!this._useWorkerLoader || !WorkerLoader._enable){
				WorkerLoader._preLoadFun.call(_this,url);
				return;
			}
			url=URL.formatURL(url);
			function clear (){
				laya.net.WorkerLoader.I.off(url,_this,onload);
			};
			var onload=function (image){
				clear();
				if (image){
					_this["onLoaded"](image);
					}else {
					WorkerLoader._preLoadFun.call(_this,url);
				}
			};
			laya.net.WorkerLoader.I.on(url,_this,onload);
			laya.net.WorkerLoader.I.loadImage(url);
		}

		/**
		*是否启用。
		*/
		__getset(1,WorkerLoader,'enable',function(){
			return WorkerLoader._enable;
			},function(value){
			if (WorkerLoader._enable !=value){
				WorkerLoader._enable=value;
				if (value && WorkerLoader._preLoadFun==null)WorkerLoader._enable=WorkerLoader.__init__();
			}
		});

		WorkerLoader.__init__=function(){
			if (WorkerLoader._preLoadFun !=null)return false;
			if (!Browser.window.Worker)return false;
			WorkerLoader._preLoadFun=Loader["prototype"]["_loadImage"];
			Loader["prototype"]["_loadImage"]=WorkerLoader["prototype"]["_loadImage"];
			if (!WorkerLoader.I)WorkerLoader.I=new WorkerLoader();
			return true;
		}

		WorkerLoader.workerSupported=function(){
			return Browser.window.Worker ? true :false;
		}

		WorkerLoader.enableWorkerLoader=function(){
			if (!WorkerLoader._tryEnabled){
				WorkerLoader.enable=true;
				WorkerLoader._tryEnabled=true;
			}
		}

		WorkerLoader.I=null
		WorkerLoader.workerPath="libs/workerloader.js";
		WorkerLoader._preLoadFun=null
		WorkerLoader._enable=false;
		WorkerLoader._tryEnabled=false;
		return WorkerLoader;
	})(EventDispatcher)


	/**
	*<code>Texture</code> 是一个纹理处理类。
	*/
	//class laya.resource.Texture extends laya.events.EventDispatcher
	var Texture=(function(_super){
		function Texture(bitmap,uv,sourceWidth,sourceHeight){
			//this.bitmap=null;
			//this._uv=null;
			this.offsetX=0;
			this.offsetY=0;
			this.sourceWidth=0;
			this.sourceHeight=0;
			//this._loaded=false;
			this._w=0;
			this._h=0;
			//this.$_GID=NaN;
			//this.url=null;
			this._uvID=0;
			//this._id=0;
			this._saveRef=0;
			Texture.__super.call(this);
			(sourceWidth===void 0)&& (sourceWidth=0);
			(sourceHeight===void 0)&& (sourceHeight=0);
			this._id=++Texture._uniqueIDCounter;
			if (bitmap){
				bitmap.useNum++;
			}
			this.setTo(bitmap,uv,sourceWidth,sourceHeight);
		}

		__class(Texture,'laya.resource.Texture',_super);
		var __proto=Texture.prototype;
		__proto._saveAddref=function(){
			this._saveRef++;
			Texture._pool[this._id]=this;
		}

		__proto._saveRelease=function(){
			this._saveRef--;
			this._saveRef===0 && (Texture._pool[this._id]=null);
		}

		__proto.getID=function(){
			return this._id;
		}

		/**privaye*/
		__proto._getSource=function(){
			return this.bitmap?this.bitmap._getSource():null;
		}

		__proto._setUV=function(value){}
		/**
		*设置此对象的位图资源、UV数据信息。
		*@param bitmap 位图资源
		*@param uv UV数据信息
		*/
		__proto.setTo=function(bitmap,uv,sourceWidth,sourceHeight){
			(sourceWidth===void 0)&& (sourceWidth=0);
			(sourceHeight===void 0)&& (sourceHeight=0);
			this.bitmap=bitmap;
			this.sourceWidth=sourceWidth;
			this.sourceHeight=sourceHeight;
			if (bitmap){
				this._w=bitmap.width;
				this._h=bitmap.height;
				this.sourceWidth=this.sourceWidth || this._w;
				this.sourceHeight=this.sourceHeight || this._h
				this._loaded=this._w > 0;
				var _this=this;
			}
			this.uv=uv || Texture.DEF_UV;
		}

		/**@private 激活资源。*/
		__proto.active=function(){
			if(this.bitmap)this.bitmap.activeResource();
		}

		__proto.getEnabled=function(){
			if (this._loaded && this.bitmap){
				return true
			}
			return false;
		}

		/**
		*销毁纹理（分直接销毁，跟计数销毁两种）。
		*@param forceDispose (default=false)true为强制销毁主纹理，false是通过计数销毁纹理。
		*/
		__proto.destroy=function(forceDispose){
			(forceDispose===void 0)&& (forceDispose=false);
			if (this.bitmap && (this.bitmap).useNum > 0){
				if (forceDispose){
					this.bitmap.destroy();
					(this.bitmap).useNum=0;
					}else {
					(this.bitmap).useNum--;
					if ((this.bitmap).useNum==0){
						this.bitmap.destroy();
					}
				}
				this.bitmap=null;
				if (this.url && this===Laya.loader.getRes(this.url))Laya.loader.clearRes(this.url,forceDispose);
				this._loaded=false;
			}
		}

		/**
		*加载指定地址的图片。
		*@param url 图片地址。
		*/
		__proto.load=function(url){
			this._loaded=false;
			Laya.loader.load(url,Handler.create(this,this._onLoaded),null,"htmlimage",1,false,null,true);
		}

		__proto._onLoaded=function(context){
			this.bitmap=context;
			this.bitmap.useNum++;
			this._loaded=true;
			this.sourceWidth=this._w=context.width;
			this.sourceHeight=this._h=context.height;
			this.event("loaded",this);
		}

		/**
		*获取Texture上的某个区域的像素点
		*@param x
		*@param y
		*@param width
		*@param height
		*@return 返回像素点集合
		*/
		__proto.getPixels=function(x,y,width,height){
			if (Render.isWebGL){
				return RunDriver.getTexturePixels(this,x,y,width,height);
				}else {
				Browser.canvas.size(width,height);
				Browser.canvas.clear();
				Browser.context.drawImage(this,-x,-y,this.width,this.height,0,0);
				var info=Browser.context.getImageData(0,0,width,height);
			}
			return info.data;
		}

		/**@private */
		__proto.onAsynLoaded=function(url,bitmap){
			if (bitmap)bitmap.useNum++;
			this.setTo(bitmap,this.uv);
		}

		/**
		*通过外部设置是否启用纹理平铺(后面要改成在着色器里计算)
		*/
		/**
		*获取当前纹理是否启用了纹理平铺
		*/
		__getset(0,__proto,'repeat',function(){
			if (Render.isWebGL && this.bitmap){
				return this.bitmap.repeat;
			}
			return true;
			},function(value){
			if (value){
				if (Render.isWebGL && this.bitmap){
					this.bitmap.repeat=value;
					if (value){
						this.bitmap.enableMerageInAtlas=false;
					}
				}
			}
		});

		/**实际高度。*/
		__getset(0,__proto,'height',function(){
			if (!this.loaded)return 0;
			if (this._h)return this._h;
			return (this.uv && this.uv!==Texture.DEF_UV)? (this.uv[5]-this.uv[1])*this.bitmap.height :this.bitmap.height;
			},function(value){
			this._h=value;
			this.sourceHeight || (this.sourceHeight=value);
		});

		__getset(0,__proto,'uv',function(){
			return this._uv;
			},function(value){
			this._uv=value;
			this._setUV(value);
		});

		/**
		*表示是否加载成功，只能表示初次载入成功（通常包含下载和载入）,并不能完全表示资源是否可立即使用（资源管理机制释放影响等）。
		*/
		__getset(0,__proto,'loaded',function(){
			return this._loaded;
		});

		/**
		*表示资源是否已释放。
		*/
		__getset(0,__proto,'released',function(){
			if (!this.bitmap)return true;
			return this.bitmap.released;
		});

		/**实际宽度。*/
		__getset(0,__proto,'width',function(){
			if (!this.loaded)return 0;
			if (this._w)return this._w;
			return (this.uv && this.uv!==Texture.DEF_UV)? (this.uv[2]-this.uv[0])*this.bitmap.width :this.bitmap.width;
			},function(value){
			this._w=value;
			this.sourceWidth || (this.sourceWidth=value);
		});

		/**
		*设置线性采样的状态（目前只能第一次绘制前设置false生效,来关闭线性采样）。
		*/
		/**
		*获取当前纹理是否启用了线性采样。
		*/
		__getset(0,__proto,'isLinearSampling',function(){
			return Render.isWebGL ? (this.bitmap.minFifter !=0x2600):true;
			},function(value){
			if (!value && Render.isWebGL){
				if (!value && (this.bitmap.minFifter==-1)&& (this.bitmap.magFifter==-1)){
					this.bitmap.minFifter=0x2600;
					this.bitmap.magFifter=0x2600;
					this.bitmap.enableMerageInAtlas=false;
				}
			}
		});

		Texture.getTextureByID=function(id){
			return Texture._pool[id];
		}

		Texture.moveUV=function(offsetX,offsetY,uv){
			for (var i=0;i < 8;i+=2){
				uv[i]+=offsetX;
				uv[i+1]+=offsetY;
			}
			return uv;
		}

		Texture.create=function(source,x,y,width,height,offsetX,offsetY,sourceWidth,sourceHeight){
			(offsetX===void 0)&& (offsetX=0);
			(offsetY===void 0)&& (offsetY=0);
			(sourceWidth===void 0)&& (sourceWidth=0);
			(sourceHeight===void 0)&& (sourceHeight=0);
			var btex=(source instanceof laya.resource.Texture );
			var uv=btex ? source.uv :Texture.DEF_UV;
			var bitmap=btex ? source.bitmap :source;
			if (bitmap.width && (x+width)> bitmap.width)width=bitmap.width-x;
			if (bitmap.height && (y+height)> bitmap.height)height=bitmap.height-y;
			var tex=new Texture(bitmap,null,sourceWidth || width,sourceHeight || height);
			tex.width=width;
			tex.height=height;
			tex.offsetX=offsetX;
			tex.offsetY=offsetY;
			var dwidth=1 / bitmap.width;
			var dheight=1 / bitmap.height;
			x *=dwidth;
			y *=dheight;
			width *=dwidth;
			height *=dheight;
			var u1=tex.uv[0],v1=tex.uv[1],u2=tex.uv[4],v2=tex.uv[5];
			var inAltasUVWidth=(u2-u1),inAltasUVHeight=(v2-v1);
			var oriUV=Texture.moveUV(uv[0],uv[1],[x,y,x+width,y,x+width,y+height,x,y+height]);
			tex.uv=[u1+oriUV[0] *inAltasUVWidth,v1+oriUV[1] *inAltasUVHeight,u2-(1-oriUV[2])*inAltasUVWidth,v1+oriUV[3] *inAltasUVHeight,u2-(1-oriUV[4])*inAltasUVWidth,v2-(1-oriUV[5])*inAltasUVHeight,u1+oriUV[6] *inAltasUVWidth,v2-(1-oriUV[7])*inAltasUVHeight];
			return tex;
		}

		Texture.createFromTexture=function(texture,x,y,width,height){
			var rect=Rectangle.TEMP.setTo(x-texture.offsetX,y-texture.offsetY,width,height);
			var result=rect.intersection(Texture._rect1.setTo(0,0,texture.width,texture.height),Texture._rect2);
			if (result)
				var tex=Texture.create(texture,result.x,result.y,result.width,result.height,result.x-rect.x,result.y-rect.y,width,height);
			else return null;
			tex.bitmap.useNum--;
			return tex;
		}

		Texture.DEF_UV=[0,0,1.0,0,1.0,1.0,0,1.0];
		Texture.NO_UV=[0,0,0,0,0,0,0,0];
		Texture.INV_UV=[0,1,1.0,1,1.0,0.0,0,0.0];
		Texture._rect1=new Rectangle();
		Texture._rect2=new Rectangle();
		Texture._uniqueIDCounter=0;
		Texture._pool=[];
		return Texture;
	})(EventDispatcher)


	/**
	*文本的样式类
	*/
	//class laya.display.css.TextStyle extends laya.display.css.SpriteStyle
	var TextStyle=(function(_super){
		function TextStyle(){
			this.italic=false;
			//this.align=null;
			//this.wordWrap=false;
			//this.leading=NaN;
			//this.padding=null;
			//this.bgColor=null;
			//this.borderColor=null;
			//this.asPassword=false;
			//this.stroke=NaN;
			//this.strokeColor=null;
			//this.bold=false;
			//this.underline=false;
			//this.underlineColor=null;
			//this.currBitmapFont=null;
			TextStyle.__super.call(this);
		}

		__class(TextStyle,'laya.display.css.TextStyle',_super);
		var __proto=TextStyle.prototype;
		__proto.reset=function(){
			_super.prototype.reset.call(this);
			this.italic=false;
			this.align="left";
			this.wordWrap=false;
			this.leading=0;
			this.padding=[0,0,0,0];
			this.bgColor=null;
			this.borderColor=null;
			this.asPassword=false;
			this.stroke=0;
			this.strokeColor="#000000";
			this.bold=false;
			this.underline=false;
			this.underlineColor=null;
			this.currBitmapFont=null;
			return this;
		}

		__proto.recover=function(){
			if (this===TextStyle.EMPTY)
				return;
			Pool.recover("TextStyle",this.reset());
		}

		/**@inheritDoc */
		__proto.render=function(sprite,context,x,y){
			(this.bgColor || this.borderColor)&& context.drawRect(x,y,sprite.width,sprite.height,this.bgColor,this.borderColor,1);
		}

		TextStyle.create=function(){
			return Pool.getItemByClass("TextStyle",TextStyle);
		}

		TextStyle.EMPTY=new TextStyle();
		return TextStyle;
	})(SpriteStyle)


	/**
	*<code>AnimationPlayer</code> 类用于动画播放器。
	*/
	//class laya.ani.AnimationPlayer extends laya.events.EventDispatcher
	var AnimationPlayer=(function(_super){
		function AnimationPlayer(){
			this._destroyed=false;
			this._templet=null;
			this._currentTime=NaN;
			this._currentFrameTime=NaN;
			this._playStart=NaN;
			this._playEnd=NaN;
			this._playDuration=NaN;
			this._overallDuration=NaN;
			this._stopWhenCircleFinish=false;
			this._elapsedPlaybackTime=NaN;
			this._startUpdateLoopCount=NaN;
			this._currentAnimationClipIndex=0;
			this._currentKeyframeIndex=0;
			this._paused=false;
			this._cacheFrameRate=0;
			this._cacheFrameRateInterval=NaN;
			this._cachePlayRate=NaN;
			this._fullFrames=null;
			this.isCache=true;
			this.playbackRate=1.0;
			this.returnToZeroStopped=false;
			AnimationPlayer.__super.call(this);
			this._destroyed=false;
			this._currentAnimationClipIndex=-1;
			this._currentKeyframeIndex=-1;
			this._currentTime=0.0;
			this._overallDuration=Number.MAX_VALUE;
			this._stopWhenCircleFinish=false;
			this._elapsedPlaybackTime=0;
			this._startUpdateLoopCount=-1;
			this._cachePlayRate=1.0;
			this.cacheFrameRate=60;
			this.returnToZeroStopped=false;
		}

		__class(AnimationPlayer,'laya.ani.AnimationPlayer',_super);
		var __proto=AnimationPlayer.prototype;
		Laya.imps(__proto,{"laya.resource.IDestroy":true})
		/**
		*@private
		*/
		__proto._onTempletLoadedComputeFullKeyframeIndices=function(cachePlayRate,cacheFrameRate,templet){
			if (this._templet===templet && this._cachePlayRate===cachePlayRate && this._cacheFrameRate===cacheFrameRate)
				this._computeFullKeyframeIndices();
		}

		/**
		*@private
		*/
		__proto._computeFullKeyframeIndices=function(){
			var anifullFrames=this._fullFrames=[];
			var templet=this._templet;
			var cacheFrameInterval=this._cacheFrameRateInterval *this._cachePlayRate;
			for (var i=0,iNum=templet.getAnimationCount();i < iNum;i++){
				var aniFullFrame=[];
				if (!templet.getAnimation(i).nodes){
					anifullFrames.push(aniFullFrame);
					continue ;
				}
				for (var j=0,jNum=templet.getAnimation(i).nodes.length;j < jNum;j++){
					var node=templet.getAnimation(i).nodes[j];
					var frameCount=Math.floor(node.playTime / cacheFrameInterval+0.01);
					var nodeFullFrames=new Uint16Array(frameCount+1);
					var lastFrameIndex=-1;
					for (var n=0,nNum=node.keyFrame.length;n < nNum;n++){
						var keyFrame=node.keyFrame[n];
						var tm=keyFrame.startTime;
						var endTm=tm+keyFrame.duration+cacheFrameInterval;
						do {
							var frameIndex=Math.floor(tm / cacheFrameInterval+0.5);
							for (var k=lastFrameIndex+1;k < frameIndex;k++)
							nodeFullFrames[k]=n;
							lastFrameIndex=frameIndex;
							nodeFullFrames[frameIndex]=n;
							tm+=cacheFrameInterval;
						}while (tm <=endTm);
					}
					aniFullFrame.push(nodeFullFrames);
				}
				anifullFrames.push(aniFullFrame);
			}
		}

		/**
		*@private
		*/
		__proto._onAnimationTempletLoaded=function(){
			(this.destroyed)|| (this._calculatePlayDuration());
		}

		/**
		*@private
		*/
		__proto._calculatePlayDuration=function(){
			if (this.state!==0){
				var oriDuration=this._templet.getAniDuration(this._currentAnimationClipIndex);
				(this._playEnd===0)&& (this._playEnd=oriDuration);
				if (this._playEnd > oriDuration)
					this._playEnd=oriDuration;
				this._playDuration=this._playEnd-this._playStart;
			}
		}

		/**
		*@private
		*/
		__proto._setPlayParams=function(time,cacheFrameInterval){
			this._currentTime=time;
			this._currentKeyframeIndex=Math.floor((this.currentPlayTime)/ cacheFrameInterval+0.01);
			this._currentFrameTime=this._currentKeyframeIndex *cacheFrameInterval;
		}

		/**
		*@private
		*/
		__proto._setPlayParamsWhenStop=function(currentAniClipPlayDuration,cacheFrameInterval){
			this._currentTime=currentAniClipPlayDuration;
			this._currentKeyframeIndex=Math.floor(currentAniClipPlayDuration / cacheFrameInterval+0.01);
			this._currentFrameTime=this._currentKeyframeIndex *cacheFrameInterval;
			this._currentAnimationClipIndex=-1;
		}

		/**
		*@private
		*/
		__proto._update=function(elapsedTime){
			if (this._currentAnimationClipIndex===-1 || this._paused || !this._templet || !this._templet.loaded)
				return;
			var cacheFrameInterval=this._cacheFrameRateInterval *this._cachePlayRate;
			var time=0;
			(this._startUpdateLoopCount!==Stat.loopCount)&& (time=elapsedTime *this.playbackRate,this._elapsedPlaybackTime+=time);
			var currentAniClipPlayDuration=this.playDuration;
			if ((this._overallDuration!==0 && this._elapsedPlaybackTime >=this._overallDuration)|| (this._overallDuration===0 && this._elapsedPlaybackTime >=currentAniClipPlayDuration)){
				this._setPlayParamsWhenStop(currentAniClipPlayDuration,cacheFrameInterval);
				this.event("stopped");
				return;
			}
			time+=this._currentTime;
			if (currentAniClipPlayDuration > 0){
				if (time >=currentAniClipPlayDuration){
					do {
						time-=currentAniClipPlayDuration;
						if (this._stopWhenCircleFinish){
							this._setPlayParamsWhenStop(currentAniClipPlayDuration,cacheFrameInterval);
							this._stopWhenCircleFinish=false;
							this.event("stopped");
							return;
						}
						if (time < currentAniClipPlayDuration){
							this._setPlayParams(time,cacheFrameInterval);
							this.event("complete");
						}
					}while (time >=currentAniClipPlayDuration)
					}else {
					this._setPlayParams(time,cacheFrameInterval);
				}
				}else {
				if (this._stopWhenCircleFinish){
					this._setPlayParamsWhenStop(currentAniClipPlayDuration,cacheFrameInterval);
					this._stopWhenCircleFinish=false;
					this.event("stopped");
					return;
				}
				this._currentTime=this._currentFrameTime=this._currentKeyframeIndex=0;
				this.event("complete");
			}
		}

		/**
		*@private
		*/
		__proto._destroy=function(){
			this.offAll();
			this._templet=null;
			this._fullFrames=null;
			this._destroyed=true;
		}

		/**
		*播放动画。
		*@param index 动画索引。
		*@param playbackRate 播放速率。
		*@param duration 播放时长（0为1次,Number.MAX_VALUE为循环播放）。
		*@param playStart 播放的起始时间位置。
		*@param playEnd 播放的结束时间位置。（0为动画一次循环的最长结束时间位置）。
		*/
		__proto.play=function(index,playbackRate,overallDuration,playStart,playEnd){
			(index===void 0)&& (index=0);
			(playbackRate===void 0)&& (playbackRate=1.0);
			(overallDuration===void 0)&& (overallDuration=2147483647);
			(playStart===void 0)&& (playStart=0);
			(playEnd===void 0)&& (playEnd=0);
			if (!this._templet)
				throw new Error("AnimationPlayer:templet must not be null,maybe you need to set url.");
			if (overallDuration < 0 || playStart < 0 || playEnd < 0)
				throw new Error("AnimationPlayer:overallDuration,playStart and playEnd must large than zero.");
			if ((playEnd!==0)&& (playStart > playEnd))
				throw new Error("AnimationPlayer:start must less than end.");
			this._currentTime=0;
			this._currentFrameTime=0;
			this._elapsedPlaybackTime=0;
			this.playbackRate=playbackRate;
			this._overallDuration=overallDuration;
			this._playStart=playStart;
			this._playEnd=playEnd;
			this._paused=false;
			this._currentAnimationClipIndex=index;
			this._currentKeyframeIndex=0;
			this._startUpdateLoopCount=Stat.loopCount;
			this.event("played");
			if (this._templet.loaded)
				this._calculatePlayDuration();
			else
			this._templet.once("loaded",this,this._onAnimationTempletLoaded);
			this._update(0);
		}

		/**
		*播放动画。
		*@param index 动画索引。
		*@param playbackRate 播放速率。
		*@param duration 播放时长（0为1次,Number.MAX_VALUE为循环播放）。
		*@param playStartFrame 播放的原始起始帧率位置。
		*@param playEndFrame 播放的原始结束帧率位置。（0为动画一次循环的最长结束时间位置）。
		*/
		__proto.playByFrame=function(index,playbackRate,overallDuration,playStartFrame,playEndFrame,fpsIn3DBuilder){
			(index===void 0)&& (index=0);
			(playbackRate===void 0)&& (playbackRate=1.0);
			(overallDuration===void 0)&& (overallDuration=2147483647);
			(playStartFrame===void 0)&& (playStartFrame=0);
			(playEndFrame===void 0)&& (playEndFrame=0);
			(fpsIn3DBuilder===void 0)&& (fpsIn3DBuilder=30);
			var interval=1000.0 / fpsIn3DBuilder;
			this.play(index,playbackRate,overallDuration,playStartFrame *interval,playEndFrame *interval);
		}

		/**
		*停止播放当前动画
		*@param immediate 是否立即停止
		*/
		__proto.stop=function(immediate){
			(immediate===void 0)&& (immediate=true);
			if (immediate){
				this._currentTime=this._currentFrameTime=this._currentKeyframeIndex=0;
				this._currentAnimationClipIndex=-1;
				this.event("stopped");
				}else {
				this._stopWhenCircleFinish=true;
			}
		}

		/**
		*动画播放的结束时间位置。
		*@return 结束时间位置。
		*/
		__getset(0,__proto,'playEnd',function(){
			return this._playEnd;
		});

		/**
		*设置动画数据模板,注意：修改此值会有计算开销。
		*@param value 动画数据模板
		*/
		/**
		*获取动画数据模板
		*@param value 动画数据模板
		*/
		__getset(0,__proto,'templet',function(){
			return this._templet;
			},function(value){
			if (!this.state===0)
				this.stop(true);
			if (this._templet!==value){
				this._templet=value;
				if (value.loaded)
					this._computeFullKeyframeIndices();
				else
				value.once("loaded",this,this._onTempletLoadedComputeFullKeyframeIndices,[this._cachePlayRate,this._cacheFrameRate]);
			}
		});

		/**
		*动画播放的起始时间位置。
		*@return 起始时间位置。
		*/
		__getset(0,__proto,'playStart',function(){
			return this._playStart;
		});

		/**
		*获取动画播放一次的总时间
		*@return 动画播放一次的总时间
		*/
		__getset(0,__proto,'playDuration',function(){
			return this._playDuration;
		});

		/**
		*获取当前播放状态
		*@return 当前播放状态
		*/
		__getset(0,__proto,'state',function(){
			if (this._currentAnimationClipIndex===-1)
				return 0;
			if (this._paused)
				return 1;
			return 2;
		});

		/**
		*获取当前帧数
		*@return 当前帧数
		*/
		__getset(0,__proto,'currentKeyframeIndex',function(){
			return this._currentKeyframeIndex;
		});

		/**
		*获取动画播放的总总时间
		*@return 动画播放的总时间
		*/
		__getset(0,__proto,'overallDuration',function(){
			return this._overallDuration;
		});

		/**
		*获取当前帧时间，不包括重播时间
		*@return value 当前时间
		*/
		__getset(0,__proto,'currentFrameTime',function(){
			return this._currentFrameTime;
		});

		/**
		*获取当前动画索引
		*@return value 当前动画索引
		*/
		__getset(0,__proto,'currentAnimationClipIndex',function(){
			return this._currentAnimationClipIndex;
		});

		/**
		*获取当前精确时间，不包括重播时间
		*@return value 当前时间
		*/
		__getset(0,__proto,'currentPlayTime',function(){
			return this._currentTime+this._playStart;
		});

		/**
		*设置缓存播放速率,默认值为1.0,注意：修改此值会有计算开销。*
		*@return value 缓存播放速率。
		*/
		/**
		*获取缓存播放速率。*
		*@return 缓存播放速率。
		*/
		__getset(0,__proto,'cachePlayRate',function(){
			return this._cachePlayRate;
			},function(value){
			if (this._cachePlayRate!==value){
				this._cachePlayRate=value;
				if (this._templet)
					if (this._templet.loaded)
				this._computeFullKeyframeIndices();
				else
				this._templet.once("loaded",this,this._onTempletLoadedComputeFullKeyframeIndices,[value,this._cacheFrameRate]);
			}
		});

		/**
		*设置默认帧率,每秒60帧,注意：修改此值会有计算开销。*
		*@return value 缓存帧率
		*/
		/**
		*获取默认帧率*
		*@return value 默认帧率
		*/
		__getset(0,__proto,'cacheFrameRate',function(){
			return this._cacheFrameRate;
			},function(value){
			if (this._cacheFrameRate!==value){
				this._cacheFrameRate=value;
				this._cacheFrameRateInterval=1000.0 / this._cacheFrameRate;
				if (this._templet)
					if (this._templet.loaded)
				this._computeFullKeyframeIndices();
				else
				this._templet.once("loaded",this,this._onTempletLoadedComputeFullKeyframeIndices,[this._cachePlayRate,value]);
			}
		});

		/**
		*设置当前播放位置
		*@param value 当前时间
		*/
		__getset(0,__proto,'currentTime',null,function(value){
			if (this._currentAnimationClipIndex===-1 || !this._templet || !this._templet.loaded)
				return;
			if (value < this._playStart || value > this._playEnd)
				throw new Error("AnimationPlayer:value must large than playStartTime,small than playEndTime.");
			this._startUpdateLoopCount=Stat.loopCount;
			var cacheFrameInterval=this._cacheFrameRateInterval *this._cachePlayRate;
			this._currentTime=value;
			this._currentKeyframeIndex=Math.floor(this.currentPlayTime / cacheFrameInterval);
			this._currentFrameTime=this._currentKeyframeIndex *cacheFrameInterval;
		});

		/**
		*设置是否暂停
		*@param value 是否暂停
		*/
		/**
		*获取当前是否暂停
		*@return 是否暂停
		*/
		__getset(0,__proto,'paused',function(){
			return this._paused;
			},function(value){
			this._paused=value;
			value && this.event("paused");
		});

		/**
		*获取缓存帧率间隔时间
		*@return 缓存帧率间隔时间
		*/
		__getset(0,__proto,'cacheFrameRateInterval',function(){
			return this._cacheFrameRateInterval;
		});

		/**
		*获取是否已销毁。
		*@return 是否已销毁。
		*/
		__getset(0,__proto,'destroyed',function(){
			return this._destroyed;
		});

		return AnimationPlayer;
	})(EventDispatcher)


	/**
	*<p><code>ColorFilter</code> 是颜色滤镜。使用 ColorFilter 类可以将 4 x 5 矩阵转换应用于输入图像上的每个像素的 RGBA 颜色和 Alpha 值，以生成具有一组新的 RGBA 颜色和 Alpha 值的结果。该类允许饱和度更改、色相旋转、亮度转 Alpha 以及各种其他效果。您可以将滤镜应用于任何显示对象（即，从 Sprite 类继承的对象）。</p>
	*<p>注意：对于 RGBA 值，最高有效字节代表红色通道值，其后的有效字节分别代表绿色、蓝色和 Alpha 通道值。</p>
	*/
	//class laya.filters.ColorFilter extends laya.filters.Filter
	var ColorFilter=(function(_super){
		function ColorFilter(mat){
			//this._mat=null;
			//this._alpha=null;
			//this._matrix=null;
			ColorFilter.__super.call(this);
			if (!mat)mat=this._copyMatrix(ColorFilter.IDENTITY_MATRIX);
			this._mat=new Float32Array(16);
			this._alpha=new Float32Array(4);
			this.setByMatrix(mat);
			this._action=RunDriver.createFilterAction(0x20);
			this._action.data=this;
		}

		__class(ColorFilter,'laya.filters.ColorFilter',_super);
		var __proto=ColorFilter.prototype;
		Laya.imps(__proto,{"laya.filters.IFilter":true})
		/**
		*设置为灰色滤镜
		*/
		__proto.gray=function(){
			return this.setByMatrix(ColorFilter.GRAY_MATRIX);
		}

		/**
		*设置为变色滤镜
		*@param red 红色增量,范围:0~255
		*@param green 绿色增量,范围:0~255
		*@param blue 蓝色增量,范围:0~255
		*@param alpha alpha,范围:0~1
		*/
		__proto.color=function(red,green,blue,alpha){
			(red===void 0)&& (red=0);
			(green===void 0)&& (green=0);
			(blue===void 0)&& (blue=0);
			(alpha===void 0)&& (alpha=1);
			return this.setByMatrix([1,0,0,0,red,0,1,0,0,green,0,0,1,0,blue,0,0,0,1,alpha]);
		}

		/**
		*设置矩阵数据
		*@param matrix 由 20 个项目（排列成 4 x 5 矩阵）组成的数组
		*@return this
		*/
		__proto.setByMatrix=function(matrix){
			if (this._matrix !=matrix)this._copyMatrix(matrix);
			var j=0;
			var z=0;
			for (var i=0;i < 20;i++){
				if (i % 5 !=4){
					this._mat[j++]=matrix[i];
					}else {
					this._alpha[z++]=matrix[i];
				}
			}
			return this;
		}

		/**
		*调整颜色，包括亮度，对比度，饱和度和色调
		*@param brightness 亮度,范围:-100~100
		*@param contrast 对比度,范围:-100~100
		*@param saturation 饱和度,范围:-100~100
		*@param hue 色调,范围:-180~180
		*@return this
		*/
		__proto.adjustColor=function(brightness,contrast,saturation,hue){
			this.adjustHue(hue);
			this.adjustContrast(contrast);
			this.adjustBrightness(brightness);
			this.adjustSaturation(saturation);
			return this;
		}

		/**
		*调整亮度
		*@param brightness 亮度,范围:-100~100
		*@return this
		*/
		__proto.adjustBrightness=function(brightness){
			brightness=this._clampValue(brightness,100);
			if (brightness==0 || isNaN(brightness))return this;
			return this._multiplyMatrix([1,0,0,0,brightness,0,1,0,0,brightness,0,0,1,0,brightness,0,0,0,1,0,0,0,0,0,1]);
		}

		/**
		*调整对比度
		*@param contrast 对比度,范围:-100~100
		*@return this
		*/
		__proto.adjustContrast=function(contrast){
			contrast=this._clampValue(contrast,100);
			if (contrast==0 || isNaN(contrast))return this;
			var x=NaN;
			if (contrast < 0){
				x=127+contrast / 100 *127
				}else {
				x=contrast % 1;
				if (x==0){
					x=ColorFilter.DELTA_INDEX[contrast];
					}else {
					x=ColorFilter.DELTA_INDEX[(contrast << 0)] *(1-x)+ColorFilter.DELTA_INDEX[(contrast << 0)+1] *x;
				}
				x=x *127+127;
			};
			var x1=x / 127;
			var x2=(127-x)*0.5;
			return this._multiplyMatrix([x1,0,0,0,x2,0,x1,0,0,x2,0,0,x1,0,x2,0,0,0,1,0,0,0,0,0,1]);
		}

		/**
		*调整饱和度
		*@param saturation 饱和度,范围:-100~100
		*@return this
		*/
		__proto.adjustSaturation=function(saturation){
			saturation=this._clampValue(saturation,100);
			if (saturation==0 || isNaN(saturation))return this;
			var x=1+((saturation > 0)? 3 *saturation / 100 :saturation / 100);
			var dx=1-x;
			var r=0.3086 *dx;
			var g=0.6094 *dx;
			var b=0.0820 *dx;
			return this._multiplyMatrix([r+x,g,b,0,0,r,g+x,b,0,0,r,g,b+x,0,0,0,0,0,1,0,0,0,0,0,1]);
		}

		/**
		*调整色调
		*@param hue 色调,范围:-180~180
		*@return this
		*/
		__proto.adjustHue=function(hue){
			hue=this._clampValue(hue,180)/ 180 *Math.PI;
			if (hue==0 || isNaN(hue))return this;
			var cos=Math.cos(hue);
			var sin=Math.sin(hue);
			var r=0.213;
			var g=0.715;
			var b=0.072;
			return this._multiplyMatrix([r+cos *(1-r)+sin *(-r),g+cos *(-g)+sin *(-g),b+cos *(-b)+sin *(1-b),0,0,r+cos *(-r)+sin *(0.143),g+cos *(1-g)+sin *(0.140),b+cos *(-b)+sin *(-0.283),0,0,r+cos *(-r)+sin *(-(1-r)),g+cos *(-g)+sin *(g),b+cos *(1-b)+sin *(b),0,0,0,0,0,1,0,0,0,0,0,1]);
		}

		/**
		*重置成单位矩阵，去除滤镜效果
		*/
		__proto.reset=function(){
			return this.setByMatrix(this._copyMatrix(ColorFilter.IDENTITY_MATRIX));
		}

		/**
		*矩阵乘法
		*@param matrix
		*@return this
		*/
		__proto._multiplyMatrix=function(matrix){
			var col=[];
			this._matrix=this._fixMatrix(this._matrix);
			for (var i=0;i < 5;i++){
				for (var j=0;j < 5;j++){
					col[j]=this._matrix[j+i *5];
				}
				for (j=0;j < 5;j++){
					var val=0;
					for (var k=0;k < 5;k++){
						val+=matrix[j+k *5] *col[k];
					}
					this._matrix[j+i *5]=val;
				}
			}
			return this.setByMatrix(this._matrix);
		}

		/**
		*规范值的范围
		*@param val 当前值
		*@param limit 值的范围-limit~limit
		*/
		__proto._clampValue=function(val,limit){
			return Math.min(limit,Math.max(-limit,val));
		}

		/**
		*规范矩阵,将矩阵调整到正确的大小
		*@param matrix 需要调整的矩阵
		*/
		__proto._fixMatrix=function(matrix){
			if (matrix==null)return ColorFilter.IDENTITY_MATRIX;
			if (matrix.length < 25)matrix=matrix.slice(0,matrix.length).concat(ColorFilter.IDENTITY_MATRIX.slice(matrix.length,25));
			else if (matrix.length > 25)matrix=matrix.slice(0,25);
			return matrix;
		}

		/**
		*复制矩阵
		*/
		__proto._copyMatrix=function(matrix){
			var len=25;
			if (!this._matrix)this._matrix=[];
			for (var i=0;i < len;i++){
				this._matrix[i]=matrix[i];
			}
			return this._matrix;
		}

		/**@private */
		__getset(0,__proto,'type',function(){
			return 0x20;
		});

		/**@private */
		__getset(0,__proto,'action',function(){
			return this._action;
		});

		ColorFilter.LENGTH=25;
		__static(ColorFilter,
		['DELTA_INDEX',function(){return this.DELTA_INDEX=[0,0.01,0.02,0.04,0.05,0.06,0.07,0.08,0.1,0.11,0.12,0.14,0.15,0.16,0.17,0.18,0.20,0.21,0.22,0.24,0.25,0.27,0.28,0.30,0.32,0.34,0.36,0.38,0.40,0.42,0.44,0.46,0.48,0.5,0.53,0.56,0.59,0.62,0.65,0.68,0.71,0.74,0.77,0.80,0.83,0.86,0.89,0.92,0.95,0.98,1.0,1.06,1.12,1.18,1.24,1.30,1.36,1.42,1.48,1.54,1.60,1.66,1.72,1.78,1.84,1.90,1.96,2.0,2.12,2.25,2.37,2.50,2.62,2.75,2.87,3.0,3.2,3.4,3.6,3.8,4.0,4.3,4.7,4.9,5.0,5.5,6.0,6.5,6.8,7.0,7.3,7.5,7.8,8.0,8.4,8.7,9.0,9.4,9.6,9.8,10.0];},'GRAY_MATRIX',function(){return this.GRAY_MATRIX=[0.3086,0.6094,0.082,0,0,0.3086,0.6094,0.082,0,0,0.3086,0.6094,0.082,0,0,0,0,0,1,0];},'IDENTITY_MATRIX',function(){return this.IDENTITY_MATRIX=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1];}
		]);
		return ColorFilter;
	})(Filter)


	//class laya.webgl.display.GraphicsGL extends laya.display.Graphics
	var GraphicsGL=(function(_super){
		function GraphicsGL(){
			GraphicsGL.__super.call(this);
		}

		__class(GraphicsGL,'laya.webgl.display.GraphicsGL',_super);
		var __proto=GraphicsGL.prototype;
		__proto.setShader=function(shader){}
		//_saveToCmd(Render.context._setShader,[shader]);
		__proto.setIBVB=function(x,y,ib,vb,numElement,shader){}
		//_saveToCmd(Render.context._setIBVB,[x,y,ib,vb,numElement,shader]);
		__proto.drawParticle=function(x,y,ps){}
		return GraphicsGL;
	})(Graphics)


	/**
	*<code>Transform3D</code> 类用于实现3D变换。
	*/
	//class laya.d3.animation.AnimationTransform3D extends laya.events.EventDispatcher
	var AnimationTransform3D=(function(_super){
		function AnimationTransform3D(owner){
			//this._localMatrix=null;
			//this._worldMatrix=null;
			//this._localPosition=null;
			//this._localRotation=null;
			//this._localScale=null;
			//this._localQuaternionUpdate=false;
			//this._locaEulerlUpdate=false;
			//this._localUpdate=false;
			//this._parent=null;
			//this._children=null;
			//this._localRotationEuler=null;
			//this._owner=null;
			//this._worldUpdate=false;
			//this._entity=null;
			AnimationTransform3D.__super.call(this);
			this._owner=owner;
			this._children=[];
			this._localMatrix=new Float32Array(16);
			this._localQuaternionUpdate=false;
			this._locaEulerlUpdate=false;
			this._localUpdate=false;
			this._worldUpdate=true;
		}

		__class(AnimationTransform3D,'laya.d3.animation.AnimationTransform3D',_super);
		var __proto=AnimationTransform3D.prototype;
		/**
		*@private
		*/
		__proto._getlocalMatrix=function(){
			if (this._localUpdate){
				Utils3D._createAffineTransformationArray(this._localPosition,this._localRotation,this._localScale,this._localMatrix);
				this._localUpdate=false;
			}
			return this._localMatrix;
		}

		/**
		*@private
		*/
		__proto._onWorldTransform=function(){
			if (!this._worldUpdate){
				this._worldUpdate=true;
				for (var i=0,n=this._children.length;i < n;i++)
				this._children[i]._onWorldTransform();
			}
		}

		/**
		*@private
		*/
		__proto._setWorldMatrixAndUpdate=function(matrix){
			this._worldMatrix=matrix;
			if (this._parent==null){
				throw new Error("don't need to set worldMatrix to root Node.");
				}else {
				if (this._parent._parent==null){
					var locMat=this._getlocalMatrix();
					for (var i=0;i < 16;++i)
					this._worldMatrix[i]=locMat[i];
					}else {
					Utils3D.matrix4x4MultiplyFFF(this._parent.getWorldMatrix(),this._getlocalMatrix(),this._worldMatrix);
				}
			}
			this._worldUpdate=false;
		}

		/**
		*@private
		*/
		__proto._setWorldMatrixNoUpdate=function(matrix){
			this._worldMatrix=matrix;
		}

		/**
		*@private
		*/
		__proto._setWorldMatrixIgnoreUpdate=function(matrix){
			this._worldMatrix=matrix;
			this._worldUpdate=false;
		}

		/**
		*获取局部位置。
		*@return 局部位置。
		*/
		__proto.getLocalPosition=function(){
			return this._localPosition;
		}

		/**
		*设置局部位置。
		*@param value 局部位置。
		*/
		__proto.setLocalPosition=function(value){
			if (this._parent){
				this._localPosition=value;
				this._localUpdate=true;
				this._onWorldTransform();
				}else {
				var entityTransform=this._entity.owner._transform;
				var entityPosition=this._entity.localPosition;
				var entityPositionE=entityPosition.elements;
				entityPositionE[0]=value[0];
				entityPositionE[1]=value[1];
				entityPositionE[2]=value[2];
				entityTransform.localPosition=entityPosition;
			}
		}

		/**
		*获取局部旋转。
		*@return 局部旋转。
		*/
		__proto.getLocalRotation=function(){
			if (this._localQuaternionUpdate){
				var eulerE=this._localRotationEuler;
				Utils3D._quaternionCreateFromYawPitchRollArray(eulerE[1] / AnimationTransform3D._angleToRandin,eulerE[0] / AnimationTransform3D._angleToRandin,eulerE[2] / AnimationTransform3D._angleToRandin,this._localRotation);
				this._localQuaternionUpdate=false;
			}
			return this._localRotation;
		}

		/**
		*设置局部旋转。
		*@param value 局部旋转。
		*/
		__proto.setLocalRotation=function(value){
			if (this._parent){
				this._localRotation=value;
				Utils3D.quaterionNormalize(this._localRotation,this._localRotation);
				this._locaEulerlUpdate=true;
				this._localQuaternionUpdate=false;
				this._localUpdate=true;
				this._onWorldTransform();
				}else {
				var entityTransform=this._entity.owner._transform;
				var entityRotation=this._entity.localRotation;
				var entityRotationE=entityRotation.elements;
				entityRotationE[0]=value[0];
				entityRotationE[1]=value[1];
				entityRotationE[2]=value[2];
				entityRotationE[3]=value[3];
				entityTransform.localRotation=entityRotation;
			}
		}

		/**
		*获取局部缩放。
		*@return 局部缩放。
		*/
		__proto.getLocalScale=function(){
			return this._localScale;
		}

		/**
		*设置局部缩放。
		*@param value 局部缩放。
		*/
		__proto.setLocalScale=function(value){
			if (this._parent){
				this._localScale=value;
				this._localUpdate=true;
				this._onWorldTransform();
				}else {
				var entityTransform=this._entity.owner._transform;
				var entityScale=this._entity.localScale;
				var entityScaleE=entityScale.elements;
				entityScaleE[0]=value[0];
				entityScaleE[1]=value[1];
				entityScaleE[2]=value[2];
				entityTransform.localScale=entityScale;
			}
		}

		/**
		*获取局部空间的旋转角度。
		*@return 欧拉角的旋转值，顺序为x、y、z。
		*/
		__proto.getLocalRotationEuler=function(){
			if (this._locaEulerlUpdate){
				Utils3D.getYawPitchRoll(this._localRotation,AnimationTransform3D._tempVector3);
				var eulerE=AnimationTransform3D._tempVector3;
				var localRotationEulerE=this._localRotationEuler;
				localRotationEulerE[0]=eulerE[1] *AnimationTransform3D._angleToRandin;
				localRotationEulerE[1]=eulerE[0] *AnimationTransform3D._angleToRandin;
				localRotationEulerE[2]=eulerE[2] *AnimationTransform3D._angleToRandin;
				this._locaEulerlUpdate=false;
			}
			return this._localRotationEuler;
		}

		/**
		*设置局部空间的旋转角度。
		*@param value 欧拉角的旋转值，顺序为x、y、z。
		*/
		__proto.setLocalRotationEuler=function(value){
			if (this._parent){
				Utils3D._quaternionCreateFromYawPitchRollArray(value[1] / AnimationTransform3D._angleToRandin,value[0] / AnimationTransform3D._angleToRandin,value[2] / AnimationTransform3D._angleToRandin,this._localRotation);
				this._localRotationEuler=value;
				this._locaEulerlUpdate=false;
				this._localQuaternionUpdate=false;
				this._localUpdate=true;
				this._onWorldTransform();
				}else {
				var entityTransform=this._entity.owner._transform;
				var entityLocalRotationEuler=this._entity.localRotationEuler;
				var elements=entityLocalRotationEuler.elements;
				elements[0]=value[0];
				elements[1]=value[1];
				elements[2]=value[2];
				entityTransform.localRotationEuler=entityLocalRotationEuler;
			}
		}

		/**
		*获取世界矩阵。
		*@return 世界矩阵。
		*/
		__proto.getWorldMatrix=function(){
			if (this._worldUpdate){
				if (this._parent._parent !=null){
					Utils3D.matrix4x4MultiplyFFF(this._parent.getWorldMatrix(),this._getlocalMatrix(),this._worldMatrix);
					}else {
					var locMat=this._getlocalMatrix();
					for (var i=0;i < 16;++i)
					this._worldMatrix[i]=locMat[i];
				}
				this._worldUpdate=false;
			}
			return this._worldMatrix;
		}

		/**
		*设置父3D变换。
		*@param value 父3D变换。
		*/
		__proto.setParent=function(value){
			if (this._parent!==value){
				if (this._parent){
					var parentChilds=this._parent._children;
					var index=parentChilds.indexOf(this);
					parentChilds.splice(index,1);
				}
				if (value){
					value._children.push(this);
					(value)&& (this._onWorldTransform());
				}
				this._parent=value;
			}
		}

		__static(AnimationTransform3D,
		['_tempVector3',function(){return this._tempVector3=new Float32Array(3);},'_angleToRandin',function(){return this._angleToRandin=180 / Math.PI;}
		]);
		return AnimationTransform3D;
	})(EventDispatcher)


	/**
	*<code>MeshFilter</code> 类用于创建网格过滤器。
	*/
	//class laya.d3.core.MeshFilter extends laya.events.EventDispatcher
	var MeshFilter=(function(_super){
		function MeshFilter(owner){
			this._owner=null;
			this._sharedMesh=null;
			MeshFilter.__super.call(this);
			this._owner=owner;
		}

		__class(MeshFilter,'laya.d3.core.MeshFilter',_super);
		var __proto=MeshFilter.prototype;
		/**
		*@private
		*/
		__proto._sharedMeshLoaded=function(){
			this.event("loaded");
		}

		/**
		*@inheritDoc
		*/
		__proto.destroy=function(){
			this._owner=null;
			(this._sharedMesh)&& (this._sharedMesh._removeReference(),this._sharedMesh=null);
		}

		/**
		*设置共享网格。
		*@return value 共享网格。
		*/
		/**
		*获取共享网格。
		*@return 共享网格。
		*/
		__getset(0,__proto,'sharedMesh',function(){
			return this._sharedMesh;
			},function(value){
			var lastValue=this._sharedMesh;
			(lastValue)&& (lastValue._removeReference());
			this._sharedMesh=value;
			value._addReference();
			this.event("meshchanged",[this,lastValue,value]);
			if (!value.loaded){
				this._sharedMesh.once("loaded",this,this._sharedMeshLoaded);
			}
		});

		return MeshFilter;
	})(EventDispatcher)


	/**
	*<code>Render</code> 类用于渲染器的父类，抽象类不允许实例。
	*/
	//class laya.d3.core.render.BaseRender extends laya.events.EventDispatcher
	var BaseRender=(function(_super){
		function BaseRender(owner,shaderDataSize){
			//this._id=0;
			//this._destroyed=false;
			//this._lightmapScaleOffset=null;
			//this._lightmapIndex=0;
			//this._enable=false;
			//this._receiveShadow=false;
			//this._materialsInstance=null;
			//this._boundingSphere=null;
			//this._boundingBox=null;
			//this._boundingBoxCenter=null;
			//this._boundingSphereNeedChange=false;
			//this._boundingBoxNeedChange=false;
			//this._boundingBoxCenterNeedChange=false;
			//this._octreeNodeNeedChange=false;
			//this._shaderValues=null;
			//this._defineDatas=null;
			//this._indexInSceneList=0;
			//this._materials=null;
			//this._scene=null;
			//this._owner=null;
			//this._renderElements=null;
			//this._distanceForSort=NaN;
			//this._treeNode=null;
			//this._isPartOfStaticBatch=false;
			//this._staticBatchRootSprite3D=null;
			//this._staticBatchRenderElements=null;
			//this._updateMark=0;
			//this.sortingFudge=NaN;
			//this.castShadow=false;
			BaseRender.__super.call(this);
			this._id=++BaseRender._uniqueIDCounter;
			this._indexInSceneList=-1;
			this._boundingBox=new BoundBox(new Vector3(),new Vector3());
			this._boundingBoxCenter=new Vector3();
			this._boundingSphere=new BoundSphere(new Vector3(),0);
			this._boundingSphereNeedChange=true;
			this._boundingBoxNeedChange=true;
			this._boundingBoxCenterNeedChange=true;
			this._octreeNodeNeedChange=true;
			this._materials=[];
			this._renderElements=[];
			this._isPartOfStaticBatch=false;
			this._destroyed=false;
			this._owner=owner;
			this._enable=true;
			this._materialsInstance=[];
			this._updateMark=-1;
			this._shaderValues=new ShaderDatas(this,shaderDataSize);
			this._defineDatas=new DefineDatas();
			this.lightmapIndex=-1;
			this.castShadow=false;
			this.receiveShadow=false;
			this.sortingFudge=0.0;
			(owner)&& (this._owner.transform.on("worldmatrixneedchanged",this,this._onWorldMatNeedChange));
		}

		__class(BaseRender,'laya.d3.core.render.BaseRender',_super);
		var __proto=BaseRender.prototype;
		Laya.imps(__proto,{"laya.resource.IDestroy":true})
		/**
		*@private
		*/
		__proto._changeMaterialReference=function(lastValue,value){
			(lastValue)&& (lastValue._removeReference());
			value._addReference();
		}

		/**
		*@private
		*/
		__proto._getInstanceMaterial=function(material,index){
			var insMat=new material.constructor();
			material.cloneTo(insMat);
			insMat.name=insMat.name+"(Instance)";
			this._materialsInstance[index]=true;
			this._changeMaterialReference(this._materials[index],insMat);
			this._materials[index]=insMat;
			return insMat;
		}

		/**
		*@private
		*/
		__proto._applyLightMapParams=function(){
			if (this._scene && this._lightmapIndex >=0){
				var lightMaps=this._scene.getlightmaps();
				if (this._lightmapIndex < lightMaps.length){
					this._defineDatas.add(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
					this._shaderValues.setTexture(3,lightMaps[this._lightmapIndex]);
					}else {
					this._defineDatas.remove(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
				}
				}else {
				this._defineDatas.remove(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
			}
		}

		/**
		*@private
		*/
		__proto._onWorldMatNeedChange=function(){
			this._boundingSphereNeedChange=true;
			this._boundingBoxNeedChange=true;
			this._boundingBoxCenterNeedChange=true;
			this._octreeNodeNeedChange=true;
		}

		/**
		*@private
		*/
		__proto._renderRenderableBoundBox=function(){
			var linePhasor=Laya3D._debugPhasorSprite;
			var boundBox=this.boundingBox;
			var corners=BaseRender._tempBoundBoxCorners;
			boundBox.getCorners(corners);
			linePhasor.line(corners[0],BaseRender._greenColor,corners[1],BaseRender._greenColor);
			linePhasor.line(corners[2],BaseRender._greenColor,corners[3],BaseRender._greenColor);
			linePhasor.line(corners[4],BaseRender._greenColor,corners[5],BaseRender._greenColor);
			linePhasor.line(corners[6],BaseRender._greenColor,corners[7],BaseRender._greenColor);
			linePhasor.line(corners[0],BaseRender._greenColor,corners[3],BaseRender._greenColor);
			linePhasor.line(corners[1],BaseRender._greenColor,corners[2],BaseRender._greenColor);
			linePhasor.line(corners[2],BaseRender._greenColor,corners[6],BaseRender._greenColor);
			linePhasor.line(corners[3],BaseRender._greenColor,corners[7],BaseRender._greenColor);
			linePhasor.line(corners[0],BaseRender._greenColor,corners[4],BaseRender._greenColor);
			linePhasor.line(corners[1],BaseRender._greenColor,corners[5],BaseRender._greenColor);
			linePhasor.line(corners[4],BaseRender._greenColor,corners[7],BaseRender._greenColor);
			linePhasor.line(corners[5],BaseRender._greenColor,corners[6],BaseRender._greenColor);
		}

		/**
		*@private
		*/
		__proto._calculateBoundingSphere=function(){
			throw("BaseRender: must override it.");
		}

		/**
		*@private
		*/
		__proto._calculateBoundingBox=function(){
			throw("BaseRender: must override it.");
		}

		/**
		*@private
		*/
		__proto._setBelongScene=function(scene){
			if (this._scene!==scene){
				this._scene=scene;
				this._applyLightMapParams();
			}
		}

		/**
		*@private
		*@param boundFrustum 如果boundFrustum为空则为摄像机不裁剪模式。
		*/
		__proto._needRender=function(boundFrustum){
			return true;
		}

		/**
		*@private
		*/
		__proto._renderUpdate=function(context,transform){}
		/**
		*@private
		*/
		__proto._updateOctreeNode=function(){
			var treeNode=this._treeNode;
			if (treeNode && this._octreeNodeNeedChange){
				treeNode.updateObject(this);
				this._octreeNodeNeedChange=false;
			}
		}

		/**
		*@private
		*/
		__proto._destroy=function(){
			this.offAll();
			var i=0,n=0;
			for (i=0,n=this._renderElements.length;i < n;i++)
			this._renderElements[i]._destroy();
			for (i=0,n=this._materials.length;i < n;i++)
			this._materials[i]._removeReference();
			this._renderElements=null;
			this._owner=null;
			this._materials=null;
			this._boundingBox=null;
			this._boundingBoxCenter=null;
			this._boundingSphere=null;
			this._lightmapScaleOffset=null;
			this._destroyed=true;
		}

		/**
		*获取包围球,只读,不允许修改其值。
		*@return 包围球。
		*/
		__getset(0,__proto,'boundingSphere',function(){
			if (this._boundingSphereNeedChange){
				this._calculateBoundingSphere();
				this._boundingSphereNeedChange=false;
			}
			return this._boundingSphere;
		});

		/**
		*获取唯一标识ID,通常用于识别。
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		/**
		*设置第一个实例材质。
		*@param value 第一个实例材质。
		*/
		/**
		*返回第一个实例材质,第一次使用会拷贝实例对象。
		*@return 第一个实例材质。
		*/
		__getset(0,__proto,'material',function(){
			var material=this._materials[0];
			if (material && !this._materialsInstance[0]){
				var insMat=this._getInstanceMaterial(material,0);
				var renderElement=this._renderElements[0];
				(renderElement)&& (renderElement.material=insMat);
			}
			return this._materials[0];
			},function(value){
			this.sharedMaterial=value;
		});

		/**
		*设置第一个材质。
		*@param value 第一个材质。
		*/
		/**
		*返回第一个材质。
		*@return 第一个材质。
		*/
		__getset(0,__proto,'sharedMaterial',function(){
			return this._materials[0];
			},function(value){
			var lastValue=this._materials[0];
			if (lastValue!==value){
				this._materials[0]=value;
				this._materialsInstance[0]=false;
				this._changeMaterialReference(lastValue,value);
				var renderElement=this._renderElements[0];
				(renderElement)&& (renderElement.material=value);
			}
		});

		/**
		*设置光照贴图的索引。
		*@param value 光照贴图的索引。
		*/
		/**
		*获取光照贴图的索引。
		*@return 光照贴图的索引。
		*/
		__getset(0,__proto,'lightmapIndex',function(){
			return this._lightmapIndex;
			},function(value){
			if (this._lightmapIndex!==value){
				this._lightmapIndex=value;
				this._applyLightMapParams();
			}
		});

		/**
		*设置光照贴图的缩放和偏移。
		*@param 光照贴图的缩放和偏移。
		*/
		/**
		*获取光照贴图的缩放和偏移。
		*@return 光照贴图的缩放和偏移。
		*/
		__getset(0,__proto,'lightmapScaleOffset',function(){
			return this._lightmapScaleOffset;
			},function(value){
			this._lightmapScaleOffset=value;
			this._shaderValues.setVector(2,value);
			this._defineDatas.add(RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV);
		});

		/**
		*设置是否可用。
		*@param value 是否可用。
		*/
		/**
		*获取是否可用。
		*@return 是否可用。
		*/
		__getset(0,__proto,'enable',function(){
			return this._enable;
			},function(value){
			this._enable=value;
			this.event("enablechanged",[this,value]);
		});

		/**
		*设置实例材质列表。
		*@param value 实例材质列表。
		*/
		/**
		*获取潜拷贝实例材质列表,第一次使用会拷贝实例对象。
		*@return 浅拷贝实例材质列表。
		*/
		__getset(0,__proto,'materials',function(){
			for (var i=0,n=this._materials.length;i < n;i++){
				if (!this._materialsInstance[i]){
					var insMat=this._getInstanceMaterial(this._materials[i],i);
					var renderElement=this._renderElements[i];
					(renderElement)&& (renderElement.material=insMat);
				}
			}
			return this._materials.slice();
			},function(value){
			this.sharedMaterials=value;
		});

		/**
		*设置材质列表。
		*@param value 材质列表。
		*/
		/**
		*获取浅拷贝材质列表。
		*@return 浅拷贝材质列表。
		*/
		__getset(0,__proto,'sharedMaterials',function(){
			var materials=this._materials.slice();
			return materials;
			},function(value){
			if (!value)
				throw new Error("MeshRender: shadredMaterials value can't be null.");
			var len=value.length;
			this._materialsInstance.length=len;
			for (var i=0;i < len;i++){
				var lastValue=this._materials[i];
				if (lastValue!==value[i]){
					this._materialsInstance[i]=false;
					this._changeMaterialReference(lastValue,value[i]);
					var renderElement=this._renderElements[i];
					(renderElement)&& (renderElement.material=value[i]);
				}
			}
			this._materials=value;
		});

		/**
		*获取包围盒,只读,不允许修改其值。
		*@return 包围盒。
		*/
		__getset(0,__proto,'boundingBox',function(){
			if (this._boundingBoxNeedChange){
				this._calculateBoundingBox();
				this._boundingBoxNeedChange=false;
			}
			return this._boundingBox;
		});

		/**
		*获取包围盒中心,不允许修改其值。
		*@return 包围盒中心。
		*/
		__getset(0,__proto,'boundingBoxCenter',function(){
			if (this._boundingBoxCenterNeedChange){
				var boundBox=this.boundingBox;
				Vector3.add(boundBox.min,boundBox.max,this._boundingBoxCenter);
				Vector3.scale(this._boundingBoxCenter,0.5,this._boundingBoxCenter);
				this._boundingBoxCenterNeedChange=false;
			}
			return this._boundingBoxCenter;
		});

		/**
		*设置是否接收阴影属性
		*/
		/**
		*获得是否接收阴影属性
		*/
		__getset(0,__proto,'receiveShadow',function(){
			return this._receiveShadow;
			},function(value){
			if (this._receiveShadow!==value){
				this._receiveShadow=value;
				if (value)
					this._defineDatas.add(RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW);
				else
				this._defineDatas.remove(RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW);
			}
		});

		/**
		*获取是否已销毁。
		*@return 是否已销毁。
		*/
		__getset(0,__proto,'destroyed',function(){
			return this._destroyed;
		});

		BaseRender._uniqueIDCounter=0;
		__static(BaseRender,
		['_tempBoundBoxCorners',function(){return this._tempBoundBoxCorners=[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];},'_greenColor',function(){return this._greenColor=new Vector4(0.0,1.0,0.0,1.0);}
		]);
		return BaseRender;
	})(EventDispatcher)


	//class laya.webgl.canvas.WebGLContext2D extends laya.resource.Context
	var WebGLContext2D=(function(_super){
		var ContextParams;
		function WebGLContext2D(c){
			this._x=0;
			this._y=0;
			this._id=++WebGLContext2D._COUNT;
			//this._other=null;
			//this._renderNextSubmitIndex=0;
			this._path=null;
			//this._primitiveValue2D=null;
			this._drawCount=1;
			this._maxNumEle=0;
			this._renderCount=0;
			this._isConvexCmd=true;
			this._submits=null;
			this._curSubmit=null;
			//this._mesh=null;
			//this._pathMesh=null;
			//this._triangleMesh=null;
			this.meshlist=[];
			this._clipTransed=false;
			this._clipInfoID=0;
			//this._curMat=null;
			this._nBlendType=0;
			//this._save=null;
			//this._targets=null;
			this._saveMark=null;
			//this.sprite=null;
			this._drawTextureUseColor=false;
			this._italicDeg=0;
			this._lastTex=null;
			this.mId=-1;
			this.mHaveKey=false;
			this.mHaveLineKey=false;
			WebGLContext2D.__super.call(this);
			this._width=99999999;
			this._height=99999999;
			this._submitKey=new SubmitKey();
			this._transedPoints=new Array(8);
			this._temp4Points=new Array(8);
			this._clipRect=WebGLContext2D.MAXCLIPRECT;
			this._transedClipInfo=new Array(6);
			this._shader2D=new Shader2D();
			this._charBook=new CharBook();
			this.mOutPoint
			this._canvas=c;
			WebGLContext2D._contextcount++;
			this.clear();
		}

		__class(WebGLContext2D,'laya.webgl.canvas.WebGLContext2D',_super);
		var __proto=WebGLContext2D.prototype;
		__proto.setIsMainContext=function(){}
		__proto.clearBG=function(r,g,b,a){
			var gl=WebGL.mainContext;
			gl.clearColor(r,g,b,a);
			gl.clear(0x00004000);
		}

		__proto._getSubmits=function(){
			return this._submits;
		}

		__proto._releaseMem=function(){
			if (!this._submits)
				return;
			this._curMat.destroy();
			this._curMat=null;
			this._shader2D.destroy();
			this._shader2D=null;
			for (var i=0,n=this._submits._length;i < n;i++){
				this._submits[i].releaseRender();
			}
			this._submits.length=0;
			this._submits._length=0;
			this._submits=null;
			this._curSubmit=null;
			this._path && this._path.recover();
			this._path=null;
			this._other && (this._other.font=null);
			this._save=null;
		}

		//TODO mesh 暂时releaseMem了
		__proto.destroy=function(){
			--WebGLContext2D._contextcount;
			this.sprite=null;
			this._releaseMem();
			this._targets && this._targets.destroy();
			this._targets=null;
			this._canvas=null;
			this._mesh.destroy();
		}

		__proto.clear=function(){
			if (!this._submits){
				this._other=ContextParams.DEFAULT;
				this._curMat=Matrix.create();
				this._mesh=MeshQuadTexture.getAMesh();
				this.meshlist.push(this._mesh);
				this._pathMesh=MeshVG.getAMesh();
				this.meshlist.push(this._pathMesh);
				this._triangleMesh=MeshTexture.getAMesh();
				this.meshlist.push(this._triangleMesh);
				this._submits=[];
				this._save=[SaveMark.Create(this)];
				this._save.length=10;
				this._shader2D=new Shader2D();
			}
			this._submitKey.clear();
			this._mesh.clearVB();
			Config.smartCache && (this._renderCount++);
			this._drawCount=1;
			this._other=ContextParams.DEFAULT;
			this._other.lineWidth=this._shader2D.ALPHA=1.0;
			this._nBlendType=0;
			this._clipRect=WebGLContext2D.MAXCLIPRECT;
			this._clipTransed=false;
			this._curSubmit=Submit.RENDERBASE;
			Submit.RENDERBASE._ref=0xFFFFFF;
			Submit.RENDERBASE._numEle=0;
			this._shader2D.fillStyle=this._shader2D.strokeStyle=DrawStyle.DEFAULT;
			for (var i=0,n=this._submits._length;i < n;i++)
			this._submits[i].releaseRender();
			this._submits._length=0;
			this._curMat.identity();
			this._other.clear();
			this._saveMark=this._save[0];
			this._save._length=1;
		}

		__proto.size=function(w,h){
			if (this._width !=w || this._height !=h){
				if (w==0 || h==0){
					for (var i=0,n=this._submits._length;i < n;i++)
					this._submits[i].releaseRender();
					this._submits.length=0;
					this._submits._length=0;
					this._curSubmit=null;
					this._path && this._path.recover();
					this._path=null;
					this.sprite=null;
					this._targets && (this._targets.destroy());
					this._targets=null;
					}else {
					this._width=w;
					this._height=h;
					this._targets && (this._targets.size(w,h));
					this._canvas.memorySize-=this._canvas.memorySize;
				}
			}
			if (w===0 && h===0)this._releaseMem();
		}

		//_targets=null;
		__proto._getTransformMatrix=function(){
			return this._curMat;
		}

		__proto.setAlpha=function(value,save){
			value=Math.floor(value*this._shader2D.ALPHA *1000)/ 1000;
			if (save && value !=this._shader2D.ALPHA)
				SaveBase.save(this,0x1,this._shader2D,false);
			this._shader2D.ALPHA=this._submitKey.alpha=value;
		}

		__proto._reCalculateBlendShader=function(){
			this._submitKey.blendShader=this._nBlendType+(this._shader2D.shader?this._shader2D.shader._id *100:0);
			if (this._shader2D.filters){
				this._submitKey.blendShader+=this._shader2D.filters.key / 10000;
				this._submitKey.blendShader=-this._submitKey.blendShader;
			}
		}

		__proto.translate=function(x,y){
			if (x!==0 || y!==0){
				this._clipTransed=false;
				SaveTranslate.save(this);
				if (this._curMat._bTransform){
					SaveTransform.save(this);
					this._curMat.tx+=(x *this._curMat.a+y *this._curMat.c);
					this._curMat.ty+=(x *this._curMat.b+y *this._curMat.d);
					}else{
					this._x+=x;
					this._y+=y;
				}
			}
		}

		__proto.save=function(){
			this._save[this._save._length++]=SaveMark.Create(this);
		}

		__proto.restore=function(){
			var sz=this._save._length;
			if (sz < 1)
				return;
			for (var i=sz-1;i >=0;i--){
				var o=this._save[i];
				o.restore(this);
				if (o.isSaveMark()){
					this._save._length=i;
					return;
				}
			}
		}

		/**
		*
		*@param txt
		*@param words HTMLChar 数组，是已经在外面排好版的一个数组
		*@param x
		*@param y
		*@param fontStr
		*@param color
		*@param strokeColor
		*@param lineWidth
		*@param textAlign
		*@param underLine
		*/
		__proto._fillText=function(txt,words,x,y,fontStr,color,strokeColor,lineWidth,textAlign,underLine){
			(underLine===void 0)&& (underLine=0);
			this._charBook.filltext(this,txt,x,y,fontStr,color,strokeColor,lineWidth,textAlign,underLine);
		}

		__proto.fillWords=function(words,x,y,fontStr,color,underLine){
			this._fillText(null,words,x,y,fontStr,color,null,-1,null,underLine);
		}

		__proto.fillBorderWords=function(words,x,y,font,color,borderColor,lineWidth){
			this._fillBorderText(null,words,x,y,font,color,borderColor,lineWidth,null);
		}

		__proto.drawText=function(text,x,y,font,color,textAlign){
			this._fillText(text,null,x,y,font,Color.create(color).strColor,null,-1,textAlign);
		}

		/**
		*只画边框
		*@param text
		*@param x
		*@param y
		*@param font
		*@param color
		*@param lineWidth
		*@param textAlign
		*/
		__proto.strokeWord=function(text,x,y,font,color,lineWidth,textAlign){
			debugger;
			this._fillText(text,null,x,y,font,null,Color.create(color).strColor,lineWidth || 1,textAlign);
		}

		/**
		*即画文字又画边框
		*@param txt
		*@param x
		*@param y
		*@param fontStr
		*@param fillColor
		*@param borderColor
		*@param lineWidth
		*@param textAlign
		*/
		__proto.fillBorderText=function(txt,x,y,fontStr,fillColor,borderColor,lineWidth,textAlign){
			this._fillBorderText(txt,null,x,y,fontStr,Color.create(fillColor).strColor,Color.create(borderColor).strColor,lineWidth,textAlign);
		}

		__proto._fillBorderText=function(txt,words,x,y,fontStr,fillColor,borderColor,lineWidth,textAlign){
			this._fillText(txt,words,x,y,fontStr,fillColor,borderColor,lineWidth || 1,textAlign);
		}

		__proto._fillRect=function(x,y,width,height,rgba){
			x+=this._x;
			y+=this._y;
			var submit=this._curSubmit;
			var sameKey=submit && (submit._key.submitType===2 && submit._key.blendShader===this._submitKey.blendShader);
			if (this._mesh.vertNum+4 > 65535){
				this._mesh=MeshQuadTexture.getAMesh();
				this.meshlist.push(this._mesh);
				sameKey=false;
			};
			var clipinfo=this.getTransedClipInfo();
			sameKey && (sameKey=sameKey&& this.isSameClipInfo(submit,clipinfo));
			this.transformQuad(x,y,width,height,0,this._curMat,this._transedPoints);
			if(!this.clipedOff(this._transedPoints)){
				this._mesh.addQuad(this._transedPoints,Texture.NO_UV,rgba,this.getTransedClipInfo(),false);
				if (!sameKey){
					var submit=this._curSubmit=SubmitTexture.create(this,this._mesh,Value2D.create(0x01,0));
					this._submits[this._submits._length++]=submit;
					this.copyClipInfo(submit,clipinfo);
					submit.shaderValue.textureHost=this._lastTex;
					submit._key.copyFrom2(this._submitKey,2,this._lastTex?this._lastTex.bitmap.id:-1);
					submit._renderType=10016;
				}
				this._curSubmit._numEle+=6;
				this._mesh.indexNum+=6;
				this._mesh.vertNum+=4;
			}
		}

		__proto.fillRect=function(x,y,width,height,fillStyle){
			var drawstyle=fillStyle? DrawStyle.create(fillStyle):this._shader2D.fillStyle;
			var rgba=this.mixRGBandAlpha(drawstyle.toInt());
			this._fillRect(x,y,width,height,rgba);
		}

		__proto.fillTexture=function(texture,x,y,width,height,type,offset,other){
			debugger;
		}

		/*
		if (!(texture.loaded && texture.bitmap && texture.source)){
			if (this.sprite){
				Laya.timer.callLater(this,this._repaintSprite);
			}
			return;
		}

		var vb:VertexBuffer2D=_mesh._vb;//TODO 这样不太好,不要直接操作_mesh._vb
		var w:Number=texture.bitmap.width,h:Number=texture.bitmap.height,uv:Array=texture.uv;
		var ox:Number=offset.x % texture.width,oy:Number=offset.y % texture.height;
		if (w !=other.w || h !=other.h){
			if (!other.w && !other.h){
				other.oy=other.ox=0;
				switch (type){
					case "repeat":
						other.width=width;
						other.height=height;
						break;
					case "repeat-x":
						other.width=width;
						if (oy < 0){
							if (texture.height+oy > height){
								other.height=height;
								}else {
								other.height=texture.height+oy;
							}
							}else {
							other.oy=oy;
							if (texture.height+oy > height){
								other.height=height-oy;
								}else {
								other.height=texture.height;
							}
						}
						break;
					case "repeat-y":
						if (ox < 0){
							if (texture.width+ox > width){
								other.width=width;
								}else {
								other.width=texture.width+ox;
							}
							}else {
							other.ox=ox;
							if (texture.width+ox > width){
								other.width=width-ox;
								}else {
								other.width=texture.width;
							}
						}
						other.height=height;
						break;
					default:
						other.width=width;
						other.height=height;
						break;
					}
			}
			other.w=w;
			other.h=h;
			other.uv=[0,0,other.width / w,0,other.width / w,other.height / h,0,other.height / h];
		}

		x+=other.ox;
		y+=other.oy;
		ox-=other.ox;
		oy-=other.oy;
		if (GlUtils.fillRectImgVb(vb,_clipRect,x,y,other.width,other.height,other.uv,_curMat)){
			var submit:SubmitTexture=SubmitTexture.create(this,_mesh,_mesh.indexNum,Value2D.create(ShaderDefines2D.FILLTEXTURE,0));
			submit._key.clear();
			_submits[_submits._length++]=submit;
			var shaderValue:FillTextureSV=submit.shaderValue as FillTextureSV;
			shaderValue.textureHost=texture;
			var tTextureX:Number=uv[0] *w;
			var tTextureY:Number=uv[1] *h;
			var tTextureW:Number=(uv[2]-uv[0])*w;
			var tTextureH:Number=(uv[5]-uv[3])*h;
			var tx:Number=-ox / w;
			var ty:Number=-oy / h;
			shaderValue.u_TexRange[0]=tTextureX / w;
			shaderValue.u_TexRange[1]=tTextureW / w;
			shaderValue.u_TexRange[2]=tTextureY / h;
			shaderValue.u_TexRange[3]=tTextureH / h;
			shaderValue.u_offset[0]=tx;
			shaderValue.u_offset[1]=ty;
			_curSubmit=submit;
			submit._renderType=Submit.TYPE_FILLTEXTURE;
			submit._numEle+=6;
			_mesh.vertNum+=4;
			_mesh.indexNum+=6;
		}

		*/
		__proto.setShader=function(shader){
			SaveBase.save(this,0x100000,this._shader2D,true);
			this._shader2D.shader=shader;
			this._reCalculateBlendShader();
		}

		__proto.setFilters=function(value){
			SaveBase.save(this,0x200000,this._shader2D,true);
			this._shader2D.filters=value;
			this._curSubmit=Submit.RENDERBASE;
			this._drawCount++;
			this._reCalculateBlendShader();
		}

		__proto.drawTexture=function(tex,x,y,width,height){
			this._drawTextureM(tex,x+this._x,y+this._y,width,height,null,1);
		}

		__proto.drawTextures=function(tex,pos,tx,ty){
			debugger;
		}

		/**
		*为drawTexture添加一个新的submit。类型是 SubmitTexture
		*@param vbSize
		*@param alpha
		*@param webGLImg
		*@param tex
		*/
		__proto._drawTextureAddSubmit=function(imgid,tex){
			var submit=null;
			submit=SubmitTexture.create(this,this._mesh,Value2D.create(0x01,0));
			this._submits[this._submits._length++]=submit;
			submit.shaderValue.textureHost=tex;
			submit._key.copyFrom2(this._submitKey,2,imgid);
			submit._renderType=10016;
			this._curSubmit=submit;
		}

		//shader.ALPHA=alphaBack;
		__proto._drawTextureM=function(tex,x,y,width,height,m,alpha,uv){
			if (!(tex._loaded && tex._getSource())){
				if (this.sprite){
					Laya.timer.callLater(this,this._repaintSprite);
				}
				return false;
			}
			this._inner_drawTexture(tex,tex.bitmap.id,x,y,width,height,m,alpha,uv);
		}

		__proto._drawRenderTexture=function(tex,x,y,width,height,m,alpha,uv){
			this._inner_drawTexture(tex,-1,x,y,width,height,m,alpha,uv);
		}

		__proto.submitDebugger=function(){
			this._submits[this._submits._length++]=SubmitCMD.create([],function(){debugger;});
		}

		__proto.copyClipInfo=function(submit,clipInfo){
			var cd=submit.shaderValue.clipDir;
			cd[0]=clipInfo[2];cd[1]=clipInfo[3];cd[2]=clipInfo[4];cd[3]=clipInfo[5];
			var cp=submit.shaderValue.clipRect;
			cp[0]=clipInfo[0];cp[1]=clipInfo[1];
			submit.clipInfoID=this._clipInfoID;
		}

		__proto.isSameClipInfo=function(submit,clipInfo){
			return (submit.clipInfoID===this._clipInfoID);
		}

		/**
		*
		*@param tex {Texture | RenderTexture }
		*@param imgid 图片id用来比较合并的
		*@param x
		*@param y
		*@param width
		*@param height
		*@param m
		*@param alpha
		*@param uv
		*@return
		*/
		__proto._inner_drawTexture=function(tex,imgid,x,y,width,height,m,alpha,uv){
			this._drawCount++;
			var preKey=this._curSubmit._key;
			var sameKey=imgid >=0 && preKey.submitType===2 && preKey.other===imgid;
			var clipInfo=this.getTransedClipInfo();
			sameKey && (sameKey=sameKey&& this.isSameClipInfo(this._curSubmit,clipInfo));
			this._lastTex=tex;
			var rgba=this.mixRGBandAlpha(this._drawTextureUseColor?(this.fillStyle?this.fillStyle.toInt():0):0xffffffff);
			if (this._mesh.vertNum+4 > 65535){
				this._mesh=MeshQuadTexture.getAMesh();
				this.meshlist.push(this._mesh);
				sameKey=false;
			}
			this.transformQuad(x,y,width || tex.width,height || tex.height,this._italicDeg,m || this._curMat,this._transedPoints);
			if(!this.clipedOff(this._transedPoints)){
				this._mesh.addQuad(this._transedPoints,uv || tex.uv,rgba,clipInfo,true);
				sameKey || this._drawTextureAddSubmit(imgid,tex);
				this.copyClipInfo(this._curSubmit,clipInfo);
				this._curSubmit._numEle+=6;
				this._mesh.indexNum+=6;
				this._mesh.vertNum+=4;
				this._maxNumEle=Math.max(this._maxNumEle,this._curSubmit._numEle);
				return true;
			}
			return false;
		}

		/**
		*转换4个顶点。为了效率这个不做任何检查。需要调用者的配合。
		*@param a 输入。8个元素表示4个点
		*@param out 输出
		*/
		__proto.transform4Points=function(a,m,out){
			if (m._bTransform){
				out[0]=a[0] *m.a+a[1] *m.c+m.tx;out[1]=a[0] *m.b+a[1] *m.d+m.ty;
				out[2]=a[2] *m.a+a[3] *m.c+m.tx;out[3]=a[2] *m.b+a[3] *m.d+m.ty;
				out[4]=a[4] *m.a+a[5] *m.c+m.tx;out[5]=a[4] *m.b+a[5] *m.d+m.ty;
				out[6]=a[6] *m.a+a[7] *m.c+m.tx;out[7]=a[6] *m.b+a[7] *m.d+m.ty;
				}else {
				out[0]=a[0]+m.tx;out[1]=a[1]+m.ty;
				out[2]=a[2]+m.tx;out[3]=a[3]+m.ty;
				out[4]=a[4]+m.tx;out[5]=a[5]+m.ty;
				out[6]=a[6]+m.tx;out[7]=a[7]+m.ty;
			}
		}

		/**
		*pt所描述的多边形完全在clip外边，整个被裁掉了
		*@param pt
		*@return
		*/
		__proto.clipedOff=function(pt){
			return false;
		}

		/**
		*应用当前矩阵。把转换后的位置放到输出数组中。
		*@param x
		*@param y
		*@param w
		*@param h
		*@param italicDeg 倾斜角度，单位是度。0度无，目前是下面不动。以后要做成可调的
		*/
		__proto.transformQuad=function(x,y,w,h,italicDeg,m,out){
			var xoff=0;
			if (italicDeg !=0){
				xoff=Math.tan(italicDeg *Math.PI / 180)*h;
			};
			var maxx=x+w;var maxy=y+h;
			this._temp4Points[0]=x+xoff;this._temp4Points[1]=y;
			this._temp4Points[2]=maxx+xoff;this._temp4Points[3]=y;
			this._temp4Points[4]=maxx;this._temp4Points[5]=maxy;
			this._temp4Points[6]=x;this._temp4Points[7]=maxy;
			this.transform4Points(this._temp4Points,m,out);
		}

		/**
		*
		*@param tex
		*@param imgid
		*@param pos 四个顶点
		*@param m null 则表示不用
		*@param alpha
		*@param uv
		*@return
		*/
		__proto._inner_drawTextureVerts=function(tex,imgid,pos,m,alpha,uv){}
		/*
		_drawCount++;
		var preKey:SubmitKey=_curSubmit._key;
		var sameKey:Boolean=imgid>=0 && preKey.submitType===Submit.KEY_DRAWTEXTURE && preKey.other===imgid ;
		var rgba=mixRGBandAlpha(_drawTextureUseColor?(fillStyle?fillStyle.toInt():0):0xffffffff);
		if (_mesh.vertNum+4 > _MAXVERTNUM){
			_mesh=MeshQuadTexture.getAMesh();//创建新的mesh TODO 如果_mesh不是常见格式，这里就不能这么做了。以后把_mesh单独表示成常用模式
			meshlist.push(_mesh);
			sameKey=false;//新的mesh不能算samekey了
		}

		//凡是这个都是在_mesh上操作，不用考虑samekey
		if (GlUtils.fillRectImgVb(_mesh._vb,_clipRect,x,y,width || tex.width,height || tex.height,uv || tex.uv,m || _curMat,rgba,this)){
			sameKey || _drawTextureAddSubmit(imgid,tex);
			_curSubmit._numEle+=6;
			_mesh.indexNum+=6;
			_mesh.vertNum+=4;
			_maxNumEle=Math.max(_maxNumEle,_curSubmit._numEle);
			return true;
		}

		return false;
		*/
		__proto._drawTextureM2=function(tex,x,y,width,height,_x,_y){
			debugger;
			return false;
		}

		__proto.pushRT=function(){
			this.addRenderObject(SubmitCMD.create(null,RenderTexture.pushRT));
		}

		__proto.popRT=function(){
			this.addRenderObject(SubmitCMD.create(null,RenderTexture.popRT));
			this.onChangeRT();
		}

		__proto.useRT=function(rt){
			function _use (rt){
				if (!rt){
					throw 'error useRT'
					}else{
					rt.start();
					rt.clear(0,0,0,0);
				}
			}
			this.addRenderObject(SubmitCMD.create([rt],_use));
			this.onChangeRT();
		}

		/**
		*异步执行rt的restore函数
		*@param rt
		*/
		__proto.RTRestore=function(rt){
			function _restore (rt){
				rt.restore();
			}
			this.addRenderObject(SubmitCMD.create([rt],_restore));
			this.onChangeRT();
		}

		/**
		*切换rt的时候需要做的一些处理
		*在生成submit阶段执行。
		*/
		__proto.onChangeRT=function(){
			this._curSubmit=Submit.RENDERBASE;
			this._shader2D.glTexture=null;
		}

		//绘制前置空下，保证不会被打包进上一个序列
		__proto._repaintSprite=function(){
			this.sprite && this.sprite.repaint();
		}

		/**
		*
		*@param tex
		*@param x
		*@param y
		*@param width
		*@param height
		*@param transform 图片本身希望的矩阵
		*@param tx 节点的位置
		*@param ty
		*@param alpha
		*/
		__proto.drawTextureWithTransform=function(tex,x,y,width,height,transform,tx,ty,alpha){
			if (!transform){
				this._drawTextureM(tex,x+tx,y+ty,width,height,null,alpha);
				return;
			};
			var curMat=this._curMat;
			WebGLContext2D._tmpMatrix.a=transform.a;WebGLContext2D._tmpMatrix.b=transform.b;WebGLContext2D._tmpMatrix.c=transform.c;WebGLContext2D._tmpMatrix.d=transform.d;WebGLContext2D._tmpMatrix.tx=transform.tx+tx;WebGLContext2D._tmpMatrix.ty=transform.ty+ty;
			if (transform && curMat._bTransform){
				Matrix.mul(WebGLContext2D._tmpMatrix,curMat,WebGLContext2D._tmpMatrix);
				transform=WebGLContext2D._tmpMatrix;
				transform._bTransform=false;
				}else {
				transform=WebGLContext2D._tmpMatrix;
			}
			this._drawTextureM(tex,x,y,width,height,transform,alpha);
		}

		__proto.drawTexture2Slow=function(x,y,pivotX,pivotY,transform,alpha,blendMode,args){
			if (alpha==0)return;
			var curMat=this._curMat;
			this._x=x *curMat.a+y *curMat.c;
			this._y=y *curMat.d+x *curMat.b;
			if (transform){
				if (curMat._bTransform || transform._bTransform){
					Matrix.mul(transform,curMat,WebGLContext2D._tmpMatrix);
					transform=WebGLContext2D._tmpMatrix;
					}else {
					this._x+=transform.tx+curMat.tx;
					this._y+=transform.ty+curMat.ty;
					transform=Matrix.EMPTY;
				}
			}
			if (alpha===1 && !blendMode)
				this._drawTextureM(args[0],args[1]-pivotX,args[2]-pivotY,args[3],args[4],transform,1);
			else {
				var preAlpha=this._shader2D.ALPHA;
				var preblendType=this._nBlendType;
				this._shader2D.ALPHA=alpha;
				blendMode && (this._nBlendType=BlendMode.TOINT(blendMode));
				this._drawTextureM(args[0],args[1]-pivotX,args[2]-pivotY,args[3],args[4],transform,1);
				this._shader2D.ALPHA=preAlpha;
				this._nBlendType=preblendType;
			}
			this._x=this._y=0;
		}

		__proto.drawTexture2=function(x,y,pivotX,pivotY,transform,alpha,blendMode,args){
			if (this._curMat._bTransform || transform || alpha!==1 || blendMode)
				this.drawTexture2Slow(x,y,pivotX,pivotY,transform,alpha,blendMode,args);
			else
			this._drawTextureM2(args[0],args[1]-pivotX,args[2]-pivotY,args[3],args[4],x,y);
		}

		/**
		**把ctx中的submits提交。结果渲染到target上
		*@param ctx
		*@param target
		*/
		__proto.flushRenderTarget=function(ctx,target){
			var gl=LayaGL.instance;
			target.start();
			ctx.flush();
			ctx.clear();
			target.restore();
		}

		/*
		RenderState2D.width=oldRSW;
		RenderState2D.height=oldRSH;
		gl.viewport(0,0,oldRSW,oldRSH);//TODO 如果不是这样呢
		*/
		__proto._flushToTarget=function(context,target){
			RenderState2D.worldScissorTest=false;
			WebGL.mainContext.disable(0x0C11);
			var preAlpha=RenderState2D.worldAlpha;
			var preMatrix4=RenderState2D.worldMatrix4;
			var preMatrix=RenderState2D.worldMatrix;
			var preShaderDefines=RenderState2D.worldShaderDefines;
			RenderState2D.worldMatrix=Matrix.EMPTY;
			RenderState2D.restoreTempArray();
			RenderState2D.worldMatrix4=RenderState2D.TEMPMAT4_ARRAY;
			RenderState2D.worldAlpha=1;
			BaseShader.activeShader=null;
			target.start();
			Config.showCanvasMark ? target.clear(0,1,0,0.3):target.clear(0,0,0,0);
			context._curSubmit=Submit.RENDERBASE;
			context.flush();
			context.clear();
			target.restore();
			context._curSubmit=Submit.RENDERBASE;
			BaseShader.activeShader=null;
			RenderState2D.worldAlpha=preAlpha;
			RenderState2D.worldMatrix4=preMatrix4;
			RenderState2D.worldMatrix=preMatrix;
		}

		//RenderState2D.worldShaderDefines=preShaderDefines;
		__proto.drawCanvas=function(canvas,x,y,width,height){
			var src=canvas.context;
			if (src._targets){
				if (src._submits._length > 0){
					var submit=SubmitCMD.create([src,src._targets],this._flushToTarget,this);
					this._submits[this._submits._length++]=submit;
				}
				this._drawRenderTexture(src._targets,x,y,width,height,null,1.0,RenderTexture.flipyuv);
				this._curSubmit=Submit.RENDERBASE;
				}else {
				var submit=this._submits[this._submits._length++]=SubmitCanvas.create(src,this._shader2D.ALPHA,this._shader2D.filters);
				submit._key.clear();
				var sx=width / canvas.width;
				var sy=height / canvas.height;
				var mat=submit._matrix;
				this._curMat.copyTo(mat);
				sx !=1 && sy !=1 && mat.scale(sx,sy);
				var tx=mat.tx,ty=mat.ty;
				mat.tx=mat.ty=0;
				mat.transformPoint(Point.TEMP.setTo(x,y));
				mat.translate(Point.TEMP.x+tx,Point.TEMP.y+ty);
				this._curSubmit=Submit.RENDERBASE;
			}
			if (Config.showCanvasMark){
				this.save();
				this.lineWidth=4;
				this.strokeStyle=src._targets ? "yellow" :"green";
				this.strokeRect(x-1,y-1,width+2,height+2,1);
				this.strokeRect(x,y,width,height,1);
				this.restore();
			}
		}

		__proto.drawTarget=function(scope,x,y,width,height,m,proName,shaderValue,uv,blend){
			(blend===void 0)&& (blend=-1);
			this._drawCount++;
			var rgba=this.mixRGBandAlpha(this._drawTextureUseColor?(this.fillStyle?this.fillStyle.toInt():0):0xffffffff);
			if (this._mesh.vertNum+4 > 65535){
				this._mesh=MeshQuadTexture.getAMesh();
				this.meshlist.push(this._mesh);
			}
			this.transformQuad(x,y,width,height,0,m || this._curMat,this._transedPoints);
			if(!this.clipedOff(this._transedPoints)){
				this._mesh.addQuad(this._transedPoints,uv || Texture.DEF_UV,0xffffffff,this.getTransedClipInfo(),true);
				var submit=this._curSubmit=SubmitTarget.create(this,this._mesh,shaderValue,proName);
				submit.blendType=(blend==-1)?this._nBlendType:blend;
				submit.scope=scope;
				this.copyClipInfo(submit,this.getTransedClipInfo());
				submit._numEle=6;
				this._mesh.indexNum+=6;
				this._mesh.vertNum+=4;
				this._maxNumEle=Math.max(this._maxNumEle,submit._numEle);
				this._submits[this._submits._length++]=submit;
				return true;
			}
			return false;
		}

		__proto.drawTriangles=function(tex,x,y,vertices,uvs,indices,matrix,alpha,color,blendMode){
			if (!(tex._loaded && tex._getSource())){
				if (this.sprite){
					Laya.timer.callLater(this,this._repaintSprite);
				}
				return false;
			}
			this._drawCount++;
			var webGLImg=tex.bitmap;
			var preKey=this._curSubmit._key;
			var sameKey=preKey.submitType===4 && preKey.other===webGLImg.id;
			var rgba=this._mixRGBandAlpha(0xffffffff,alpha);
			var vertNum=vertices.length / 2;
			var eleNum=indices.length;
			if (this._triangleMesh.vertNum+vertNum > 65535){
				this._triangleMesh=MeshTexture.getAMesh();
				this.meshlist.push(this._triangleMesh);
				sameKey=false;
			}
			if (!sameKey){
				var submit=this._curSubmit=SubmitTexture.create(this,this._triangleMesh,Value2D.create(0x01,0));
				submit.shaderValue.textureHost=tex;
				submit._key.copyFrom2(this._submitKey,4,webGLImg.id);
				submit._renderType=10016;
				this._submits[this._submits._length++]=submit;
			}
			WebGLContext2D._tmpMatrix.a=matrix.a;WebGLContext2D._tmpMatrix.b=matrix.b;WebGLContext2D._tmpMatrix.c=matrix.c;WebGLContext2D._tmpMatrix.d=matrix.d;WebGLContext2D._tmpMatrix.tx=matrix.tx+x;WebGLContext2D._tmpMatrix.ty=matrix.ty+y;
			Matrix.mul(WebGLContext2D._tmpMatrix,this._curMat,WebGLContext2D._tmpMatrix);
			this._triangleMesh.addData(vertices,uvs,indices,WebGLContext2D._tmpMatrix,rgba,this);
			this._curSubmit._numEle+=eleNum;
			this._maxNumEle=Math.max(this._maxNumEle,this._curSubmit._numEle);
			return true;
		}

		__proto.transform=function(a,b,c,d,tx,ty){
			SaveTransform.save(this);
			this._clipTransed=false;
			Matrix.mul(Matrix.TEMP.setTo(a,b,c,d,tx,ty),this._curMat,this._curMat);
			this._curMat._checkTransform();
		}

		__proto._transformByMatrix=function(matrix,tx,ty){
			matrix.setTranslate(tx,ty);
			Matrix.mul(matrix,this._curMat,this._curMat);
			matrix.setTranslate(0,0);
			this._curMat._bTransform=true;
			this._clipTransed=false;
		}

		__proto.setTransformByMatrix=function(value){
			value.copyTo(this._curMat);
			this._clipTransed=false;
		}

		__proto.transformByMatrix=function(value){
			SaveTransform.save(this);
			this._clipTransed=false;
			Matrix.mul(value,this._curMat,this._curMat);
			this._curMat._checkTransform();
		}

		__proto.rotate=function(angle){
			SaveTransform.save(this);
			this._clipTransed=false;
			this._curMat.rotateEx(angle);
		}

		__proto.scale=function(scaleX,scaleY){
			SaveTransform.save(this);
			this._clipTransed=false;
			this._curMat.scaleEx(scaleX,scaleY);
		}

		/**
		*获得受到矩阵缩放影响后的clip信息。
		*@return
		*/
		__proto.getTransedClipInfo=function(){
			if (this._clipTransed){
				return this._transedClipInfo;
			}
			this._clipInfoID=(++this._clipInfoID)% 10000;
			if (this._clipRect.width >=99999999){
				this._transedClipInfo[0]=0;this._transedClipInfo[1]=0;
				this._transedClipInfo[2]=99999999;this._transedClipInfo[3]=0;
				this._transedClipInfo[5]=99999999;this._transedClipInfo[4]=0;
				this._clipTransed=true;
				return this._transedClipInfo;
			}
			if(this._curMat._bTransform){
				this._transedClipInfo[0]=this._clipRect.x *this._curMat.a+this._clipRect.y *this._curMat.c+this._curMat.tx;
				this._transedClipInfo[1]=this._clipRect.x *this._curMat.b+this._clipRect.y *this._curMat.d+this._curMat.ty;
				this._transedClipInfo[2]=this._clipRect.width *this._curMat.a;
				this._transedClipInfo[3]=this._clipRect.width *this._curMat.b;
				this._transedClipInfo[4]=this._clipRect.height *this._curMat.c;
				this._transedClipInfo[5]=this._clipRect.height *this._curMat.d;
				}else {
				this._transedClipInfo[0]=this._clipRect.x+this._curMat.tx;
				this._transedClipInfo[1]=this._clipRect.y+this._curMat.ty;
				this._transedClipInfo[2]=this._clipRect.width;
				this._transedClipInfo[3]=0;
				this._transedClipInfo[4]=0;
				this._transedClipInfo[5]=this._clipRect.height;
			}
			this._clipTransed=true;
			return this._transedClipInfo;
		}

		__proto.clipRect=function(x,y,width,height){
			if (this._clipRect==WebGLContext2D.MAXCLIPRECT){
				this._clipRect=new Rectangle(x,y,width,height);
				}else {
				this._clipRect.width=width;
				this._clipRect.height=height;
				this._clipRect.x=x;
				this._clipRect.y=y;
			}
			this._clipTransed=false;
		}

		/**
		*从setIBVB改为drawMesh
		*type 参数不知道是干什么的，先删掉。offset好像跟attribute有关，删掉
		*@param x
		*@param y
		*@param ib
		*@param vb
		*@param numElement
		*@param mat
		*@param shader
		*@param shaderValues
		*@param startIndex
		*@param offset
		*/
		__proto.drawMesh=function(x,y,ib,vb,numElement,mat,shader,shaderValues,startIndex){
			(startIndex===void 0)&& (startIndex=0);
			debugger;
		}

		/*
		if (ib===null){
			ib=_ib;
			GlUtils.expandIBQuadrangle(ib,(vb._byteLength / (Buffer2D.FLOAT32 *vb.vertexStride *4)));//由于允许任意vb，所以这里不应该这么调用了。
		}

		if (!shaderValues || !shader)
			throw Error("setIBVB must input:shader shaderValues");
		var submit:SubmitOtherIBVB=SubmitOtherIBVB.create(this,vb,ib,numElement,shader,shaderValues,startIndex);
		mat || (mat=Matrix.EMPTY);
		mat.translate(x,y);
		Matrix.mul(mat,_curMat,submit._mat);
		mat.translate(-x,-y);
		_submits[this._submits._length++]=submit;
		submit._key.clear();
		_curSubmit=Submit.RENDERBASE;
		*/
		__proto.addRenderObject=function(o){
			this._submits[this._submits._length++]=o;
		}

		__proto.fillTrangles=function(tex,x,y,points,m){
			debugger;
		}

		/**
		*
		*@param start
		*@param end
		*/
		__proto.submitElement=function(start,end){
			var renderList=this._submits;
			end < 0 && (end=renderList._length);
			var submit=Submit.RENDERBASE;
			while (start < end){
				this._renderNextSubmitIndex=start+1;
				if (renderList[start]===Submit.RENDERBASE){
					start++;
					continue ;
				}
				Submit.preRender=submit;
				submit=renderList[start];
				start+=submit.renderSubmit();
			}
		}

		__proto.submitNextElement=function(count){
			return this.submitElement(this._renderNextSubmitIndex,this._renderNextSubmitIndex+count);
		}

		__proto.flush=function(){
			this.submitElement(0,this._submits._length);
			this._path && this._path.reset();
			SkinMeshBuffer.instance && SkinMeshBuffer.getInstance().reset();
			Stat.mesh2DNum+=this.meshlist.length;
			this._curSubmit=Submit.RENDERBASE;
			for (var i=0,sz=this.meshlist.length;i < sz;i++){
				var curm=this.meshlist[i];
				curm.canReuse?(curm.releaseMesh()):(curm.destroy());
			}
			this.meshlist.length=0;
			this._mesh=MeshQuadTexture.getAMesh();
			this._pathMesh=MeshVG.getAMesh();
			this._triangleMesh=MeshTexture.getAMesh();
			this.meshlist.push(this._mesh,this._pathMesh,this._triangleMesh);
			return this._submits._length;
		}

		__proto.setPathId=function(id){
			this.mId=id;
			if (this.mId !=-1){
				this.mHaveKey=false;
				var tVGM=VectorGraphManager.getInstance();
				if (tVGM.shapeDic[this.mId]){
					this.mHaveKey=true;
				}
				this.mHaveLineKey=false;
				if (tVGM.shapeLineDic[this.mId]){
					this.mHaveLineKey=true;
				}
			}
		}

		__proto.beginPath=function(convex){
			(convex===void 0)&& (convex=false);
			var tPath=this._getPath();
			tPath.beginPath(convex);
		}

		__proto.closePath=function(convex){
			this._path.closePath();
		}

		/**
		*添加一个path。
		*@param points [x,y,x,y....] 这个会被保存下来，所以调用者需要注意复制。
		*@param close 是否闭合
		*@param convex 是否是凸多边形。convex的优先级是这个最大。fill的时候的次之。其实fill的时候不应该指定convex，因为可以多个path
		*@param dx 需要添加的平移。这个需要在应用矩阵之前应用。
		*@param dy
		*/
		__proto.addPath=function(points,close,convex,dx,dy){
			var ci=0;
			var m=this._curMat;
			if(this._curMat._bTransform){
				for (var i=0,sz=points.length / 2;i < sz;i++){
					var x=points[ci]+dx,y=points[ci+1]+dy;
					points[ci]=x*m.a+y*m.c+m.tx;
					points[ci+1]=x*m.b+y*m.d+m.ty;
					ci+=2;
				}
				}else {
				if (m.tx==0 && m.ty==0 && !dx && !dy){}
					else {
					for (var i=0,sz=points.length / 2;i < sz;i++){
						var x=points[ci]+dx,y=points[ci+1]+dy;
						points[ci]=x+m.tx;
						points[ci+1]=y+m.ty;
						ci+=2;
					}
				}
			}
			this._getPath().push(points,convex);
		}

		__proto.fill=function(){
			var tPath=this._getPath();
			var submit=this._curSubmit;
			var sameKey=(submit._key.submitType===3 && submit._key.blendShader===this._submitKey.blendShader);
			sameKey && (sameKey=sameKey&&this.isSameClipInfo(submit,this.getTransedClipInfo()));
			if (!sameKey){
				this._curSubmit=this.addVGSubmit(this._pathMesh);
			};
			var rgba=this.mixRGBandAlpha(this.fillStyle.toInt());
			var curEleNum=0;
			for (var i=0,sz=tPath.paths.length;i < sz;i++){
				var p=tPath.paths[i];
				var vertNum=p.path.length / 2;
				if (this._pathMesh.vertNum+vertNum > 65535){
					this._curSubmit._numEle+=curEleNum;
					curEleNum=0;
					this._pathMesh=MeshVG.getAMesh();
					this._curSubmit=this.addVGSubmit(this._pathMesh);
				};
				var curvert=this._pathMesh.vertNum;
				if (p.convex){
					var faceNum=vertNum-2;
					var idx=new Array(faceNum *3);
					var idxpos=0;
					for (var fi=0;fi < faceNum;fi++){
						idx[idxpos++]=curvert;
						idx[idxpos++]=fi+1+curvert;
						idx[idxpos++]=fi+2+curvert;
					}
				}
				else {
					var idx=Earcut.earcut(p.path,null,2);
					if (curvert > 0){
						for (var ii=0;ii < idx.length;ii++){
							idx[ii]+=curvert;
						}
					}
				}
				this._pathMesh.addVertAndIBToMesh(this,p.path,rgba,idx);
				curEleNum+=idx.length;
			}
			this._curSubmit._numEle+=curEleNum;
		}

		__proto.addVGSubmit=function(mesh){
			var submit=Submit.createShape(this,mesh,0,Value2D.create(0x04,0));
			submit._key.blendShader=this._submitKey.blendShader;
			submit._key.submitType=3;
			this._submits[this._submits._length++]=submit;
			this.copyClipInfo(submit,this.getTransedClipInfo());
			return submit;
		}

		__proto.stroke=function(){
			if (this.lineWidth > 0){
				var rgba=this.mixRGBandAlpha(this.strokeStyle._color.numColor);
				var tPath=this._getPath();
				var submit=this._curSubmit;
				var sameKey=(submit._key.submitType===3 && submit._key.blendShader===this._submitKey.blendShader);
				sameKey && (sameKey=sameKey&& this.isSameClipInfo(submit,this.getTransedClipInfo()));
				if (!sameKey){
					this._curSubmit=this.addVGSubmit(this._pathMesh);
				};
				var curEleNum=0;
				for (var i=0,sz=tPath.paths.length;i < sz;i++){
					var p=tPath.paths[i];
					if (p.path.length <=0)
						continue ;
					var idx=[];
					var vertex=[];
					var maxVertexNum=p.path.length *2;
					if (this._pathMesh.vertNum+maxVertexNum > 65535){
						this._curSubmit._numEle+=curEleNum;
						curEleNum=0;
						this._pathMesh=MeshVG.getAMesh();
						this.meshlist.push(this._pathMesh);
						this._curSubmit=this.addVGSubmit(this._pathMesh);
					}
					BasePoly.createLine2(p.path,idx,this.lineWidth,this._pathMesh.vertNum,vertex,p.path.length / 2);
					this._pathMesh.addVertAndIBToMesh(this,vertex,rgba,idx);
					curEleNum+=idx.length;
				}
				this._curSubmit._numEle+=curEleNum;
			}
		}

		__proto.moveTo=function(x,y,b){
			(b===void 0)&& (b=true);
			var tPath=this._getPath();
			tPath.newPath();
			tPath._lastOriX=x;
			tPath._lastOriY=y;
			if (b){
				var _x1=x,_y1=y;
				x=this._curMat.a *_x1+this._curMat.c *_y1+this._curMat.tx;
				y=this._curMat.b *_x1+this._curMat.d *_y1+this._curMat.ty;
			}
			tPath.addPoint(x,y);
		}

		/**
		*
		*@param x
		*@param y
		*@param b 是否应用矩阵
		*/
		__proto.lineTo=function(x,y,b){
			(b===void 0)&& (b=true);
			var tPath=this._getPath();
			if (Math.abs(x-tPath._lastOriX)<1e-3 && Math.abs(y-tPath._lastOriY)<1e-3)
				return;
			tPath._lastOriX=x;
			tPath._lastOriY=y;
			if (b){
				var _x1=x,_y1=y;
				x=this._curMat.a *_x1+this._curMat.c *_y1+this._curMat.tx;
				y=this._curMat.b *_x1+this._curMat.d *_y1+this._curMat.ty;
			}
			tPath.addPoint(x,y);
		}

		/*
		override public function drawCurves(x:Number,y:Number,points:Array,lineColor:*,lineWidth:Number=1):void {
			//setPathId(-1);
			beginPath();
			strokeStyle=lineColor;
			this.lineWidth=lineWidth;
			var points:Array=points;
			//movePath(x,y);TODO 这个被去掉了
			moveTo(points[0],points[1]);
			var i:int=2,n:int=points.length;
			while (i < n){
				quadraticCurveTo(points[i++],points[i++],points[i++],points[i++]);
			}
			stroke();
		}

		*/
		__proto.arcTo=function(x1,y1,x2,y2,r){
			var i=0;
			var x=0,y=0;
			var dx=this._path._lastOriX-x1;
			var dy=this._path._lastOriY-y1;
			var len1=Math.sqrt(dx*dx+dy*dy);
			if (len1 <=0.000001){
				return;
			};
			var ndx=dx / len1;
			var ndy=dy / len1;
			var dx2=x2-x1;
			var dy2=y2-y1;
			var len22=dx2*dx2+dy2*dy2;
			var len2=Math.sqrt(len22);
			if (len2 <=0.000001){
				return;
			};
			var ndx2=dx2 / len2;
			var ndy2=dy2 / len2;
			var odx=ndx+ndx2;
			var ody=ndy+ndy2;
			var olen=Math.sqrt(odx*odx+ody*ody);
			if (olen <=0.000001){
				return;
			};
			var nOdx=odx / olen;
			var nOdy=ody / olen;
			var alpha=Math.acos(nOdx*ndx+nOdy*ndy);
			var halfAng=Math.PI / 2-alpha;
			len1=r / Math.tan(halfAng);
			var ptx1=len1*ndx+x1;
			var pty1=len1*ndy+y1;
			var orilen=Math.sqrt(len1 *len1+r *r);
			var orix=x1+nOdx*orilen;
			var oriy=y1+nOdy*orilen;
			var ptx2=len1*ndx2+x1;
			var pty2=len1*ndy2+y1;
			var dir=ndx *ndy2-ndy *ndx2;
			var fChgAng=0;
			var sinx=0.0;
			var cosx=0.0;
			if (dir >=0){
				fChgAng=halfAng *2;
				var fda=fChgAng / WebGLContext2D.SEGNUM;
				sinx=Math.sin(fda);
				cosx=Math.cos(fda);
			}
			else {
				fChgAng=-halfAng *2;
				fda=fChgAng / WebGLContext2D.SEGNUM;
				sinx=Math.sin(fda);
				cosx=Math.cos(fda);
			};
			var lastx=this._path._lastOriX,lasty=this._path._lastOriY;
			var _x1=ptx1 ,_y1=pty1;
			if (Math.abs(_x1-this._path._lastOriX)>0.1 || Math.abs(_y1-this._path._lastOriY)>0.1){
				x=this._curMat.a *_x1+this._curMat.c *_y1+this._curMat.tx;
				y=this._curMat.b *_x1+this._curMat.d *_y1+this._curMat.ty;
				lastx=_x1;
				lasty=_y1;
				this._path.addPoint(x,y);
			};
			var cvx=ptx1-orix;
			var cvy=pty1-oriy;
			var tx=0.0;
			var ty=0.0;
			for (i=0;i < WebGLContext2D.SEGNUM;i++){
				var cx=cvx*cosx+cvy*sinx;
				var cy=-cvx*sinx+cvy*cosx;
				x=cx+orix;
				y=cy+oriy;
				if (Math.abs(lastx-x)>0.1 || Math.abs(lasty-y)>0.1){
					var _x1=x,_y1=y;
					x=this._curMat.a *_x1+this._curMat.c *_y1+this._curMat.tx;
					y=this._curMat.b *_x1+this._curMat.d *_y1+this._curMat.ty;
					this._path.addPoint(x,y);
					lastx=x;
					lasty=y;
				}
				cvx=cx;
				cvy=cy;
			}
		}

		__proto.arc=function(cx,cy,r,startAngle,endAngle,counterclockwise,b){
			(counterclockwise===void 0)&& (counterclockwise=false);
			(b===void 0)&& (b=true);
			var a=0,da=0,hda=0,kappa=0;
			var dx=0,dy=0,x=0,y=0,tanx=0,tany=0;
			var px=0,py=0,ptanx=0,ptany=0;
			var i=0,ndivs=0,nvals=0;
			da=endAngle-startAngle;
			if (!counterclockwise){
				if (Math.abs(da)>=Math.PI *2){
					da=Math.PI *2;
					}else {
					while (da < 0.0){
						da+=Math.PI *2;
					}
				}
				}else {
				if (Math.abs(da)>=Math.PI *2){
					da=-Math.PI *2;
					}else {
					while (da > 0.0){
						da-=Math.PI *2;
					}
				}
			}
			if (r < 101){
				ndivs=Math.max(10,da *r / 5);
				}else if (r < 201){
				ndivs=Math.max(10,da *r / 20);
				}else {
				ndivs=Math.max(10,da *r / 40);
			}
			hda=(da / ndivs)/ 2.0;
			kappa=Math.abs(4 / 3 *(1-Math.cos(hda))/ Math.sin(hda));
			if (counterclockwise)
				kappa=-kappa;
			nvals=0;
			var tPath=this._getPath();
			var _x1=NaN,_y1=NaN;
			for (i=0;i <=ndivs;i++){
				a=startAngle+da *(i / ndivs);
				dx=Math.cos(a);
				dy=Math.sin(a);
				x=cx+dx *r;
				y=cy+dy *r;
				if (x !=this._path._lastOriX|| y !=this._path._lastOriY){
					var _x1=x,_y1=y;
					x=this._curMat.a *_x1+this._curMat.c *_y1+this._curMat.tx;
					y=this._curMat.b *_x1+this._curMat.d *_y1+this._curMat.ty;
					tPath.addPoint(x,y);
				}
			}
			dx=Math.cos(endAngle);
			dy=Math.sin(endAngle);
			x=cx+dx *r;
			y=cy+dy *r;
			if (x !=this._path._lastOriX|| y !=this._path._lastOriY){
				var _x1=x,_y1=y;
				x=this._curMat.a *_x1+this._curMat.c *_y1+this._curMat.tx;
				y=this._curMat.b *_x1+this._curMat.d *_y1+this._curMat.ty;
				tPath.addPoint(x,y);
			}
		}

		__proto.quadraticCurveTo=function(cpx,cpy,x,y){
			var tBezier=Bezier.I;
			var tResultArray=[];
			var tArray=tBezier.getBezierPoints([this._path._lastOriX,this._path._lastOriY,cpx,cpy,x,y],30,2);
			for (var i=0,n=tArray.length / 2;i < n;i++){
				this.lineTo(tArray[i *2],tArray[i *2+1]);
			}
			this.lineTo(x,y);
		}

		__proto.rect=function(x,y,width,height){
			this._other=this._other.make();
			this._other.path || (this._other.path=new Path());
			this._other.path.rect(x,y,width,height);
		}

		/**
		*把颜色跟当前设置的alpha混合
		*@return
		*/
		__proto.mixRGBandAlpha=function(color){
			return this._mixRGBandAlpha(color,this._shader2D.ALPHA);
		}

		__proto._mixRGBandAlpha=function(color,alpha){
			var a=((color & 0xff000000)>>> 24);
			if (a !=0){
				a*=alpha;
				}else {
				a=alpha*255;
			}
			return (color & 0x00ffffff)| (a << 24);
		}

		__proto.strokeRect=function(x,y,width,height,parameterLineWidth){
			x+=this._x;
			y+=this._y;
			var tW=parameterLineWidth *0.5;
			if (this.lineWidth > 0){
				var rgba=this.mixRGBandAlpha(this.strokeStyle._color.numColor);
				var hw=this.lineWidth / 2;
				this._fillRect(x-hw,y-hw,width+this.lineWidth,this.lineWidth,rgba);
				this._fillRect(x-hw,y-hw+height,width+this.lineWidth,this.lineWidth,rgba);
				this._fillRect(x-hw,y+hw,this.lineWidth,height-this.lineWidth,rgba);
				this._fillRect(x-hw+width,y+hw,this.lineWidth,height-this.lineWidth,rgba);
			}
		}

		//右
		__proto.clip=function(){}
		/*******************************************end矢量绘制***************************************************/
		__proto.drawParticle=function(x,y,pt){
			pt.x=x;
			pt.y=y;
			this._submits[this._submits._length++]=pt;
		}

		__proto._getPath=function(){
			return this._path || (this._path=new Path());
		}

		/*******************************************自动缓存处理***************************************************/
		__proto.smartCacheStart=function(value){
			debugger;
		}

		/*
		_curSubmit=Submit.RENDERBASE;
		value.clear();
		value.vbIndex=_vb._byteLength >> 2;
		value.submitIndex=_submits._length;
		value.spriteCount=-Stat.spriteCount;
		*/
		__proto.smartCacheEnd=function(value,x,y,scrollRect){
			debugger;
		}

		/*
		var i:int=value.submitIndex,s:int=0,n:int=_submits._length;
		for (;i < n;i++,s++)(value.submit[s]=_submits[i])._ref++;
		value.submit.length=s;
		if (scrollRect){
			x-=scrollRect.x;
			y-=scrollRect.y;
		}

		value.x=x;
		value.y=y;
		value.spriteCount+=Stat.spriteCount;
		value.nVb=(_vb._byteLength >> 2)-value.vbIndex;
		_curSubmit=Submit.RENDERBASE;
		*/
		__proto._moveCacheVBPos=function(vbdata,i,n,dx,dy){
			n+=i;
			if (dy===0){
				for (;i < n;i+=16){
					vbdata[i]+=dx;
					vbdata[i+4]+=dx;
					vbdata[i+8]+=dx;
					vbdata[i+12]+=dx;
				}
			}
			else if (dx===0){
				for (;i < n;i+=16){
					vbdata[i+1]+=dy;
					vbdata[i+5]+=dy;
					vbdata[i+9]+=dy;
					vbdata[i+13]+=dy;
				}
			}
			else{
				for (;i < n;i+=16){
					vbdata[i]+=dx;
					vbdata[i+1]+=dy;
					vbdata[i+4]+=dx;
					vbdata[i+5]+=dy;
					vbdata[i+8]+=dx;
					vbdata[i+9]+=dy;
					vbdata[i+12]+=dx;
					vbdata[i+13]+=dy;
				}
			}
		}

		__proto.smartCacheCopy=function(value,x,y,scrollRect){
			debugger;
		}

		//=============新增==================
		__proto.saveTransform=function(matrix){
			this._curMat.copyTo(matrix);
		}

		__proto.restoreTransform=function(matrix){
			matrix.copyTo(this._curMat);
		}

		__proto.transformByMatrix=function(matrix,tx,ty){
			var mat=this._curMat;
			matrix.setTranslate(tx,ty);
			Matrix.mul(matrix,mat,mat);
			matrix.setTranslate(0,0);
			mat._bTransform=true;
		}

		__getset(0,__proto,'globalCompositeOperation',function(){
			return BlendMode.NAMES[this._nBlendType];
			},function(value){
			var n=BlendMode.TOINT[value];
			n==null || (this._nBlendType===n)|| (SaveBase.save(this,0x10000,this,true),this._curSubmit=Submit.RENDERBASE,this._nBlendType=n ,this._reCalculateBlendShader());
		});

		__getset(0,__proto,'strokeStyle',function(){
			return this._shader2D.strokeStyle;
			},function(value){
			this._shader2D.strokeStyle.equal(value)|| (SaveBase.save(this,0x200,this._shader2D,false),this._shader2D.strokeStyle=DrawStyle.create(value),this._submitKey.other=-this._shader2D.strokeStyle.toInt());
		});

		__getset(0,__proto,'globalAlpha',function(){
			return this._shader2D.ALPHA;
			},function(value){
			value=Math.floor(value *1000)/ 1000;
			if (value !=this._shader2D.ALPHA){
				SaveBase.save(this,0x1,this._shader2D,false);
				this._shader2D.ALPHA=this._submitKey.alpha=value;
			}
		});

		/**
		*当前canvas请求保存渲染结果。
		*实现：
		*如果value==true，就要给_target赋值
		*@param value {Boolean}
		*/
		__getset(0,__proto,'asBitmap',null,function(value){
			if (value){
				this._targets || (this._targets=new RenderTexture(this._width,this._height,1,-1));
				this._targets.tex_fun=null;
				this._targets.tex_funThis=this;
				this._targets.tex_funargs=null;
				if (!this._width || !this._height)
					throw Error("asBitmap no size!");
			}else{}
		});

		__getset(0,__proto,'fillStyle',function(){
			return this._shader2D.fillStyle;
			},function(value){
			this._shader2D.fillStyle.equal(value)||
			(SaveBase.save(this,0x2,this._shader2D,false),this._shader2D.fillStyle=DrawStyle.create(value),this._submitKey.other=-this._shader2D.fillStyle.toInt());
		});

		__getset(0,__proto,'textAlign',function(){
			return this._other.textAlign;
			},function(value){
			(this._other.textAlign===value)|| (this._other=this._other.make(),SaveBase.save(this,0x8000,this._other,false),this._other.textAlign=value);
		});

		__getset(0,__proto,'lineWidth',function(){
			return this._other.lineWidth;
			},function(value){
			(this._other.lineWidth===value)|| (this._other=this._other.make(),SaveBase.save(this,0x100,this._other,false),this._other.lineWidth=value);
		});

		__getset(0,__proto,'textBaseline',function(){
			return this._other.textBaseline;
			},function(value){
			(this._other.textBaseline===value)|| (this._other=this._other.make(),SaveBase.save(this,0x4000,this._other,false),this._other.textBaseline=value);
		});

		__getset(0,__proto,'font',null,function(str){
			if (str==this._other.font.toString())
				return;
			this._other=this._other.make();
			SaveBase.save(this,0x8,this._other,false);
			this._other.font===FontInContext.EMPTY ? (this._other.font=new FontInContext(str)):(this._other.font.setFont(str));
		});

		WebGLContext2D.__init__=function(){
			ContextParams.DEFAULT=new ContextParams();
		}

		WebGLContext2D._tempPoint=new Point();
		WebGLContext2D._SUBMITVBSIZE=32000;
		WebGLContext2D._MAXSIZE=99999999;
		WebGLContext2D._MAXVERTNUM=65535;
		WebGLContext2D.MAXCLIPRECT=new Rectangle(0,0,99999999,99999999);
		WebGLContext2D._COUNT=0;
		WebGLContext2D._tmpMatrix=new Matrix();
		WebGLContext2D.SEGNUM=32;
		WebGLContext2D._contextcount=0;
		__static(WebGLContext2D,
		['_fontTemp',function(){return this._fontTemp=new FontInContext();},'_drawStyleTemp',function(){return this._drawStyleTemp=new DrawStyle(null);},'_keyMap',function(){return this._keyMap=new StringKey();}
		]);
		WebGLContext2D.__init$=function(){
			//class ContextParams
			ContextParams=(function(){
				function ContextParams(){
					this.lineWidth=1;
					this.path=null;
					this.textAlign=null;
					this.textBaseline=null;
					this.font=FontInContext.EMPTY;
				}
				__class(ContextParams,'');
				var __proto=ContextParams.prototype;
				__proto.clear=function(){
					this.lineWidth=1;
					this.path && this.path.clear();
					this.textAlign=this.textBaseline=null;
					this.font=FontInContext.EMPTY;
				}
				__proto.make=function(){
					return this===ContextParams.DEFAULT ? new ContextParams():this;
				}
				ContextParams.DEFAULT=null
				return ContextParams;
			})()
		}

		return WebGLContext2D;
	})(Context)


	/**
	*@private
	*Canvas版本的SkinMesh
	*/
	//class laya.ani.bone.canvasmesh.SkinMeshCanvas extends laya.ani.bone.canvasmesh.CanvasMeshRender
	var SkinMeshCanvas=(function(_super){
		function SkinMeshCanvas(){
			SkinMeshCanvas.__super.call(this);
			this.mesh=new MeshData();
		}

		__class(SkinMeshCanvas,'laya.ani.bone.canvasmesh.SkinMeshCanvas',_super);
		var __proto=SkinMeshCanvas.prototype;
		__proto.init2=function(texture,ps,verticles,uvs){
			if (this.transform){
				this.transform=null;
			};
			var _ps=ps || [0,1,3,3,1,2];
			this.mesh.texture=texture;
			this.mesh.indexes=_ps;
			this.mesh.vertices=verticles;
			this.mesh.uvs=uvs;
		}

		__proto.render=function(context,x,y){
			if(!this.mesh.texture)return;
			if(!this.transform){
				this.transform=SkinMeshCanvas._tempMatrix;
				this.transform.identity();
				this.transform.translate(x,y);
				this.renderToContext(context);
				this.transform.translate(-x,-y);
				this.transform=null;
				}else{
				this.transform.translate(x,y);
				this.renderToContext(context);
				this.transform.translate(-x,-y);
			}
		}

		__static(SkinMeshCanvas,
		['_tempMatrix',function(){return this._tempMatrix=new Matrix();}
		]);
		return SkinMeshCanvas;
	})(CanvasMeshRender)


	/**
	*<code>Transform3D</code> 类用于实现3D变换。
	*/
	//class laya.d3.core.Transform3D extends laya.events.EventDispatcher
	var Transform3D=(function(_super){
		function Transform3D(owner){
			this._owner=null;
			this._localQuaternionUpdate=false;
			this._locaEulerlUpdate=false;
			this._localUpdate=false;
			this._worldUpdate=true;
			this._positionUpdate=true;
			this._rotationUpdate=true;
			this._scaleUpdate=true;
			this._parent=null;
			this._children=null;
			this._dummy=null;
			this.pivot=null;
			Transform3D.__super.call(this);
			this._localPosition=new Vector3();
			this._localRotation=new Quaternion(0,0,0,1);
			this._localScale=new Vector3(1,1,1);
			this._localRotationEuler=new Vector3();
			this._localMatrix=new Matrix4x4();
			this._position=new Vector3();
			this._rotation=new Quaternion(0,0,0,1);
			this._scale=new Vector3(1,1,1);
			this._worldMatrix=new Matrix4x4();
			this._forward=new Vector3();
			this._up=new Vector3();
			this._right=new Vector3();
			this._owner=owner;
			this._children=[];
		}

		__class(Transform3D,'laya.d3.core.Transform3D',_super);
		var __proto=Transform3D.prototype;
		/**
		*@private
		*/
		__proto._updateLocalMatrix=function(){
			if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0)){
				var scalePivot=Transform3D._tempVector30;
				Vector3.multiply(this.pivot,this._localScale,scalePivot);
				var scaleOffsetPosition=Transform3D._tempVector31;
				Vector3.subtract(scalePivot,this.pivot,scaleOffsetPosition);
				var rotationOffsetPosition=Transform3D._tempVector32;
				var localRot=this.localRotation;
				Vector3.transformQuat(scalePivot,localRot,rotationOffsetPosition);
				Vector3.subtract(rotationOffsetPosition,scalePivot,rotationOffsetPosition);
				var resultLocalPosition=Transform3D._tempVector33;
				Vector3.subtract(this._localPosition,scaleOffsetPosition,resultLocalPosition);
				Vector3.subtract(resultLocalPosition,rotationOffsetPosition,resultLocalPosition);
				Matrix4x4.createAffineTransformation(resultLocalPosition,localRot,this._localScale,this._localMatrix);
				}else {
				Matrix4x4.createAffineTransformation(this._localPosition,this.localRotation,this._localScale,this._localMatrix);
			}
		}

		/**
		*@private
		*/
		__proto._onWorldPositionRotationTransform=function(){
			if (!this._worldUpdate || !this._positionUpdate || !this._rotationUpdate){
				this._worldUpdate=this._positionUpdate=this._rotationUpdate=true;
				this.event("worldmatrixneedchanged");
				for (var i=0,n=this._children.length;i < n;i++)
				this._children[i]._onWorldPositionRotationTransform();
			}
		}

		/**
		*@private
		*/
		__proto._onWorldPositionScaleTransform=function(){
			if (!this._worldUpdate || !this._positionUpdate || !this._scaleUpdate){
				this._worldUpdate=this._positionUpdate=this._scaleUpdate=true;
				this.event("worldmatrixneedchanged");
				for (var i=0,n=this._children.length;i < n;i++)
				this._children[i]._onWorldPositionScaleTransform();
			}
		}

		/**
		*@private
		*/
		__proto._onWorldPositionTransform=function(){
			if (!this._worldUpdate || !this._positionUpdate){
				this._worldUpdate=this._positionUpdate=true;
				this.event("worldmatrixneedchanged");
				for (var i=0,n=this._children.length;i < n;i++)
				this._children[i]._onWorldPositionTransform();
			}
		}

		/**
		*@private
		*/
		__proto._onWorldRotationTransform=function(){
			if (!this._worldUpdate || !this._rotationUpdate){
				this._worldUpdate=this._rotationUpdate=true;
				this.event("worldmatrixneedchanged");
				for (var i=0,n=this._children.length;i < n;i++)
				this._children[i]._onWorldPositionRotationTransform();
			}
		}

		/**
		*@private
		*/
		__proto._onWorldScaleTransform=function(){
			if (!this._worldUpdate || !this._scaleUpdate){
				this._worldUpdate=this._scaleUpdate=true;
				this.event("worldmatrixneedchanged");
				for (var i=0,n=this._children.length;i < n;i++)
				this._children[i]._onWorldPositionScaleTransform();
			}
		}

		/**
		*@private
		*/
		__proto._onWorldTransform=function(){
			if (!this._worldUpdate || !this._positionUpdate || !this._rotationUpdate || !this._scaleUpdate){
				this._worldUpdate=this._positionUpdate=this._rotationUpdate=this._scaleUpdate=true;
				this.event("worldmatrixneedchanged");
				for (var i=0,n=this._children.length;i < n;i++)
				this._children[i]._onWorldTransform();
			}
		}

		/**
		*平移变换。
		*@param translation 移动距离。
		*@param isLocal 是否局部空间。
		*/
		__proto.translate=function(translation,isLocal){
			(isLocal===void 0)&& (isLocal=true);
			if (isLocal){
				Matrix4x4.createFromQuaternion(this.localRotation,Transform3D._tempMatrix0);
				Vector3.transformCoordinate(translation,Transform3D._tempMatrix0,Transform3D._tempVector30);
				Vector3.add(this.localPosition,Transform3D._tempVector30,this._localPosition);
				this.localPosition=this._localPosition;
				}else {
				Vector3.add(this.position,translation,this._position);
				this.position=this._position;
			}
		}

		/**
		*旋转变换。
		*@param rotations 旋转幅度。
		*@param isLocal 是否局部空间。
		*@param isRadian 是否弧度制。
		*/
		__proto.rotate=function(rotation,isLocal,isRadian){
			(isLocal===void 0)&& (isLocal=true);
			(isRadian===void 0)&& (isRadian=true);
			var rot;
			if (isRadian){
				rot=rotation;
				}else {
				Vector3.scale(rotation,Math.PI / 180.0,Transform3D._tempVector30);
				rot=Transform3D._tempVector30;
			}
			Quaternion.createFromYawPitchRoll(rot.y,rot.x,rot.z,Transform3D._tempQuaternion0);
			if (isLocal){
				Quaternion.multiply(this._localRotation,Transform3D._tempQuaternion0,this._localRotation);
				this.localRotation=this._localRotation;
				}else {
				Quaternion.multiply(Transform3D._tempQuaternion0,this.rotation,this._rotation);
				this.rotation=this._rotation;
			}
		}

		/**
		*观察目标位置。
		*@param target 观察目标。
		*@param up 向上向量。
		*@param isLocal 是否局部空间。
		*/
		__proto.lookAt=function(target,up,isLocal){
			(isLocal===void 0)&& (isLocal=false);
			var targetE=target.elements;
			var eyeE;
			if (isLocal){
				eyeE=this._localPosition.elements;
				if (Math.abs(eyeE[0]-targetE[0])< MathUtils3D.zeroTolerance && Math.abs(eyeE[1]-targetE[1])< MathUtils3D.zeroTolerance && Math.abs(eyeE[2]-targetE[2])< MathUtils3D.zeroTolerance)
					return;
				Quaternion.lookAt(this._localPosition,target,up,this._localRotation);
				this._localRotation.invert(this._localRotation);
				this.localRotation=this._localRotation;
				}else {
				var worldPosition=this.position;
				eyeE=worldPosition.elements;
				if (Math.abs(eyeE[0]-targetE[0])< MathUtils3D.zeroTolerance && Math.abs(eyeE[1]-targetE[1])< MathUtils3D.zeroTolerance && Math.abs(eyeE[2]-targetE[2])< MathUtils3D.zeroTolerance)
					return;
				Quaternion.lookAt(worldPosition,target,up,this._rotation);
				this._rotation.invert(this._rotation);
				this.rotation=this._rotation;
			}
		}

		/**
		*@private
		*/
		__getset(0,__proto,'_isFrontFaceInvert',function(){
			var scale=this.scale;
			var isInvert=scale.x < 0;
			(scale.y < 0)&& (isInvert=!isInvert);
			(scale.z < 0)&& (isInvert=!isInvert);
			return isInvert;
		});

		/**
		*获取所属精灵。
		*/
		__getset(0,__proto,'owner',function(){
			return this._owner;
		});

		/**
		*设置局部旋转。
		*@param value 局部旋转。
		*/
		/**
		*获取局部旋转。
		*@return 局部旋转。
		*/
		__getset(0,__proto,'localRotation',function(){
			if (this._localQuaternionUpdate){
				var eulerE=this._localRotationEuler.elements;
				Quaternion.createFromYawPitchRoll(eulerE[1] / Transform3D._angleToRandin,eulerE[0] / Transform3D._angleToRandin,eulerE[2] / Transform3D._angleToRandin,this._localRotation);
			}
			return this._localRotation;
			},function(value){
			this._localRotation=value;
			this._localRotation.normalize(this._localRotation);
			this._locaEulerlUpdate=true;
			this._localQuaternionUpdate=false;
			this._localUpdate=true;
			if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0))
				this._onWorldPositionRotationTransform();
			else
			this._onWorldRotationTransform();
		});

		/**
		*设置世界矩阵。
		*@param value 世界矩阵。
		*/
		/**
		*获取世界矩阵。
		*@return 世界矩阵。
		*/
		__getset(0,__proto,'worldMatrix',function(){
			if (this._worldUpdate){
				if (this._parent !=null)
					Matrix4x4.multiply(this._parent.worldMatrix,this.localMatrix,this._worldMatrix);
				else
				this.localMatrix.cloneTo(this._worldMatrix);
				this._worldUpdate=false;
			}
			return this._worldMatrix;
			},function(value){
			if (this._parent===null){
				value.cloneTo(this._localMatrix);
				}else {
				this._parent.worldMatrix.invert(this._localMatrix);
				Matrix4x4.multiply(this._localMatrix,value,this._localMatrix);
			}
			this.localMatrix=this._localMatrix;
			this._worldMatrix=value;
			this._worldUpdate=false;
		});

		/**
		*获取世界矩阵是否需要更新。
		*@return 世界矩阵是否需要更新。
		*/
		__getset(0,__proto,'worldNeedUpdate',function(){
			return this._worldUpdate;
		});

		/**
		*设置局部矩阵。
		*@param value 局部矩阵。
		*/
		/**
		*获取局部矩阵。
		*@return 局部矩阵。
		*/
		__getset(0,__proto,'localMatrix',function(){
			if (this._localUpdate){
				this._updateLocalMatrix();
				this._localUpdate=false;
			}
			return this._localMatrix;
			},function(value){
			this._localMatrix=value;
			this._localMatrix.decomposeTransRotScale(this._localPosition,this._localRotation,this._localScale);
			this._localUpdate=false;
			this._onWorldTransform();
		});

		/**
		*设置关联虚拟变换。
		*@param value 虚拟变换。
		*/
		/**
		*获取关联虚拟变换。
		*@return 虚拟变换。
		*/
		__getset(0,__proto,'dummy',function(){
			return this._dummy;
			},function(value){
			if (this._dummy!==value){
				(this._dummy)&& (this._dummy._entity=null);
				(value)&& (value._entity=this);
				this._dummy=value;
			}
		});

		/**
		*设置局部位置。
		*@param value 局部位置。
		*/
		/**
		*获取局部位置。
		*@return 局部位置。
		*/
		__getset(0,__proto,'localPosition',function(){
			return this._localPosition;
			},function(value){
			this._localPosition=value;
			this._localUpdate=true;
			this._onWorldPositionTransform();
		});

		/**
		*设置世界位置。
		*@param value 世界位置。
		*/
		/**
		*获取世界位置。
		*@return 世界位置。
		*/
		__getset(0,__proto,'position',function(){
			if (this._positionUpdate){
				if (this._parent !=null){
					var parentPosition=this._parent.position;
					Vector3.multiply(this._localPosition,this._parent.scale,Transform3D._tempVector30);
					Vector3.transformQuat(Transform3D._tempVector30,this._parent.rotation,Transform3D._tempVector30);
					Vector3.add(parentPosition,Transform3D._tempVector30,this._position);
					}else {
					this._localPosition.cloneTo(this._position);
				}
				this._positionUpdate=false;
			}
			return this._position;
			},function(value){
			if (this._parent !=null){
				Vector3.subtract(value,this._parent.position,this._localPosition);
				var parentScaleE=this._parent.scale.elements;
				var psX=parentScaleE[0],psY=parentScaleE[1],psZ=parentScaleE[2];
				if (psX!==1.0 || psY!==1.0 || psZ!==1.0){
					var invertScale=Transform3D._tempVector30;
					var invertScaleE=invertScale.elements;
					invertScaleE[0]=1.0 / psX;
					invertScaleE[1]=1.0 / psY;
					invertScaleE[2]=1.0 / psZ;
					Vector3.multiply(this._localPosition,invertScale,this._localPosition);
				};
				var parentRotation=this._parent.rotation;
				parentRotation.invert(Transform3D._tempQuaternion0);
				Vector3.transformQuat(this._localPosition,Transform3D._tempQuaternion0,this._localPosition);
				}else {
				value.cloneTo(this._localPosition);
			}
			this.localPosition=this._localPosition;
			this._position=value;
			this._positionUpdate=false;
		});

		/**
		*设置局部缩放。
		*@param value 局部缩放。
		*/
		/**
		*获取局部缩放。
		*@return 局部缩放。
		*/
		__getset(0,__proto,'localScale',function(){
			return this._localScale;
			},function(value){
			this._localScale=value;
			this._localUpdate=true;
			if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0))
				this._onWorldPositionScaleTransform();
			else
			this._onWorldScaleTransform();
		});

		/**
		*设置局部空间的旋转角度。
		*@param value 欧拉角的旋转值，顺序为x、y、z。
		*/
		/**
		*获取局部空间的旋转角度。
		*@return 欧拉角的旋转值，顺序为x、y、z。
		*/
		__getset(0,__proto,'localRotationEuler',function(){
			if (this._locaEulerlUpdate){
				this._localRotation.getYawPitchRoll(Transform3D._tempVector30);
				var eulerE=Transform3D._tempVector30.elements;
				var localRotationEulerE=this._localRotationEuler.elements;
				localRotationEulerE[0]=eulerE[1] *Transform3D._angleToRandin;
				localRotationEulerE[1]=eulerE[0] *Transform3D._angleToRandin;
				localRotationEulerE[2]=eulerE[2] *Transform3D._angleToRandin;
			}
			return this._localRotationEuler;
			},function(value){
			this._localRotationEuler=value;
			this._locaEulerlUpdate=false;
			this._localQuaternionUpdate=true;
			this._localUpdate=true;
			if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0))
				this._onWorldPositionRotationTransform();
			else
			this._onWorldRotationTransform();
		});

		/**
		*设置世界旋转。
		*@param value 世界旋转。
		*/
		/**
		*获取世界旋转。
		*@return 世界旋转。
		*/
		__getset(0,__proto,'rotation',function(){
			if (this._rotationUpdate){
				if (this._parent !=null)
					Quaternion.multiply(this._parent.rotation,this.localRotation,this._rotation);
				else
				this.localRotation.cloneTo(this._rotation);
				this._rotationUpdate=false;
			}
			return this._rotation;
			},function(value){
			if (this._parent !=null){
				this._parent.rotation.invert(Transform3D._tempQuaternion0);
				Quaternion.multiply(value,Transform3D._tempQuaternion0,this._localRotation);
				}else {
				value.cloneTo(this._localRotation);
			}
			this.localRotation=this._localRotation;
			this._rotation=value;
			this._rotationUpdate=false;
		});

		/**
		*设置世界缩放。
		*@param value 世界缩放。
		*/
		/**
		*获取世界缩放。
		*@return 世界缩放。
		*/
		__getset(0,__proto,'scale',function(){
			if (!this._scaleUpdate)
				return this._scale;
			if (this._parent!==null)
				Vector3.multiply(this._parent.scale,this._localScale,this._scale);
			else
			this._localScale.cloneTo(this._scale);
			this._scaleUpdate=false;
			return this._scale;
			},function(value){
			if (this._parent!==null){
				var pScaleE=this._parent.scale.elements;
				var invPScaleE=Transform3D._tempVector30.elements;
				invPScaleE[0]=1.0 / pScaleE[0];
				invPScaleE[1]=1.0 / pScaleE[1];
				invPScaleE[2]=1.0 / pScaleE[2];
				Vector3.multiply(value,Transform3D._tempVector30,this._localScale);
				}else {
				value.cloneTo(this._localScale);
			}
			this.localScale=this._localScale;
			this._scale=value;
			this._scaleUpdate=false;
		});

		/**
		*设置局部空间的旋转角度。
		*@param 欧拉角的旋转值，顺序为x、y、z。
		*/
		__getset(0,__proto,'rotationEuler',null,function(value){
			Quaternion.createFromYawPitchRoll(value.y,value.x,value.z,this._rotation);
			this.rotation=this._rotation;
		});

		/**
		*获取向前方向。
		*@return 向前方向。
		*/
		__getset(0,__proto,'forward',function(){
			var worldMatElem=this.worldMatrix.elements;
			this._forward.elements[0]=-worldMatElem[8];
			this._forward.elements[1]=-worldMatElem[9];
			this._forward.elements[2]=-worldMatElem[10];
			return this._forward;
		});

		/**
		*获取向上方向。
		*@return 向上方向。
		*/
		__getset(0,__proto,'up',function(){
			var worldMatElem=this.worldMatrix.elements;
			this._up.elements[0]=worldMatElem[4];
			this._up.elements[1]=worldMatElem[5];
			this._up.elements[2]=worldMatElem[6];
			return this._up;
		});

		/**
		*获取向右方向。
		*@return 向右方向。
		*/
		__getset(0,__proto,'right',function(){
			var worldMatElem=this.worldMatrix.elements;
			this._right.elements[0]=worldMatElem[0];
			this._right.elements[1]=worldMatElem[1];
			this._right.elements[2]=worldMatElem[2];
			return this._right;
		});

		/**
		*设置父3D变换。
		*@param value 父3D变换。
		*/
		/**
		*获取父3D变换。
		*@return 父3D变换。
		*/
		__getset(0,__proto,'parent',function(){
			return this._parent;
			},function(value){
			if (this._parent!==value){
				if (this._parent){
					var parentChilds=this._parent._children;
					var index=parentChilds.indexOf(this);
					parentChilds.splice(index,1);
				}
				if (value){
					value._children.push(this);
					(value)&& (this._onWorldTransform());
				}
				this._parent=value;
			}
		});

		__static(Transform3D,
		['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempVector32',function(){return this._tempVector32=new Vector3();},'_tempVector33',function(){return this._tempVector33=new Vector3();},'_tempQuaternion0',function(){return this._tempQuaternion0=new Quaternion();},'_tempMatrix0',function(){return this._tempMatrix0=new Matrix4x4();},'_angleToRandin',function(){return this._angleToRandin=180 / Math.PI;}
		]);
		return Transform3D;
	})(EventDispatcher)


	/**
	*<code>TransformUV</code> 类用于实现UV变换。
	*/
	//class laya.d3.core.TransformUV extends laya.events.EventDispatcher
	var TransformUV=(function(_super){
		function TransformUV(){
			this._rotation=0;
			//this._tiling=null;
			this._matNeedUpdte=false;
			TransformUV.__super.call(this);
			this._matrix=new Matrix4x4();
			this._offset=new Vector2();
			this._tiling=new Vector2(1.0,1.0);
		}

		__class(TransformUV,'laya.d3.core.TransformUV',_super);
		var __proto=TransformUV.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*@private
		*/
		__proto._updateMatrix=function(){
			TransformUV._tempOffsetV3.elements[0]=this._offset.x;
			TransformUV._tempOffsetV3.elements[1]=this._offset.y;
			Quaternion.createFromYawPitchRoll(0,0,this._rotation,TransformUV._tempRotationQua);
			TransformUV._tempTitlingV3.elements[0]=this._tiling.x;
			TransformUV._tempTitlingV3.elements[1]=this._tiling.y;
			Matrix4x4.createAffineTransformation(TransformUV._tempOffsetV3,TransformUV._tempRotationQua,TransformUV._tempTitlingV3,this._matrix);
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			destObject._matrix=this._matrix.clone();
			destObject._offset=this._offset.clone();
			destObject._rotation=this._rotation;
			destObject._tiling=this._tiling.clone();
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		/**
		*获取变换矩阵。
		*@return 变换矩阵。
		*/
		__getset(0,__proto,'matrix',function(){
			if (this._matNeedUpdte){
				this._updateMatrix();
				this._matNeedUpdte=false;
			}
			return this._matrix;
		});

		/**
		*设置平铺次数。
		*@param value 平铺次数。
		*/
		/**
		*获取平铺次数。
		*@return 平铺次数。
		*/
		__getset(0,__proto,'tiling',function(){
			return this._tiling;
			},function(value){
			this._tiling=value;
			this._matNeedUpdte=true;
		});

		/**
		*设置偏移。
		*@param value 偏移。
		*/
		/**
		*获取偏移。
		*@return 偏移。
		*/
		__getset(0,__proto,'offset',function(){
			return this._offset;
			},function(value){
			this._offset=value;
			this._matNeedUpdte=true;
		});

		/**
		*设置旋转。
		*@param value 旋转。
		*/
		/**
		*获取旋转。
		*@return 旋转。
		*/
		__getset(0,__proto,'rotation',function(){
			return this._rotation;
			},function(value){
			this._rotation=value;
			this._matNeedUpdte=true;
		});

		__static(TransformUV,
		['_tempOffsetV3',function(){return this._tempOffsetV3=new Vector3(0,0,0);},'_tempRotationQua',function(){return this._tempRotationQua=new Quaternion();},'_tempTitlingV3',function(){return this._tempTitlingV3=new Vector3(1,1,1);}
		]);
		return TransformUV;
	})(EventDispatcher)


	//class laya.webgl.utils.RenderSprite3D extends laya.renders.RenderSprite
	var RenderSprite3D=(function(_super){
		function RenderSprite3D(type,next){
			RenderSprite3D.__super.call(this,type,next);
		}

		__class(RenderSprite3D,'laya.webgl.utils.RenderSprite3D',_super);
		var __proto=RenderSprite3D.prototype;
		__proto.onCreate=function(type){
			switch (type){
				case 0x04:
					this._fun=this._blend;
					return;
				case 0x02:
					this._fun=this._transform;
					return;
				}
		}

		__proto._mask=function(sprite,context,x,y){
			var next=this._next;
			var mask=sprite.mask;
			var submitCMD;
			var submitStencil;
			if (mask){
				context.save();
				var preBlendMode=context.globalCompositeOperation;
				var tRect=new Rectangle();
				tRect.copyFrom(mask.getBounds());
				tRect.width=Math.round(tRect.width);
				tRect.height=Math.round(tRect.height);
				tRect.x=Math.round(tRect.x);
				tRect.y=Math.round(tRect.y);
				if (tRect.width > 0 && tRect.height > 0){
					var scope=SubmitCMDScope.create();
					scope.addValue("bounds",tRect);
					context.onChangeRT();
					context.pushRT();
					context.addRenderObject(SubmitCMD.create([scope,context],laya.webgl.utils.RenderSprite3D.tmpTarget));
					mask.render(context,-tRect.x,-tRect.y);
					context.onChangeRT();
					context.popRT();
					context.save();
					context.clipRect(x+tRect.x,y+tRect.y,tRect.width,tRect.height);
					next._fun.call(next,sprite,context,x,y);
					context.restore();
					submitStencil=SubmitStencil.create(6);
					preBlendMode=context.globalCompositeOperation;
					submitStencil.blendMode="mask";
					context.addRenderObject(submitStencil);
					Matrix.TEMP.identity();
					var shaderValue=Value2D.create(0x01,0);
					var uv=Texture.INV_UV;
					var w=tRect.width;
					var h=tRect.height;
					var tempLimit=32;
					if (tRect.width < tempLimit || tRect.height < tempLimit){
						uv=RenderSprite3D.tempUV;
						uv[0]=0;
						uv[1]=0;
						uv[2]=(tRect.width >=32)? 1 :tRect.width / tempLimit;
						uv[3]=0
						uv[4]=(tRect.width >=32)? 1 :tRect.width / tempLimit;
						uv[5]=(tRect.height >=32)? 1 :tRect.height / tempLimit;
						uv[6]=0;
						uv[7]=(tRect.height >=32)? 1 :tRect.height / tempLimit;
						tRect.width=(tRect.width >=32)? tRect.width :tempLimit;
						tRect.height=(tRect.height >=32)? tRect.height :tempLimit;
						uv[1] *=-1;
						uv[3] *=-1;
						uv[5] *=-1;
						uv[7] *=-1;
						uv[1]+=1;
						uv[3]+=1;
						uv[5]+=1;
						uv[7]+=1;
					}
					context.drawTarget(scope,x+tRect.x,y+tRect.y,w,h,Matrix.TEMP,"tmpTarget",shaderValue,uv,6);
					context.addRenderObject(SubmitCMD.create([scope],laya.webgl.utils.RenderSprite3D.recycleTarget));
					submitStencil=SubmitStencil.create(6);
					submitStencil.blendMode=preBlendMode;
					context.addRenderObject(submitStencil);
				}
				context.restore();
				}else {
				next._fun.call(next,sprite,context,x,y);
			}
		}

		__proto._blend=function(sprite,context,x,y){
			var style=sprite._style;
			var next=this._next;
			if (style.blendMode){
				context.save();
				context.globalCompositeOperation=style.blendMode;
				next._fun.call(next,sprite,context,x,y);
				context.restore();
				}else {
				next._fun.call(next,sprite,context,x,y);
			}
		}

		__proto._transform=function(sprite,context,x,y){
			'use strict';
			var transform=sprite.transform,_next=this._next;
			if (transform && _next !=RenderSprite.NORENDER){
				var ctx=context;
				var style=sprite._style;
				transform.tx=x+style.pivotX;
				transform.ty=y+style.pivotY;
				var m2=ctx._getTransformMatrix();
				var m1=m2.clone();
				Matrix.mul(transform,m2,m2);
				m2._checkTransform();
				transform.tx=transform.ty=0;
				_next._fun.call(_next,sprite,context,-style.pivotX,-style.pivotY);
				m1.copyTo(m2);
				m1.destroy();
				}else {
				_next._fun.call(_next,sprite,context,x,y);
			}
		}

		RenderSprite3D.tmpTarget=function(scope,context){
			var b=scope.getValue("bounds");
			var tmpTarget=WebGLRTMgr.getRT(b.width,b.height);
			window.rt_1=tmpTarget;
			tmpTarget.start();
			tmpTarget.clear(0,0,0,0);
			scope.addValue("tmpTarget",tmpTarget);
		}

		RenderSprite3D.recycleTarget=function(scope){
			var tmpTarget=scope.getValue("tmpTarget");
			WebGLRTMgr.releaseRT(tmpTarget);
			scope.recycle();
		}

		__static(RenderSprite3D,
		['tempUV',function(){return this.tempUV=new Array(8);}
		]);
		return RenderSprite3D;
	})(RenderSprite)


	//class laya.filters.webgl.ColorFilterActionGL extends laya.filters.webgl.FilterActionGL
	var ColorFilterActionGL=(function(_super){
		function ColorFilterActionGL(){
			this.data=null;
			ColorFilterActionGL.__super.call(this);
		}

		__class(ColorFilterActionGL,'laya.filters.webgl.ColorFilterActionGL',_super);
		var __proto=ColorFilterActionGL.prototype;
		Laya.imps(__proto,{"laya.filters.IFilterActionGL":true})
		__proto.setValue=function(shader){
			shader.colorMat=this.data._mat;
			shader.colorAlpha=this.data._alpha;
		}

		__proto.apply3d=function(scope,sprite,context,x,y){
			var b=scope.getValue("bounds");
			var shaderValue=Value2D.create(0x01,0);
			shaderValue.setFilters([this.data]);
			var tMatrix=Matrix.TEMP;
			tMatrix.identity();
			context.drawTarget(scope,0,0,b.width,b.height,tMatrix,"src",shaderValue);
		}

		return ColorFilterActionGL;
	})(FilterActionGL)


	//class laya.webgl.shader.d2.ShaderDefines2D extends laya.webgl.shader.ShaderDefines
	var ShaderDefines2D=(function(_super){
		function ShaderDefines2D(){
			ShaderDefines2D.__super.call(this,ShaderDefines2D.__name2int,ShaderDefines2D.__int2name,ShaderDefines2D.__int2nameMap);
		}

		__class(ShaderDefines2D,'laya.webgl.shader.d2.ShaderDefines2D',_super);
		ShaderDefines2D.__init__=function(){
			ShaderDefines2D.reg("TEXTURE2D",0x01);
			ShaderDefines2D.reg("PRIMITIVE",0x04);
			ShaderDefines2D.reg("GLOW_FILTER",0x08);
			ShaderDefines2D.reg("BLUR_FILTER",0x10);
			ShaderDefines2D.reg("COLOR_FILTER",0x20);
			ShaderDefines2D.reg("COLOR_ADD",0x40);
			ShaderDefines2D.reg("WORLDMAT",0x80);
			ShaderDefines2D.reg("FILLTEXTURE",0x100);
			ShaderDefines2D.reg("FSHIGHPRECISION",0x400);
		}

		ShaderDefines2D.reg=function(name,value){
			ShaderDefines._reg(name,value,ShaderDefines2D.__name2int,ShaderDefines2D.__int2name);
		}

		ShaderDefines2D.toText=function(value,int2name,int2nameMap){
			return ShaderDefines._toText(value,int2name,int2nameMap);
		}

		ShaderDefines2D.toInt=function(names){
			return ShaderDefines._toInt(names,ShaderDefines2D.__name2int);
		}

		ShaderDefines2D.TEXTURE2D=0x01;
		ShaderDefines2D.PRIMITIVE=0x04;
		ShaderDefines2D.FILTERGLOW=0x08;
		ShaderDefines2D.FILTERBLUR=0x10;
		ShaderDefines2D.FILTERCOLOR=0x20;
		ShaderDefines2D.COLORADD=0x40;
		ShaderDefines2D.WORLDMAT=0x80;
		ShaderDefines2D.FILLTEXTURE=0x100;
		ShaderDefines2D.SKINMESH=0x200;
		ShaderDefines2D.SHADERDEFINE_FSHIGHPRECISION=0x400;
		ShaderDefines2D.__name2int={};
		ShaderDefines2D.__int2name=[];
		ShaderDefines2D.__int2nameMap=[];
		return ShaderDefines2D;
	})(ShaderDefines)


	//class laya.webgl.shader.d2.skinAnishader.SkinSV extends laya.webgl.shader.d2.value.Value2D
	var SkinSV=(function(_super){
		function SkinSV(type){
			this.texcoord=null;
			this.offsetX=300;
			this.offsetY=0;
			SkinSV.__super.call(this,0x200,0);
			var _vlen=8 *CONST3D2D.BYTES_PE;
			this.position=[2,0x1406,false,_vlen,0];
			this.texcoord=[2,0x1406,false,_vlen,2 *CONST3D2D.BYTES_PE];
			this.color=[4,0x1406,false,_vlen,4 *CONST3D2D.BYTES_PE];
		}

		__class(SkinSV,'laya.webgl.shader.d2.skinAnishader.SkinSV',_super);
		return SkinSV;
	})(Value2D)


	//class laya.webgl.shader.d2.value.FillTextureSV extends laya.webgl.shader.d2.value.Value2D
	var FillTextureSV=(function(_super){
		function FillTextureSV(type){
			this.u_colorMatrix=null;
			this.strength=0;
			this.colorMat=null;
			this.colorAlpha=null;
			this.u_TexRange=[0,1,0,1];
			this.u_offset=[0,0];
			FillTextureSV.__super.call(this,0x100,0);
		}

		__class(FillTextureSV,'laya.webgl.shader.d2.value.FillTextureSV',_super);
		var __proto=FillTextureSV.prototype;
		//this.color=[4,WebGLContext.FLOAT,false,_vlen,4 *CONST3D2D.BYTES_PE];
		__proto.setValue=function(vo){
			this.ALPHA=vo.ALPHA;
			vo.filters && this.setFilters(vo.filters);
		}

		__proto.clear=function(){
			this.texture=null;
			this.shader=null;
			this.defines.setValue(0);
		}

		return FillTextureSV;
	})(Value2D)


	//class laya.webgl.shader.d2.value.TextureSV extends laya.webgl.shader.d2.value.Value2D
	var TextureSV=(function(_super){
		function TextureSV(subID){
			this.u_colorMatrix=null;
			this.strength=0;
			this.blurInfo=null;
			this.colorMat=null;
			this.colorAlpha=null;
			(subID===void 0)&& (subID=0);
			TextureSV.__super.call(this,0x01,subID);
			this._attribLocation=['posuv',0,'attribColor',1,'attribFlags',2];
		}

		__class(TextureSV,'laya.webgl.shader.d2.value.TextureSV',_super);
		var __proto=TextureSV.prototype;
		// ,'clipDir',3,'clipRect',4];
		__proto.setValue=function(vo){
			this.ALPHA=vo.ALPHA;
			vo.filters && this.setFilters(vo.filters);
		}

		__proto.clear=function(){
			this.texture=null;
			this.shader=null;
			this.defines._value=this.subID+(WebGL.shaderHighPrecision?0x400:0);
		}

		return TextureSV;
	})(Value2D)


	//class laya.webgl.shader.d2.value.PrimitiveSV extends laya.webgl.shader.d2.value.Value2D
	var PrimitiveSV=(function(_super){
		function PrimitiveSV(args){
			PrimitiveSV.__super.call(this,0x04,0);
			this._attribLocation=['position',0,'attribColor',1];
		}

		__class(PrimitiveSV,'laya.webgl.shader.d2.value.PrimitiveSV',_super);
		return PrimitiveSV;
	})(Value2D)


	/**
	*<code>TerrainFilter</code> 类用于创建TerrainFilter过滤器。
	*/
	//class laya.d3.terrain.TerrainFilter extends laya.events.EventDispatcher
	var TerrainFilter=(function(_super){
		function TerrainFilter(owner,chunkOffsetX,chunkOffsetZ,gridSize,terrainHeightData,heightDataWidth,heightDataHeight,cameraCoordinateInverse){
			this._owner=null;
			this._gridSize=NaN;
			this.memorySize=0;
			this._numberVertices=0;
			this._maxNumberIndices=0;
			this._currentNumberIndices=0;
			this._numberTriangle=0;
			this._vertexBuffer=null;
			this._indexBuffer=null;
			this._boundingSphere=null;
			this._boundingBox=null;
			this._indexArrayBuffer=null;
			this._boundingBoxCorners=null;
			this._leafs=null;
			this._leafNum=0;
			this._terrainHeightData=null;
			this._terrainHeightDataWidth=0;
			this._terrainHeightDataHeight=0;
			this._chunkOffsetX=0;
			this._chunkOffsetZ=0;
			this._cameraCoordinateInverse=false;
			this._cameraPos=null;
			this._currentLOD=0;
			this._perspectiveFactor=NaN;
			this._LODTolerance=0;
			TerrainFilter.__super.call(this);
			this._owner=owner;
			this._cameraPos=new Vector3();
			this._chunkOffsetX=chunkOffsetX;
			this._chunkOffsetZ=chunkOffsetZ;
			this._gridSize=gridSize;
			this._terrainHeightData=terrainHeightData;
			this._terrainHeightDataWidth=heightDataWidth;
			this._terrainHeightDataHeight=heightDataHeight;
			this._leafNum=(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM);
			this._leafs=__newvec(this._leafNum);
			this._cameraCoordinateInverse=cameraCoordinateInverse;
			for (var i=0;i < this._leafNum;i++){
				this._leafs[i]=new TerrainLeaf();
			}
			this.recreateResource();
		}

		__class(TerrainFilter,'laya.d3.terrain.TerrainFilter',_super);
		var __proto=TerrainFilter.prototype;
		/**
		*@inheritDoc
		*/
		__proto.destroy=function(){
			this._owner=null;
			if (this._vertexBuffer)this._vertexBuffer.destroy();
			if (this._indexBuffer)this._indexBuffer.destroy();
		}

		__proto.recreateResource=function(){
			this._currentNumberIndices=0;
			this._numberTriangle=0;
			var nLeafVertexCount=TerrainLeaf.LEAF_VERTEXT_COUNT;
			var nLeafIndexCount=TerrainLeaf.LEAF_MAX_INDEX_COUNT;
			this._numberVertices=nLeafVertexCount *this._leafNum;
			this._maxNumberIndices=nLeafIndexCount *this._leafNum;
			this._indexArrayBuffer=new Uint16Array(this._maxNumberIndices);
			var vertexDeclaration=VertexPositionTerrain.vertexDeclaration;
			var vertexFloatStride=vertexDeclaration.vertexStride / 4;
			var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
			var nNum=TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM;
			var i=0,x=0,z=0;
			for (i=0;i < this._leafNum;i++){
				x=i % nNum;
				z=Math.floor(i / nNum);
				this._leafs[i].calcVertextBuffer(this._chunkOffsetX,this._chunkOffsetZ,x *TerrainLeaf.LEAF_GRID_NUM,z *TerrainLeaf.LEAF_GRID_NUM,this._gridSize,vertices,i *TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT,vertexFloatStride,this._terrainHeightData,this._terrainHeightDataWidth,this._terrainHeightDataHeight,this._cameraCoordinateInverse);
			}
			for (i=0;i < this._leafNum;i++){
				x=i % nNum;
				z=Math.floor(i / nNum);
				this._leafs[i].calcSkirtVertextBuffer(this._chunkOffsetX,this._chunkOffsetZ,x *TerrainLeaf.LEAF_GRID_NUM,z *TerrainLeaf.LEAF_GRID_NUM,this._gridSize,vertices,this._leafNum *TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT+i *TerrainLeaf.LEAF_SKIRT_VERTEXT_COUNT,vertexFloatStride,this._terrainHeightData,this._terrainHeightDataWidth,this._terrainHeightDataHeight);
			}
			this.assembleIndexInit();
			this._vertexBuffer=new VertexBuffer3D(vertexDeclaration.vertexStride*this._numberVertices,0x88E4,false);
			this._vertexBuffer.vertexDeclaration=vertexDeclaration;
			this._indexBuffer=new IndexBuffer3D("ushort",this._maxNumberIndices,0x88E4,false);
			this._vertexBuffer.setData(vertices);
			this._indexBuffer.setData(this._indexArrayBuffer);
			this.memorySize=(this._vertexBuffer._byteLength+this._indexBuffer._byteLength)*2;
			this.calcOriginalBoudingBoxAndSphere();
		}

		__proto.setLODLevel=function(leafsLODLevel){
			if (leafsLODLevel.length !=4)return true;
			var nLOD=((leafsLODLevel[0]+1)<< 24)+((leafsLODLevel[1]+1)<< 16)+((leafsLODLevel[2]+1)<< 8)+(leafsLODLevel[3]+1);
			if (this._currentLOD==nLOD){
				return false;
			}
			this._currentLOD=nLOD;
			return true;
		}

		__proto.assembleIndexInit=function(){
			this._currentNumberIndices=0;
			this._numberTriangle=0;
			var nOffsetIndex=0;
			for (var i=0;i < this._leafNum;i++){
				var planeLODIndex=TerrainLeaf.getPlaneLODIndex(i,0);
				this._indexArrayBuffer.set(planeLODIndex,nOffsetIndex);
				nOffsetIndex+=planeLODIndex.length;
				var skirtLODIndex=TerrainLeaf.getSkirtLODIndex(i,0);
				this._indexArrayBuffer.set(skirtLODIndex,nOffsetIndex);
				nOffsetIndex+=skirtLODIndex.length;
				this._currentNumberIndices+=(planeLODIndex.length+skirtLODIndex.length);
			}
			this._numberTriangle=this._currentNumberIndices / 3;
		}

		__proto.isNeedAssemble=function(camera,cameraPostion){
			var perspectiveFactor=Math.min(camera.viewport.width,camera.viewport.height)/ (2 *Math.tan(Math.PI *camera.fieldOfView / 180.0));
			if (this._perspectiveFactor !=perspectiveFactor){
				this._perspectiveFactor=perspectiveFactor;
				return 1;
			}
			if (this._LODTolerance !=Terrain.LOD_TOLERANCE_VALUE){
				this._LODTolerance=Terrain.LOD_TOLERANCE_VALUE;
				return 1;
			}
			if (Vector3.equals(cameraPostion,this._cameraPos)==false){
				this._cameraPos.x=cameraPostion.x;
				this._cameraPos.y=cameraPostion.y;
				this._cameraPos.z=cameraPostion.z;
				return 2;
			}
			return 0;
		}

		__proto.assembleIndex=function(camera,cameraPostion){
			var nNeedType=this.isNeedAssemble(camera,cameraPostion);
			if (nNeedType > 0){
				for (var i=0;i < this._leafNum;i++){
					TerrainFilter._TEMP_ARRAY_BUFFER[i]=this._leafs[i].determineLod(cameraPostion,this._perspectiveFactor,Terrain.LOD_TOLERANCE_VALUE,nNeedType==1);
				}
				if (this.setLODLevel(TerrainFilter._TEMP_ARRAY_BUFFER)){
					this._currentNumberIndices=0;
					this._numberTriangle=0;
					var nOffsetIndex=0;
					for (i=0;i < this._leafNum;i++){
						var nLODLevel=TerrainFilter._TEMP_ARRAY_BUFFER[i];
						var planeLODIndex=TerrainLeaf.getPlaneLODIndex(i,nLODLevel);
						this._indexArrayBuffer.set(planeLODIndex,nOffsetIndex);
						nOffsetIndex+=planeLODIndex.length;
						var skirtLODIndex=TerrainLeaf.getSkirtLODIndex(i,nLODLevel);
						this._indexArrayBuffer.set(skirtLODIndex,nOffsetIndex);
						nOffsetIndex+=skirtLODIndex.length;
						this._currentNumberIndices+=(planeLODIndex.length+skirtLODIndex.length);
					}
					this._numberTriangle=this._currentNumberIndices / 3;
					return true;
				}
			}
			return false;
		}

		__proto.calcOriginalBoudingBoxAndSphere=function(){
			var sizeOfY=new Vector2(2147483647,-2147483647);
			for (var i=0;i < this._leafNum;i++){
				sizeOfY.x=this._leafs[i]._sizeOfY.x < sizeOfY.x ? this._leafs[i]._sizeOfY.x :sizeOfY.x;
				sizeOfY.y=this._leafs[i]._sizeOfY.y > sizeOfY.y ? this._leafs[i]._sizeOfY.y :sizeOfY.y;
			};
			var min=new Vector3(this._chunkOffsetX *TerrainLeaf.CHUNK_GRID_NUM *this._gridSize,sizeOfY.x,this._chunkOffsetZ *TerrainLeaf.CHUNK_GRID_NUM *this._gridSize);
			var max=new Vector3((this._chunkOffsetX+1)*TerrainLeaf.CHUNK_GRID_NUM *this._gridSize,sizeOfY.y,(this._chunkOffsetZ+1)*TerrainLeaf.CHUNK_GRID_NUM *this._gridSize);
			if (TerrainLeaf.__ADAPT_MATRIX__){
				Vector3.transformV3ToV3(min,TerrainLeaf.__ADAPT_MATRIX__,min);
				Vector3.transformV3ToV3(max,TerrainLeaf.__ADAPT_MATRIX__,max);
			}
			this._boundingBox=new BoundBox(min,max);
			var size=new Vector3();
			Vector3.subtract(max,min,size);
			Vector3.scale(size,0.5,size);
			var center=new Vector3();
			Vector3.add(min,size,center);
			this._boundingSphere=new BoundSphere(center,Vector3.scalarLength(size));
			this._boundingBoxCorners=__newvec(8,null);
			this._boundingBox.getCorners(this._boundingBoxCorners);
		}

		__proto.calcLeafBoudingBox=function(worldMatrix){
			for (var i=0;i < this._leafNum;i++){
				this._leafs[i].calcLeafBoudingBox(worldMatrix);
			}
		}

		__proto.calcLeafBoudingSphere=function(worldMatrix,maxScale){
			for (var i=0;i < this._leafNum;i++){
				this._leafs[i].calcLeafBoudingSphere(worldMatrix,maxScale);
			}
		}

		__proto._getVertexBuffer=function(index){
			(index===void 0)&& (index=0);
			if (index==0){
				return this._vertexBuffer;
			}
			return null;
		}

		__proto._getIndexBuffer=function(){
			return this._indexBuffer;
		}

		__proto._beforeRender=function(state){
			this._indexBuffer.bind();
			var terrainMaterial=state.renderElement.material;
			if (terrainMaterial.blend==BaseMaterial.BLEND_DISABLE){
				var camera=state.camera;
				if (this.assembleIndex(camera,camera.position)){
					this._indexBuffer.setData(this._indexArrayBuffer);
				}
			}
			return true;
		}

		__proto._render=function(state){
			LayaGL.instance.drawElements(Terrain.RENDER_LINE_MODEL ? 0x0001 :0x0004,this._currentNumberIndices,0x1403,0);
			Stat.trianglesFaces+=this._numberTriangle;
			Stat.drawCall++;
		}

		__getset(0,__proto,'_vertexBufferCount',function(){
			return this._numberVertices;
		});

		__getset(0,__proto,'triangleCount',function(){
			return this._numberTriangle;
		});

		__static(TerrainFilter,
		['_TEMP_ARRAY_BUFFER',function(){return this._TEMP_ARRAY_BUFFER=new Uint32Array(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM *TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM);}
		]);
		return TerrainFilter;
	})(EventDispatcher)


	/**
	*<code>CollsionManager</code> 类用于碰撞管理器。
	*/
	//class laya.d3.utils.CollisionManager extends laya.events.EventDispatcher
	var CollisionManager=(function(_super){
		/**
		*创建一个新的 <code>CollsionManager</code> 实例。
		*/
		function CollisionManager(){
			CollisionManager.__super.call(this);
		}

		__class(CollisionManager,'laya.d3.utils.CollisionManager',_super);
		CollisionManager._onTrigger=function(rigidCol,receiveCol,rigidScripts,receiveScripts,bothRigid){
			var i=0,n=0;
			var rigidID=rigidCol.id;
			var receiveID=receiveCol.id;
			if (!rigidCol._ignoreCollisonMap[receiveID]){
				var colMan=Physics.collisionManager;
				var needTest=rigidCol._runtimeCollisonTestMap[receiveID];
				if (needTest !=null){
					if (needTest){
						if (rigidCol._collisonTo(receiveCol)){
							if (rigidCol._runtimeCollisonMap[receiveID]){
								for (i=0,n=rigidScripts.length;i < n;i++)
								rigidScripts[i].onTriggerStay(receiveCol);
								for (i=0,n=receiveScripts.length;i < n;i++)
								receiveScripts[i].onTriggerStay(rigidCol);
								}else {
								rigidCol._runtimeCollisonMap[receiveID]=receiveCol;
								rigidCol._runtimeCollisonTestMap[receiveID]=false;
								receiveCol._runtimeCollisonMap[rigidID]=rigidCol;
								if (bothRigid)
									receiveCol._runtimeCollisonTestMap[rigidID]=false;
								for (i=0,n=rigidScripts.length;i < n;i++)
								rigidScripts[i].onTriggerEnter(receiveCol);
								for (i=0,n=receiveScripts.length;i < n;i++)
								receiveScripts[i].onTriggerEnter(rigidCol);
							}
							}else {
							var rigidMap=rigidCol._runtimeCollisonMap;
							if (rigidMap[receiveID]){
								delete rigidMap[receiveID];
								delete rigidCol._runtimeCollisonTestMap[receiveID];
								delete receiveCol._runtimeCollisonMap[rigidID];
								if (bothRigid)
									delete receiveCol._runtimeCollisonTestMap[rigidID];
								for (i=0,n=rigidScripts.length;i < n;i++)
								rigidScripts[i].onTriggerExit(receiveCol);
								for (i=0,n=receiveScripts.length;i < n;i++)
								receiveScripts[i].onTriggerExit(rigidCol);
							}
						}
						}else {
						for (i=0,n=rigidScripts.length;i < n;i++)
						rigidScripts[i].onTriggerStay(receiveCol);
						for (i=0,n=receiveScripts.length;i < n;i++)
						receiveScripts[i].onTriggerStay(rigidCol);
					}
					}else {
					if (rigidCol._collisonTo(receiveCol)){
						rigidCol._runtimeCollisonMap[receiveID]=receiveCol;
						rigidCol._runtimeCollisonTestMap[receiveID]=false;
						receiveCol._runtimeCollisonMap[rigidID]=rigidCol;
						if (bothRigid)
							receiveCol._runtimeCollisonTestMap[rigidID]=false;
						for (i=0,n=rigidScripts.length;i < n;i++)
						rigidScripts[i].onTriggerEnter(receiveCol);
						for (i=0,n=receiveScripts.length;i < n;i++)
						receiveScripts[i].onTriggerEnter(rigidCol);
					}
				}
			}
		}

		CollisionManager._triggerCollision=function(){
			var colList=Layer._collsionTestList;
			var colCount=colList.length;
			var colMat=Physics._layerCollsionMatrix;
			for (var i=0;i < colCount;i++){
				var row=colList[i];
				var rowLayer=Layer.getLayerByNumber(row);
				var rowColliders=rowLayer._colliders;
				var rowRigOffset=rowLayer._nonRigidbodyOffset;
				for (var j=colCount-1;j >=i;j--){
					var col=colList[j];
					var test=colMat[row][(31-1)-col];
					if (test){
						var k=0,c=0,x=0,z=0;
						var rowCol,colCol,rowScripts;
						var colLayer=Layer.getLayerByNumber(col);
						var colColliders=colLayer._colliders;
						var colRigOffset=colLayer._nonRigidbodyOffset;
						if (rowLayer!==colLayer){
							for (k=0;k < rowRigOffset;k++){
								rowCol=rowColliders[k];
								if (rowCol.enable){
									rowScripts=rowCol.owner._scripts;
									for (x=0,z=colRigOffset;x < z;x++){
										colCol=colColliders[x];
										(colCol.enable)&& (CollisionManager._onTrigger(rowCol,colCol,rowScripts,colCol.owner._scripts,true));
									}
									for (x=colRigOffset,z=colColliders.length;x < z;x++){
										colCol=colColliders[x];
										(colCol.enable)&& (CollisionManager._onTrigger(rowCol,colCol,rowScripts,colCol.owner._scripts,false));
									}
								}
							}
							for (k=rowRigOffset,c=rowColliders.length;k < c;k++){
								rowCol=rowColliders[k];
								if (rowCol.enable){
									rowScripts=rowCol.owner._scripts;
									for (x=0,z=colLayer._nonRigidbodyOffset;x < z;x++){
										colCol=colColliders[x];
										(colCol.enable)&& (CollisionManager._onTrigger(colCol,rowCol,rowScripts,colCol.owner._scripts,false));
									}
								}
							}
							}else {
							for (k=0;k < rowRigOffset;k++){
								rowCol=rowColliders[k];
								if (rowCol.enable){
									rowScripts=rowCol.owner._scripts;
									for (x=k+1,z=rowRigOffset;x < z;x++){
										colCol=colColliders[x];
										(colCol.enable)&& (CollisionManager._onTrigger(rowCol,colCol,rowScripts,colCol.owner._scripts,true));
									}
									for (x=rowRigOffset,z=rowColliders.length;x < z;x++){
										colCol=colColliders[x];
										(colCol.enable)&& (CollisionManager._onTrigger(rowCol,colCol,rowScripts,colCol.owner._scripts,false));
									}
								}
							}
						}
					}
				}
			}
		}

		return CollisionManager;
	})(EventDispatcher)


	//class laya.webgl.shapes.Polygon extends laya.webgl.shapes.BasePoly
	var Polygon=(function(_super){
		function Polygon(x,y,points,color,borderWidth,borderColor){
			this._points=null;
			this._start=-1;
			this._repaint=false;
			this.earcutTriangles=null;
			this._mat=Matrix.create();
			this._points=points.slice(0,points.length);
			Polygon.__super.call(this,x,y,0,0,this._points.length / 2,color,borderWidth,borderColor);
		}

		__class(Polygon,'laya.webgl.shapes.Polygon',_super);
		var __proto=Polygon.prototype;
		__proto.rebuild=function(point){
			if (!this._repaint){
				this._points.length=0;
				this._points=this._points.concat(point);
			}
		}

		__proto.setMatrix=function(mat){
			mat.copyTo(this._mat);
		}

		__proto.needUpdate=function(mat){
			this._repaint=(this._mat.a==mat.a && this._mat.b==mat.b && this._mat.c==mat.c && this._mat.d==mat.d && this._mat.tx==mat.tx && this._mat.ty==mat.ty);
			return !this._repaint;
		}

		/**
		*��λ�����鱣�浽vb��ib��
		*@param ib
		*@param vb
		*@param start
		*/
		__proto.getData=function(ib,vb,start){
			var indices,i=0;
			var tArray=this._points;
			var tLen=0;
			if (this.mUint16Array && this.mFloat32Array&&this._repaint){
				if (this._start !=start){
					this._start=start;
					indices=[];
					tLen=this.earcutTriangles.length;
					for (i=0;i < tLen;i++){
						indices.push(this.earcutTriangles[i]+start);
					}
					this.mUint16Array=new Uint16Array(indices);
				}
			}
			else {
				this._start=start;
				indices=[];
				var verts=[];
				var vertsEarcut=[];
				var color=this.color;
				var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
				tLen=Math.floor(tArray.length / 2);
				for (i=0;i < tLen;i++){
					verts.push(this.x+tArray[i *2],this.y+tArray[i *2+1],r,g,b);
					vertsEarcut.push(this.x+tArray[i *2],this.y+tArray[i *2+1]);
				}
				this.earcutTriangles=Earcut.earcut(vertsEarcut,null,2);
				tLen=this.earcutTriangles.length;
				for (i=0;i < tLen;i++){
					indices.push(this.earcutTriangles[i]+start);
				}
				this.mUint16Array=new Uint16Array(indices);
				this.mFloat32Array=new Float32Array(verts);
			}
			ib.append(this.mUint16Array);
			vb.append(this.mFloat32Array);
		}

		return Polygon;
	})(BasePoly)


	//class laya.webgl.submit.SubmitCanvas extends laya.webgl.submit.Submit
	var SubmitCanvas=(function(_super){
		function SubmitCanvas(){
			//this._ctx_src=null;
			this._matrix=new Matrix();
			this._matrix4=CONST3D2D.defaultMatrix4.concat();
			SubmitCanvas.__super.call(this,10000);
			this.shaderValue=new Value2D(0,0);
		}

		__class(SubmitCanvas,'laya.webgl.submit.SubmitCanvas',_super);
		var __proto=SubmitCanvas.prototype;
		__proto.renderSubmit=function(){
			if (this._ctx_src._targets){
				this._ctx_src._targets.flush(this._ctx_src);
				return 1;
			};
			var preAlpha=RenderState2D.worldAlpha;
			var preMatrix4=RenderState2D.worldMatrix4;
			var preMatrix=RenderState2D.worldMatrix;
			var preFilters=RenderState2D.worldFilters;
			var preWorldShaderDefines=RenderState2D.worldShaderDefines;
			var v=this.shaderValue;
			var m=this._matrix;
			var m4=this._matrix4;
			var mout=Matrix.TEMP;
			Matrix.mul(m,preMatrix,mout);
			m4[0]=mout.a;
			m4[1]=mout.b;
			m4[4]=mout.c;
			m4[5]=mout.d;
			m4[12]=mout.tx;
			m4[13]=mout.ty;
			RenderState2D.worldMatrix=mout.clone();
			RenderState2D.worldMatrix4=m4;
			RenderState2D.worldAlpha=RenderState2D.worldAlpha *v.alpha;
			if (v.filters && v.filters.length){
				RenderState2D.worldFilters=v.filters;
				RenderState2D.worldShaderDefines=v.defines;
			}
			this._ctx_src.flush();
			RenderState2D.worldAlpha=preAlpha;
			RenderState2D.worldMatrix4=preMatrix4;
			RenderState2D.worldMatrix.destroy();
			RenderState2D.worldMatrix=preMatrix;
			RenderState2D.worldFilters=preFilters;
			RenderState2D.worldShaderDefines=preWorldShaderDefines;
			return 1;
		}

		__proto.releaseRender=function(){
			if((--this._ref)<1){
				var cache=SubmitCanvas.POOL;
				this._ctx_src=null;
				this._mesh=null;
				cache[cache._length++]=this;
			}
		}

		__proto.clone=function(context,ib,vb,pos){
			return null;
		}

		__proto.getRenderType=function(){
			return 10003;
		}

		SubmitCanvas.create=function(ctx_src,alpha,filters){
			var o=(!SubmitCanvas.POOL._length)? (new SubmitCanvas()):SubmitCanvas.POOL[--SubmitCanvas.POOL._length];
			o._ctx_src=ctx_src;
			o._ref=1;
			o._numEle=0;
			var v=o.shaderValue;
			v.alpha=alpha;
			v.defines.setValue(0);
			filters && filters.length && v.setFilters(filters);
			return o;
		}

		SubmitCanvas.POOL=(SubmitCanvas.POOL=[],SubmitCanvas.POOL._length=0,SubmitCanvas.POOL);
		return SubmitCanvas;
	})(Submit)


	//class laya.webgl.submit.SubmitTexture extends laya.webgl.submit.Submit
	var SubmitTexture=(function(_super){
		function SubmitTexture(renderType){
			(renderType===void 0)&& (renderType=10000);
			SubmitTexture.__super.call(this,renderType);
		}

		__class(SubmitTexture,'laya.webgl.submit.SubmitTexture',_super);
		var __proto=SubmitTexture.prototype;
		__proto.clone=function(context,mesh,pos){
			var o=SubmitTexture._poolSize ? SubmitTexture.POOL[--SubmitTexture._poolSize] :new SubmitTexture();
			this._cloneInit(o,context,mesh,pos);
			return o;
		}

		__proto.releaseRender=function(){
			if ((--this._ref)< 1){
				SubmitTexture.POOL[SubmitTexture._poolSize++]=this;
				this.shaderValue.release();
				this._mesh=null;
				this._parent && (this._parent.releaseRender(),this._parent=null);
			}
		}

		__proto.renderSubmit=function(){
			if (this._numEle===0)
				return 1;
			var tex=this.shaderValue.textureHost;
			var source=tex?tex._getSource():null;
			if (!source)return 1;
			var gl=WebGL.mainContext;
			this._mesh.useMesh(gl);
			var prekey=Submit.preRender._key;
			if (this._key.blendShader===0 && (this._key.submitType===prekey.submitType && this._key.blendShader===prekey.blendShader)&& BaseShader.activeShader &&
				Submit.preRender.clipInfoID==this.clipInfoID){
				(BaseShader.activeShader).uploadTexture2D(source);
			}
			else{
				if (BlendMode.activeBlendFunction!==this._blendFn){
					WebGLContext.setBlend(gl,true);
					this._blendFn(gl);
					BlendMode.activeBlendFunction=this._blendFn;
				}
				this.shaderValue.texture=source;
				this.shaderValue.upload();
			}
			gl.drawElements(0x0004,this._numEle,0x1403,this._startIdx);
			Stat.drawCall++;
			Stat.trianglesFaces+=this._numEle / 3;
			return 1;
		}

		SubmitTexture.create=function(context,mesh,sv){
			var o=SubmitTexture._poolSize ? SubmitTexture.POOL[--SubmitTexture._poolSize] :new SubmitTexture();
			o._mesh=mesh;
			o._key.clear();
			o._ref=1;
			o._startIdx=mesh.indexNum *CONST3D2D.BYTES_PIDX;
			o._numEle=0;
			var blendType=context._nBlendType;
			o._blendFn=context._targets ? BlendMode.targetFns[blendType] :BlendMode.fns[blendType];
			o.shaderValue=sv;
			sv.setValue(context._shader2D);
			return o;
		}

		SubmitTexture._poolSize=0;
		SubmitTexture.POOL=[];
		return SubmitTexture;
	})(Submit)


	/**
	*drawImage，fillRect等会用到的简单的mesh。每次添加必然是一个四边形。
	*/
	//class laya.webgl.utils.MeshQuadTexture extends laya.webgl.utils.Mesh2D
	var MeshQuadTexture=(function(_super){
		//private static var _num;
		function MeshQuadTexture(){
			MeshQuadTexture.__super.call(this,laya.webgl.utils.MeshQuadTexture.const_stride);
			this.canReuse=true;
			this._fixedib=true;
			this.setAttributes(laya.webgl.utils.MeshQuadTexture._fixattriInfo);
			if(!laya.webgl.utils.MeshQuadTexture._fixib){
				this.createQuadIB(MeshQuadTexture._maxIB);
				laya.webgl.utils.MeshQuadTexture._fixib=this._ib;
				}else {
				this._ib=laya.webgl.utils.MeshQuadTexture._fixib;
				this._quadNum=MeshQuadTexture._maxIB;
			}
		}

		__class(MeshQuadTexture,'laya.webgl.utils.MeshQuadTexture',_super);
		var __proto=MeshQuadTexture.prototype;
		/**
		*把本对象放到回收池中，以便getMesh能用。
		*/
		__proto.releaseMesh=function(){
			this._vb.setByteLength(0);
			this.vertNum=0;
			this.indexNum=0;
			laya.webgl.utils.MeshQuadTexture._POOL.push(this);
		}

		__proto.destroy=function(){
			this._vb.destroy();
		}

		/**
		*
		*@param pos
		*@param uv
		*@param color
		*@param clip ox,oy,xx,xy,yx,yy
		*@param useTex 使用使用贴图。false的话是给fillRect用的
		*/
		__proto.addQuad=function(pos,uv,color,clip,useTex){
			var vb=this._vb;
			var vpos=(vb._byteLength >> 2);
			vb.setByteLength((vpos<<2)+laya.webgl.utils.MeshQuadTexture.const_stride*4);
			var vbdata=vb._floatArray32 || vb.getFloat32Array();
			var vbu32Arr=vb._uint32Array;
			var cpos=vpos;
			var useTexVal=useTex?0xff:0;
			vbdata[cpos++]=pos[0];vbdata[cpos++]=pos[1];vbdata[cpos++]=uv[0];vbdata[cpos++]=uv[1];vbu32Arr[cpos++]=color;vbu32Arr[cpos++]=useTexVal;
			vbdata[cpos++]=pos[2];vbdata[cpos++]=pos[3];vbdata[cpos++]=uv[2];vbdata[cpos++]=uv[3];vbu32Arr[cpos++]=color;vbu32Arr[cpos++]=useTexVal;
			vbdata[cpos++]=pos[4];vbdata[cpos++]=pos[5];vbdata[cpos++]=uv[4];vbdata[cpos++]=uv[5];vbu32Arr[cpos++]=color;vbu32Arr[cpos++]=useTexVal;
			vbdata[cpos++]=pos[6];vbdata[cpos++]=pos[7];vbdata[cpos++]=uv[6];vbdata[cpos++]=uv[7];vbu32Arr[cpos++]=color;vbu32Arr[cpos++]=useTexVal;
			vb._upload=true;
		}

		MeshQuadTexture.getAMesh=function(){
			if (laya.webgl.utils.MeshQuadTexture._POOL.length){
				return laya.webgl.utils.MeshQuadTexture._POOL.pop();
			}
			return new MeshQuadTexture();
		}

		MeshQuadTexture.const_stride=24;
		MeshQuadTexture._fixib=null
		MeshQuadTexture._maxIB=16 *1024;
		MeshQuadTexture._POOL=[];
		__static(MeshQuadTexture,
		['_fixattriInfo',function(){return this._fixattriInfo=[
			0x1406,4,0,
			0x1401,4,16,
			0x1401,4,20];}
		]);
		return MeshQuadTexture;
	})(Mesh2D)


	/**
	*与MeshQuadTexture基本相同。不过index不是固定的
	*/
	//class laya.webgl.utils.MeshTexture extends laya.webgl.utils.Mesh2D
	var MeshTexture=(function(_super){
		function MeshTexture(){
			MeshTexture.__super.call(this,laya.webgl.utils.MeshTexture.const_stride);
			this.canReuse=true;
			this._fixedib=false;
			this.setAttributes(laya.webgl.utils.MeshTexture._fixattriInfo);
		}

		__class(MeshTexture,'laya.webgl.utils.MeshTexture',_super);
		var __proto=MeshTexture.prototype;
		__proto.addData=function(vertices,uvs,idx,matrix,rgba,ctx){
			var sz=vertices.length / 2;
			var startpos=this._vb.needSize(sz *MeshTexture.const_stride);
			var f32pos=startpos >> 2;
			var vbdata=this._vb._floatArray32 || this._vb.getFloat32Array();
			var vbu32Arr=this._vb._uint32Array;
			var ci=0;
			var clipinfo=ctx.getTransedClipInfo();
			for (var i=0;i < sz;i++){
				var x=vertices[ci],y=vertices[ci+1];
				var x1=x *matrix.a+y *matrix.c+matrix.tx;
				var y1=x *matrix.b+y *matrix.d+matrix.ty;
				vbdata[f32pos++]=x1;vbdata[f32pos++]=y1;
				vbdata[f32pos++]=uvs[ci];vbdata[f32pos++]=uvs[ci+1];
				ci+=2;
				vbu32Arr[f32pos++]=rgba;
				vbdata[f32pos++]=clipinfo[2];vbdata[f32pos++]=clipinfo[3];vbdata[f32pos++]=clipinfo[4];vbdata[f32pos++]=clipinfo[5];
				vbdata[f32pos++]=clipinfo[0];vbdata[f32pos++]=clipinfo[1];
			}
			this._vb.setNeedUpload();
			var vertN=this.vertNum;
			if (vertN > 0){
				var sz=idx.length;
				if (sz > MeshTexture.tmpIdx.length)MeshTexture.tmpIdx=new Uint16Array(sz);
				for (var ii=0;ii < sz;ii++){
					MeshTexture.tmpIdx[ii]=idx[ii]+vertN;
				}
				this._ib.appendU16Array(MeshTexture.tmpIdx,idx.length);
				}else {
				this._ib.append(idx);
			}
			this._ib.setNeedUpload();
			this.vertNum+=sz;
			this.indexNum+=idx.length;
		}

		/**
		*把本对象放到回收池中，以便getMesh能用。
		*/
		__proto.releaseMesh=function(){
			this._vb.setByteLength(0);
			this._ib.setByteLength(0);
			this.vertNum=0;
			this.indexNum=0;
			laya.webgl.utils.MeshTexture._POOL.push(this);
		}

		__proto.destroy=function(){
			this._ib.destroy();
			this._vb.destroy();
		}

		MeshTexture.getAMesh=function(){
			if (laya.webgl.utils.MeshTexture._POOL.length){
				return laya.webgl.utils.MeshTexture._POOL.pop();
			}
			return new MeshTexture();
		}

		MeshTexture.const_stride=44;
		MeshTexture._POOL=[];
		__static(MeshTexture,
		['_fixattriInfo',function(){return this._fixattriInfo=[
			0x1406,4,0,
			0x1401,4,16,
			0x1406,4,20,
			0x1406,2,36];},'tmpIdx',function(){return this.tmpIdx=new Uint16Array(4);}
		]);
		return MeshTexture;
	})(Mesh2D)


	/**
	*用来画矢量的mesh。顶点格式固定为 x,y,rgba
	*/
	//class laya.webgl.utils.MeshVG extends laya.webgl.utils.Mesh2D
	var MeshVG=(function(_super){
		function MeshVG(){
			MeshVG.__super.call(this,laya.webgl.utils.MeshVG.const_stride,null,64*1024);
			this.canReuse=true;
			this.setAttributes(laya.webgl.utils.MeshVG._fixattriInfo);
		}

		__class(MeshVG,'laya.webgl.utils.MeshVG',_super);
		var __proto=MeshVG.prototype;
		/**
		*往矢量mesh中添加顶点和index。会把rgba和points在mesh中合并。
		*@param points 顶点数组，只包含x,y。[x,y,x,y...]
		*@param rgba rgba颜色
		*@param ib index数组。
		*/
		__proto.addVertAndIBToMesh=function(ctx,points,rgba,ib){
			var startpos=this._vb.needSize(points.length / 2 *MeshVG.const_stride);
			var f32pos=startpos >> 2;
			var vbdata=this._vb._floatArray32 || this._vb.getFloat32Array();
			var vbu32Arr=this._vb._uint32Array;
			var ci=0;
			var clipinfo=ctx.getTransedClipInfo();
			var sz=points.length / 2;
			for (var i=0;i < sz;i++){
				vbdata[f32pos++]=points[ci];vbdata[f32pos++]=points[ci+1];ci+=2;
				vbu32Arr[f32pos++]=rgba;
			}
			this._vb.setNeedUpload();
			this._ib.append(new Uint16Array(ib));
			this._ib.setNeedUpload();
			this.vertNum+=sz;
			this.indexNum+=ib.length;
		}

		/**
		*把本对象放到回收池中，以便getMesh能用。
		*/
		__proto.releaseMesh=function(){
			this._vb.setByteLength(0);
			this._ib.setByteLength(0);
			this.vertNum=0;
			this.indexNum=0;
			laya.webgl.utils.MeshVG._POOL.push(this);
		}

		__proto.destroy=function(){
			this._ib.destroy();
			this._vb.destroy();
		}

		MeshVG.getAMesh=function(){
			if (laya.webgl.utils.MeshVG._POOL.length){
				return laya.webgl.utils.MeshVG._POOL.pop();
			}
			return new MeshVG();
		}

		MeshVG.const_stride=12;
		MeshVG._POOL=[];
		__static(MeshVG,
		['_fixattriInfo',function(){return this._fixattriInfo=[
			0x1406,2,0,
			0x1401,4,8];}
		]);
		return MeshVG;
	})(Mesh2D)


	/**
	*<code>ShurikenParticleSystem</code> 类用于创建3D粒子数据模板。
	*/
	//class laya.d3.core.particleShuriKen.ShurikenParticleSystem extends laya.d3.core.GeometryElement
	var ShurikenParticleSystem=(function(_super){
		function ShurikenParticleSystem(owner){
			//this._boundingSphere=null;
			//this._boundingBox=null;
			//this._boundingBoxCorners=null;
			//this._owner=null;
			//this._ownerRender=null;
			//this._vertices=null;
			//this._floatCountPerVertex=0;
			//this._startLifeTimeIndex=0;
			//this._timeIndex=0;
			//this._simulateUpdate=false;
			//this._firstActiveElement=0;
			//this._firstNewElement=0;
			//this._firstFreeElement=0;
			//this._firstRetiredElement=0;
			//this._drawCounter=0;
			//this._bufferMaxParticles=0;
			//this._emission=null;
			//this._shape=null;
			//this._isEmitting=false;
			//this._isPlaying=false;
			//this._isPaused=false;
			//this._playStartDelay=NaN;
			//this._frameRateTime=NaN;
			//this._emissionTime=NaN;
			//this._totalDelayTime=NaN;
			//this._burstsIndex=0;
			//this._velocityOverLifetime=null;
			//this._colorOverLifetime=null;
			//this._sizeOverLifetime=null;
			//this._rotationOverLifetime=null;
			//this._textureSheetAnimation=null;
			//this._startLifetimeType=0;
			//this._startLifetimeConstant=NaN;
			//this._startLifeTimeGradient=null;
			//this._startLifetimeConstantMin=NaN;
			//this._startLifetimeConstantMax=NaN;
			//this._startLifeTimeGradientMin=null;
			//this._startLifeTimeGradientMax=null;
			//this._maxStartLifetime=NaN;
			//this._vertexStride=0;
			//this._indexStride=0;
			//this._indexBuffer=null;
			//this._currentTime=NaN;
			//this._startUpdateLoopCount=0;
			//this._rand=null;
			//this._randomSeeds=null;
			//this.duration=NaN;
			//this.looping=false;
			//this.prewarm=false;
			//this.startDelayType=0;
			//this.startDelay=NaN;
			//this.startDelayMin=NaN;
			//this.startDelayMax=NaN;
			//this.startSpeedType=0;
			//this.startSpeedConstant=NaN;
			//this.startSpeedConstantMin=NaN;
			//this.startSpeedConstantMax=NaN;
			//this.threeDStartSize=false;
			//this.startSizeType=0;
			//this.startSizeConstant=NaN;
			//this.startSizeConstantSeparate=null;
			//this.startSizeConstantMin=NaN;
			//this.startSizeConstantMax=NaN;
			//this.startSizeConstantMinSeparate=null;
			//this.startSizeConstantMaxSeparate=null;
			//this.threeDStartRotation=false;
			//this.startRotationType=0;
			//this.startRotationConstant=NaN;
			//this.startRotationConstantSeparate=null;
			//this.startRotationConstantMin=NaN;
			//this.startRotationConstantMax=NaN;
			//this.startRotationConstantMinSeparate=null;
			//this.startRotationConstantMaxSeparate=null;
			//this.randomizeRotationDirection=NaN;
			//this.startColorType=0;
			//this.startColorConstant=null;
			//this.startColorConstantMin=null;
			//this.startColorConstantMax=null;
			//this.gravityModifier=NaN;
			//this.simulationSpace=0;
			//this.scaleMode=0;
			//this.playOnAwake=false;
			//this.randomSeed=null;
			//this.autoRandomSeed=false;
			//this.isPerformanceMode=false;
			ShurikenParticleSystem.__super.call(this);
			this._tempRotationMatrix=new Matrix4x4();
			this._uvLength=new Vector2();
			this._firstActiveElement=0;
			this._firstNewElement=0;
			this._firstFreeElement=0;
			this._firstRetiredElement=0;
			this._owner=owner;
			this._ownerRender=owner.particleRender;
			this._boundingBoxCorners=__newvec(8,null);
			this._boundingSphere=new BoundSphere(new Vector3(),Number.MAX_VALUE);
			this._boundingBox=new BoundBox(new Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),new Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE));
			this._currentTime=0;
			this._isEmitting=false;
			this._isPlaying=false;
			this._isPaused=false;
			this._burstsIndex=0;
			this._frameRateTime=0;
			this._emissionTime=0;
			this._totalDelayTime=0;
			this._simulateUpdate=false;
			this._bufferMaxParticles=1;
			this.duration=5.0;
			this.looping=true;
			this.prewarm=false;
			this.startDelayType=0;
			this.startDelay=0.0;
			this.startDelayMin=0.0;
			this.startDelayMax=0.0;
			this._startLifetimeType=0;
			this._startLifetimeConstant=5.0;
			this._startLifeTimeGradient=new GradientDataNumber();
			this._startLifetimeConstantMin=0.0;
			this._startLifetimeConstantMax=5.0;
			this._startLifeTimeGradientMin=new GradientDataNumber();
			this._startLifeTimeGradientMax=new GradientDataNumber();
			this._maxStartLifetime=5.0;
			this.startSpeedType=0;
			this.startSpeedConstant=5.0;
			this.startSpeedConstantMin=0.0;
			this.startSpeedConstantMax=5.0;
			this.threeDStartSize=false;
			this.startSizeType=0;
			this.startSizeConstant=1;
			this.startSizeConstantSeparate=new Vector3(1,1,1);
			this.startSizeConstantMin=0;
			this.startSizeConstantMax=1;
			this.startSizeConstantMinSeparate=new Vector3(0,0,0);
			this.startSizeConstantMaxSeparate=new Vector3(1,1,1);
			this.threeDStartRotation=false;
			this.startRotationType=0;
			this.startRotationConstant=0;
			this.startRotationConstantSeparate=new Vector3(0,0,0);
			this.startRotationConstantMin=0.0;
			this.startRotationConstantMax=0.0;
			this.startRotationConstantMinSeparate=new Vector3(0,0,0);
			this.startRotationConstantMaxSeparate=new Vector3(0,0,0);
			this.randomizeRotationDirection=0.0;
			this.startColorType=0;
			this.startColorConstant=new Vector4(1,1,1,1);
			this.startColorConstantMin=new Vector4(1,1,1,1);
			this.startColorConstantMax=new Vector4(1,1,1,1);
			this.gravityModifier=0.0;
			this.simulationSpace=1;
			this.scaleMode=0;
			this.playOnAwake=true;
			this._rand=new Rand(0);
			this.autoRandomSeed=true;
			this.randomSeed=new Uint32Array(1);
			this._randomSeeds=new Uint32Array(ShurikenParticleSystem._RANDOMOFFSET.length);
			this.isPerformanceMode=true;
			this._emission=new Emission();
			this._emission.enbale=true;
		}

		__class(ShurikenParticleSystem,'laya.d3.core.particleShuriKen.ShurikenParticleSystem',_super);
		var __proto=ShurikenParticleSystem.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		__proto._getVertexBuffer=function(index){
			(index===void 0)&& (index=0);
			if (index===0)
				return this._vertexBuffer;
			else
			return null;
		}

		__proto._getIndexBuffer=function(){
			return this._indexBuffer;
		}

		/**
		*@private
		*/
		__proto._generateBoundingSphere=function(){
			var centerE=this._boundingSphere.center.elements;
			centerE[0]=0;
			centerE[1]=0;
			centerE[2]=0;
			this._boundingSphere.radius=Number.MAX_VALUE;
		}

		/**
		*@private
		*/
		__proto._generateBoundingBox=function(){
			var particle=this._owner;
			var particleRender=particle.particleRender;
			var boundMin=this._boundingBox.min;
			var boundMax=this._boundingBox.max;
			var i=0,n=0;
			var maxStartLifeTime=NaN;
			switch (this.startLifetimeType){
				case 0:
					maxStartLifeTime=this.startLifetimeConstant;
					break ;
				case 1:
					maxStartLifeTime=-Number.MAX_VALUE;
					var startLifeTimeGradient=startLifeTimeGradient;
					for (i=0,n=startLifeTimeGradient.gradientCount;i < n;i++)
					maxStartLifeTime=Math.max(maxStartLifeTime,startLifeTimeGradient.getValueByIndex(i));
					break ;
				case 2:
					maxStartLifeTime=Math.max(this.startLifetimeConstantMin,this.startLifetimeConstantMax);
					break ;
				case 3:
					maxStartLifeTime=-Number.MAX_VALUE;
					var startLifeTimeGradientMin=startLifeTimeGradientMin;
					for (i=0,n=startLifeTimeGradientMin.gradientCount;i < n;i++)
					maxStartLifeTime=Math.max(maxStartLifeTime,startLifeTimeGradientMin.getValueByIndex(i));
					var startLifeTimeGradientMax=startLifeTimeGradientMax;
					for (i=0,n=startLifeTimeGradientMax.gradientCount;i < n;i++)
					maxStartLifeTime=Math.max(maxStartLifeTime,startLifeTimeGradientMax.getValueByIndex(i));
					break ;
				};
			var minStartSpeed=NaN,maxStartSpeed=NaN;
			switch (this.startSpeedType){
				case 0:
					minStartSpeed=maxStartSpeed=this.startSpeedConstant;
					break ;
				case 1:
					break ;
				case 2:
					minStartSpeed=this.startLifetimeConstantMin;
					maxStartSpeed=this.startLifetimeConstantMax;
					break ;
				case 3:
					break ;
				};
			var minPosition,maxPosition,minDirection,maxDirection;
			if (this._shape && this._shape.enable){
				}else {
				minPosition=maxPosition=Vector3.ZERO;
				minDirection=Vector3.ZERO;
				maxDirection=Vector3.UnitZ;
			};
			var startMinVelocity=new Vector3(minDirection.x *minStartSpeed,minDirection.y *minStartSpeed,minDirection.z *minStartSpeed);
			var startMaxVelocity=new Vector3(maxDirection.x *maxStartSpeed,maxDirection.y *maxStartSpeed,maxDirection.z *maxStartSpeed);
			if (this._velocityOverLifetime && this._velocityOverLifetime.enbale){
				var lifeMinVelocity;
				var lifeMaxVelocity;
				var velocity=this._velocityOverLifetime.velocity;
				switch (velocity.type){
					case 0:
						lifeMinVelocity=lifeMaxVelocity=velocity.constant;
						break ;
					case 1:
						lifeMinVelocity=lifeMaxVelocity=new Vector3(velocity.gradientX.getAverageValue(),velocity.gradientY.getAverageValue(),velocity.gradientZ.getAverageValue());
						break ;
					case 2:
						lifeMinVelocity=velocity.constantMin;
						lifeMaxVelocity=velocity.constantMax;
						break ;
					case 3:
						lifeMinVelocity=new Vector3(velocity.gradientXMin.getAverageValue(),velocity.gradientYMin.getAverageValue(),velocity.gradientZMin.getAverageValue());
						lifeMaxVelocity=new Vector3(velocity.gradientXMax.getAverageValue(),velocity.gradientYMax.getAverageValue(),velocity.gradientZMax.getAverageValue());
						break ;
					}
			};
			var positionScale,velocityScale;
			var transform=this._owner.transform;
			var worldPosition=transform.position;
			var sizeScale=ShurikenParticleSystem._tempVector39;
			var sizeScaleE=sizeScale.elements;
			var renderMode=particleRender.renderMode;
			switch (this.scaleMode){
				case 0:;
					var scale=transform.scale;
					positionScale=scale;
					sizeScaleE[0]=scale.x;
					sizeScaleE[1]=scale.z;
					sizeScaleE[2]=scale.y;
					(renderMode===1)&& (velocityScale=scale);
					break ;
				case 1:;
					var localScale=transform.localScale;
					positionScale=localScale;
					sizeScaleE[0]=localScale.x;
					sizeScaleE[1]=localScale.z;
					sizeScaleE[2]=localScale.y;
					(renderMode===1)&& (velocityScale=localScale);
					break ;
				case 2:
					positionScale=transform.scale;
					sizeScaleE[0]=sizeScaleE[1]=sizeScaleE[2]=1;
					(renderMode===1)&& (velocityScale=Vector3.ONE);
					break ;
				};
			var minStratPosition,maxStratPosition;
			if (this._velocityOverLifetime && this._velocityOverLifetime.enbale){
				}else {
				minStratPosition=new Vector3(startMinVelocity.x *maxStartLifeTime,startMinVelocity.y *maxStartLifeTime,startMinVelocity.z *maxStartLifeTime);
				maxStratPosition=new Vector3(startMaxVelocity.x *maxStartLifeTime,startMaxVelocity.y *maxStartLifeTime,startMaxVelocity.z *maxStartLifeTime);
				if (this.scaleMode !=2){
					Vector3.add(minPosition,minStratPosition,boundMin);
					Vector3.multiply(positionScale,boundMin,boundMin);
					Vector3.add(maxPosition,maxStratPosition,boundMax);
					Vector3.multiply(positionScale,boundMax,boundMax);
					}else {
					Vector3.multiply(positionScale,minPosition,boundMin);
					Vector3.add(boundMin,minStratPosition,boundMin);
					Vector3.multiply(positionScale,maxPosition,boundMax);
					Vector3.add(boundMax,maxStratPosition,boundMax);
				}
			}
			switch (this.simulationSpace){
				case 0:
					break ;
				case 1:
					Vector3.add(boundMin,worldPosition,boundMin);
					Vector3.add(boundMax,worldPosition,boundMax);
					break ;
				};
			var maxSize=NaN,maxSizeY=NaN;
			switch (this.startSizeType){
				case 0:
					if (this.threeDStartSize){
						var startSizeConstantSeparate=startSizeConstantSeparate;
						maxSize=Math.max(startSizeConstantSeparate.x,startSizeConstantSeparate.y);
						if (renderMode===1)
							maxSizeY=startSizeConstantSeparate.y;
						}else {
						maxSize=this.startSizeConstant;
						if (renderMode===1)
							maxSizeY=this.startSizeConstant;
					}
					break ;
				case 1:
					break ;
				case 2:
					if (this.threeDStartSize){
						var startSizeConstantMaxSeparate=startSizeConstantMaxSeparate;
						maxSize=Math.max(startSizeConstantMaxSeparate.x,startSizeConstantMaxSeparate.y);
						if (renderMode===1)
							maxSizeY=startSizeConstantMaxSeparate.y;
						}else {
						maxSize=this.startSizeConstantMax;
						if (renderMode===1)
							maxSizeY=this.startSizeConstantMax;
					}
					break ;
				case 3:
					break ;
				}
			if (this._sizeOverLifetime && this._sizeOverLifetime.enbale){
				var size=this._sizeOverLifetime.size;
				maxSize *=this._sizeOverLifetime.size.getMaxSizeInGradient();
			};
			var threeDMaxSize=ShurikenParticleSystem._tempVector30;
			var threeDMaxSizeE=threeDMaxSize.elements;
			var rotSize=NaN,nonRotSize=NaN;
			switch (renderMode){
				case 0:
					rotSize=maxSize *ShurikenParticleSystem.halfKSqrtOf2;
					Vector3.scale(sizeScale,maxSize,threeDMaxSize);
					Vector3.subtract(boundMin,threeDMaxSize,boundMin);
					Vector3.add(boundMax,threeDMaxSize,boundMax);
					break ;
				case 1:;
					var maxStretchPosition=ShurikenParticleSystem._tempVector31;
					var maxStretchVelocity=ShurikenParticleSystem._tempVector32;
					var minStretchVelocity=ShurikenParticleSystem._tempVector33;
					var minStretchPosition=ShurikenParticleSystem._tempVector34;
					if (this._velocityOverLifetime && this._velocityOverLifetime.enbale){
						}else {
						Vector3.multiply(velocityScale,startMaxVelocity,maxStretchVelocity);
						Vector3.multiply(velocityScale,startMinVelocity,minStretchVelocity);
					};
					var sizeStretch=maxSizeY *particleRender.stretchedBillboardLengthScale;
					var maxStretchLength=Vector3.scalarLength(maxStretchVelocity)*particleRender.stretchedBillboardSpeedScale+sizeStretch;
					var minStretchLength=Vector3.scalarLength(minStretchVelocity)*particleRender.stretchedBillboardSpeedScale+sizeStretch;
					var norMaxStretchVelocity=ShurikenParticleSystem._tempVector35;
					var norMinStretchVelocity=ShurikenParticleSystem._tempVector36;
					Vector3.normalize(maxStretchVelocity,norMaxStretchVelocity);
					Vector3.scale(norMaxStretchVelocity,maxStretchLength,minStretchPosition);
					Vector3.subtract(maxStratPosition,minStretchPosition,minStretchPosition);
					Vector3.normalize(minStretchVelocity,norMinStretchVelocity);
					Vector3.scale(norMinStretchVelocity,minStretchLength,maxStretchPosition);
					Vector3.add(minStratPosition,maxStretchPosition,maxStretchPosition);
					rotSize=maxSize *ShurikenParticleSystem.halfKSqrtOf2;
					Vector3.scale(sizeScale,rotSize,threeDMaxSize);
					var halfNorMaxStretchVelocity=ShurikenParticleSystem._tempVector37;
					var halfNorMinStretchVelocity=ShurikenParticleSystem._tempVector38;
					Vector3.scale(norMaxStretchVelocity,0.5,halfNorMaxStretchVelocity);
					Vector3.scale(norMinStretchVelocity,0.5,halfNorMinStretchVelocity);
					Vector3.multiply(halfNorMaxStretchVelocity,sizeScale,halfNorMaxStretchVelocity);
					Vector3.multiply(halfNorMinStretchVelocity,sizeScale,halfNorMinStretchVelocity);
					Vector3.add(boundMin,halfNorMinStretchVelocity,boundMin);
					Vector3.min(boundMin,minStretchPosition,boundMin);
					Vector3.subtract(boundMin,threeDMaxSize,boundMin);
					Vector3.subtract(boundMax,halfNorMaxStretchVelocity,boundMax);
					Vector3.max(boundMax,maxStretchPosition,boundMax);
					Vector3.add(boundMax,threeDMaxSize,boundMax);
					break ;
				case 2:
					maxSize *=Math.cos(0.78539816339744830961566084581988);
					nonRotSize=maxSize *0.5;
					threeDMaxSizeE[0]=sizeScale.x *nonRotSize;
					threeDMaxSizeE[1]=sizeScale.z *nonRotSize;
					Vector3.subtract(boundMin,threeDMaxSize,boundMin);
					Vector3.add(boundMax,threeDMaxSize,boundMax);
					break ;
				case 3:
					maxSize *=Math.cos(0.78539816339744830961566084581988);
					nonRotSize=maxSize *0.5;
					Vector3.scale(sizeScale,nonRotSize,threeDMaxSize);
					Vector3.subtract(boundMin,threeDMaxSize,boundMin);
					Vector3.add(boundMax,threeDMaxSize,boundMax);
					break ;
				}
			this._boundingBox.getCorners(this._boundingBoxCorners);
		}

		/**
		*@private
		*/
		__proto._updateEmission=function(){
			if (!this.isAlive)
				return;
			if (this._simulateUpdate){
				this._simulateUpdate=false;
			}
			else{
				var elapsedTime=(this._startUpdateLoopCount!==Stat.loopCount && !this._isPaused)?Laya.timer.delta / 1000.0:0;
				elapsedTime=Math.min(ShurikenParticleSystem._maxElapsedTime,elapsedTime);
				this._updateParticles(elapsedTime);
			}
		}

		/**
		*@private
		*/
		__proto._updateParticles=function(elapsedTime){
			if (this._ownerRender.renderMode===4 && !this._ownerRender.mesh)
				return;
			this._currentTime+=elapsedTime;
			this._retireActiveParticles();
			this._freeRetiredParticles();
			this._totalDelayTime+=elapsedTime;
			if (this._totalDelayTime < this._playStartDelay){
				return;
			}
			if (this._emission.enbale&&this._isEmitting &&!this._isPaused)
				this._advanceTime(elapsedTime,this._currentTime);
		}

		/**
		*@private
		*/
		__proto._updateParticlesSimulationRestart=function(time){
			this._firstActiveElement=0;
			this._firstNewElement=0;
			this._firstFreeElement=0;
			this._firstRetiredElement=0;
			this._burstsIndex=0;
			this._frameRateTime=time;
			this._emissionTime=0;
			this._totalDelayTime=0;
			this._currentTime=time;
			var delayTime=time;
			if (delayTime < this._playStartDelay){
				this._totalDelayTime=delayTime;
				return;
			}
			if (this._emission.enbale)
				this._advanceTime(time,time);
		}

		/**
		*@private
		*/
		__proto._retireActiveParticles=function(){
			var epsilon=0.0001;
			while (this._firstActiveElement !=this._firstNewElement){
				var index=this._firstActiveElement *this._floatCountPerVertex *this._vertexStride;
				var timeIndex=index+this._timeIndex;
				var particleAge=this._currentTime-this._vertices[timeIndex];
				if (particleAge+epsilon < this._vertices[index+this._startLifeTimeIndex])
					break ;
				this._vertices[timeIndex]=this._drawCounter;
				this._firstActiveElement++;
				if (this._firstActiveElement >=this._bufferMaxParticles)
					this._firstActiveElement=0;
			}
		}

		/**
		*@private
		*/
		__proto._freeRetiredParticles=function(){
			while (this._firstRetiredElement !=this._firstActiveElement){
				var age=this._drawCounter-this._vertices[this._firstRetiredElement *this._floatCountPerVertex *this._vertexStride+this._timeIndex];
				if (this.isPerformanceMode)
					if (age < 3)
				break ;
				this._firstRetiredElement++;
				if (this._firstRetiredElement >=this._bufferMaxParticles)
					this._firstRetiredElement=0;
			}
		}

		/**
		*@private
		*/
		__proto._burst=function(fromTime,toTime){
			var totalEmitCount=0;
			var bursts=this._emission._bursts;
			for (var n=bursts.length;this._burstsIndex < n;this._burstsIndex++){
				var burst=bursts[this._burstsIndex];
				var burstTime=burst.time;
				if (fromTime<=burstTime && burstTime < toTime){
					var emitCount=0;
					if (this.autoRandomSeed){
						emitCount=MathUtil.lerp(burst.minCount,burst.maxCount,Math.random());
						}else {
						this._rand.seed=this._randomSeeds[0];
						emitCount=MathUtil.lerp(burst.minCount,burst.maxCount,this._rand.getFloat());
						this._randomSeeds[0]=this._rand.seed;
					}
					totalEmitCount+=emitCount;
					}else {
					break ;
				}
			}
			return totalEmitCount;
		}

		/**
		*@private
		*/
		__proto._advanceTime=function(elapsedTime,emitTime){
			var i=0;
			var lastEmissionTime=this._emissionTime;
			this._emissionTime+=elapsedTime;
			var totalEmitCount=0;
			if (this._emissionTime > this.duration){
				if (this.looping){
					totalEmitCount+=this._burst(lastEmissionTime,this._emissionTime);
					this._emissionTime-=this.duration;
					this._burstsIndex=0;
					totalEmitCount+=this._burst(0,this._emissionTime);
					}else {
					totalEmitCount=Math.min(this.maxParticles-this.aliveParticleCount,totalEmitCount);
					for (i=0;i < totalEmitCount;i++)
					this.emit(emitTime);
					this._isPlaying=false;
					this.stop();
					return;
				}
				}else {
				totalEmitCount+=this._burst(lastEmissionTime,this._emissionTime);
			}
			totalEmitCount=Math.min(this.maxParticles-this.aliveParticleCount,totalEmitCount);
			for (i=0;i < totalEmitCount;i++)
			this.emit(emitTime);
			var emissionRate=this.emission.emissionRate;
			if (emissionRate>0){
				var minEmissionTime=1/emissionRate;
				this._frameRateTime+=minEmissionTime;
				this._frameRateTime=this._currentTime-(this._currentTime-this._frameRateTime)% this._maxStartLifetime;
				while (this._frameRateTime <=emitTime){
					if (this.emit(this._frameRateTime))
						this._frameRateTime+=minEmissionTime;
					else
					break ;
				}
				this._frameRateTime=Math.floor(emitTime / minEmissionTime)*minEmissionTime;
			}
		}

		/**
		*@private
		*/
		__proto._initBufferDatas=function(){
			if (this._vertexBuffer){
				this._vertexBuffer.destroy();
				this._indexBuffer.destroy();
			};
			var render=this._ownerRender;
			var renderMode=render.renderMode;
			if (renderMode!==-1 && this.maxParticles > 0){
				var indices,i=0,j=0,m=0,indexOffset=0,perPartOffset=0,vertexDeclaration;;
				var mesh=render.mesh;
				if (renderMode===4){
					if(mesh){
						var vertexBufferCount=mesh._vertexBuffers.length;
						if (vertexBufferCount > 1){
							throw new Error("ShurikenParticleSystem: submesh Count mesh be One or all subMeshes have the same vertexDeclaration.");
							}else {
							vertexDeclaration=VertexShurikenParticleMesh.vertexDeclaration;
							this._floatCountPerVertex=vertexDeclaration.vertexStride/4;
							this._startLifeTimeIndex=12;
							this._timeIndex=16;
							this._vertexStride=mesh._vertexBuffers[0].vertexCount;
							var totalVertexCount=this._bufferMaxParticles *this._vertexStride;
							var vbCount=Math.floor(totalVertexCount / 65535)+1;
							var lastVBVertexCount=totalVertexCount % 65535;
							if (vbCount > 1){
								throw new Error("ShurikenParticleSystem:the maxParticleCount multiply mesh vertexCount is large than 65535.");
							}
							this._vertexBuffer=new VertexBuffer3D(vertexDeclaration.vertexStride*lastVBVertexCount,0x88E8);
							this._vertexBuffer.vertexDeclaration=vertexDeclaration;
							this._vertices=new Float32Array(this._floatCountPerVertex *lastVBVertexCount);
							this._setVertexBuffer(this._vertexBuffer);
							this._indexStride=mesh._indexBuffer.indexCount;
							var indexDatas=mesh._indexBuffer.getData();
							var indexCount=this._bufferMaxParticles *this._indexStride;
							this._indexBuffer=IndexBuffer3D.create("ushort",indexCount,0x88E4);
							indices=new Uint16Array(indexCount);
							indexOffset=0;
							for (i=0;i < this._bufferMaxParticles;i++){
								var indexValueOffset=i *this._vertexStride;
								for (j=0,m=indexDatas.length;j < m;j++)
								indices[indexOffset++]=indexValueOffset+indexDatas[j];
							}
							this._indexBuffer.setData(indices);
						}
					}
					}else {
					vertexDeclaration=VertexShurikenParticleBillboard.vertexDeclaration;
					this._floatCountPerVertex=vertexDeclaration.vertexStride/4;
					this._startLifeTimeIndex=7;
					this._timeIndex=11;
					this._vertexStride=4;
					this._vertexBuffer=new VertexBuffer3D(vertexDeclaration.vertexStride*this._bufferMaxParticles *this._vertexStride,0x88E8);
					this._vertexBuffer.vertexDeclaration=vertexDeclaration;
					this._vertices=new Float32Array(this._floatCountPerVertex *this._bufferMaxParticles *this._vertexStride);
					this._setVertexBuffer(this._vertexBuffer);
					for (i=0;i < this._bufferMaxParticles;i++){
						perPartOffset=i *this._floatCountPerVertex *this._vertexStride;
						this._vertices[perPartOffset]=-0.5;
						this._vertices[perPartOffset+1]=-0.5;
						this._vertices[perPartOffset+2]=0;
						this._vertices[perPartOffset+3]=1;
						perPartOffset+=this._floatCountPerVertex;
						this._vertices[perPartOffset]=0.5;
						this._vertices[perPartOffset+1]=-0.5;
						this._vertices[perPartOffset+2]=1;
						this._vertices[perPartOffset+3]=1;
						perPartOffset+=this._floatCountPerVertex
						this._vertices[perPartOffset]=0.5;
						this._vertices[perPartOffset+1]=0.5;
						this._vertices[perPartOffset+2]=1;
						this._vertices[perPartOffset+3]=0;
						perPartOffset+=this._floatCountPerVertex
						this._vertices[perPartOffset]=-0.5;
						this._vertices[perPartOffset+1]=0.5;
						this._vertices[perPartOffset+2]=0;
						this._vertices[perPartOffset+3]=0;
					}
					this._indexStride=6;
					this._indexBuffer=IndexBuffer3D.create("ushort",this._bufferMaxParticles *6,0x88E4);
					indices=new Uint16Array(this._bufferMaxParticles *6);
					for (i=0;i < this._bufferMaxParticles;i++){
						indexOffset=i *6;
						var firstVertex=i *this._vertexStride,secondVertex=firstVertex+2;
						indices[indexOffset++]=firstVertex;
						indices[indexOffset++]=secondVertex;
						indices[indexOffset++]=firstVertex+1;
						indices[indexOffset++]=firstVertex;
						indices[indexOffset++]=firstVertex+3;
						indices[indexOffset++]=secondVertex;
					}
					this._indexBuffer.setData(indices);
				}
			}
		}

		/**
		*@private
		*/
		__proto.destroy=function(){
			_super.prototype.destroy.call(this);
			this._vertexBuffer.destroy();
			this._indexBuffer.destroy();
			this._emission._destroy();
			this._owner=null;
			this._vertices=null;
			this._vertexBuffer=null;
			this._indexBuffer=null;
			this._emission=null;
			this._shape=null;
			this.startLifeTimeGradient=null;
			this.startLifeTimeGradientMin=null;
			this.startLifeTimeGradientMax=null;
			this.startSizeConstantSeparate=null;
			this.startSizeConstantMinSeparate=null;
			this.startSizeConstantMaxSeparate=null;
			this.startRotationConstantSeparate=null;
			this.startRotationConstantMinSeparate=null;
			this.startRotationConstantMaxSeparate=null;
			this.startColorConstant=null;
			this.startColorConstantMin=null;
			this.startColorConstantMax=null;
			this._velocityOverLifetime=null;
			this._colorOverLifetime=null;
			this._sizeOverLifetime=null;
			this._rotationOverLifetime=null;
			this._textureSheetAnimation=null;
		}

		/**
		*发射一个粒子。
		*/
		__proto.emit=function(time){
			var position=ShurikenParticleSystem._tempPosition;
			var direction=ShurikenParticleSystem._tempDirection;
			if (this._shape&&this._shape.enable){
				if (this.autoRandomSeed)
					this._shape.generatePositionAndDirection(position,direction);
				else
				this._shape.generatePositionAndDirection(position,direction,this._rand,this._randomSeeds);
				}else {
				var positionE=position.elements;
				var directionE=direction.elements;
				positionE[0]=positionE[1]=positionE[2]=0;
				directionE[0]=directionE[1]=0;
				directionE[2]=1;
			}
			return this.addParticle(position,direction,time);
		}

		//TODO:提前判断优化
		__proto.addParticle=function(position,direction,time){
			Vector3.normalize(direction,direction);
			var nextFreeParticle=this._firstFreeElement+1;
			if (nextFreeParticle >=this._bufferMaxParticles)
				nextFreeParticle=0;
			if (nextFreeParticle===this._firstRetiredElement)
				return false;
			ShurikenParticleData.create(this,this._ownerRender,this._owner.transform);
			var particleAge=this._currentTime-time;
			if (particleAge >=ShurikenParticleData.startLifeTime)
				return true;
			var randomVelocityX=NaN,randomVelocityY=NaN,randomVelocityZ=NaN,randomColor=NaN,randomSize=NaN,randomRotation=NaN,randomTextureAnimation=NaN;
			var needRandomVelocity=this._velocityOverLifetime && this._velocityOverLifetime.enbale;
			if (needRandomVelocity){
				var velocityType=this._velocityOverLifetime.velocity.type;
				if (velocityType===2 || velocityType===3){
					if (this.autoRandomSeed){
						randomVelocityX=Math.random();
						randomVelocityY=Math.random();
						randomVelocityZ=Math.random();
						}else {
						this._rand.seed=this._randomSeeds[9];
						randomVelocityX=this._rand.getFloat();
						randomVelocityY=this._rand.getFloat();
						randomVelocityZ=this._rand.getFloat();
						this._randomSeeds[9]=this._rand.seed;
					}
					}else {
					needRandomVelocity=false;
				}
				}else {
				needRandomVelocity=false;
			};
			var needRandomColor=this._colorOverLifetime && this._colorOverLifetime.enbale;
			if (needRandomColor){
				var colorType=this._colorOverLifetime.color.type;
				if (colorType===3){
					if (this.autoRandomSeed){
						randomColor=Math.random();
						}else {
						this._rand.seed=this._randomSeeds[10];
						randomColor=this._rand.getFloat();
						this._randomSeeds[10]=this._rand.seed;
					}
					}else {
					needRandomColor=false;
				}
				}else {
				needRandomColor=false;
			};
			var needRandomSize=this._sizeOverLifetime && this._sizeOverLifetime.enbale;
			if (needRandomSize){
				var sizeType=this._sizeOverLifetime.size.type;
				if (sizeType===3){
					if (this.autoRandomSeed){
						randomSize=Math.random();
						}else {
						this._rand.seed=this._randomSeeds[11];
						randomSize=this._rand.getFloat();
						this._randomSeeds[11]=this._rand.seed;
					}
					}else {
					needRandomSize=false;
				}
				}else {
				needRandomSize=false;
			};
			var needRandomRotation=this._rotationOverLifetime && this._rotationOverLifetime.enbale;
			if (needRandomRotation){
				var rotationType=this._rotationOverLifetime.angularVelocity.type;
				if (rotationType===2 || rotationType===3){
					if (this.autoRandomSeed){
						randomRotation=Math.random();
						}else {
						this._rand.seed=this._randomSeeds[12];
						randomRotation=this._rand.getFloat();
						this._randomSeeds[12]=this._rand.seed;
					}
					}else {
					needRandomRotation=false;
				}
				}else {
				needRandomRotation=false;
			};
			var needRandomTextureAnimation=this._textureSheetAnimation && this._textureSheetAnimation.enable;
			if (needRandomTextureAnimation){
				var textureAnimationType=this._textureSheetAnimation.frame.type;
				if (textureAnimationType===3){
					if (this.autoRandomSeed){
						randomTextureAnimation=Math.random();
						}else {
						this._rand.seed=this._randomSeeds[15];
						randomTextureAnimation=this._rand.getFloat();
						this._randomSeeds[15]=this._rand.seed;
					}
					}else {
					needRandomTextureAnimation=false;
				}
				}else {
				needRandomTextureAnimation=false;
			};
			var startIndex=this._firstFreeElement *this._floatCountPerVertex *this._vertexStride;
			var subU=ShurikenParticleData.startUVInfo[0];
			var subV=ShurikenParticleData.startUVInfo[1];
			var startU=ShurikenParticleData.startUVInfo[2];
			var startV=ShurikenParticleData.startUVInfo[3];
			var positionE=position.elements;
			var directionE=direction.elements;
			var meshVertices,meshVertexStride=0,meshPosOffset=0,meshCorOffset=0,meshUVOffset=0,meshVertexIndex=0;
			var render=this._ownerRender;
			if (render.renderMode===4){
				var meshVB=render.mesh._vertexBuffers[0];
				meshVertices=meshVB.getData();
				var meshVertexDeclaration=meshVB.vertexDeclaration;
				meshPosOffset=meshVertexDeclaration.getVertexElementByUsage(0).offset / 4;
				var colorElement=meshVertexDeclaration.getVertexElementByUsage(1);
				meshCorOffset=colorElement?colorElement.offset / 4:-1;
				var uvElement=meshVertexDeclaration.getVertexElementByUsage(2);
				meshUVOffset=uvElement?uvElement.offset / 4:-1;
				meshVertexStride=meshVertexDeclaration.vertexStride / 4;
				meshVertexIndex=0;
				}else {
				this._vertices[startIndex+2]=startU;
				this._vertices[startIndex+3]=startV+subV;
				var secondOffset=startIndex+this._floatCountPerVertex;
				this._vertices[secondOffset+2]=startU+subU;
				this._vertices[secondOffset+3]=startV+subV;
				var thirdOffset=secondOffset+this._floatCountPerVertex;
				this._vertices[thirdOffset+2]=startU+subU;
				this._vertices[thirdOffset+3]=startV;
				var fourthOffset=thirdOffset+this._floatCountPerVertex;
				this._vertices[fourthOffset+2]=startU;
				this._vertices[fourthOffset+3]=startV;
			}
			for (var i=startIndex,n=startIndex+this._floatCountPerVertex *this._vertexStride;i < n;i+=this._floatCountPerVertex){
				var offset=0;
				if (render.renderMode===4){
					offset=i;
					var vertexOffset=meshVertexStride *(meshVertexIndex++);
					var meshOffset=vertexOffset+meshPosOffset;
					this._vertices[offset++]=meshVertices[meshOffset++];
					this._vertices[offset++]=meshVertices[meshOffset++];
					this._vertices[offset++]=meshVertices[meshOffset];
					if (meshCorOffset===-1){
						this._vertices[offset++]=1.0;
						this._vertices[offset++]=1.0;
						this._vertices[offset++]=1.0;
						this._vertices[offset++]=1.0;
					}
					else{
						meshOffset=vertexOffset+meshCorOffset;
						this._vertices[offset++]=meshVertices[meshOffset++];
						this._vertices[offset++]=meshVertices[meshOffset++];
						this._vertices[offset++]=meshVertices[meshOffset++];
						this._vertices[offset++]=meshVertices[meshOffset];
					}
					if (meshUVOffset===-1){
						this._vertices[offset++]=0.0;
						this._vertices[offset++]=0.0;
					}
					else{
						meshOffset=vertexOffset+meshUVOffset;
						this._vertices[offset++]=startU+meshVertices[meshOffset++] *subU;
						this._vertices[offset++]=startV+meshVertices[meshOffset] *subV;
					}
					}else {
					offset=i+4;
				}
				this._vertices[offset++]=positionE[0];
				this._vertices[offset++]=positionE[1];
				this._vertices[offset++]=positionE[2];
				this._vertices[offset++]=ShurikenParticleData.startLifeTime;
				this._vertices[offset++]=directionE[0];
				this._vertices[offset++]=directionE[1];
				this._vertices[offset++]=directionE[2];
				this._vertices[offset++]=time;
				this._vertices[offset++]=ShurikenParticleData.startColor[0];
				this._vertices[offset++]=ShurikenParticleData.startColor[1];
				this._vertices[offset++]=ShurikenParticleData.startColor[2];
				this._vertices[offset++]=ShurikenParticleData.startColor[3];
				this._vertices[offset++]=ShurikenParticleData.startSize[0];
				this._vertices[offset++]=ShurikenParticleData.startSize[1];
				this._vertices[offset++]=ShurikenParticleData.startSize[2];
				this._vertices[offset++]=ShurikenParticleData.startRotation[0];
				this._vertices[offset++]=ShurikenParticleData.startRotation[1];
				this._vertices[offset++]=ShurikenParticleData.startRotation[2];
				this._vertices[offset++]=ShurikenParticleData.startSpeed;
				needRandomColor && (this._vertices[offset+1]=randomColor);
				needRandomSize && (this._vertices[offset+2]=randomSize);
				needRandomRotation && (this._vertices[offset+3]=randomRotation);
				needRandomTextureAnimation && (this._vertices[offset+4]=randomTextureAnimation);
				if (needRandomVelocity){
					this._vertices[offset+5]=randomVelocityX;
					this._vertices[offset+6]=randomVelocityY;
					this._vertices[offset+7]=randomVelocityZ;
				}
				switch(this.simulationSpace){
					case 0:
						offset+=8;
						this._vertices[offset++]=ShurikenParticleData.simulationWorldPostion[0];
						this._vertices[offset++]=ShurikenParticleData.simulationWorldPostion[1];
						this._vertices[offset++]=ShurikenParticleData.simulationWorldPostion[2];
						this._vertices[offset++]=ShurikenParticleData.simulationWorldRotation[0];
						this._vertices[offset++]=ShurikenParticleData.simulationWorldRotation[1];
						this._vertices[offset++]=ShurikenParticleData.simulationWorldRotation[2];
						this._vertices[offset++]=ShurikenParticleData.simulationWorldRotation[3];
						break ;
					case 1:
						break ;
					default :
						throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
					}
			}
			this._firstFreeElement=nextFreeParticle;
			return true;
		}

		__proto.addNewParticlesToVertexBuffer=function(){
			var start=0;
			if (this._firstNewElement < this._firstFreeElement){
				start=this._firstNewElement *this._vertexStride *this._floatCountPerVertex;
				this._vertexBuffer.setData(this._vertices,start,start,(this._firstFreeElement-this._firstNewElement)*this._vertexStride *this._floatCountPerVertex);
				}else {
				start=this._firstNewElement *this._vertexStride *this._floatCountPerVertex;
				this._vertexBuffer.setData(this._vertices,start,start,(this._bufferMaxParticles-this._firstNewElement)*this._vertexStride *this._floatCountPerVertex);
				if (this._firstFreeElement > 0){
					this._vertexBuffer.setData(this._vertices,0,0,this._firstFreeElement *this._vertexStride *this._floatCountPerVertex);
				}
			}
			this._firstNewElement=this._firstFreeElement;
		}

		/**
		*@inheritDoc
		*/
		__proto._prepareRender=function(state){
			this._updateEmission();
			if (this._firstNewElement !=this._firstFreeElement)
				this.addNewParticlesToVertexBuffer();
			this._drawCounter++;
			if (this._firstActiveElement !=this._firstFreeElement)
				return true;
			else
			return false;
		}

		/**
		*@private
		*/
		__proto._render=function(state){
			this._indexBuffer.bind();
			var indexCount=0;
			var gl=LayaGL.instance;
			if (this._firstActiveElement < this._firstFreeElement){
				indexCount=(this._firstFreeElement-this._firstActiveElement)*this._indexStride;
				gl.drawElements(0x0004,indexCount,0x1403,2 *this._firstActiveElement *this._indexStride);
				Stat.trianglesFaces+=indexCount / 3;
				Stat.drawCall++;
				}else {
				indexCount=(this._bufferMaxParticles-this._firstActiveElement)*this._indexStride;
				gl.drawElements(0x0004,indexCount,0x1403,2 *this._firstActiveElement *this._indexStride);
				Stat.trianglesFaces+=indexCount / 3;
				Stat.drawCall++;
				if (this._firstFreeElement > 0){
					indexCount=this._firstFreeElement *this._indexStride;
					gl.drawElements(0x0004,indexCount,0x1403,0);
					Stat.trianglesFaces+=indexCount / 3;
					Stat.drawCall++;
				}
			}
		}

		/**
		*开始发射粒子。
		*/
		__proto.play=function(){
			this._burstsIndex=0;
			this._isEmitting=true;
			this._isPlaying=true;
			this._isPaused=false;
			this._emissionTime=0;
			this._totalDelayTime=0;
			if (!this.autoRandomSeed){
				for (var i=0,n=this._randomSeeds.length;i < n;i++)
				this._randomSeeds[i]=this.randomSeed[0]+ShurikenParticleSystem._RANDOMOFFSET[i];
			}
			switch (this.startDelayType){
				case 0:
					this._playStartDelay=this.startDelay;
					break ;
				case 1:
					if (this.autoRandomSeed){
						this._playStartDelay=MathUtil.lerp(this.startDelayMin,this.startDelayMax,Math.random());
						}else {
						this._rand.seed=this._randomSeeds[2];
						this._playStartDelay=MathUtil.lerp(this.startDelayMin,this.startDelayMax,this._rand.getFloat());
						this._randomSeeds[2]=this._rand.seed;
					}
					break ;
				default :
					throw new Error("Utils3D: startDelayType is invalid.");
				}
			this._frameRateTime=this._currentTime+this._playStartDelay;
			this._startUpdateLoopCount=Stat.loopCount;
		}

		/**
		*暂停发射粒子。
		*/
		__proto.pause=function(){
			this._isPaused=true;
		}

		/**
		*通过指定时间增加粒子播放进度，并暂停播放。
		*@param time 进度时间.如果restart为true,粒子播放时间会归零后再更新进度。
		*@param restart 是否重置播放状态。
		*/
		__proto.simulate=function(time,restart){
			(restart===void 0)&& (restart=true);
			this._simulateUpdate=true;
			if (restart){
				this._updateParticlesSimulationRestart(time);
			}
			else{
				this._isPaused=false;
				this._updateParticles(time);
			}
			this.pause();
		}

		/**
		*停止发射粒子。
		*/
		__proto.stop=function(){
			this._burstsIndex=0;
			this._isEmitting=false;
			this._emissionTime=0;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var dest=destObject;
			dest.duration=this.duration;
			dest.looping=this.looping;
			dest.prewarm=this.prewarm;
			dest.startDelayType=this.startDelayType;
			dest.startDelay=this.startDelay;
			dest.startDelayMin=this.startDelayMin;
			dest.startDelayMax=this.startDelayMax;
			dest._maxStartLifetime=this._maxStartLifetime;
			dest.startLifetimeType=this.startLifetimeType;
			dest.startLifetimeConstant=this.startLifetimeConstant;
			this.startLifeTimeGradient.cloneTo(dest.startLifeTimeGradient);
			dest.startLifetimeConstantMin=this.startLifetimeConstantMin;
			dest.startLifetimeConstantMax=this.startLifetimeConstantMax;
			this.startLifeTimeGradientMin.cloneTo(dest.startLifeTimeGradientMin);
			this.startLifeTimeGradientMax.cloneTo(dest.startLifeTimeGradientMax);
			dest.startSpeedType=this.startSpeedType;
			dest.startSpeedConstant=this.startSpeedConstant;
			dest.startSpeedConstantMin=this.startSpeedConstantMin;
			dest.startSpeedConstantMax=this.startSpeedConstantMax;
			dest.threeDStartSize=this.threeDStartSize;
			dest.startSizeType=this.startSizeType;
			dest.startSizeConstant=this.startSizeConstant;
			this.startSizeConstantSeparate.cloneTo(dest.startSizeConstantSeparate);
			dest.startSizeConstantMin=this.startSizeConstantMin;
			dest.startSizeConstantMax=this.startSizeConstantMax;
			this.startSizeConstantMinSeparate.cloneTo(dest.startSizeConstantMinSeparate);
			this.startSizeConstantMaxSeparate.cloneTo(dest.startSizeConstantMaxSeparate);
			dest.threeDStartRotation=this.threeDStartRotation;
			dest.startRotationType=this.startRotationType;
			dest.startRotationConstant=this.startRotationConstant;
			this.startRotationConstantSeparate.cloneTo(dest.startRotationConstantSeparate);
			dest.startRotationConstantMin=this.startRotationConstantMin;
			dest.startRotationConstantMax=this.startRotationConstantMax;
			this.startRotationConstantMinSeparate.cloneTo(dest.startRotationConstantMinSeparate);
			this.startRotationConstantMaxSeparate.cloneTo(dest.startRotationConstantMaxSeparate);
			dest.randomizeRotationDirection=this.randomizeRotationDirection;
			dest.startColorType=this.startColorType;
			this.startColorConstant.cloneTo(dest.startColorConstant);
			this.startColorConstantMin.cloneTo(dest.startColorConstantMin);
			this.startColorConstantMax.cloneTo(dest.startColorConstantMax);
			dest.gravityModifier=this.gravityModifier;
			dest.simulationSpace=this.simulationSpace;
			dest.scaleMode=this.scaleMode;
			dest.playOnAwake=this.playOnAwake;
			dest.maxParticles=this.maxParticles;
			(this._emission)&& (dest._emission=this._emission.clone());
			(this.shape)&& (dest.shape=this.shape.clone());
			(this.velocityOverLifetime)&& (dest.velocityOverLifetime=this.velocityOverLifetime.clone());
			(this.colorOverLifetime)&& (dest.colorOverLifetime=this.colorOverLifetime.clone());
			(this.sizeOverLifetime)&& (dest.sizeOverLifetime=this.sizeOverLifetime.clone());
			(this.rotationOverLifetime)&& (dest.rotationOverLifetime=this.rotationOverLifetime.clone());
			(this.textureSheetAnimation)&& (dest.textureSheetAnimation=this.textureSheetAnimation.clone());
			dest.isPerformanceMode=this.isPerformanceMode;
			dest._isEmitting=this._isEmitting;
			dest._isPlaying=this._isPlaying;
			dest._isPaused=this._isPaused;
			dest._playStartDelay=this._playStartDelay;
			dest._frameRateTime=this._frameRateTime;
			dest._emissionTime=this._emissionTime;
			dest._totalDelayTime=this._totalDelayTime;
			dest._burstsIndex=this._burstsIndex;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		/**设置最大粒子数,注意:谨慎修改此属性，有性能损耗。*/
		/**获取最大粒子数。*/
		__getset(0,__proto,'maxParticles',function(){
			return this._bufferMaxParticles-1;
			},function(value){
			var newMaxParticles=value+1;
			if (newMaxParticles!==this._bufferMaxParticles){
				this._bufferMaxParticles=newMaxParticles;
				this._initBufferDatas();
			}
		});

		/**
		*是否正在发射。
		*/
		__getset(0,__proto,'isEmitting',function(){
			return this._isEmitting;
		});

		/**
		*是否存活。
		*/
		__getset(0,__proto,'isAlive',function(){
			if (this._isPlaying || this.aliveParticleCount > 0)
				return true;
			return false;
		});

		/**
		*设置形状。
		*/
		/**
		*获取形状。
		*/
		__getset(0,__proto,'shape',function(){
			return this._shape;
			},function(value){
			if (this._shape!==value){
				if (value&&value.enable)
					this._owner._render._defineDatas.add(ShuriKenParticle3D.SHADERDEFINE_SHAPE);
				else
				this._owner._render._defineDatas.remove(ShuriKenParticle3D.SHADERDEFINE_SHAPE);
				this._shape=value;
			}
		});

		/**
		*设置生命周期旋转,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@param value 生命周期旋转。
		*/
		/**
		*获取生命周期旋转,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@return 生命周期旋转。
		*/
		__getset(0,__proto,'rotationOverLifetime',function(){
			return this._rotationOverLifetime;
			},function(value){
			var defDat=this._owner._render._defineDatas;
			var shaDat=this._owner._render._shaderValues;
			if (value){
				var rotation=value.angularVelocity;
				if (!rotation)
					return;
				var rotationSeparate=rotation.separateAxes;
				var rotationType=rotation.type;
				if (value.enbale){
					if (rotationSeparate)
						defDat.add(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
					else
					defDat.add(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME);
					switch (rotationType){
						case 0:
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
							break ;
						case 1:
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
							break ;
						case 2:
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
							break ;
						case 3:
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
							break ;
						}
					}else {
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME);
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
				}
				switch (rotationType){
					case 0:
						if (rotationSeparate){
							shaDat.setVector(35,rotation.constantSeparate);
							}else {
							shaDat.setNumber(34,rotation.constant);
						}
						break ;
					case 1:
						if (rotationSeparate){
							shaDat.setBuffer(37,rotation.gradientX._elements);
							shaDat.setBuffer(38,rotation.gradientY._elements);
							shaDat.setBuffer(39,rotation.gradientZ._elements);
							shaDat.setBuffer(40,rotation.gradientW._elements);
							}else {
							shaDat.setBuffer(36,rotation.gradient._elements);
						}
						break ;
					case 2:
						if (rotationSeparate){
							shaDat.setVector(35,rotation.constantMinSeparate);
							shaDat.setVector(42,rotation.constantMaxSeparate);
							}else {
							shaDat.setNumber(34,rotation.constantMin);
							shaDat.setNumber(41,rotation.constantMax);
						}
						break ;
					case 3:
						if (rotationSeparate){
							shaDat.setBuffer(37,rotation.gradientXMin._elements);
							shaDat.setBuffer(44,rotation.gradientXMax._elements);
							shaDat.setBuffer(38,rotation.gradientYMin._elements);
							shaDat.setBuffer(45,rotation.gradientYMax._elements);
							shaDat.setBuffer(39,rotation.gradientZMin._elements);
							shaDat.setBuffer(46,rotation.gradientZMax._elements);
							shaDat.setBuffer(40,rotation.gradientWMin._elements);
							shaDat.setBuffer(47,rotation.gradientWMax._elements);
							}else {
							shaDat.setBuffer(36,rotation.gradientMin._elements);
							shaDat.setBuffer(43,rotation.gradientMax._elements);
						}
						break ;
					}
				}else {
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
				shaDat.setVector(35,null);
				shaDat.setVector(42,null);
				shaDat.setNumber(34,undefined);
				shaDat.setNumber(41,undefined);
				shaDat.setBuffer(37,null);
				shaDat.setBuffer(44,null);
				shaDat.setBuffer(38,null);
				shaDat.setBuffer(45,null);
				shaDat.setBuffer(39,null);
				shaDat.setBuffer(46,null);
				shaDat.setBuffer(40,null);
				shaDat.setBuffer(47,null);
				shaDat.setBuffer(36,null);
				shaDat.setBuffer(43,null);
			}
			this._rotationOverLifetime=value;
		});

		/**
		*获取发射器。
		*/
		__getset(0,__proto,'emission',function(){
			return this._emission;
		});

		/**
		*获取一次循环内的累计时间。
		*@return 一次循环内的累计时间。
		*/
		__getset(0,__proto,'emissionTime',function(){
			return this._emissionTime > this.duration ? this.duration :this._emissionTime;
		});

		/**
		*粒子存活个数。
		*/
		__getset(0,__proto,'aliveParticleCount',function(){
			if (this._firstNewElement >=this._firstRetiredElement)
				return this._firstNewElement-this._firstRetiredElement;
			else
			return this._bufferMaxParticles-this._firstRetiredElement+this._firstNewElement;
		});

		/**
		*是否正在播放。
		*/
		__getset(0,__proto,'isPlaying',function(){
			return this._isPlaying;
		});

		/**
		*是否已暂停。
		*/
		__getset(0,__proto,'isPaused',function(){
			return this._isPaused;
		});

		/**
		*设置开始生命周期模式,0为固定时间，1为渐变时间，2为两个固定之间的随机插值,3为两个渐变时间的随机插值。
		*/
		/**
		*获取开始生命周期模式,0为固定时间，1为渐变时间，2为两个固定之间的随机插值,3为两个渐变时间的随机插值。
		*/
		__getset(0,__proto,'startLifetimeType',function(){
			return this._startLifetimeType;
			},function(value){
			var i=0,n=0;
			switch (this.startLifetimeType){
				case 0:
					this._maxStartLifetime=this.startLifetimeConstant;
					break ;
				case 1:
					this._maxStartLifetime=-Number.MAX_VALUE;
					var startLifeTimeGradient=startLifeTimeGradient;
					for (i=0,n=startLifeTimeGradient.gradientCount;i < n;i++)
					this._maxStartLifetime=Math.max(this._maxStartLifetime,startLifeTimeGradient.getValueByIndex(i));
					break ;
				case 2:
					this._maxStartLifetime=Math.max(this.startLifetimeConstantMin,this.startLifetimeConstantMax);
					break ;
				case 3:
					this._maxStartLifetime=-Number.MAX_VALUE;
					var startLifeTimeGradientMin=startLifeTimeGradientMin;
					for (i=0,n=startLifeTimeGradientMin.gradientCount;i < n;i++)
					this._maxStartLifetime=Math.max(this._maxStartLifetime,startLifeTimeGradientMin.getValueByIndex(i));
					var startLifeTimeGradientMax=startLifeTimeGradientMax;
					for (i=0,n=startLifeTimeGradientMax.gradientCount;i < n;i++)
					this._maxStartLifetime=Math.max(this._maxStartLifetime,startLifeTimeGradientMax.getValueByIndex(i));
					break ;
				}
			this._startLifetimeType=value;
		});

		/**
		*设置开始生命周期，0模式,单位为秒。
		*/
		/**
		*获取开始生命周期，0模式,单位为秒。
		*/
		__getset(0,__proto,'startLifetimeConstant',function(){
			return this._startLifetimeConstant;
			},function(value){
			if(this._startLifetimeType===0)
				this._maxStartLifetime=value;
			this._startLifetimeConstant=value;
		});

		/**
		*设置最小开始生命周期，2模式,单位为秒。
		*/
		/**
		*获取最小开始生命周期，2模式,单位为秒。
		*/
		__getset(0,__proto,'startLifetimeConstantMin',function(){
			return this._startLifetimeConstantMin;
			},function(value){
			if (this._startLifetimeType===2)
				this._maxStartLifetime=Math.max(value,this._startLifetimeConstantMax);
			this._startLifetimeConstantMin=value;
		});

		/**
		*设置开始渐变生命周期，1模式,单位为秒。
		*/
		/**
		*获取开始渐变生命周期，1模式,单位为秒。
		*/
		__getset(0,__proto,'startLifeTimeGradient',function(){
			return this._startLifeTimeGradient;
			},function(value){
			if (this._startLifetimeType===1){
				this._maxStartLifetime=-Number.MAX_VALUE;
				for (var i=0,n=value.gradientCount;i < n;i++)
				this._maxStartLifetime=Math.max(this._maxStartLifetime,value.getValueByIndex(i));
			}
			this._startLifeTimeGradient=value;
		});

		/**
		*设置最大开始生命周期，2模式,单位为秒。
		*/
		/**
		*获取最大开始生命周期，2模式,单位为秒。
		*/
		__getset(0,__proto,'startLifetimeConstantMax',function(){
			return this._startLifetimeConstantMax;
			},function(value){
			if (this._startLifetimeType===2)
				this._maxStartLifetime=Math.max(this._startLifetimeConstantMin,value);
			this._startLifetimeConstantMax=value;
		});

		/**
		*设置开始渐变最小生命周期，3模式,单位为秒。
		*/
		/**
		*获取开始渐变最小生命周期，3模式,单位为秒。
		*/
		__getset(0,__proto,'startLifeTimeGradientMin',function(){
			return this._startLifeTimeGradientMin;
			},function(value){
			if (this._startLifetimeType===3){
				var i=0,n=0;
				this._maxStartLifetime=-Number.MAX_VALUE;
				for (i=0,n=value.gradientCount;i < n;i++)
				this._maxStartLifetime=Math.max(this._maxStartLifetime,value.getValueByIndex(i));
				for (i=0,n=this._startLifeTimeGradientMax.gradientCount;i < n;i++)
				this._maxStartLifetime=Math.max(this._maxStartLifetime,this._startLifeTimeGradientMax.getValueByIndex(i));
			}
			this._startLifeTimeGradientMin=value;
		});

		/**
		*设置开始渐变最大生命周期，3模式,单位为秒。
		*/
		/**
		*获取开始渐变最大生命周期，3模式,单位为秒。
		*/
		__getset(0,__proto,'startLifeTimeGradientMax',function(){
			return this._startLifeTimeGradientMax;
			},function(value){
			if (this._startLifetimeType===3){
				var i=0,n=0;
				this._maxStartLifetime=-Number.MAX_VALUE;
				for (i=0,n=this._startLifeTimeGradientMin.gradientCount;i < n;i++)
				this._maxStartLifetime=Math.max(this._maxStartLifetime,this._startLifeTimeGradientMin.getValueByIndex(i));
				for (i=0,n=value.gradientCount;i < n;i++)
				this._maxStartLifetime=Math.max(this._maxStartLifetime,value.getValueByIndex(i));
			}
			this._startLifeTimeGradientMax=value;
		});

		/**
		*设置生命周期速度,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@param value 生命周期速度.
		*/
		/**
		*获取生命周期速度,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@return 生命周期速度.
		*/
		__getset(0,__proto,'velocityOverLifetime',function(){
			return this._velocityOverLifetime;
			},function(value){
			var defDat=this._owner._render._defineDatas;
			var shaDat=this._owner._render._shaderValues;
			if (value){
				var velocity=value.velocity;
				var velocityType=velocity.type;
				if (value.enbale){
					switch (velocityType){
						case 0:
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
							break ;
						case 1:
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
							break ;
						case 2:
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
							break ;
						case 3:
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
							break ;
						}
					}else {
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
				}
				switch (velocityType){
					case 0:
						shaDat.setVector(13,velocity.constant);
						break ;
					case 1:
						shaDat.setBuffer(14,velocity.gradientX._elements);
						shaDat.setBuffer(15,velocity.gradientY._elements);
						shaDat.setBuffer(16,velocity.gradientZ._elements);
						break ;
					case 2:
						shaDat.setVector(13,velocity.constantMin);
						shaDat.setVector(17,velocity.constantMax);
						break ;
					case 3:
						shaDat.setBuffer(14,velocity.gradientXMin._elements);
						shaDat.setBuffer(18,velocity.gradientXMax._elements);
						shaDat.setBuffer(15,velocity.gradientYMin._elements);
						shaDat.setBuffer(19,velocity.gradientYMax._elements);
						shaDat.setBuffer(16,velocity.gradientZMin._elements);
						shaDat.setBuffer(20,velocity.gradientZMax._elements);
						break ;
					}
				shaDat.setInt(21,value.space);
				}else {
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
				shaDat.setVector(13,null);
				shaDat.setBuffer(14,null);
				shaDat.setBuffer(15,null);
				shaDat.setBuffer(16,null);
				shaDat.setVector(13,null);
				shaDat.setVector(17,null);
				shaDat.setBuffer(14,null);
				shaDat.setBuffer(18,null);
				shaDat.setBuffer(15,null);
				shaDat.setBuffer(19,null);
				shaDat.setBuffer(16,null);
				shaDat.setBuffer(20,null);
				shaDat.setInt(21,undefined);
			}
			this._velocityOverLifetime=value;
		});

		/**
		*设置生命周期颜色,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@param value 生命周期颜色
		*/
		/**
		*获取生命周期颜色,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@return 生命周期颜色
		*/
		__getset(0,__proto,'colorOverLifetime',function(){
			return this._colorOverLifetime;
			},function(value){
			var defDat=this._owner._render._defineDatas;
			var shaDat=this._owner._render._shaderValues;
			if (value){
				var color=value.color;
				if (value.enbale){
					switch (color.type){
						case 1:
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME);
							break ;
						case 3:
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
							break ;
						}
					}else {
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME);
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
				}
				switch (color.type){
					case 1:;
						var gradientColor=color.gradient;
						shaDat.setBuffer(22,gradientColor._alphaElements);
						shaDat.setBuffer(23,gradientColor._rgbElements);
						break ;
					case 3:;
						var minGradientColor=color.gradientMin;
						var maxGradientColor=color.gradientMax;
						shaDat.setBuffer(22,minGradientColor._alphaElements);
						shaDat.setBuffer(23,minGradientColor._rgbElements);
						shaDat.setBuffer(24,maxGradientColor._alphaElements);
						shaDat.setBuffer(25,maxGradientColor._rgbElements);
						break ;
					}
				}else {
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
				shaDat.setBuffer(22,gradientColor._alphaElements);
				shaDat.setBuffer(23,gradientColor._rgbElements);
				shaDat.setBuffer(22,minGradientColor._alphaElements);
				shaDat.setBuffer(23,minGradientColor._rgbElements);
				shaDat.setBuffer(24,maxGradientColor._alphaElements);
				shaDat.setBuffer(25,maxGradientColor._rgbElements);
			}
			this._colorOverLifetime=value;
		});

		/**
		*设置生命周期尺寸,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@param value 生命周期尺寸
		*/
		/**
		*获取生命周期尺寸,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@return 生命周期尺寸
		*/
		__getset(0,__proto,'sizeOverLifetime',function(){
			return this._sizeOverLifetime;
			},function(value){
			var defDat=this._owner._render._defineDatas;
			var shaDat=this._owner._render._shaderValues;
			if (value){
				var size=value.size;
				var sizeSeparate=size.separateAxes;
				var sizeType=size.type;
				if (value.enbale){
					switch (sizeType){
						case 0:
							if (sizeSeparate)
								defDat.add(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
							else
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
							break ;
						case 2:
							if (sizeSeparate)
								defDat.add(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
							else
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
							break ;
						}
					}else {
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
				}
				switch (sizeType){
					case 0:
						if (sizeSeparate){
							shaDat.setBuffer(27,size.gradientX._elements);
							shaDat.setBuffer(28,size.gradientY._elements);
							shaDat.setBuffer(29,size.gradientZ._elements);
							}else {
							shaDat.setBuffer(26,size.gradient._elements);
						}
						break ;
					case 2:
						if (sizeSeparate){
							shaDat.setBuffer(27,size.gradientXMin._elements);
							shaDat.setBuffer(31,size.gradientXMax._elements);
							shaDat.setBuffer(28,size.gradientYMin._elements);
							shaDat.setBuffer(32,size.gradientYMax._elements);
							shaDat.setBuffer(29,size.gradientZMin._elements);
							shaDat.setBuffer(33,size.gradientZMax._elements);
							}else {
							shaDat.setBuffer(26,size.gradientMin._elements);
							shaDat.setBuffer(30,size.gradientMax._elements);
						}
						break ;
					}
				}else {
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
				shaDat.setBuffer(27,null);
				shaDat.setBuffer(31,null);
				shaDat.setBuffer(28,null);
				shaDat.setBuffer(32,null);
				shaDat.setBuffer(29,null);
				shaDat.setBuffer(33,null);
				shaDat.setBuffer(26,null);
				shaDat.setBuffer(30,null);
			}
			this._sizeOverLifetime=value;
		});

		/**
		*设置生命周期纹理动画,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@param value 生命周期纹理动画。
		*/
		/**
		*获取生命周期纹理动画,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@return 生命周期纹理动画。
		*/
		__getset(0,__proto,'textureSheetAnimation',function(){
			return this._textureSheetAnimation;
			},function(value){
			var defDat=this._owner._render._defineDatas;
			var shaDat=this._owner._render._shaderValues;
			if (value){
				var frameOverTime=value.frame;
				var textureAniType=frameOverTime.type;
				if (value.enable){
					switch (textureAniType){
						case 1:
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
							break ;
						case 3:
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
							break ;
						}
					}else {
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
					defDat.remove(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
				}
				if (textureAniType===1 || textureAniType===3){
					shaDat.setInt(48,value.cycles);
					var title=value.tiles;
					var _uvLengthE=this._uvLength.elements;
					_uvLengthE[0]=1.0 / title.x;
					_uvLengthE[1]=1.0 / title.y;
					shaDat.setVector(49,this._uvLength);
				}
				switch (textureAniType){
					case 1:
						shaDat.setBuffer(50,frameOverTime.frameOverTimeData._elements);
						break ;
					case 3:
						shaDat.setBuffer(50,frameOverTime.frameOverTimeDataMin._elements);
						shaDat.setBuffer(51,frameOverTime.frameOverTimeDataMax._elements);
						break ;
					}
				}else {
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
				shaDat.setInt(48,undefined);
				shaDat.setVector(49,null);
				shaDat.setBuffer(50,null);
				shaDat.setBuffer(51,null);
			}
			this._textureSheetAnimation=value;
		});

		__getset(0,__proto,'_vertexBufferCount',function(){
			return 1;
		});

		__getset(0,__proto,'triangleCount',function(){
			return this._indexBuffer?this._indexBuffer.indexCount / 3:0;
		});

		ShurikenParticleSystem.halfKSqrtOf2=1.42 *0.5;
		__static(ShurikenParticleSystem,
		['_RANDOMOFFSET',function(){return this._RANDOMOFFSET=new Uint32Array([0x23571a3e,0xc34f56fe,0x13371337,0x12460f3b,0x6aed452e,0xdec4aea1,0x96aa4de3,0x8d2c8431,0xf3857f6f,0xe0fbd834,0x13740583,0x591bc05c,0x40eb95e4,0xbc524e5f,0xaf502044,0xa614b381,0x1034e524,0xfc524e5f]);},'_maxElapsedTime',function(){return this._maxElapsedTime=1.0 / 3.0;},'_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempVector32',function(){return this._tempVector32=new Vector3();},'_tempVector33',function(){return this._tempVector33=new Vector3();},'_tempVector34',function(){return this._tempVector34=new Vector3();},'_tempVector35',function(){return this._tempVector35=new Vector3();},'_tempVector36',function(){return this._tempVector36=new Vector3();},'_tempVector37',function(){return this._tempVector37=new Vector3();},'_tempVector38',function(){return this._tempVector38=new Vector3();},'_tempVector39',function(){return this._tempVector39=new Vector3();},'_tempPosition',function(){return this._tempPosition=new Vector3();},'_tempDirection',function(){return this._tempDirection=new Vector3();}
		]);
		return ShurikenParticleSystem;
	})(GeometryElement)


	/**
	*@private
	*<code>DynamicBatch</code> 类用于动态批处理。
	*/
	//class laya.d3.graphics.DynamicBatch extends laya.d3.core.GeometryElement
	var DynamicBatch=(function(_super){
		/**
		*创建一个 <code>DynamicBatch</code> 实例。
		*/
		function DynamicBatch(){
			DynamicBatch.__super.call(this);
		}

		__class(DynamicBatch,'laya.d3.graphics.DynamicBatch',_super);
		DynamicBatch.maxAllowVertexCount=8;
		DynamicBatch.maxAllowAttribueCount=900;
		DynamicBatch.maxIndicesCount=32000;
		return DynamicBatch;
	})(GeometryElement)


	/**
	*<code>BoxShape</code> 类用于创建球形粒子形状。
	*/
	//class laya.d3.core.particleShuriKen.module.shape.BoxShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
	var BoxShape=(function(_super){
		function BoxShape(){
			this.x=NaN;
			this.y=NaN;
			this.z=NaN;
			BoxShape.__super.call(this);
			this.x=1.0;
			this.y=1.0;
			this.z=1.0;
			this.randomDirection=false;
		}

		__class(BoxShape,'laya.d3.core.particleShuriKen.module.shape.BoxShape',_super);
		var __proto=BoxShape.prototype;
		/**
		*@inheritDoc
		*/
		__proto._getShapeBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=-this.x *0.5;
			minE[1]=-this.y *0.5;
			minE[2]=-this.z *0.5;
			var maxE=boundBox.max.elements;
			maxE[0]=this.x *0.5;
			maxE[1]=this.y *0.5;
			maxE[2]=this.z *0.5;
		}

		/**
		*@inheritDoc
		*/
		__proto._getSpeedBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=0.0;
			minE[1]=0.0;
			minE[2]=0.0;
			var maxE=boundBox.max.elements;
			maxE[0]=0.0;
			maxE[1]=1.0;
			maxE[2]=0.0;
		}

		/**
		*用于生成粒子初始位置和方向。
		*@param position 粒子位置。
		*@param direction 粒子方向。
		*/
		__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
			var rpE=position.elements;
			var rdE=direction.elements;
			if (rand){
				rand.seed=randomSeeds[16];
				ShapeUtils._randomPointInsideHalfUnitBox(position,rand);
				randomSeeds[16]=rand.seed;
				}else {
				ShapeUtils._randomPointInsideHalfUnitBox(position);
			}
			rpE[0]=this.x *rpE[0];
			rpE[1]=this.y *rpE[1];
			rpE[2]=this.z *rpE[2];
			if (this.randomDirection){
				if (rand){
					rand.seed=randomSeeds[17];
					ShapeUtils._randomPointUnitSphere(direction,rand);
					randomSeeds[17]=rand.seed;
					}else {
					ShapeUtils._randomPointUnitSphere(direction);
				}
				}else {
				rdE[0]=0.0;
				rdE[1]=0.0;
				rdE[2]=1.0;
			}
		}

		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var destShape=destObject;
			destShape.x=this.x;
			destShape.y=this.y;
			destShape.z=this.z;
			destShape.randomDirection=this.randomDirection;
		}

		return BoxShape;
	})(BaseShape)


	/**
	*<code>CircleShape</code> 类用于创建环形粒子形状。
	*/
	//class laya.d3.core.particleShuriKen.module.shape.CircleShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
	var CircleShape=(function(_super){
		function CircleShape(){
			this.radius=NaN;
			this.arc=NaN;
			this.emitFromEdge=false;
			CircleShape.__super.call(this);
			this.radius=1.0;
			this.arc=360.0 / 180.0 *Math.PI;
			this.emitFromEdge=false;
			this.randomDirection=false;
		}

		__class(CircleShape,'laya.d3.core.particleShuriKen.module.shape.CircleShape',_super);
		var __proto=CircleShape.prototype;
		/**
		*@inheritDoc
		*/
		__proto._getShapeBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=minE[2]=-this.radius;
			minE[1]=0;
			var maxE=boundBox.max.elements;
			maxE[0]=maxE[2]=this.radius;
			maxE[1]=0;
		}

		/**
		*@inheritDoc
		*/
		__proto._getSpeedBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=minE[1]=-1;
			minE[2]=0;
			var maxE=boundBox.max.elements;
			maxE[0]=maxE[1]=1;
			maxE[2]=0;
		}

		/**
		*用于生成粒子初始位置和方向。
		*@param position 粒子位置。
		*@param direction 粒子方向。
		*/
		__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
			var rpE=position.elements;
			var positionPointE=CircleShape._tempPositionPoint.elements;
			if (rand){
				rand.seed=randomSeeds[16];
				if (this.emitFromEdge)
					ShapeUtils._randomPointUnitArcCircle(this.arc,CircleShape._tempPositionPoint,rand);
				else
				ShapeUtils._randomPointInsideUnitArcCircle(this.arc,CircleShape._tempPositionPoint,rand);
				randomSeeds[16]=rand.seed;
				}else {
				if (this.emitFromEdge)
					ShapeUtils._randomPointUnitArcCircle(this.arc,CircleShape._tempPositionPoint);
				else
				ShapeUtils._randomPointInsideUnitArcCircle(this.arc,CircleShape._tempPositionPoint);
			}
			rpE[0]=-positionPointE[0];
			rpE[1]=positionPointE[1];
			rpE[2]=0;
			Vector3.scale(position,this.radius,position);
			if (this.randomDirection){
				if (rand){
					rand.seed=randomSeeds[17];
					ShapeUtils._randomPointUnitSphere(direction,rand);
					randomSeeds[17]=rand.seed;
					}else {
					ShapeUtils._randomPointUnitSphere(direction);
				}
				}else {
				position.cloneTo(direction);
			}
		}

		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var destShape=destObject;
			destShape.radius=this.radius;
			destShape.arc=this.arc;
			destShape.emitFromEdge=this.emitFromEdge;
			destShape.randomDirection=this.randomDirection;
		}

		__static(CircleShape,
		['_tempPositionPoint',function(){return this._tempPositionPoint=new Vector2();}
		]);
		return CircleShape;
	})(BaseShape)


	/**
	*<code>ConeShape</code> 类用于创建锥形粒子形状。
	*/
	//class laya.d3.core.particleShuriKen.module.shape.ConeShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
	var ConeShape=(function(_super){
		function ConeShape(){
			this.angle=NaN;
			this.radius=NaN;
			this.length=NaN;
			this.emitType=0;
			ConeShape.__super.call(this);
			this.angle=25.0 / 180.0 *Math.PI;
			this.radius=1.0;
			this.length=5.0;
			this.emitType=0;
			this.randomDirection=false;
		}

		__class(ConeShape,'laya.d3.core.particleShuriKen.module.shape.ConeShape',_super);
		var __proto=ConeShape.prototype;
		/**
		*@inheritDoc
		*/
		__proto._getShapeBoundBox=function(boundBox){
			var coneRadius2=this.radius+this.length *Math.sin(this.angle);
			var coneLength=this.length *Math.cos(this.angle);
			var minE=boundBox.min.elements;
			minE[0]=minE[1]=-coneRadius2;
			minE[2]=0;
			var maxE=boundBox.max.elements;
			maxE[0]=maxE[1]=coneRadius2;
			maxE[2]=coneLength;
		}

		/**
		*@inheritDoc
		*/
		__proto._getSpeedBoundBox=function(boundBox){
			var sinA=Math.sin(this.angle);
			var minE=boundBox.min.elements;
			minE[0]=minE[1]=-sinA;
			minE[2]=0;
			var maxE=boundBox.max.elements;
			maxE[0]=minE[1]=sinA;
			maxE[2]=1;
		}

		/**
		*用于生成粒子初始位置和方向。
		*@param position 粒子位置。
		*@param direction 粒子方向。
		*/
		__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
			var rpE=position.elements;
			var rdE=direction.elements;
			var positionPointE=ConeShape._tempPositionPoint.elements;
			var positionX=NaN;
			var positionY=NaN;
			var directionPointE;
			var dirCosA=Math.cos(this.angle);
			var dirSinA=Math.sin(this.angle);
			switch (this.emitType){
				case 0:
					if (rand){
						rand.seed=randomSeeds[16];
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint,rand);
						randomSeeds[16]=rand.seed;
						}else {
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint);
					}
					positionX=positionPointE[0];
					positionY=positionPointE[1];
					rpE[0]=positionX *this.radius;
					rpE[1]=positionY *this.radius;
					rpE[2]=0;
					if (this.randomDirection){
						if (rand){
							rand.seed=randomSeeds[17];
							ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint,rand);
							randomSeeds[17]=rand.seed;
							}else {
							ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint);
						}
						directionPointE=ConeShape._tempDirectionPoint.elements;
						rdE[0]=directionPointE[0] *dirSinA;
						rdE[1]=directionPointE[1] *dirSinA;
						}else {
						rdE[0]=positionX *dirSinA;
						rdE[1]=positionY *dirSinA;
					}
					rdE[2]=dirCosA;
					break ;
				case 1:
					if (rand){
						rand.seed=randomSeeds[16];
						ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint,rand);
						randomSeeds[16]=rand.seed;
						}else {
						ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint);
					}
					positionX=positionPointE[0];
					positionY=positionPointE[1];
					rpE[0]=positionX *this.radius;
					rpE[1]=positionY *this.radius;
					rpE[2]=0;
					if (this.randomDirection){
						if (rand){
							rand.seed=randomSeeds[17];
							ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint,rand);
							randomSeeds[17]=rand.seed;
							}else {
							ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint);
						}
						directionPointE=ConeShape._tempDirectionPoint.elements;
						rdE[0]=directionPointE[0] *dirSinA;
						rdE[1]=directionPointE[1] *dirSinA;
						}else {
						rdE[0]=positionX *dirSinA;
						rdE[1]=positionY *dirSinA;
					}
					rdE[2]=dirCosA;
					break ;
				case 2:
					if (rand){
						rand.seed=randomSeeds[16];
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint,rand);
						}else {
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint);
					}
					positionX=positionPointE[0];
					positionY=positionPointE[1];
					rpE[0]=positionX *this.radius;
					rpE[1]=positionY *this.radius;
					rpE[2]=0;
					rdE[0]=positionX *dirSinA;
					rdE[1]=positionY *dirSinA;
					rdE[2]=dirCosA;
					Vector3.normalize(direction,direction);
					if (rand){
						Vector3.scale(direction,this.length *rand.getFloat(),direction);
						randomSeeds[16]=rand.seed;
						}else {
						Vector3.scale(direction,this.length *Math.random(),direction);
					}
					Vector3.add(position,direction,position);
					if (this.randomDirection){
						if (rand){
							rand.seed=randomSeeds[17];
							ShapeUtils._randomPointUnitSphere(direction,rand);
							randomSeeds[17]=rand.seed;
							}else {
							ShapeUtils._randomPointUnitSphere(direction);
						}
					}
					break ;
				case 3:
					if (rand){
						rand.seed=randomSeeds[16];
						ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint,rand);
						}else {
						ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint);
					}
					positionX=positionPointE[0];
					positionY=positionPointE[1];
					rpE[0]=positionX *this.radius;
					rpE[1]=positionY *this.radius;
					rpE[2]=0;
					rdE[0]=positionX *dirSinA;
					rdE[1]=positionY *dirSinA;
					rdE[2]=dirCosA;
					Vector3.normalize(direction,direction);
					if (rand){
						Vector3.scale(direction,this.length *rand.getFloat(),direction);
						randomSeeds[16]=rand.seed;
						}else {
						Vector3.scale(direction,this.length *Math.random(),direction);
					}
					Vector3.add(position,direction,position);
					if (this.randomDirection){
						if (rand){
							rand.seed=randomSeeds[17];
							ShapeUtils._randomPointUnitSphere(direction,rand);
							randomSeeds[17]=rand.seed;
							}else {
							ShapeUtils._randomPointUnitSphere(direction);
						}
					}
					break ;
				default :
					throw new Error("ConeShape:emitType is invalid.");
				}
		}

		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var destShape=destObject;
			destShape.angle=this.angle;
			destShape.radius=this.radius;
			destShape.length=this.length;
			destShape.emitType=this.emitType;
			destShape.randomDirection=this.randomDirection;
		}

		__static(ConeShape,
		['_tempPositionPoint',function(){return this._tempPositionPoint=new Vector2();},'_tempDirectionPoint',function(){return this._tempDirectionPoint=new Vector2();}
		]);
		return ConeShape;
	})(BaseShape)


	/**
	*<code>HemisphereShape</code> 类用于创建半球形粒子形状。
	*/
	//class laya.d3.core.particleShuriKen.module.shape.HemisphereShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
	var HemisphereShape=(function(_super){
		function HemisphereShape(){
			this.radius=NaN;
			this.emitFromShell=false;
			HemisphereShape.__super.call(this);
			this.radius=1.0;
			this.emitFromShell=false;
			this.randomDirection=false;
		}

		__class(HemisphereShape,'laya.d3.core.particleShuriKen.module.shape.HemisphereShape',_super);
		var __proto=HemisphereShape.prototype;
		/**
		*@inheritDoc
		*/
		__proto._getShapeBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=minE[1]=minE[2]=-this.radius;
			var maxE=boundBox.max.elements;
			maxE[0]=maxE[1]=this.radius;
			maxE[2]=0;
		}

		/**
		*@inheritDoc
		*/
		__proto._getSpeedBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=minE[1]=-1;
			minE[2]=0;
			var maxE=boundBox.max.elements;
			maxE[0]=maxE[1]=maxE[2]=1;
		}

		/**
		*用于生成粒子初始位置和方向。
		*@param position 粒子位置。
		*@param direction 粒子方向。
		*/
		__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
			var rpE=position.elements;
			if (rand){
				rand.seed=randomSeeds[16];
				if (this.emitFromShell)
					ShapeUtils._randomPointUnitSphere(position,rand);
				else
				ShapeUtils._randomPointInsideUnitSphere(position,rand);
				randomSeeds[16]=rand.seed;
				}else {
				if (this.emitFromShell)
					ShapeUtils._randomPointUnitSphere(position);
				else
				ShapeUtils._randomPointInsideUnitSphere(position);
			}
			Vector3.scale(position,this.radius,position);
			var z=rpE[2];
			(z < 0.0)&& (rpE[2]=z *-1.0);
			if (this.randomDirection){
				if (rand){
					rand.seed=randomSeeds[17];
					ShapeUtils._randomPointUnitSphere(direction,rand);
					randomSeeds[17]=rand.seed;
					}else {
					ShapeUtils._randomPointUnitSphere(direction);
				}
				}else {
				position.cloneTo(direction);
			}
		}

		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var destShape=destObject;
			destShape.radius=this.radius;
			destShape.emitFromShell=this.emitFromShell;
			destShape.randomDirection=this.randomDirection;
		}

		return HemisphereShape;
	})(BaseShape)


	/**
	*<code>SphereShape</code> 类用于创建球形粒子形状。
	*/
	//class laya.d3.core.particleShuriKen.module.shape.SphereShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
	var SphereShape=(function(_super){
		function SphereShape(){
			this.radius=NaN;
			this.emitFromShell=false;
			SphereShape.__super.call(this);
			this.radius=1.0;
			this.emitFromShell=false;
			this.randomDirection=false;
		}

		__class(SphereShape,'laya.d3.core.particleShuriKen.module.shape.SphereShape',_super);
		var __proto=SphereShape.prototype;
		/**
		*@inheritDoc
		*/
		__proto._getShapeBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=minE[1]=minE[2]=-this.radius;
			var maxE=boundBox.max.elements;
			maxE[0]=maxE[1]=maxE[2]=this.radius;
		}

		/**
		*@inheritDoc
		*/
		__proto._getSpeedBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=minE[1]=minE[2]=-1;
			var maxE=boundBox.max.elements;
			maxE[0]=maxE[1]=maxE[2]=1;
		}

		/**
		*用于生成粒子初始位置和方向。
		*@param position 粒子位置。
		*@param direction 粒子方向。
		*/
		__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
			if (rand){
				rand.seed=randomSeeds[16];
				if (this.emitFromShell)
					ShapeUtils._randomPointUnitSphere(position,rand);
				else
				ShapeUtils._randomPointInsideUnitSphere(position,rand);
				randomSeeds[16]=rand.seed;
				}else {
				if (this.emitFromShell)
					ShapeUtils._randomPointUnitSphere(position);
				else
				ShapeUtils._randomPointInsideUnitSphere(position);
			}
			Vector3.scale(position,this.radius,position);
			if (this.randomDirection){
				if (rand){
					rand.seed=randomSeeds[17];
					ShapeUtils._randomPointUnitSphere(direction,rand);
					randomSeeds[17]=rand.seed;
					}else {
					ShapeUtils._randomPointUnitSphere(direction);
				}
				}else {
				position.cloneTo(direction);
			}
		}

		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var destShape=destObject;
			destShape.radius=this.radius;
			destShape.emitFromShell=this.emitFromShell;
			destShape.randomDirection=this.randomDirection;
		}

		return SphereShape;
	})(BaseShape)


	/**
	*@private
	*<code>StaticBatch</code> 类用于静态合并的父类,该类为抽象类。
	*/
	//class laya.d3.graphics.StaticBatch extends laya.d3.core.GeometryElement
	var StaticBatch=(function(_super){
		function StaticBatch(key,manager,rootOwner){
			//this._batchElements=null;
			//this._batchID=0;
			//this.rootOwner=null;
			//this.key=null;
			//this.manager=null;
			StaticBatch.__super.call(this);
			this._batchElements=[];
			this._batchID=StaticBatch._batchIDCounter++;
			this.key=key;
			this.manager=manager;
			this.rootOwner=rootOwner;
		}

		__class(StaticBatch,'laya.d3.graphics.StaticBatch',_super);
		var __proto=StaticBatch.prototype;
		Laya.imps(__proto,{"laya.resource.IDispose":true})
		/**
		*@private
		*/
		__proto._compareBatchRenderElement=function(a,b){
			throw new Error("StaticBatch:must override this function.");
		}

		/**
		*@private
		*/
		__proto.finishInit=function(){
			throw "StaticBatch:must override this function.";
		}

		/**
		*@private
		*/
		__proto.add=function(renderElement){
			throw "StaticBatch:must override this function.";
		}

		/**
		*@private
		*/
		__proto.remove=function(renderElement){
			throw "StaticBatch:must override this function.";
		}

		/**
		*@private
		*/
		__proto.getBatchElementsCount=function(){
			return this._batchElements.length;
		}

		/**
		*@private
		*/
		__proto.dispose=function(){
			this._batchElements=null;
			this.rootOwner=null;
			this.key=null;
			this.manager=null;
		}

		StaticBatch.maxBatchVertexCount=65535;
		StaticBatch._batchIDCounter=0;
		return StaticBatch;
	})(GeometryElement)


	/**
	*@private
	*/
	//class laya.d3.core.render.SubMeshRenderElement extends laya.d3.core.render.RenderElement
	var SubMeshRenderElement=(function(_super){
		function SubMeshRenderElement(){
			//this.skinnedDatas=null;
			//this.staticBatch=null;
			//this.staticBatchIndexStart=0;
			//this.staticBatchIndexEnd=0;
			//this.staticBatchElementList=null;
			//this.dynamicBatchElementList=null;
			//this.dynamicVertexDeclaration=null;
			SubMeshRenderElement.__super.call(this);
		}

		__class(SubMeshRenderElement,'laya.d3.core.render.SubMeshRenderElement',_super);
		var __proto=SubMeshRenderElement.prototype;
		/**
		*@inheritDoc
		*/
		__proto.addToOpaqueRenderQueue=function(scene,queue){
			var elements=queue._elements;
			if (this.staticBatch){
				var staManager=MeshSprite3DStaticBatchManager.instance;
				var staLightIndex=this.render.lightmapIndex+1;
				var staLightMapMarks=(staManager._opaqueBatchMarks[staLightIndex])|| (staManager._opaqueBatchMarks[staLightIndex]=[]);
				var staReceiveShadowMarks=(staLightMapMarks[this.render.receiveShadow ? 0 :1])|| (staLightMapMarks[this.render.receiveShadow ? 0 :1]=[]);
				var staMaterialMarks=(staReceiveShadowMarks[this.material.id])|| (staReceiveShadowMarks[this.material.id]=[]);
				var staBatchMarks=(staMaterialMarks[this.staticBatch._batchID])|| (staMaterialMarks[this.staticBatch._batchID]=new Array(3));
				if (staManager._updateCountMark===staBatchMarks[0]){
					var staBatchIndex=staBatchMarks[1];
					if (staBatchMarks[2]){
						elements[staBatchIndex].staticBatchElementList.push(this);
						}else {
						var staOriElement=elements[staBatchIndex];
						var staOriRender=staOriElement.render;
						var staBatchElement=staManager._getBatchRenderElementFromPool();
						staBatchElement.geometry=this.staticBatch;
						staBatchElement.material=staOriElement.material;
						var staRootOwner=this.staticBatch.rootOwner;
						staBatchElement.transform=staRootOwner ? staRootOwner._transform :null;
						var batchRender=staManager._getBatchRender(staOriRender.lightmapIndex,staOriRender.receiveShadow);
						batchRender._setBelongScene(scene);
						staBatchElement.render=batchRender;
						var staBatchList=staBatchElement.staticBatchElementList;
						staBatchList.length=0;
						staBatchList.push(staOriElement);
						staBatchList.push(this);
						elements[staBatchIndex]=staBatchElement;
						staBatchMarks[2]=true;
					}
					}else {
					staBatchMarks[0]=staManager._updateCountMark;
					staBatchMarks[1]=elements.length;
					staBatchMarks[2]=false;
					elements.push(this);
				}
				}else {
				var verDec=this.geometry._vertexBuffer.vertexDeclaration;
				var vertexCount=(this.geometry)._vertexCount;
				var attributeCount=vertexCount *verDec.vertexElements.length;
				if (attributeCount < 900 && vertexCount <=8){
					var dynManager=MeshSprite3DDynamicBatchManager.instance;
					var dynLightIndex=this.render.lightmapIndex+1;
					var dynLightMapMarks=(dynManager._opaqueBatchMarks[dynLightIndex])|| (dynManager._opaqueBatchMarks[dynLightIndex]=[]);
					var dynReceiveShadowMarks=(dynLightMapMarks[this.render.receiveShadow ? 0 :1])|| (dynLightMapMarks[this.render.receiveShadow ? 0 :1]=[]);
					var staMaterialMarks=(dynReceiveShadowMarks[this.material.id])|| (dynReceiveShadowMarks[this.material.id]=[]);
					var dynBatchMarks=(staMaterialMarks[verDec.id])|| (staMaterialMarks[verDec.id]=new Array(3));
					if (dynManager._updateCountMark===dynBatchMarks[0]){
						var dynBatchIndex=dynBatchMarks[1];
						if (dynBatchMarks[2]){
							elements[dynBatchIndex].dynamicBatchElementList.push(this);
							}else {
							var dynOriElement=elements[dynBatchIndex];
							var dynOriRender=dynOriElement.render;
							var dynBatchElement=dynManager._getBatchRenderElementFromPool();
							dynBatchElement.geometry=SubMeshDynamicBatch.instance;
							dynBatchElement.material=dynOriElement.material;
							dynBatchElement.transform=null;
							dynBatchElement.render=dynOriElement.render;
							dynBatchElement.dynamicVertexDeclaration=verDec;
							var dynBatchList=dynBatchElement.dynamicBatchElementList;
							dynBatchList.length=0;
							dynBatchList.push(dynOriElement);
							dynBatchList.push(this);
							elements[dynBatchIndex]=dynBatchElement;
							dynBatchMarks[2]=true;
						}
						}else {
						dynBatchMarks[0]=dynManager._updateCountMark;
						dynBatchMarks[1]=elements.length;
						dynBatchMarks[2]=false;
						elements.push(this);
					}
					}else {
					elements.push(this);
				}
			}
		}

		/**
		*@inheritDoc
		*/
		__proto.addToTransparentRenderQueue=function(queue){
			var elements=queue._elements;
			if (this.staticBatch){
				var lastElement=queue._lastRenderElement;
				if (lastElement){
					var lastRender=lastElement.render;
					if (lastElement.staticBatch!==this.staticBatch || lastElement.material!==this.material || lastRender.receiveShadow!==this.render.receiveShadow || lastRender.lightmapIndex!==this.render.lightmapIndex){
						elements.push(this);
						queue._lastBatched=false;
						}else {
						if (queue._lastBatched){
							(elements [elements.length-1]).staticBatchElementList.push((this));
							}else {
							var staBatchElement=(this.staticBatch.manager)._getBatchRenderElementFromPool();
							staBatchElement.geometry=this.staticBatch;
							staBatchElement.material=lastElement.material;
							var staRootOwner=this.staticBatch.rootOwner;
							staBatchElement.transform=staRootOwner ? staRootOwner._transform :null;
							staBatchElement.render=lastElement.render;
							var staBatchList=staBatchElement.staticBatchElementList;
							staBatchList.length=0;
							staBatchList.push(lastElement);
							staBatchList.push(this);
							elements[elements.length-1]=staBatchElement;
						}
						queue._lastBatched=true;
					}
					}else {
					elements.push(this);
					queue._lastBatched=false;
				}
				queue._lastRenderElement=this;
				}else {
				elements.push(this);
				queue._lastRenderElement=this;
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._destroy=function(){
			(this.staticBatch)&& (this.staticBatch.manager._destroyRenderElement(this));
		}

		return SubMeshRenderElement;
	})(RenderElement)


	/**
	*<code>ShaderPass</code> 类用于实现ShaderPass。
	*/
	//class laya.d3.shader.ShaderPass extends laya.webgl.utils.ShaderCompile
	var ShaderPass=(function(_super){
		function ShaderPass(owner,vs,ps){
			//this._owner=null;
			//this._cacheSharders=null;
			//this._validDefineMap=null;
			this._owner=owner;
			this._cacheSharders=[];
			this._validDefineMap={};
			ShaderPass.__super.call(this,vs,ps,null,this._validDefineMap);
		}

		__class(ShaderPass,'laya.d3.shader.ShaderPass',_super);
		var __proto=ShaderPass.prototype;
		/**
		*@private
		*/
		__proto._definesToNameDic=function(value,int2Name){
			var o={};
			var d=1;
			for (var i=0;i < 32;i++){
				d=1 << i;
				if (d > value)break ;
				if (value & d){
					var name=int2Name[d];
					o[name]="";
				}
			}
			return o;
		}

		/**
		*@private
		*/
		__proto.withCompile=function(publicDefine,spriteDefine,materialDefine){
			publicDefine &=this._owner._publicDefinesValue;
			spriteDefine &=this._owner._spriteDefinesValue;
			materialDefine &=this._owner._materialDefinesValue;
			var shader;
			var spriteDefShaders,materialDefShaders;
			spriteDefShaders=this._cacheSharders[publicDefine];
			if (spriteDefShaders){
				materialDefShaders=spriteDefShaders[spriteDefine];
				if (materialDefShaders){
					shader=materialDefShaders[materialDefine];
					if (shader)
						return shader;
					}else {
					materialDefShaders=spriteDefShaders[spriteDefine]=[];
				}
				}else {
				spriteDefShaders=this._cacheSharders[publicDefine]=[];
				materialDefShaders=spriteDefShaders[spriteDefine]=[];
			};
			var publicDefGroup=this._definesToNameDic(publicDefine,this._owner._publicDefines);
			var spriteDefGroup=this._definesToNameDic(spriteDefine,this._owner._spriteDefines);
			var materialDefGroup=this._definesToNameDic(materialDefine,this._owner._materialDefines);
			var key;
			if (Shader3D.debugMode){
				var publicDefGroupStr="";
				for (key in publicDefGroup)
				publicDefGroupStr+=key+" ";
				var spriteDefGroupStr="";
				for (key in spriteDefGroup)
				spriteDefGroupStr+=key+" ";
				var materialDefGroupStr="";
				for (key in materialDefGroup)
				materialDefGroupStr+=key+" ";
				console.log("ShaderCompile3DDebugMode---(Name:"+this._owner._name+" PassIndex:"+this._owner._passes.indexOf(this)+" PublicDefine:"+publicDefine+" SpriteDefine:"+spriteDefine+" MaterialDefine:"+materialDefine+" PublicDefineGroup:"+publicDefGroupStr+" SpriteDefineGroup:"+spriteDefGroupStr+"MaterialDefineGroup: "+materialDefGroupStr+")---ShaderCompile3DDebugMode");
			};
			var defMap={};
			var defineStr="";
			if (publicDefGroup){
				for (key in publicDefGroup){
					defineStr+="#define "+key+"\n";
					defMap[key]=true;
				}
			}
			if (spriteDefGroup){
				for (key in spriteDefGroup){
					defineStr+="#define "+key+"\n";
					defMap[key]=true;
				}
			}
			if (materialDefGroup){
				for (key in materialDefGroup){
					defineStr+="#define "+key+"\n";
					defMap[key]=true;
				}
			};
			var vs=this._VS.toscript(defMap,[]);
			var ps=this._PS.toscript(defMap,[]);
			shader=new ShaderInstance(defineStr+vs.join('\n'),defineStr+ps.join('\n'),this._owner._attributeMap,this._owner._uniformMap);
			materialDefShaders[materialDefine]=shader;
			return shader;
		}

		return ShaderPass;
	})(ShaderCompile)


	/**
	*@private
	*<code>MeshSprite3DDynamicBatchManager</code> 类用于网格精灵动态批处理管理。
	*/
	//class laya.d3.graphics.MeshSprite3DDynamicBatchManager extends laya.d3.graphics.DynamicBatchManager
	var MeshSprite3DDynamicBatchManager=(function(_super){
		function MeshSprite3DDynamicBatchManager(){
			//this._updateCountMark=0;
			this._opaqueBatchMarks=[];
			MeshSprite3DDynamicBatchManager.__super.call(this);
			SubMeshDynamicBatch.instance=new SubMeshDynamicBatch();
			this._updateCountMark=0;
		}

		__class(MeshSprite3DDynamicBatchManager,'laya.d3.graphics.MeshSprite3DDynamicBatchManager',_super);
		var __proto=MeshSprite3DDynamicBatchManager.prototype;
		/**
		*@inheritDoc
		*/
		__proto._getBatchRenderElementFromPool=function(){
			var renderElement=this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
			if (!renderElement){
				renderElement=new SubMeshRenderElement();
				this._batchRenderElementPool[this._batchRenderElementPoolIndex-1]=renderElement;
				renderElement.dynamicBatchElementList=[];
			}
			return renderElement;
		}

		/**
		*@inheritDoc
		*/
		__proto._clear=function(){
			_super.prototype._clear.call(this);
			this._updateCountMark++;
		}

		__static(MeshSprite3DDynamicBatchManager,
		['instance',function(){return this.instance=new MeshSprite3DDynamicBatchManager();}
		]);
		return MeshSprite3DDynamicBatchManager;
	})(DynamicBatchManager)


	/**
	*@private
	*<code>MeshSprite3DStaticBatchManager</code> 类用于网格精灵静态批处理管理。
	*/
	//class laya.d3.graphics.MeshSprite3DStaticBatchManager extends laya.d3.graphics.StaticBatchManager
	var MeshSprite3DStaticBatchManager=(function(_super){
		function MeshSprite3DStaticBatchManager(){
			//this._cacheBatchOwner=null;
			//this._updateCountMark=0;
			this._opaqueBatchMarks=[];
			MeshSprite3DStaticBatchManager.__super.call(this);
			this._cacheBatchOwner=[];
			this._updateCountMark=0;
		}

		__class(MeshSprite3DStaticBatchManager,'laya.d3.graphics.MeshSprite3DStaticBatchManager',_super);
		var __proto=MeshSprite3DStaticBatchManager.prototype;
		/**
		*@inheritDoc
		*/
		__proto._compare=function(left,right){
			var lRender=left.render,rRender=right.render;
			var leftGeo=left.geometry,rightGeo=right.geometry;
			var lightOffset=lRender.lightmapIndex-rRender.lightmapIndex;
			if (lightOffset===0){
				var receiveShadowOffset=lRender.receiveShadow-rRender.receiveShadow;
				if (receiveShadowOffset===0){
					var materialOffset=left.material.id-right.material.id;
					if (materialOffset===0){
						var verDec=leftGeo._vertexBuffer.vertexDeclaration.id-rightGeo._vertexBuffer.vertexDeclaration.id;
						if (verDec==0){
							return rightGeo.triangleCount-leftGeo.triangleCount;
							}else {
							return verDec;
						}
						}else {
						return materialOffset;
					}
					}else {
					return receiveShadowOffset;
				}
				}else {
				return lightOffset;
			}
		}

		/**
		*@private
		*/
		__proto._getBatchRender=function(lightMapIndex,receiveShadow){
			var subCacheRender=this._cacheBatchOwner[lightMapIndex];
			(subCacheRender)|| (subCacheRender=this._cacheBatchOwner[lightMapIndex]=__newvec(2,null));
			var render=subCacheRender[receiveShadow ? 1 :0];
			if (render){
				return render;
				}else {
				render=new MeshRender(null,4);
				render.lightmapIndex=lightMapIndex;
				render.receiveShadow=receiveShadow;
				subCacheRender[receiveShadow ? 1 :0]=render;
				return render;
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._getBatchRenderElementFromPool=function(){
			var renderElement=this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
			if (!renderElement){
				renderElement=new SubMeshRenderElement();
				this._batchRenderElementPool[this._batchRenderElementPoolIndex-1]=renderElement;
				renderElement.staticBatchElementList=[];
			}
			return renderElement;
		}

		/**
		*@inheritDoc
		*/
		__proto._getStaticBatch=function(rootOwner,number){
			var key;
			if (rootOwner)
				key=rootOwner.id.toString()+number.toString();
			else
			key=number.toString();
			return (this._staticBatches[key])|| (this._staticBatches[key]=new SubMeshStaticBatch(key,this,rootOwner,VertexPositionNormalColorTexture0Texture1STangent.vertexDeclaration));
		}

		/**
		*@inheritDoc
		*/
		__proto._initStaticBatchs=function(rootOwner){
			this._quickSort(this._initBatchElements,0,this._initBatchElements.length-1);
			var lastCanMerage=false;
			var curStaticBatch;
			var batchNumber=0;
			for (var i=0,n=this._initBatchElements.length;i < n;i++){
				var renderElement=this._initBatchElements[i];
				if (lastCanMerage){
					if (curStaticBatch.addTest(renderElement)){
						curStaticBatch.add(renderElement);
						}else {
						lastCanMerage=false;
						batchNumber++;
					}
					}else {
					var lastIndex=n-1;
					if (i!==lastIndex){
						curStaticBatch=this._getStaticBatch(rootOwner,batchNumber);
						curStaticBatch.add(renderElement);
						lastCanMerage=true;
					}
				}
			}
			_super.prototype._initStaticBatchs.call(this);
		}

		/**
		*@inheritDoc
		*/
		__proto._clear=function(){
			_super.prototype._clear.call(this);
			this._updateCountMark++;
		}

		__static(MeshSprite3DStaticBatchManager,
		['instance',function(){return this.instance=new MeshSprite3DStaticBatchManager();}
		]);
		return MeshSprite3DStaticBatchManager;
	})(StaticBatchManager)


	/**
	*<code>SubMesh</code> 类用于创建子网格数据模板。
	*/
	//class laya.d3.resource.models.SubMesh extends laya.d3.core.GeometryElement
	var SubMesh=(function(_super){
		function SubMesh(mesh){
			this._mesh=null;
			this._boneIndicesList=null;
			this._subIndexBufferStart=null;
			this._subIndexBufferCount=null;
			this._skinAnimationDatas=null;
			this._indexInMesh=0;
			this._vertexStart=0;
			this._vertexCount=0;
			this._indexStart=0;
			this._indexCount=0;
			this._indices=null;
			this._indexBuffer=null;
			SubMesh.__super.call(this);
			this._mesh=mesh;
			this._boneIndicesList=[];
			this._subIndexBufferStart=[];
			this._subIndexBufferCount=[];
		}

		__class(SubMesh,'laya.d3.resource.models.SubMesh',_super);
		var __proto=SubMesh.prototype;
		Laya.imps(__proto,{"laya.resource.IDispose":true})
		/**
		*@private
		*渲染。
		*@param state 渲染状态。
		*/
		__proto._render=function(state){
			this._indexBuffer.bind();
			var skinAnimationDatas=(state.renderElement).skinnedDatas;
			var boneIndicesListCount=this._boneIndicesList.length;
			var shader=state.shader;
			for (var i=0;i < boneIndicesListCount;i++){
				(skinAnimationDatas)&& (shader.uploadCustomUniform(0,skinAnimationDatas[i]));
				LayaGL.instance.drawElements(0x0004,this._subIndexBufferCount[i],0x1403,this._subIndexBufferStart[i] *2);
			}
			Stat.drawCall+=boneIndicesListCount;
			Stat.trianglesFaces+=this._indexCount / 3;
		}

		/**
		*@private
		*/
		__proto.getIndices=function(){
			return this._indices;
		}

		/**
		*<p>彻底清理资源。</p>
		*<p><b>注意：</b>会强制解锁清理。</p>
		*/
		__proto.dispose=function(){
			this._mesh=null;
			this._boneIndicesList=null;
			this._subIndexBufferStart=null;
			this._subIndexBufferCount=null;
			this._skinAnimationDatas=null;
			this._indexBuffer.destroy();
			this._indexBuffer=null;
		}

		/**
		*@private
		*/
		__getset(0,__proto,'_vertexBufferCount',function(){
			return 1;
		});

		/**
		*@private
		*/
		__getset(0,__proto,'triangleCount',function(){
			return this._indexBuffer.indexCount / 3;
		});

		return SubMesh;
	})(GeometryElement)


	/**
	*<code>Vector2</code> 类用于创建二维向量。
	*/
	//class laya.d3.math.Vector2 extends laya.d3.math.BaseVector
	var Vector2=(function(_super){
		/**
		*创建一个 <code>Vector2</code> 实例。
		*@param x X轴坐标。
		*@param y Y轴坐标。
		*/
		function Vector2(x,y){
			Vector2.__super.call(this);
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			var v=this.elements=new Float32Array(2);
			v[0]=x;
			v[1]=y;
		}

		__class(Vector2,'laya.d3.math.Vector2',_super);
		var __proto=Vector2.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*从Array数组拷贝值。
		*@param array 数组。
		*@param offset 数组偏移。
		*/
		__proto.fromArray=function(array,offset){
			(offset===void 0)&& (offset=0);
			this.elements[0]=array[offset+0];
			this.elements[1]=array[offset+1];
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destVector2=destObject;
			var destE=destVector2.elements;
			var s=this.elements;
			destE[0]=s[0];
			destE[1]=s[1];
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destVector2=new this.constructor();
			this.cloneTo(destVector2);
			return destVector2;
		}

		/**
		*设置X轴坐标。
		*@param value X轴坐标。
		*/
		/**
		*获取X轴坐标。
		*@return X轴坐标。
		*/
		__getset(0,__proto,'x',function(){
			return this.elements[0];
			},function(value){
			this.elements[0]=value;
		});

		/**
		*设置Y轴坐标。
		*@param value Y轴坐标。
		*/
		/**
		*获取Y轴坐标。
		*@return Y轴坐标。
		*/
		__getset(0,__proto,'y',function(){
			return this.elements[1];
			},function(value){
			this.elements[1]=value;
		});

		Vector2.scale=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			e[0]=f[0] *b;
			e[1]=f[1] *b;
		}

		__static(Vector2,
		['ZERO',function(){return this.ZERO=new Vector2(0.0,0.0);},'ONE',function(){return this.ONE=new Vector2(1.0,1.0);}
		]);
		return Vector2;
	})(BaseVector)


	/**
	*<code>Vector3</code> 类用于创建三维向量。
	*/
	//class laya.d3.math.Vector3 extends laya.d3.math.BaseVector
	var Vector3=(function(_super){
		/**
		*创建一个 <code>Vector3</code> 实例。
		*@param x X轴坐标。
		*@param y Y轴坐标。
		*@param z Z轴坐标。
		*/
		function Vector3(x,y,z){
			Vector3.__super.call(this);
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(z===void 0)&& (z=0);
			var v=this.elements=new Float32Array(3);
			v[0]=x;
			v[1]=y;
			v[2]=z;
		}

		__class(Vector3,'laya.d3.math.Vector3',_super);
		var __proto=Vector3.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*从Array数组拷贝值。
		*@param array 数组。
		*@param offset 数组偏移。
		*/
		__proto.fromArray=function(array,offset){
			(offset===void 0)&& (offset=0);
			this.elements[0]=array[offset+0];
			this.elements[1]=array[offset+1];
			this.elements[2]=array[offset+2];
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destVector3=destObject;
			var destE=destVector3.elements;
			var s=this.elements;
			destE[0]=s[0];
			destE[1]=s[1];
			destE[2]=s[2];
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destVector3=new this.constructor();
			this.cloneTo(destVector3);
			return destVector3;
		}

		__proto.toDefault=function(){
			this.elements[0]=0;
			this.elements[1]=0;
			this.elements[2]=0;
		}

		/**
		*设置X轴坐标。
		*@param value X轴坐标。
		*/
		/**
		*获取X轴坐标。
		*@return X轴坐标。
		*/
		__getset(0,__proto,'x',function(){
			return this.elements[0];
			},function(value){
			this.elements[0]=value;
		});

		/**
		*设置Y轴坐标。
		*@param value Y轴坐标。
		*/
		/**
		*获取Y轴坐标。
		*@return Y轴坐标。
		*/
		__getset(0,__proto,'y',function(){
			return this.elements[1];
			},function(value){
			this.elements[1]=value;
		});

		/**
		*设置Z轴坐标。
		*@param value Z轴坐标。
		*/
		/**
		*获取Z轴坐标。
		*@return Z轴坐标。
		*/
		__getset(0,__proto,'z',function(){
			return this.elements[2];
			},function(value){
			this.elements[2]=value;
		});

		Vector3.distanceSquared=function(value1,value2){
			var value1e=value1.elements;
			var value2e=value2.elements;
			var x=value1e[0]-value2e[0];
			var y=value1e[1]-value2e[1];
			var z=value1e[2]-value2e[2];
			return (x *x)+(y *y)+(z *z);
		}

		Vector3.distance=function(value1,value2){
			var value1e=value1.elements;
			var value2e=value2.elements;
			var x=value1e[0]-value2e[0];
			var y=value1e[1]-value2e[1];
			var z=value1e[2]-value2e[2];
			return Math.sqrt((x *x)+(y *y)+(z *z));
		}

		Vector3.min=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=Math.min(f[0],g[0]);
			e[1]=Math.min(f[1],g[1]);
			e[2]=Math.min(f[2],g[2]);
		}

		Vector3.max=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=Math.max(f[0],g[0]);
			e[1]=Math.max(f[1],g[1]);
			e[2]=Math.max(f[2],g[2]);
		}

		Vector3.transformQuat=function(source,rotation,out){
			var destination=out.elements;
			var se=source.elements;
			var re=rotation.elements;
			var x=se[0],y=se[1],z=se[2],qx=re[0],qy=re[1],qz=re[2],qw=re[3],
			ix=qw *x+qy *z-qz *y,iy=qw *y+qz *x-qx *z,iz=qw *z+qx *y-qy *x,iw=-qx *x-qy *y-qz *z;
			destination[0]=ix *qw+iw *-qx+iy *-qz-iz *-qy;
			destination[1]=iy *qw+iw *-qy+iz *-qx-ix *-qz;
			destination[2]=iz *qw+iw *-qz+ix *-qy-iy *-qx;
		}

		Vector3.scalarLength=function(a){
			var f=a.elements;
			var x=f[0],y=f[1],z=f[2];
			return Math.sqrt(x *x+y *y+z *z);
		}

		Vector3.scalarLengthSquared=function(a){
			var f=a.elements;
			var x=f[0],y=f[1],z=f[2];
			return x *x+y *y+z *z;
		}

		Vector3.normalize=function(s,out){
			var se=s.elements;
			var oe=out.elements;
			var x=se[0],y=se[1],z=se[2];
			var len=x *x+y *y+z *z;
			if (len > 0){
				len=1 / Math.sqrt(len);
				oe[0]=se[0] *len;
				oe[1]=se[1] *len;
				oe[2]=se[2] *len;
			}
		}

		Vector3.multiply=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=f[0] *g[0];
			e[1]=f[1] *g[1];
			e[2]=f[2] *g[2];
		}

		Vector3.scale=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			e[0]=f[0] *b;
			e[1]=f[1] *b;
			e[2]=f[2] *b;
		}

		Vector3.lerp=function(a,b,t,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements;
			var ax=f[0],ay=f[1],az=f[2];
			e[0]=ax+t *(g[0]-ax);
			e[1]=ay+t *(g[1]-ay);
			e[2]=az+t *(g[2]-az);
		}

		Vector3.transformV3ToV3=function(vector,transform,result){
			var intermediate=Vector3._tempVector4;
			Vector3.transformV3ToV4(vector,transform,intermediate);
			var intermediateElem=intermediate.elements;
			var resultElem=result.elements;
			resultElem[0]=intermediateElem[0];
			resultElem[1]=intermediateElem[1];
			resultElem[2]=intermediateElem[2];
		}

		Vector3.transformV3ToV4=function(vector,transform,result){
			var vectorElem=vector.elements;
			var vectorX=vectorElem[0];
			var vectorY=vectorElem[1];
			var vectorZ=vectorElem[2];
			var transformElem=transform.elements;
			var resultElem=result.elements;
			resultElem[0]=(vectorX *transformElem[0])+(vectorY *transformElem[4])+(vectorZ *transformElem[8])+transformElem[12];
			resultElem[1]=(vectorX *transformElem[1])+(vectorY *transformElem[5])+(vectorZ *transformElem[9])+transformElem[13];
			resultElem[2]=(vectorX *transformElem[2])+(vectorY *transformElem[6])+(vectorZ *transformElem[10])+transformElem[14];
			resultElem[3]=(vectorX *transformElem[3])+(vectorY *transformElem[7])+(vectorZ *transformElem[11])+transformElem[15];
		}

		Vector3.TransformNormal=function(normal,transform,result){
			var normalElem=normal.elements;
			var normalX=normalElem[0];
			var normalY=normalElem[1];
			var normalZ=normalElem[2];
			var transformElem=transform.elements;
			var resultElem=result.elements;
			resultElem[0]=(normalX *transformElem[0])+(normalY *transformElem[4])+(normalZ *transformElem[8]);
			resultElem[1]=(normalX *transformElem[1])+(normalY *transformElem[5])+(normalZ *transformElem[9]);
			resultElem[2]=(normalX *transformElem[2])+(normalY *transformElem[6])+(normalZ *transformElem[10]);
		}

		Vector3.transformCoordinate=function(coordinate,transform,result){
			var coordinateElem=coordinate.elements;
			var coordinateX=coordinateElem[0];
			var coordinateY=coordinateElem[1];
			var coordinateZ=coordinateElem[2];
			var transformElem=transform.elements;
			var w=((coordinateX *transformElem[3])+(coordinateY *transformElem[7])+(coordinateZ *transformElem[11])+transformElem[15]);
			var resultElem=result.elements;
			resultElem[0]=(coordinateX *transformElem[0])+(coordinateY *transformElem[4])+(coordinateZ *transformElem[8])+transformElem[12] / w;
			resultElem[1]=(coordinateX *transformElem[1])+(coordinateY *transformElem[5])+(coordinateZ *transformElem[9])+transformElem[13] / w;
			resultElem[2]=(coordinateX *transformElem[2])+(coordinateY *transformElem[6])+(coordinateZ *transformElem[10])+transformElem[14] / w;
		}

		Vector3.Clamp=function(value,min,max,out){
			var valuee=value.elements;
			var x=valuee[0];
			var y=valuee[1];
			var z=valuee[2];
			var mine=min.elements;
			var mineX=mine[0];
			var mineY=mine[1];
			var mineZ=mine[2];
			var maxe=max.elements;
			var maxeX=maxe[0];
			var maxeY=maxe[1];
			var maxeZ=maxe[2];
			var oute=out.elements;
			x=(x > maxeX)? maxeX :x;
			x=(x < mineX)? mineX :x;
			y=(y > maxeY)? maxeY :y;
			y=(y < mineY)? mineY :y;
			z=(z > maxeZ)? maxeZ :z;
			z=(z < mineZ)? mineZ :z;
			oute[0]=x;
			oute[1]=y;
			oute[2]=z;
		}

		Vector3.add=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=f[0]+g[0];
			e[1]=f[1]+g[1];
			e[2]=f[2]+g[2];
		}

		Vector3.subtract=function(a,b,o){
			var oe=o.elements;
			var ae=a.elements;
			var be=b.elements;
			oe[0]=ae[0]-be[0];
			oe[1]=ae[1]-be[1];
			oe[2]=ae[2]-be[2];
		}

		Vector3.cross=function(a,b,o){
			var ae=a.elements;
			var be=b.elements;
			var oe=o.elements;
			var ax=ae[0],ay=ae[1],az=ae[2],bx=be[0],by=be[1],bz=be[2];
			oe[0]=ay *bz-az *by;
			oe[1]=az *bx-ax *bz;
			oe[2]=ax *by-ay *bx;
		}

		Vector3.dot=function(a,b){
			var ae=a.elements;
			var be=b.elements;
			var r=(ae[0] *be[0])+(ae[1] *be[1])+(ae[2] *be[2]);
			return r;
		}

		Vector3.equals=function(a,b){
			var ae=a.elements;
			var be=b.elements;
			return MathUtils3D.nearEqual(ae[0],be[0])&& MathUtils3D.nearEqual(ae[1],be[1])&& MathUtils3D.nearEqual(ae[2],be[2]);
		}

		Vector3.ZERO=new Vector3(0.0,0.0,0.0);
		Vector3.ONE=new Vector3(1.0,1.0,1.0);
		Vector3.NegativeUnitX=new Vector3(-1,0,0);
		Vector3.UnitX=new Vector3(1,0,0);
		Vector3.UnitY=new Vector3(0,1,0);
		Vector3.UnitZ=new Vector3(0,0,1);
		Vector3.ForwardRH=new Vector3(0,0,-1);
		Vector3.ForwardLH=new Vector3(0,0,1);
		Vector3.Up=new Vector3(0,1,0);
		Vector3.NAN=new Vector3(NaN,NaN,NaN);
		__static(Vector3,
		['_tempVector4',function(){return this._tempVector4=new Vector4();}
		]);
		return Vector3;
	})(BaseVector)


	/**
	*<code>Vector4</code> 类用于创建四维向量。
	*/
	//class laya.d3.math.Vector4 extends laya.d3.math.BaseVector
	var Vector4=(function(_super){
		/**
		*创建一个 <code>Vector4</code> 实例。
		*@param x X轴坐标。
		*@param y Y轴坐标。
		*@param z Z轴坐标。
		*@param w W轴坐标。
		*/
		function Vector4(x,y,z,w){
			Vector4.__super.call(this);
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(z===void 0)&& (z=0);
			(w===void 0)&& (w=0);
			var v=this.elements=new Float32Array(4);
			v[0]=x;
			v[1]=y;
			v[2]=z;
			v[3]=w;
		}

		__class(Vector4,'laya.d3.math.Vector4',_super);
		var __proto=Vector4.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*从Array数组拷贝值。
		*@param array 数组。
		*@param offset 数组偏移。
		*/
		__proto.fromArray=function(array,offset){
			(offset===void 0)&& (offset=0);
			this.elements[0]=array[offset+0];
			this.elements[1]=array[offset+1];
			this.elements[2]=array[offset+2];
			this.elements[3]=array[offset+3];
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destVector4=destObject;
			var destE=destVector4.elements;
			var s=this.elements;
			destE[0]=s[0];
			destE[1]=s[1];
			destE[2]=s[2];
			destE[3]=s[3];
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destVector4=new this.constructor();
			this.cloneTo(destVector4);
			return destVector4;
		}

		/**
		*求四维向量的长度。
		*@return 长度。
		*/
		__proto.length=function(){
			return Math.sqrt(this.x *this.x+this.y *this.y+this.z *this.z+this.w *this.w);
		}

		/**
		*求四维向量长度的平方。
		*@return 长度的平方。
		*/
		__proto.lengthSquared=function(){
			return this.x *this.x+this.y *this.y+this.z *this.z+this.w *this.w;
		}

		/**
		*设置X轴坐标。
		*@param value X轴坐标。
		*/
		/**
		*获取X轴坐标。
		*@return X轴坐标。
		*/
		__getset(0,__proto,'x',function(){
			return this.elements[0];
			},function(value){
			this.elements[0]=value;
		});

		/**
		*设置Y轴坐标。
		*@param value Y轴坐标。
		*/
		/**
		*获取Y轴坐标。
		*@return Y轴坐标。
		*/
		__getset(0,__proto,'y',function(){
			return this.elements[1];
			},function(value){
			this.elements[1]=value;
		});

		/**
		*设置Z轴坐标。
		*@param value Z轴坐标。
		*/
		/**
		*获取Z轴坐标。
		*@return Z轴坐标。
		*/
		__getset(0,__proto,'z',function(){
			return this.elements[2];
			},function(value){
			this.elements[2]=value;
		});

		/**
		*设置W轴坐标。
		*@param value W轴坐标。
		*/
		/**
		*获取W轴坐标。
		*@return W轴坐标。
		*/
		__getset(0,__proto,'w',function(){
			return this.elements[3];
			},function(value){
			this.elements[3]=value;
		});

		Vector4.lerp=function(a,b,t,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements;
			var ax=f[0],ay=f[1],az=f[2],aw=f[3];
			e[0]=ax+t *(g[0]-ax);
			e[1]=ay+t *(g[1]-ay);
			e[2]=az+t *(g[2]-az);
			e[3]=aw+t *(g[3]-aw);
		}

		Vector4.transformByM4x4=function(vector4,m4x4,out){
			var ve=vector4.elements;
			var vx=ve[0];
			var vy=ve[1];
			var vz=ve[2];
			var vw=ve[3];
			var me=m4x4.elements;
			var oe=out.elements;
			oe[0]=vx *me[0]+vy *me[4]+vz *me[8]+vw *me[12];
			oe[1]=vx *me[1]+vy *me[5]+vz *me[9]+vw *me[13];
			oe[2]=vx *me[2]+vy *me[6]+vz *me[10]+vw *me[14];
			oe[3]=vx *me[3]+vy *me[7]+vz *me[11]+vw *me[15];
		}

		Vector4.equals=function(a,b){
			var ae=a.elements;
			var be=b.elements;
			return MathUtils3D.nearEqual(Math.abs(ae[0]),Math.abs(be[0]))&& MathUtils3D.nearEqual(Math.abs(ae[1]),Math.abs(be[1]))&& MathUtils3D.nearEqual(Math.abs(ae[2]),Math.abs(be[2]))&& MathUtils3D.nearEqual(Math.abs(ae[3]),Math.abs(be[3]));
		}

		Vector4.normalize=function(s,out){
			var se=s.elements;
			var oe=out.elements;
			var len=/*if err,please use iflash.method.xmlLength()*/s.length();
			if (len > 0){
				oe[0]=se[0] *len;
				oe[1]=se[1] *len;
				oe[2]=se[2] *len;
				oe[3]=se[3] *len;
			}
		}

		Vector4.add=function(a,b,out){
			var oe=out.elements;
			var ae=a.elements;
			var be=b.elements;
			oe[0]=ae[0]+be[0];
			oe[1]=ae[1]+be[1];
			oe[2]=ae[2]+be[2];
			oe[3]=ae[3]+be[3];
		}

		Vector4.subtract=function(a,b,out){
			var oe=out.elements;
			var ae=a.elements;
			var be=b.elements;
			oe[0]=ae[0]-be[0];
			oe[1]=ae[1]-be[1];
			oe[2]=ae[2]-be[2];
			oe[3]=ae[3]-be[3];
		}

		Vector4.multiply=function(a,b,out){
			var oe=out.elements;
			var ae=a.elements;
			var be=b.elements;
			oe[0]=ae[0] *be[0];
			oe[1]=ae[1] *be[1];
			oe[2]=ae[2] *be[2];
			oe[3]=ae[3] *be[3];
		}

		Vector4.scale=function(a,b,out){
			var oe=out.elements;
			var ae=a.elements;
			oe[0]=ae[0] *b;
			oe[1]=ae[1] *b;
			oe[2]=ae[2] *b;
			oe[3]=ae[3] *b;
		}

		Vector4.Clamp=function(value,min,max,out){
			var valuee=value.elements;
			var x=valuee[0];
			var y=valuee[1];
			var z=valuee[2];
			var w=valuee[3];
			var mine=min.elements;
			var mineX=mine[0];
			var mineY=mine[1];
			var mineZ=mine[2];
			var mineW=mine[3];
			var maxe=max.elements;
			var maxeX=maxe[0];
			var maxeY=maxe[1];
			var maxeZ=maxe[2];
			var maxeW=maxe[3];
			var oute=out.elements;
			x=(x > maxeX)? maxeX :x;
			x=(x < mineX)? mineX :x;
			y=(y > maxeY)? maxeY :y;
			y=(y < mineY)? mineY :y;
			z=(z > maxeZ)? maxeZ :z;
			z=(z < mineZ)? mineZ :z;
			w=(w > maxeW)? maxeW :w;
			w=(w < mineW)? mineW :w;
			oute[0]=x;
			oute[1]=y;
			oute[2]=z;
			oute[3]=w;
		}

		Vector4.distanceSquared=function(value1,value2){
			var value1e=value1.elements;
			var value2e=value2.elements;
			var x=value1e[0]-value2e[0];
			var y=value1e[1]-value2e[1];
			var z=value1e[2]-value2e[2];
			var w=value1e[3]-value2e[3];
			return (x *x)+(y *y)+(z *z)+(w *w);
		}

		Vector4.distance=function(value1,value2){
			var value1e=value1.elements;
			var value2e=value2.elements;
			var x=value1e[0]-value2e[0];
			var y=value1e[1]-value2e[1];
			var z=value1e[2]-value2e[2];
			var w=value1e[3]-value2e[3];
			return Math.sqrt((x *x)+(y *y)+(z *z)+(w *w));
		}

		Vector4.dot=function(a,b){
			var ae=a.elements;
			var be=b.elements;
			var r=(ae[0] *be[0])+(ae[1] *be[1])+(ae[2] *be[2])+(ae[3] *be[3]);
			return r;
		}

		Vector4.min=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=Math.min(f[0],g[0]);
			e[1]=Math.min(f[1],g[1]);
			e[2]=Math.min(f[2],g[2]);
			e[3]=Math.min(f[3],g[3]);
		}

		Vector4.max=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=Math.max(f[0],g[0]);
			e[1]=Math.max(f[1],g[1]);
			e[2]=Math.max(f[2],g[2]);
			e[3]=Math.max(f[3],g[3]);
		}

		__static(Vector4,
		['ZERO',function(){return this.ZERO=new Vector4();},'ONE',function(){return this.ONE=new Vector4(1.0,1.0,1.0,1.0);},'UnitX',function(){return this.UnitX=new Vector4(1.0,0.0,0.0,0.0);},'UnitY',function(){return this.UnitY=new Vector4(0.0,1.0,0.0,0.0);},'UnitZ',function(){return this.UnitZ=new Vector4(0.0,0.0,1.0,0.0);},'UnitW',function(){return this.UnitW=new Vector4(0.0,0.0,0.0,1.0);}
		]);
		return Vector4;
	})(BaseVector)


	/**
	*<code>SkyBox</code> 类用于创建天空盒。
	*/
	//class laya.d3.resource.models.SkyBox extends laya.d3.resource.models.Sky
	var SkyBox=(function(_super){
		/**
		*创建一个 <code>SkyBox</code> 实例。
		*/
		function SkyBox(){
			SkyBox.__super.call(this);
			this._vertexBuffer=SkyBox._skyBoxVerexbuffer;
			this._indexBuffer=SkyBox._skyBoxIndexbuffer;
		}

		__class(SkyBox,'laya.d3.resource.models.SkyBox',_super);
		var __proto=SkyBox.prototype;
		/**
		*@inheritDoc
		*/
		__proto._render=function(state){
			LayaGL.instance.drawElements(0x0004,36,0x1401,0);
			Stat.trianglesFaces+=12;
			Stat.drawCall++;
		}

		SkyBox.__init__=function(){
			var halfHeight=0.5;
			var halfWidth=0.5;
			var halfDepth=0.5;
			var vertices=new Float32Array([
			-halfDepth,halfHeight,-halfWidth,halfDepth,halfHeight,-halfWidth,halfDepth,halfHeight,halfWidth,-halfDepth,halfHeight,halfWidth,
			-halfDepth,-halfHeight,-halfWidth,halfDepth,-halfHeight,-halfWidth,halfDepth,-halfHeight,halfWidth,-halfDepth,-halfHeight,halfWidth]);
			var indices=new Uint8Array([
			0,1,2,2,3,0,
			4,7,6,6,5,4,
			0,3,7,7,4,0,
			1,5,6,6,2,1,
			3,2,6,6,7,3,
			0,4,5,5,1,0]);
			SkyBox._skyBoxVerexbuffer=new VertexBuffer3D(VertexPosition.vertexDeclaration.vertexStride*8,0x88E4,false);
			SkyBox._skyBoxVerexbuffer.vertexDeclaration=VertexPosition.vertexDeclaration;
			SkyBox._skyBoxIndexbuffer=new IndexBuffer3D("ubyte",36,0x88E4,false);
			SkyBox._skyBoxVerexbuffer.setData(vertices);
			SkyBox._skyBoxIndexbuffer.setData(indices);
		}

		SkyBox._skyBoxVerexbuffer=null
		SkyBox._skyBoxIndexbuffer=null
		return SkyBox;
	})(Sky)


	/**
	*<code>Script</code> 类用于创建脚本的父类。
	*/
	//class laya.d3.component.Script extends laya.d3.component.Component3D
	var Script=(function(_super){
		function Script(){
			this.started=false;
			Script.__super.call(this);
		}

		__class(Script,'laya.d3.component.Script',_super);
		var __proto=Script.prototype;
		/**
		*@inheritDoc
		*/
		__proto._onActive=function(){
			Script._componentPool.add(this);
		}

		/**
		*@inheritDoc
		*/
		__proto._onInActive=function(){
			Script._componentPool.remove(this);
		}

		/**
		*@inheritDoc
		*/
		__proto._initialize=function(owner){
			this.started=false;
			_super.prototype._initialize.call(this,owner);
		}

		/**
		*@inheritDoc
		*/
		__proto._uninitialize=function(){
			_super.prototype._uninitialize.call(this);
		}

		/**
		*@inheritDoc
		*/
		__proto.destroy=function(){
			this._unload(this._owner);
			this._owner=null;
		}

		/**
		*@private
		*载入组件时执行,可重写此函数。
		*/
		__proto._load=function(owner){}
		/**
		*@private
		*卸载组件时执行,可重写此函数。
		*/
		__proto._unload=function(owner){
			this.offAll();
		}

		/**
		*@private
		*在任意第一次更新时执行,可重写此函数。
		*/
		__proto._start=function(state){}
		/**
		*@private
		*更新组件,可重写此函数。
		*@param state 渲染状态参数。
		*/
		__proto._update=function(){}
		/**
		*@private
		*更新的最后阶段执行,可重写此函数。
		*@param state 渲染状态参数。
		*/
		__proto._lateUpdate=function(){}
		/**
		*@private
		*渲染前设置组件相关参数,可重写此函数。
		*@param state 渲染状态参数。
		*/
		__proto._preRenderUpdate=function(){}
		/**
		*@private
		*渲染的最后阶段执行,可重写此函数。
		*@param state 渲染状态参数。
		*/
		__proto._postRenderUpdate=function(){}
		/**
		*当其他碰撞器进入时触发。
		*/
		__proto.onTriggerEnter=function(other){}
		/**
		*当其他碰撞器退出时触发。
		*/
		__proto.onTriggerExit=function(other){}
		/**
		*当其他碰撞器保持进入状态时逐帧触发。
		*/
		__proto.onTriggerStay=function(other){}
		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'isSingleton',function(){
			return Script._isSingleton;
		});

		Script._update=function(){
			var elements=Script._componentPool.elements;
			for (var i=0;i < elements.length;i++){
				var script=elements [i];
				(script && script.enable)&& (script._update());
			}
			Script._componentPool.clear();
		}

		Script._lateUpdate=function(){
			var elements=Script._componentPool.elements;
			for (var i=0;i < elements.length;i++){
				var script=elements [i];
				(script && script.enable)&& (script._lateUpdate());
			}
			Script._componentPool.clear();
		}

		Script._preRender=function(){
			var elements=Script._componentPool.elements;
			for (var i=0;i < elements.length;i++){
				var script=elements [i];
				(script && script.enable)&& (script._preRenderUpdate());
			}
			Script._componentPool.clear();
		}

		Script._postRender=function(){
			var elements=Script._componentPool.elements;
			for (var i=0;i < elements.length;i++){
				var script=elements [i];
				(script && script.enable)&& (script._postRenderUpdate());
			}
			Script._componentPool.clear();
		}

		Script._isSingleton=false;
		__static(Script,
		['_componentPool',function(){return this._componentPool=new ComponentPool();}
		]);
		return Script;
	})(Component3D)


	/**
	*<code>BaseMaterial</code> 类用于创建材质,抽象类,不允许实例。
	*/
	//class laya.d3.core.material.BaseMaterial extends laya.resource.Resource
	var BaseMaterial=(function(_super){
		function BaseMaterial(dataSize){
			//this._alphaTest=false;
			//this._renderStates=null;
			//this._defineDatas=null;
			//this._disablePublicDefineDatas=null;
			//this._shader=null;
			//this._shaderValues=null;
			//this.renderQueue=0;
			BaseMaterial.__super.call(this,dataSize);
			this._defineDatas=new DefineDatas();
			this._disablePublicDefineDatas=new DefineDatas();
			this._shaderValues=new ShaderDatas(this,dataSize);
			this.renderQueue=1;
			this._alphaTest=false;
			this._renderStates=[];
		}

		__class(BaseMaterial,'laya.d3.core.material.BaseMaterial',_super);
		var __proto=BaseMaterial.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*@inheritDoc
		*/
		__proto.onAsynLoaded=function(data,params){
			var jsonData=data[0];
			var textureMap=data[1];
			switch (jsonData.version){
				case "LAYAMATERIAL:01":;
					var i=0,n=0;
					var props=jsonData.props;
					for (var key in props){
					switch (key){
						case "vectors":;
							var vectors=props[key];
							for (i=0,n=vectors.length;i < n;i++){
								var vector=vectors[i];
								var vectorValue=vector.value;
							switch (vectorValue.length){
								case 2:
									this[vector.name]=new Vector2(vectorValue[0],vectorValue[1]);
									break ;
								case 3:
									this[vector.name]=new Vector3(vectorValue[0],vectorValue[1],vectorValue[2]);
									break ;
								case 4:
									this[vector.name]=new Vector4(vectorValue[0],vectorValue[1],vectorValue[2],vectorValue[3]);
									break ;
								default :
									throw new Error("BaseMaterial:unkonwn color length.");
								}
						}
						break ;
						case "textures":;
						var textures=props[key];
						for (i=0,n=textures.length;i < n;i++){
							var texture=textures[i];
							var path=texture.path;
							(path)&& (this[texture.name]=Loader.getRes(textureMap[path]));
						}
						break ;
						case "defines":;
						var defineNames=props[key];
						for (i=0,n=defineNames.length;i < n;i++){
							var define=this._shader.getMaterialDefineByName(defineNames[i]);
							this._defineDatas.add(define);
						}
						break ;
						case "cull":
						case "blend":
						case "srcBlend":
						case "dstBlend":
						case "depthWrite":;
						var value=props[key];
						for (i=0,n=this._renderStates.length;i < n;i++)
						this._renderStates[i][key]=value;
						break ;
						default :
						this[key]=props[key];
					}
				}
				break ;
				case "LAYAMATERIAL:02":
				break ;
				default :
				throw new Error("BaseMaterial:unkonwn version.");
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._addReference=function(){
			_super.prototype._addReference.call(this);
			var valueCount=this._shaderValues._data.length;
			for (var i=0,n=valueCount;i < n;i++){
				var value=this._shaderValues._data[i];
				if (value && (value instanceof laya.webgl.resource.BaseTexture ))
					(value)._addReference();
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._removeReference=function(){
			_super.prototype._removeReference.call(this);
			var valueCount=this._shaderValues._data.length;
			for (var i=0,n=valueCount;i < n;i++){
				var value=this._shaderValues._data[i];
				if (value && (value instanceof laya.webgl.resource.BaseTexture ))
					(value)._removeReference();
			}
		}

		/**
		*@inheritDoc
		*/
		__proto.disposeResource=function(){
			var values=this._shaderValues._data;
			var valueCount=values.length;
			for (var i=0,n=valueCount;i < n;i++){
				var value=values[i];
				if (value && (value instanceof laya.webgl.resource.BaseTexture ))
					(value)._removeReference();
			}
			this._shaderValues=null;
		}

		/**
		*设置使用Shader名字。
		*@param name 名称。
		*/
		__proto.setShaderName=function(name){
			this._shader=Shader3D._preCompileShader[name];
			if (!this._shader)
				throw new Error("BaseMaterial: unknown shader name.");
			var passCount=this._shader._passes.length;
			this._renderStates.length=passCount;
			for (var i=0;i < passCount;i++)
			(this._renderStates[i])|| (this._renderStates[i]=new RenderState());
		}

		/**
		*获取渲染状态。
		*@param passIndex 所关联Shader的pass索引。
		*/
		__proto.getRenderState=function(passIndex){
			(passIndex===void 0)&& (passIndex=0);
			return this._renderStates[passIndex];
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destBaseMaterial=destObject;
			destBaseMaterial.name=this.name;
			destBaseMaterial.renderQueue=this.renderQueue;
			this._disablePublicDefineDatas.cloneTo(destBaseMaterial._disablePublicDefineDatas);
			this._defineDatas.cloneTo(destBaseMaterial._defineDatas);
			this._shaderValues.cloneTo(destBaseMaterial._shaderValues);
			var destRenderStates=destObject._renderStates;
			for (var i=0,n=this._renderStates.length;i < n;i++)
			this._renderStates[i].cloneTo(destRenderStates[i]);
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		/**
		*设置透明测试模式裁剪值。
		*@param value 透明测试模式裁剪值。
		*/
		/**
		*获取透明测试模式裁剪值。
		*@return 透明测试模式裁剪值。
		*/
		__getset(0,__proto,'alphaTestValue',function(){
			return this._shaderValues.getNumber(0);
			},function(value){
			this._shaderValues.setNumber(0,value);
		});

		/**
		*设置是否透明裁剪。
		*@param value 是否透明裁剪。
		*/
		/**
		*获取是否透明裁剪。
		*@return 是否透明裁剪。
		*/
		__getset(0,__proto,'alphaTest',function(){
			return this._alphaTest;
			},function(value){
			this._alphaTest=value;
			if (value)
				this._defineDatas.add(laya.d3.core.material.BaseMaterial.SHADERDEFINE_ALPHATEST);
			else
			this._defineDatas.remove(laya.d3.core.material.BaseMaterial.SHADERDEFINE_ALPHATEST);
		});

		BaseMaterial.__init__=function(){
			BaseMaterial.SHADERDEFINE_ALPHATEST=BaseMaterial.shaderDefines.registerDefine("ALPHATEST");
		}

		BaseMaterial.ALPHATESTVALUE=0;
		BaseMaterial.SHADERDEFINE_ALPHATEST=0;
		__static(BaseMaterial,
		['shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1();}
		]);
		return BaseMaterial;
	})(Resource)


	/**
	*<p> <code>Sprite</code> 是基本的显示图形的显示列表节点。 <code>Sprite</code> 默认没有宽高，默认不接受鼠标事件。通过 <code>graphics</code> 可以绘制图片或者矢量图，支持旋转，缩放，位移等操作。<code>Sprite</code>同时也是容器类，可用来添加多个子节点。</p>
	*<p>注意： <code>Sprite</code> 默认没有宽高，可以通过<code>getBounds</code>函数获取；也可手动设置宽高；还可以设置<code>autoSize=true</code>，然后再获取宽高。<code>Sprite</code>的宽高一般用于进行碰撞检测和排版，并不影响显示图像大小，如果需要更改显示图像大小，请使用 <code>scaleX</code> ， <code>scaleY</code> ， <code>scale</code>。</p>
	*<p> <code>Sprite</code> 默认不接受鼠标事件，即<code>mouseEnabled=false</code>，但是只要对其监听任意鼠标事件，会自动打开自己以及所有父对象的<code>mouseEnabled=true</code>。所以一般也无需手动设置<code>mouseEnabled</code>。</p>
	*<p>LayaAir引擎API设计精简巧妙。核心显示类只有一个<code>Sprite</code>。<code>Sprite</code>针对不同的情况做了渲染优化，所以保证一个类实现丰富功能的同时，又达到高性能。</p>
	*
	*@example <caption>创建了一个 <code>Sprite</code> 实例。</caption>
	*package
	*{
		*import laya.display.Sprite;
		*import laya.events.Event;
		*
		*public class Sprite_Example
		*{
			*private var sprite:Sprite;
			*private var shape:Sprite
			*public function Sprite_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*onInit();
				*}
			*private function onInit():void
			*{
				*sprite=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
				*sprite.loadImage("resource/ui/bg.png");//加载并显示图片。
				*sprite.x=200;//设置 sprite 对象相对于父容器的水平方向坐标值。
				*sprite.y=200;//设置 sprite 对象相对于父容器的垂直方向坐标值。
				*sprite.pivotX=0;//设置 sprite 对象的水平方法轴心点坐标。
				*sprite.pivotY=0;//设置 sprite 对象的垂直方法轴心点坐标。
				*Laya.stage.addChild(sprite);//将此 sprite 对象添加到显示列表。
				*sprite.on(Event.CLICK,this,onClickSprite);//给 sprite 对象添加点击事件侦听。
				*shape=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
				*shape.graphics.drawRect(0,0,100,100,"#ccff00","#ff0000",2);//绘制一个有边框的填充矩形。
				*shape.x=400;//设置 shape 对象相对于父容器的水平方向坐标值。
				*shape.y=200;//设置 shape 对象相对于父容器的垂直方向坐标值。
				*shape.width=100;//设置 shape 对象的宽度。
				*shape.height=100;//设置 shape 对象的高度。
				*shape.pivotX=50;//设置 shape 对象的水平方法轴心点坐标。
				*shape.pivotY=50;//设置 shape 对象的垂直方法轴心点坐标。
				*Laya.stage.addChild(shape);//将此 shape 对象添加到显示列表。
				*shape.on(Event.CLICK,this,onClickShape);//给 shape 对象添加点击事件侦听。
				*}
			*private function onClickSprite():void
			*{
				*trace("点击 sprite 对象。");
				*sprite.rotation+=5;//旋转 sprite 对象。
				*}
			*private function onClickShape():void
			*{
				*trace("点击 shape 对象。");
				*shape.rotation+=5;//旋转 shape 对象。
				*}
			*}
		*}
	*
	*@example
	*var sprite;
	*var shape;
	*Sprite_Example();
	*function Sprite_Example()
	*{
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*onInit();
		*}
	*function onInit()
	*{
		*sprite=new laya.display.Sprite();//创建一个 Sprite 类的实例对象 sprite 。
		*sprite.loadImage("resource/ui/bg.png");//加载并显示图片。
		*sprite.x=200;//设置 sprite 对象相对于父容器的水平方向坐标值。
		*sprite.y=200;//设置 sprite 对象相对于父容器的垂直方向坐标值。
		*sprite.pivotX=0;//设置 sprite 对象的水平方法轴心点坐标。
		*sprite.pivotY=0;//设置 sprite 对象的垂直方法轴心点坐标。
		*Laya.stage.addChild(sprite);//将此 sprite 对象添加到显示列表。
		*sprite.on(Event.CLICK,this,onClickSprite);//给 sprite 对象添加点击事件侦听。
		*shape=new laya.display.Sprite();//创建一个 Sprite 类的实例对象 sprite 。
		*shape.graphics.drawRect(0,0,100,100,"#ccff00","#ff0000",2);//绘制一个有边框的填充矩形。
		*shape.x=400;//设置 shape 对象相对于父容器的水平方向坐标值。
		*shape.y=200;//设置 shape 对象相对于父容器的垂直方向坐标值。
		*shape.width=100;//设置 shape 对象的宽度。
		*shape.height=100;//设置 shape 对象的高度。
		*shape.pivotX=50;//设置 shape 对象的水平方法轴心点坐标。
		*shape.pivotY=50;//设置 shape 对象的垂直方法轴心点坐标。
		*Laya.stage.addChild(shape);//将此 shape 对象添加到显示列表。
		*shape.on(laya.events.Event.CLICK,this,onClickShape);//给 shape 对象添加点击事件侦听。
		*}
	*function onClickSprite()
	*{
		*console.log("点击 sprite 对象。");
		*sprite.rotation+=5;//旋转 sprite 对象。
		*}
	*function onClickShape()
	*{
		*console.log("点击 shape 对象。");
		*shape.rotation+=5;//旋转 shape 对象。
		*}
	*
	*@example
	*import Sprite=laya.display.Sprite;
	*class Sprite_Example {
		*private sprite:Sprite;
		*private shape:Sprite
		*public Sprite_Example(){
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*this.onInit();
			*}
		*private onInit():void {
			*this.sprite=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
			*this.sprite.loadImage("resource/ui/bg.png");//加载并显示图片。
			*this.sprite.x=200;//设置 sprite 对象相对于父容器的水平方向坐标值。
			*this.sprite.y=200;//设置 sprite 对象相对于父容器的垂直方向坐标值。
			*this.sprite.pivotX=0;//设置 sprite 对象的水平方法轴心点坐标。
			*this.sprite.pivotY=0;//设置 sprite 对象的垂直方法轴心点坐标。
			*Laya.stage.addChild(this.sprite);//将此 sprite 对象添加到显示列表。
			*this.sprite.on(laya.events.Event.CLICK,this,this.onClickSprite);//给 sprite 对象添加点击事件侦听。
			*this.shape=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
			*this.shape.graphics.drawRect(0,0,100,100,"#ccff00","#ff0000",2);//绘制一个有边框的填充矩形。
			*this.shape.x=400;//设置 shape 对象相对于父容器的水平方向坐标值。
			*this.shape.y=200;//设置 shape 对象相对于父容器的垂直方向坐标值。
			*this.shape.width=100;//设置 shape 对象的宽度。
			*this.shape.height=100;//设置 shape 对象的高度。
			*this.shape.pivotX=50;//设置 shape 对象的水平方法轴心点坐标。
			*this.shape.pivotY=50;//设置 shape 对象的垂直方法轴心点坐标。
			*Laya.stage.addChild(this.shape);//将此 shape 对象添加到显示列表。
			*this.shape.on(laya.events.Event.CLICK,this,this.onClickShape);//给 shape 对象添加点击事件侦听。
			*}
		*private onClickSprite():void {
			*console.log("点击 sprite 对象。");
			*this.sprite.rotation+=5;//旋转 sprite 对象。
			*}
		*private onClickShape():void {
			*console.log("点击 shape 对象。");
			*this.shape.rotation+=5;//旋转 shape 对象。
			*}
		*}
	*/
	//class laya.display.Sprite extends laya.display.Node
	var Sprite=(function(_super){
		function Sprite(){
			this._x=0;
			this._y=0;
			this._width=0;
			this._height=0;
			this._visible=true;
			this._mouseState=0;
			this._zOrder=0;
			this._renderType=0;
			this._transform=null;
			this._tfChanged=false;
			this._texture=null;
			this._boundStyle=null;
			this._graphics=null;
			this.mouseThrough=false;
			this.autoSize=false;
			this.hitTestPrior=false;
			Sprite.__super.call(this);
			this._repaint=0;
			this._style=SpriteStyle.EMPTY;
			this._cacheStyle=CacheStyle.EMPTY;
		}

		__class(Sprite,'laya.display.Sprite',_super);
		var __proto=Sprite.prototype;
		/**@inheritDoc */
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			_super.prototype.destroy.call(this,destroyChild);
			this._style && this._style.recover();
			this._cacheStyle && this._cacheStyle.recover();
			this._boundStyle && this._boundStyle.recover();
			this._style=null;
			this._cacheStyle=null;
			this._boundStyle=null;
			this._transform=null;
			this._graphics=null;
		}

		/**根据zOrder进行重新排序。*/
		__proto.updateZOrder=function(){
			Utils.updateOrder(this._children)&& this.repaint();
		}

		/**
		*@private
		*/
		__proto._getBoundsStyle=function(){
			if (!this._boundStyle)this._boundStyle=BoundsStyle.create();
			return this._boundStyle;
		}

		__proto._setCacheAs=function(value){}
		/**
		*更新_cnavas相关的状态
		*/
		__proto._checkCanvasEnable=function(){
			var tEnable=this._cacheStyle.needEnableCanvasRender();
			this._getCacheStyle().enableCanvasRender=tEnable;
			if (tEnable){
				if (this._cacheStyle.needBitmapCache()){
					this._cacheStyle.cacheAs="bitmap";
					}else {
					this._cacheStyle.cacheAs=this._cacheStyle.userSetCache;
				}
				this._cacheStyle.reCache=true;
				this._renderType |=0x08;
				}else {
				this._cacheStyle.cacheAs="none";
				this._cacheStyle.releaseContext();
				this._renderType &=~0x08;
			}
			this._setRenderType(this._renderType);
		}

		/**在设置cacheAs的情况下，调用此方法会重新刷新缓存。*/
		__proto.reCache=function(){
			this._cacheStyle.reCache=true;
			this._repaint |=0x02;
		}

		__proto._setX=function(value){
			this._x=value;
		}

		__proto._setY=function(value){
			this._y=value;
		}

		/**
		*设置对象bounds大小，如果有设置，则不再通过getBounds计算，合理使用能提高性能。
		*@param bound bounds矩形区域
		*/
		__proto.setSelfBounds=function(bound){
			this._getBoundsStyle().userBounds=bound;
		}

		/**
		*<p>获取本对象在父容器坐标系的矩形显示区域。</p>
		*<p><b>注意：</b>计算量较大，尽量少用。</p>
		*@return 矩形区域。
		*/
		__proto.getBounds=function(){
			return this._getBoundsStyle().bounds=Rectangle._getWrapRec(this._boundPointsToParent());
		}

		/**
		*获取本对象在自己坐标系的矩形显示区域。
		*<p><b>注意：</b>计算量较大，尽量少用。</p>
		*@return 矩形区域。
		*/
		__proto.getSelfBounds=function(){
			if (this._boundStyle && this._boundStyle.userBounds)return this._boundStyle.userBounds;
			if (!this._graphics && this._children.length===0)return Rectangle.TEMP.setTo(0,0,0,0);
			return this._getBoundsStyle().bounds=Rectangle._getWrapRec(this._getBoundPointsM(false));
		}

		/**
		*@private
		*获取本对象在父容器坐标系的显示区域多边形顶点列表。
		*当显示对象链中有旋转时，返回多边形顶点列表，无旋转时返回矩形的四个顶点。
		*@param ifRotate （可选）之前的对象链中是否有旋转。
		*@return 顶点列表。结构：[x1,y1,x2,y2,x3,y3,...]。
		*/
		__proto._boundPointsToParent=function(ifRotate){
			(ifRotate===void 0)&& (ifRotate=false);
			var pX=0,pY=0;
			if (this._style){
				ifRotate=ifRotate || (this._style.rotation!==0);
				if (this._style.scrollRect){
					pX+=this._style.scrollRect.x;
					pY+=this._style.scrollRect.y;
				}
			};
			var pList=this._getBoundPointsM(ifRotate);
			if (!pList || pList.length < 1)return pList;
			if (pList.length !=8){
				pList=ifRotate ? GrahamScan.scanPList(pList):Rectangle._getWrapRec(pList,Rectangle.TEMP)._getBoundPoints();
			}
			if (!this.transform){
				Utils.transPointList(pList,this._x-pX,this._y-pY);
				return pList;
			};
			var tPoint=Point.TEMP;
			var i=0,len=pList.length;
			for (i=0;i < len;i+=2){
				tPoint.x=pList[i];
				tPoint.y=pList[i+1];
				this.toParentPoint(tPoint);
				pList[i]=tPoint.x;
				pList[i+1]=tPoint.y;
			}
			return pList;
		}

		/**
		*返回此实例中的绘图对象（ <code>Graphics</code> ）的显示区域，不包括子对象。
		*@param realSize （可选）使用图片的真实大小，默认为false
		*@return 一个 Rectangle 对象，表示获取到的显示区域。
		*/
		__proto.getGraphicBounds=function(realSize){
			(realSize===void 0)&& (realSize=false);
			if (!this._graphics)return Rectangle.TEMP.setTo(0,0,0,0);
			return this._graphics.getBounds(realSize);
		}

		/**
		*@private
		*获取自己坐标系的显示区域多边形顶点列表
		*@param ifRotate （可选）当前的显示对象链是否由旋转
		*@return 顶点列表。结构：[x1,y1,x2,y2,x3,y3,...]。
		*/
		__proto._getBoundPointsM=function(ifRotate){
			(ifRotate===void 0)&& (ifRotate=false);
			if (this._boundStyle && this._boundStyle.userBounds)return this._boundStyle.userBounds._getBoundPoints();
			if (!this._boundStyle)this._getBoundsStyle();
			if (!this._boundStyle.temBM)this._boundStyle.temBM=[];
			if (this._style.scrollRect){
				var rst=Utils.clearArray(this._boundStyle.temBM);
				var rec=Rectangle.TEMP;
				rec.copyFrom(this._style.scrollRect);
				Utils.concatArray(rst,rec._getBoundPoints());
				return rst;
			};
			var pList;
			if (this._graphics){
				pList=this._graphics.getBoundPoints();
				}else {
				pList=Utils.clearArray(this._boundStyle.temBM);
			};
			var child;
			var cList;
			var __childs;
			__childs=this._children;
			for (var i=0,n=__childs.length;i < n;i++){
				child=__childs [i];
				if ((child instanceof laya.display.Sprite )&& child._visible===true){
					cList=child._boundPointsToParent(ifRotate);
					if (cList)
						pList=pList ? Utils.concatArray(pList,cList):cList;
				}
			}
			return pList;
		}

		/**
		*@private
		*获取cache数据。
		*@return cache数据 CacheStyle 。
		*/
		__proto._getCacheStyle=function(){
			this._cacheStyle===CacheStyle.EMPTY && (this._cacheStyle=CacheStyle.create());
			return this._cacheStyle;
		}

		/**
		*@private
		*获取样式。
		*@return 样式 Style 。
		*/
		__proto.getStyle=function(){
			this._style===SpriteStyle.EMPTY && (this._style=SpriteStyle.create());
			return this._style;
		}

		/**
		*@private
		*设置样式。
		*@param value 样式。
		*/
		__proto.setStyle=function(value){
			this._style=value;
		}

		__proto._setScaleX=function(value){
			this._style.scaleX=value;
		}

		__proto._setScaleY=function(value){
			this._style.scaleY=value;
		}

		__proto._setRotation=function(value){
			this._style.rotation=value;
		}

		__proto._setSkewX=function(value){
			this._style.skewX=value;
		}

		__proto._setSkewY=function(value){
			this._style.skewY=value;
		}

		__proto._createTransform=function(){
			return Matrix.create();
		}

		/**@private */
		__proto._adjustTransform=function(){
			'use strict';
			this._tfChanged=false;
			var style=this._style;
			var sx=style.scaleX,sy=style.scaleY;
			var m;
			if (style.rotation || sx!==1 || sy!==1 || style.skewX || style.skewY){
				m=this._transform || (this._transform=this._createTransform());
				m._bTransform=true;
				var skx=(style.rotation-style.skewX)*0.0174532922222222;
				var sky=(style.rotation+style.skewY)*0.0174532922222222;
				var cx=Math.cos(sky);
				var ssx=Math.sin(sky);
				var cy=Math.sin(skx);
				var ssy=Math.cos(skx);
				m.a=sx *cx;
				m.b=sx *ssx;
				m.c=-sy *cy;
				m.d=sy *ssy;
				m.tx=m.ty=0;
				return m;
				}else {
				this._transform && this._transform.destroy();
				this._transform=null;
				this._renderType &=~0x02;
				this._setRenderType(this._renderType);
			}
			return m;
		}

		__proto._setPivotX=function(value){
			var style=this.getStyle();
			style.pivotX=value;
		}

		__proto._getPivotX=function(){
			return this._style.pivotX;
		}

		__proto._setPivotY=function(value){
			var style=this.getStyle();
			style.pivotY=value;
		}

		__proto._getPivotY=function(){
			return this._style.pivotY;
		}

		__proto._setAlpha=function(value){
			if (this._style.alpha!==value){
				var style=this.getStyle();
				style.alpha=value;
				if (value!==1)this._renderType |=0x01;
				else this._renderType &=~0x01;
				this._setRenderType(this._renderType);
				this.parentRepaint();
			}
		}

		__proto._getAlpha=function(){
			return this._style.alpha;
		}

		__proto._setGraphics=function(value){}
		__proto.setLayaGL3D=function(value){
			if (value){
				if (Render.isConchApp){
					this.data._int32Data[21]=value._buffer._buffer["_ptrID"];
				}
				this._renderType |=0x400;
			}
			else{
				this._renderType &=~0x400;
			}
			this._setRenderType(this._renderType);
			this.repaint();
		}

		/**
		*<p>设置坐标位置。相当于分别设置x和y属性。</p>
		*<p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.pos(...).scale(...);</p>
		*@param x X轴坐标。
		*@param y Y轴坐标。
		*@param speedMode （可选）是否极速模式，正常是调用this.x=value进行赋值，极速模式直接调用内部函数处理，如果未重写x,y属性，建议设置为急速模式性能更高。
		*@return 返回对象本身。
		*/
		__proto.pos=function(x,y,speedMode){
			(speedMode===void 0)&& (speedMode=false);
			if (this._x!==x || this._y!==y){
				if (this.destroyed)return this;
				if (speedMode){
					this._setX(x);
					this._setY(y);
					this._setTranformChange();
					}else {
					this.x=x;
					this.y=y;
				}
			}
			return this;
		}

		/**
		*<p>设置轴心点。相当于分别设置pivotX和pivotY属性。</p>
		*<p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.pivot(...).pos(50,100);</p>
		*@param x X轴心点。
		*@param y Y轴心点。
		*@return 返回对象本身。
		*/
		__proto.pivot=function(x,y){
			this.pivotX=x;
			this.pivotY=y;
			return this;
		}

		/**
		*<p>设置宽高。相当于分别设置width和height属性。</p>
		*<p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.size(...).pos(50,100);</p>
		*@param width 宽度值。
		*@param hegiht 高度值。
		*@return 返回对象本身。
		*/
		__proto.size=function(width,height){
			this.width=width;
			this.height=height;
			return this;
		}

		/**
		*<p>设置缩放。相当于分别设置scaleX和scaleY属性。</p>
		*<p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.scale(...).pos(50,100);</p>
		*@param scaleX X轴缩放比例。
		*@param scaleY Y轴缩放比例。
		*@param speedMode （可选）是否极速模式，正常是调用this.scaleX=value进行赋值，极速模式直接调用内部函数处理，如果未重写scaleX,scaleY属性，建议设置为急速模式性能更高。
		*@return 返回对象本身。
		*/
		__proto.scale=function(scaleX,scaleY,speedMode){
			(speedMode===void 0)&& (speedMode=false);
			var style=this.getStyle();
			if (style.scaleX !=scaleX || style.scaleY !=scaleY){
				if (this.destroyed)return this;
				if (speedMode){
					this._setScaleX(scaleX);
					this._setScaleY(scaleY);
					this._setTranformChange();
					}else {
					this.scaleX=scaleX;
					this.scaleY=scaleY;
				}
			}
			return this;
		}

		/**
		*<p>设置倾斜角度。相当于分别设置skewX和skewY属性。</p>
		*<p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.skew(...).pos(50,100);</p>
		*@param skewX 水平倾斜角度。
		*@param skewY 垂直倾斜角度。
		*@return 返回对象本身
		*/
		__proto.skew=function(skewX,skewY){
			this.skewX=skewX;
			this.skewY=skewY;
			return this;
		}

		/**
		*更新、呈现显示对象。由系统调用。
		*@param context 渲染的上下文引用。
		*@param x X轴坐标。
		*@param y Y轴坐标。
		*/
		__proto.render=function(context,x,y){
			Stat.spriteCount++;
			RenderSprite.renders[this._renderType]._fun(this,context,x+this._x,y+this._y);
			this._repaint=0;
		}

		__proto.renderToNative=function(context){
			if (true){
				LayaGLTemplate.GLS[this._renderType] || LayaGLTemplate.createByRenderType(this._renderType);
				if (this._children.length > 0){
					context.blockStart(this.data);
					this._renderChilds(context);
					context.blockEnd(this.data);
				}
				else{
					context.block(this.data);
				}
			}
			else{
				context.copyCmdBuffer(this.data._int32Data[1],this.data._int32Data[2]);
			}
			this._repaint=0;
		}

		__proto._renderChilds=function(context){
			var childs=this._children,ele;
			var i=0,n=childs.length;
			var style=this._style;
			if (style.viewport){
				var rect=style.viewport;
				var left=rect.x;
				var top=rect.y;
				var right=rect.right;
				var bottom=rect.bottom;
				var _x=NaN,_y=NaN;
				for (;i < n;++i){
					if ((ele=childs[i])._visible && ((_x=ele._x)< right && (_x+ele.width)> left && (_y=ele._y)< bottom && (_y+ele.height)> top))
						ele.renderToNative(context);
				}
				}else {
				for (;i < n;++i)
				(ele=childs[i])._visible && ele.renderToNative(context);
			}
		}

		/**
		*<p>绘制 当前<code>Sprite</code> 到 <code>Canvas</code> 上，并返回一个HtmlCanvas。</p>
		*<p>绘制的结果可以当作图片源，再次绘制到其他Sprite里面，示例：</p>
		*
		*var htmlCanvas:HTMLCanvas=sprite.drawToCanvas(100,100,0,0);//把精灵绘制到canvas上面
		*var texture:Texture=new Texture(htmlCanvas);//使用htmlCanvas创建Texture
		*var sp:Sprite=new Sprite().pos(0,200);//创建精灵并把它放倒200位置
		*sp.graphics.drawImage(texture);//把截图绘制到精灵上
		*Laya.stage.addChild(sp);//把精灵显示到舞台
		*
		*<p>也可以获取原始图片数据，分享到网上，从而实现截图效果，示例：</p>
		*
		*var htmlCanvas:HTMLCanvas=sprite.drawToCanvas(100,100,0,0);//把精灵绘制到canvas上面
		*var canvas:*=htmlCanvas.getCanvas();//获取原生的canvas对象
		*trace(canvas.toDataURL("image/png"));//打印图片base64信息，可以发给服务器或者保存为图片
		*
		*@param canvasWidth 画布宽度。
		*@param canvasHeight 画布高度。
		*@param x 绘制的 X 轴偏移量。
		*@param y 绘制的 Y 轴偏移量。
		*@return HTMLCanvas 对象。
		*/
		__proto.drawToCanvas=function(canvasWidth,canvasHeight,offsetX,offsetY){
			return RunDriver.drawToCanvas(this,this._renderType,canvasWidth,canvasHeight,offsetX,offsetY);
		}

		/**
		*<p>自定义更新、呈现显示对象。一般用来扩展渲染模式，请合理使用，可能会导致在加速器上无法渲染。</p>
		*<p><b>注意</b>不要在此函数内增加或删除树节点，否则会对树节点遍历造成影响。</p>
		*@param context 渲染的上下文引用。
		*@param x X轴坐标。
		*@param y Y轴坐标。
		*/
		__proto.customRender=function(context,x,y){
			this._renderType |=0x800;
			this._setRenderType(this._renderType);
		}

		/**
		*@private
		*应用滤镜。
		*/
		__proto._applyFilters=function(){
			if (Render.isWebGL)return;
			var _filters;
			_filters=this._cacheStyle.filters;
			if (!_filters || _filters.length < 1)return;
			for (var i=0,n=_filters.length;i < n;i++){
				_filters[i].action.apply(this._cacheStyle);
			}
		}

		/**
		*@private
		*查看当前原件中是否包含发光滤镜。
		*@return 一个 Boolean 值，表示当前原件中是否包含发光滤镜。
		*/
		__proto._isHaveGlowFilter=function(){
			var i=0,len=0;
			if (this.filters){
				for (i=0;i < this.filters.length;i++){
					if (this.filters[i].type==0x08){
						return true;
					}
				}
			}
			for (i=0,len=this._children.length;i < len;i++){
				if (this._children[i]._isHaveGlowFilter()){
					return true;
				}
			}
			return false;
		}

		/**
		*把本地坐标转换为相对stage的全局坐标。
		*@param point 本地坐标点。
		*@param createNewPoint （可选）是否创建一个新的Point对象作为返回值，默认为false，使用输入的point对象返回，减少对象创建开销。
		*@return 转换后的坐标的点。
		*/
		__proto.localToGlobal=function(point,createNewPoint){
			(createNewPoint===void 0)&& (createNewPoint=false);
			if (createNewPoint===true){
				point=new Point(point.x,point.y);
			};
			var ele=this;
			while (ele){
				if (ele==Laya.stage)break ;
				point=ele.toParentPoint(point);
				ele=ele.parent;
			}
			return point;
		}

		/**
		*把stage的全局坐标转换为本地坐标。
		*@param point 全局坐标点。
		*@param createNewPoint （可选）是否创建一个新的Point对象作为返回值，默认为false，使用输入的point对象返回，减少对象创建开销。
		*@return 转换后的坐标的点。
		*/
		__proto.globalToLocal=function(point,createNewPoint){
			(createNewPoint===void 0)&& (createNewPoint=false);
			if (createNewPoint){
				point=new Point(point.x,point.y);
			};
			var ele=this;
			var list=[];
			while (ele){
				if (ele==Laya.stage)break ;
				list.push(ele);
				ele=ele.parent;
			};
			var i=list.length-1;
			while (i >=0){
				ele=list[i];
				point=ele.fromParentPoint(point);
				i--;
			}
			return point;
		}

		/**
		*将本地坐标系坐标转转换到父容器坐标系。
		*@param point 本地坐标点。
		*@return 转换后的点。
		*/
		__proto.toParentPoint=function(point){
			if (!point)return point;
			if (this.transform){
				this._transform.transformPoint(point);
			}
			point.x+=this._x;
			point.y+=this._y;
			var scroll=this._style.scrollRect;
			if (scroll){
				point.x-=scroll.x;
				point.y-=scroll.y;
			}
			return point;
		}

		/**
		*将父容器坐标系坐标转换到本地坐标系。
		*@param point 父容器坐标点。
		*@return 转换后的点。
		*/
		__proto.fromParentPoint=function(point){
			if (!point)return point;
			point.x-=this._x;
			point.y-=this._y;
			var scroll=this._style.scrollRect;
			if (scroll){
				point.x+=scroll.x;
				point.y+=scroll.y;
			}
			if (this.transform){
				this._transform.invertTransformPoint(point);
			}
			return point;
		}

		/**
		*<p>增加事件侦听器，以使侦听器能够接收事件通知。</p>
		*<p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args （可选）事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.on=function(type,caller,listener,args){
			if (this._mouseState!==1 && this.isMouseEvent(type)){
				this.mouseEnabled=true;
				this._setBit(0x04,true);
				if (this._parent){
					this._onDisplay();
				}
				return this._createListener(type,caller,listener,args,false);
			}
			return _super.prototype.on.call(this,type,caller,listener,args);
		}

		/**
		*<p>增加事件侦听器，以使侦听器能够接收事件通知，此侦听事件响应一次后则自动移除侦听。</p>
		*<p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args （可选）事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.once=function(type,caller,listener,args){
			if (this._mouseState!==1 && this.isMouseEvent(type)){
				this.mouseEnabled=true;
				this._setBit(0x04,true);
				if (this._parent){
					this._onDisplay();
				}
				return this._createListener(type,caller,listener,args,true);
			}
			return _super.prototype.once.call(this,type,caller,listener,args);
		}

		/**@private */
		__proto._onDisplay=function(){
			if (this._mouseState!==1){
				var ele=this;
				ele=ele.parent;
				while (ele && ele._mouseState!==1){
					if (ele._getBit(0x04))break ;
					ele.mouseEnabled=true;
					ele._setBit(0x04,true);
					ele=ele.parent;
				}
			}
		}

		__proto._setParent=function(value){
			_super.prototype._setParent.call(this,value);
			if (value && this._getBit(0x04)){
				this._onDisplay();
			}
		}

		/**
		*<p>加载并显示一个图片。功能等同于graphics.loadImage方法。支持异步加载。</p>
		*<p>注意：多次调用loadImage绘制不同的图片，会同时显示。</p>
		*@param url 图片地址。
		*@param x （可选）显示图片的x位置。
		*@param y （可选）显示图片的y位置。
		*@param width （可选）显示图片的宽度，设置为0表示使用图片默认宽度。
		*@param height （可选）显示图片的高度，设置为0表示使用图片默认高度。
		*@param complete （可选）加载完成回调。
		*@return 返回精灵对象本身。
		*/
		__proto.loadImage=function(url,x,y,width,height,complete){
			var _$this=this;
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(width===void 0)&& (width=0);
			(height===void 0)&& (height=0);
			function loaded (tex){
				if (!_$this.destroyed){
					_$this.repaint();
					complete && complete.runWith(tex);
				}
			}
			this.graphics.loadImage(url,x,y,width,height,loaded);
			return this;
		}

		/**cacheAs后，设置自己和父对象缓存失效。*/
		__proto.repaint=function(type){
			(type===void 0)&& (type=0x02);
			if (!(this._repaint&type)){
				this._repaint |=type;
				this.parentRepaint(type);
			}
			if (this._cacheStyle && this._cacheStyle.maskParent){
				this._cacheStyle.maskParent.repaint(type);
			}
		}

		/**
		*@private
		*获取是否重新缓存。
		*@return 如果重新缓存值为 true，否则值为 false。
		*/
		__proto._needRepaint=function(){
			return (this._repaint&0x02)&& this._cacheStyle.enableCanvasRender && this._cacheStyle.reCache;
		}

		/**@private */
		__proto._childChanged=function(child){
			if (this._children.length)this._renderType |=0x2000;
			else this._renderType &=~0x2000;
			this._setRenderType(this._renderType);
			if (child && this._getBit(0x02))Laya.timer.callLater(this,this.updateZOrder);
			this.repaint(0x03);
		}

		/**cacheAs时，设置所有父对象缓存失效。 */
		__proto.parentRepaint=function(type){
			(type===void 0)&& (type=0x02);
			var p=this._parent;
			if (p && !(p._repaint&type)){
				p._repaint |=type;
				p.parentRepaint(type);
			}
		}

		/**
		*开始拖动此对象。
		*@param area （可选）拖动区域，此区域为当前对象注册点活动区域（不包括对象宽高），可选。
		*@param hasInertia （可选）鼠标松开后，是否还惯性滑动，默认为false，可选。
		*@param elasticDistance （可选）橡皮筋效果的距离值，0为无橡皮筋效果，默认为0，可选。
		*@param elasticBackTime （可选）橡皮筋回弹时间，单位为毫秒，默认为300毫秒，可选。
		*@param data （可选）拖动事件携带的数据，可选。
		*@param disableMouseEvent （可选）禁用其他对象的鼠标检测，默认为false，设置为true能提高性能。
		*@param ratio （可选）惯性阻尼系数，影响惯性力度和时长。
		*/
		__proto.startDrag=function(area,hasInertia,elasticDistance,elasticBackTime,data,disableMouseEvent,ratio){
			(hasInertia===void 0)&& (hasInertia=false);
			(elasticDistance===void 0)&& (elasticDistance=0);
			(elasticBackTime===void 0)&& (elasticBackTime=300);
			(disableMouseEvent===void 0)&& (disableMouseEvent=false);
			(ratio===void 0)&& (ratio=0.92);
			this._style.dragging || (this.getStyle().dragging=new Dragging());
			this._style.dragging.start(this,area,hasInertia,elasticDistance,elasticBackTime,data,disableMouseEvent,ratio);
		}

		/**停止拖动此对象。*/
		__proto.stopDrag=function(){
			this._style.dragging && this._style.dragging.stop();
		}

		/**@private */
		__proto._setDisplay=function(value){
			if (!value){
				this._cacheStyle.releaseContext();
				this._cacheStyle.releaseFilterCache();
				if (this._cacheStyle.hasGlowFilter){
					this._cacheStyle.hasGlowFilter=false;
				}
			}
			_super.prototype._setDisplay.call(this,value);
		}

		/**
		*检测某个点是否在此对象内。
		*@param x 全局x坐标。
		*@param y 全局y坐标。
		*@return 表示是否在对象内。
		*/
		__proto.hitTestPoint=function(x,y){
			var point=this.globalToLocal(Point.TEMP.setTo(x,y));
			x=point.x;
			y=point.y;
			var rect=this._style.hitArea ? this._style.hitArea :(this._width > 0 && this._height > 0)? Rectangle.TEMP.setTo(0,0,this._width,this._height):this.getSelfBounds();
			return rect.contains(x,y);
		}

		/**获得相对于本对象上的鼠标坐标信息。*/
		__proto.getMousePoint=function(){
			return this.globalToLocal(Point.TEMP.setTo(Laya.stage.mouseX,Laya.stage.mouseY));
		}

		__proto._setTexture=function(value){}
		__proto._setRenderType=function(type){}
		__proto._setTranformChange=function(){
			this._tfChanged=true;
			this._renderType |=0x02
			this._setRenderType(this._renderType);
			var p=this._parent;
			if (p && !(p._repaint&0x02)){
				p._repaint |=0x02;
				p.parentRepaint();
			}
		}

		/**
		*设置是否开启自定义渲染，只有开启自定义渲染，才能使用customRender函数渲染。
		*/
		__getset(0,__proto,'customRenderEnable',null,function(b){
			if (b){
				this._renderType |=0x800;
				this._setRenderType(this._renderType);
			}
		});

		//_dataf32[SpriteConst.POSCACHE]=value=="bitmap"?2:(value=="normal"?1:0);
		/**
		*<p>指定显示对象是否缓存为静态图像，cacheAs时，子对象发生变化，会自动重新缓存，同时也可以手动调用reCache方法更新缓存。</p>
		*<p>建议把不经常变化的“复杂内容”缓存为静态图像，能极大提高渲染性能。cacheAs有"none"，"normal"和"bitmap"三个值可选。
		*<li>默认为"none"，不做任何缓存。</li>
		*<li>当值为"normal"时，canvas模式下进行画布缓存，webgl模式下进行命令缓存。</li>
		*<li>当值为"bitmap"时，canvas模式下进行依然是画布缓存，webgl模式下使用renderTarget缓存。</li></p>
		*<p>webgl下renderTarget缓存模式缺点：会额外创建renderTarget对象，增加内存开销，缓存面积有最大2048限制，不断重绘时会增加CPU开销。优点：大幅减少drawcall，渲染性能最高。
		*webgl下命令缓存模式缺点：只会减少节点遍历及命令组织，不会减少drawcall数，性能中等。优点：没有额外内存开销，无需renderTarget支持。</p>
		*/
		__getset(0,__proto,'cacheAs',function(){
			return this._cacheStyle.cacheAs;
			},function(value){
			if (value===this._cacheStyle.userSetCache)return;
			this._setCacheAs(value);
			this._getCacheStyle().userSetCache=value;
			this._checkCanvasEnable();
			this.repaint();
		});

		/**z排序，更改此值，则会按照值的大小对同一容器的所有对象重新排序。值越大，越靠上。默认为0，则根据添加顺序排序。*/
		__getset(0,__proto,'zOrder',function(){
			return this._zOrder;
			},function(value){
			if (this._zOrder !=value){
				this._zOrder=value;
				if (this._parent){
					value && this._parent._setBit(0x02,true);
					Laya.timer.callLater(this._parent,this.updateZOrder);
				}
			}
		});

		/**旋转角度，默认值为0。以角度为单位。*/
		__getset(0,__proto,'rotation',function(){
			return this._style.rotation;
			},function(value){
			var style=this.getStyle();
			if (style.rotation!==value){
				this._setRotation(value);
				this._setTranformChange();
			}
		});

		/**
		*<p>显示对象的宽度，单位为像素，默认为0。</p>
		*<p>此宽度用于鼠标碰撞检测，并不影响显示对象图像大小。需要对显示对象的图像进行缩放，请使用scale、scaleX、scaleY。</p>
		*<p>可以通过getbounds获取显示对象图像的实际宽度。</p>
		*/
		__getset(0,__proto,'width',function(){
			if (!this.autoSize)return this._width;
			if (!this._graphics && this._children.length===0)return 0;
			return this.getSelfBounds().width;
			},function(value){
			if (this._width!==value){
				this._width=value;
				this.repaint();
			}
		});

		/**表示显示对象相对于父容器的水平方向坐标值。*/
		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			if (this.destroyed)return;
			if (this._x!==value){
				this._setX(value);
				this._setTranformChange();
			}
		});

		/**
		*获得相对于stage的全局Y轴缩放值（会叠加父亲节点的缩放值）。
		*/
		__getset(0,__proto,'globalScaleY',function(){
			var scale=1;
			var ele=this;
			while (ele){
				if (ele===Laya.stage)break ;
				scale *=ele.scaleY;
				ele=ele.parent;
			}
			return scale;
		});

		/**
		*<p>可以设置一个Rectangle区域作为点击区域，或者设置一个<code>HitArea</code>实例作为点击区域，HitArea内可以设置可点击和不可点击区域。</p>
		*<p>如果不设置hitArea，则根据宽高形成的区域进行碰撞。</p>
		*/
		__getset(0,__proto,'hitArea',function(){
			return this._style.hitArea;
			},function(value){
			this.getStyle().hitArea=value;
		});

		/**设置cacheAs为非空时此值才有效，staticCache=true时，子对象变化时不会自动更新缓存，只能通过调用reCache方法手动刷新。*/
		__getset(0,__proto,'staticCache',function(){
			return this._cacheStyle.staticCache;
			},function(value){
			this._getCacheStyle().staticCache=value;
			if (!value)this.reCache();
		});

		/**设置一个Texture实例，并显示此图片（如果之前有其他绘制，则会被清除掉）。等同于graphics.clear();graphics.drawImage()*/
		__getset(0,__proto,'texture',function(){
			return this._texture;
			},function(value){
			if (this._texture !=value){
				this._texture=value;
				this._setTexture(value);
				if (value)this._renderType |=0x100;
				else this._renderType &=~0x100;
				this._setRenderType(this._renderType);
			}
		});

		/**表示显示对象相对于父容器的垂直方向坐标值。*/
		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			if (this.destroyed)return;
			if (this._y!==value){
				this._setY(value);
				this._setTranformChange();
			}
		});

		/**
		*<p>显示对象的高度，单位为像素，默认为0。</p>
		*<p>此高度用于鼠标碰撞检测，并不影响显示对象图像大小。需要对显示对象的图像进行缩放，请使用scale、scaleX、scaleY。</p>
		*<p>可以通过getbounds获取显示对象图像的实际高度。</p>
		*/
		__getset(0,__proto,'height',function(){
			if (!this.autoSize)return this._height;
			if (!this._graphics && this._children.length===0)return 0;
			return this.getSelfBounds().height;
			},function(value){
			if (this._height!==value){
				this._height=value;
				this.repaint();
			}
		});

		/**指定要使用的混合模式。目前只支持"lighter"。*/
		__getset(0,__proto,'blendMode',function(){
			return this._style.blendMode;
			},function(value){
			this.getStyle().blendMode=value;
			if (value && value !="source-over")this._renderType |=0x04;
			else this._renderType &=~0x04;
			this._setRenderType(this._renderType);
			this.parentRepaint();
		});

		/**X轴缩放值，默认值为1。设置为负数，可以实现水平反转效果，比如scaleX=-1。*/
		__getset(0,__proto,'scaleX',function(){
			return this._style.scaleX;
			},function(value){
			var style=this.getStyle();
			if (style.scaleX!==value){
				this._setScaleX(value);
				this._setTranformChange();
			}
		});

		/**Y轴缩放值，默认值为1。设置为负数，可以实现垂直反转效果，比如scaleX=-1。*/
		__getset(0,__proto,'scaleY',function(){
			return this._style.scaleY;
			},function(value){
			var style=this.getStyle();
			if (style.scaleY!==value){
				this._setScaleY(value);
				this._setTranformChange();
			}
		});

		/**对舞台 <code>stage</code> 的引用。*/
		__getset(0,__proto,'stage',function(){
			return Laya.stage;
		});

		/**水平倾斜角度，默认值为0。以角度为单位。*/
		__getset(0,__proto,'skewX',function(){
			return this._style.skewX;
			},function(value){
			var style=this.getStyle();
			if (style.skewX!==value){
				this._setSkewX(value);
				this._setTranformChange();
			}
		});

		/**
		*<p>显示对象的滚动矩形范围，具有裁剪效果(如果只想限制子对象渲染区域，请使用viewport)</p>
		*<p> srollRect和viewport的区别：<br/>
		*1.srollRect自带裁剪效果，viewport只影响子对象渲染是否渲染，不具有裁剪效果（性能更高）。<br/>
		*2.设置rect的x,y属性均能实现区域滚动效果，但scrollRect会保持0,0点位置不变。</p>
		*/
		__getset(0,__proto,'scrollRect',function(){
			return this._style.scrollRect;
			},function(value){
			this.getStyle().scrollRect=value;
			this.repaint();
			if (value){
				this._renderType |=0x40;
				}else {
				this._renderType &=~0x40;
			}
			this._setRenderType(this._renderType);
		});

		/**垂直倾斜角度，默认值为0。以角度为单位。*/
		__getset(0,__proto,'skewY',function(){
			return this._style.skewY;
			},function(value){
			var style=this.getStyle();
			if (style.skewY!==value){
				this._setSkewY(value);
				this._setTranformChange();
			}
		});

		/**
		*<p>对象的矩阵信息。通过设置矩阵可以实现节点旋转，缩放，位移效果。</p>
		*<p>矩阵更多信息请参考 <code>Matrix</code></p>
		*/
		__getset(0,__proto,'transform',function(){
			return this._tfChanged ? this._adjustTransform():this._transform;
			},function(value){
			this._tfChanged=false;
			var m=this._transform || (this._transform=this._createTransform());
			value.copyTo(m);
			if (value){
				this._x=value.tx;
				this._y=value.ty;
				value.tx=value.ty=0;
			}
			if (value)this._renderType |=0x02;
			else {
				this._renderType &=~0x02;
			}
			this._setRenderType(this._renderType);
			this.parentRepaint();
		});

		/**X轴 轴心点的位置，单位为像素，默认为0。轴心点会影响对象位置，缩放中心，旋转中心。*/
		__getset(0,__proto,'pivotX',function(){
			return this._getPivotX();
			},function(value){
			this._setPivotX(value);
			this.repaint();
		});

		/**Y轴 轴心点的位置，单位为像素，默认为0。轴心点会影响对象位置，缩放中心，旋转中心。*/
		__getset(0,__proto,'pivotY',function(){
			return this._getPivotY();
			},function(value){
			this._setPivotY(value);
			this.repaint();
		});

		/**透明度，值为0-1，默认值为1，表示不透明。更改alpha值会影响drawcall。*/
		__getset(0,__proto,'alpha',function(){
			return this._getAlpha();
			},function(value){
			value=value < 0 ? 0 :(value > 1 ? 1 :value);
			this._setAlpha(value);
		});

		/**表示是否可见，默认为true。如果设置不可见，节点将不被渲染。*/
		__getset(0,__proto,'visible',function(){
			return this._visible;
			},function(value){
			if (this._visible!==value){
				this._visible=value;
				this.parentRepaint();
			}
		});

		/**绘图对象。封装了绘制位图和矢量图的接口，Sprite所有的绘图操作都通过Graphics来实现的。*/
		__getset(0,__proto,'graphics',function(){
			return this._graphics || (this.graphics=RunDriver.createGraphics());
			},function(value){
			if (this._graphics)this._graphics._sp=null;
			this._graphics=value;
			if (value){
				this._setGraphics(value);
				this._renderType |=0x200;
				value._sp=this;
				}else {
				this._renderType &=~0x200;
			}
			this._setRenderType(this._renderType);
			this.repaint();
		});

		/**滤镜集合。可以设置多个滤镜组合。*/
		__getset(0,__proto,'filters',function(){
			return this._cacheStyle.filters;
			},function(value){
			value && value.length===0 && (value=null);
			if (this._cacheStyle.filters==value)return;
			this._getCacheStyle().filters=value ? value.slice():null;
			if (Render.isWebGL){
				if (value && value.length){
					this._renderType |=0x10;
					}else {
					this._renderType &=~0x10;
				}
				this._setRenderType(this._renderType);
			}
			if (value && value.length > 0){
				if (!this._getBit(0x01))this._setBitUp(0x01);
				if (!(Render.isWebGL && value.length==1 && (((value[0])instanceof laya.filters.ColorFilter )))){
					this._getCacheStyle().cacheForFilters=true;
					this._checkCanvasEnable();
				}
				}else {
				if (this._cacheStyle.cacheForFilters){
					this._cacheStyle.cacheForFilters=false;
					this._checkCanvasEnable();
				}
			}
			this.repaint();
		});

		/**
		*<p>遮罩，可以设置一个对象(支持位图和矢量图)，根据对象形状进行遮罩显示。</p>
		*<p>【注意】遮罩对象坐标系是相对遮罩对象本身的，和Flash机制不同</p>
		*/
		__getset(0,__proto,'mask',function(){
			return this._cacheStyle.mask;
			},function(value){
			if (value && this.mask && this.mask._cacheStyle.maskParent)return;
			this._getCacheStyle().mask=value;
			this._checkCanvasEnable();
			if (value){
				value._getCacheStyle().maskParent=this;
				}else {
				if (this.mask){
					this.mask._getCacheStyle().maskParent=null;
				}
			}
			this._renderType |=0x20;
			this._setRenderType(this._renderType);
			this.parentRepaint();
		});

		/**
		*是否接受鼠标事件。
		*默认为false，如果监听鼠标事件，则会自动设置本对象及父节点的属性 mouseEnable 的值都为 true（如果父节点手动设置为false，则不会更改）。
		**/
		__getset(0,__proto,'mouseEnabled',function(){
			return this._mouseState > 1;
			},function(value){
			this._mouseState=value ? 2 :1;
		});

		/**
		*获得相对于stage的全局X轴缩放值（会叠加父亲节点的缩放值）。
		*/
		__getset(0,__proto,'globalScaleX',function(){
			var scale=1;
			var ele=this;
			while (ele){
				if (ele===Laya.stage)break ;
				scale *=ele.scaleX;
				ele=ele.parent;
			}
			return scale;
		});

		/**
		*返回鼠标在此对象坐标系上的 X 轴坐标信息。
		*/
		__getset(0,__proto,'mouseX',function(){
			return this.getMousePoint().x;
		});

		/**
		*返回鼠标在此对象坐标系上的 Y 轴坐标信息。
		*/
		__getset(0,__proto,'mouseY',function(){
			return this.getMousePoint().y;
		});

		/**
		*<p>视口大小，视口外的子对象，将不被渲染(如果想实现裁剪效果，请使用srollRect)，合理使用能提高渲染性能。比如由一个个小图片拼成的地图块，viewport外面的小图片将不渲染</p>
		*<p>srollRect和viewport的区别：<br/>
		*1. srollRect自带裁剪效果，viewport只影响子对象渲染是否渲染，不具有裁剪效果（性能更高）。<br/>
		*2. 设置rect的x,y属性均能实现区域滚动效果，但scrollRect会保持0,0点位置不变。</p>
		*@default null
		*/
		__getset(0,__proto,'viewport',function(){
			return this._style.viewport;
			},function(value){
			this.getStyle().viewport=value;
		});

		Sprite.fromImage=function(url){
			return new Sprite().loadImage(url);
		}

		return Sprite;
	})(Node)


	/**
	*@private
	*<code>Bitmap</code> 图片资源类。
	*/
	//class laya.resource.Bitmap extends laya.resource.Resource
	var Bitmap=(function(_super){
		function Bitmap(){
			//this._width=NaN;
			//this._height=NaN;
			Bitmap.__super.call(this);
			this._width=-1;
			this._height=-1;
		}

		__class(Bitmap,'laya.resource.Bitmap',_super);
		var __proto=Bitmap.prototype;
		/**
		*@private
		*获取纹理资源。
		*/
		__proto._getSource=function(){
			throw "Bitmap: must override it.";
		}

		/**
		*获取宽度。
		*/
		__getset(0,__proto,'width',function(){
			return this._width;
		});

		/***
		*获取高度。
		*/
		__getset(0,__proto,'height',function(){
			return this._height;
		});

		return Bitmap;
	})(Resource)


	/**
	*...
	*@author ww
	*/
	//class laya.runtime.ConchSpriteAdpt extends laya.display.Node
	var ConchSpriteAdpt=(function(_super){
		function ConchSpriteAdpt(){
			this._dataf32=null;
			this._datai32=null;
			this._x=0;
			this._y=0;
			this._renderType=0;
			ConchSpriteAdpt.__super.call(this);
		}

		__class(ConchSpriteAdpt,'laya.runtime.ConchSpriteAdpt',_super);
		var __proto=ConchSpriteAdpt.prototype;
		__proto.createData=function(){
			this.data=ParamData.create(22 *4);
			this._datai32=this.data._int32Data;
			this._dataf32=this.data._float32Data;
			this._dataf32[19]=1;
			this._dataf32[5]=0;
			this._dataf32[6]=0;
			this._dataf32[7]=1;
			this._dataf32[8]=1;
			this._dataf32[13]=1;
			this._dataf32[13+1]=0;
			this._dataf32[13+2]=0;
			this._dataf32[13+3]=1;
			this._dataf32[13+4]=0;
			this._dataf32[13+5]=0;
		}

		__proto._createTransform=function(){
			return MatrixConch.create(new Float32Array(this._dataf32.buffer,13*4,6*4));
		}

		__proto._setGraphics=function(value){
			this.data._int32Data[20]=value._commandEncoder._buffer["_ptrID"];
		}

		__proto._setCacheAs=function(value){
			this._dataf32[SpriteConst.POSCACHE]=value=="bitmap"?2:(value=="normal"?1:0);
		}

		__proto._setX=function(value){
			this._x=this._dataf32[3]=value;
			this._dataf32[12]=1.0;
		}

		__proto._setY=function(value){
			this._y=this._dataf32[4]=value;
			this._dataf32[12]=1.0;
		}

		__proto._setPivotX=function(value){
			this._dataf32[5]=value;
			this._dataf32[12]=1.0;
		}

		__proto._getPivotX=function(){
			return this._dataf32[5];
		}

		__proto._setPivotY=function(value){
			this._dataf32[6]=value;
			this._dataf32[12]=1.0;
		}

		__proto._getPivotY=function(){
			return this._dataf32[6];
		}

		__proto._setAlpha=function(value){
			if (this._dataf32[19]!==value){
				this._dataf32[19]=value;
				if (value!==1)
					this._renderType |=0x01;
				else
				this._renderType &=~0x01;
				this._setRenderType(this._renderType);
				this.parentRepaint();
			}
		}

		__proto._setRenderType=function(type){
			this._datai32[0]=type;
		}

		__proto.parentRepaint=function(){}
		__proto._getAlpha=function(){
			return this._dataf32[19];
		}

		__proto._setScaleX=function(value){
			this._style.scaleX=this._dataf32[7]=value;
			this._dataf32[12]=1.0;
		}

		__proto._setScaleY=function(value){
			this._style.scaleY=this._dataf32[8]=value;
			this._dataf32[12]=1.0;
		}

		__proto._setSkewX=function(value){
			this._style.skewX=this._dataf32[9]=value;
			this._dataf32[12]=1.0;
		}

		__proto._setSkewY=function(value){
			this._style.skewY=this._dataf32[10]=value;
			this._dataf32[12]=1.0;
		}

		__proto._setRotation=function(value){
			this._style.rotation=this._dataf32[11]=value;
			this._dataf32[12]=1.0;
		}

		__proto._setTexture=function(value){
			this._datai32[SpriteConst.POSTEXTURE]=value._conchTexture.id;
		}

		__proto._adjustTransform=function(){
			var style=this._style;
			var sx=style.scaleX,sy=style.scaleY;
			var m;
			m=this._transform || (this._transform=this._createTransform());
			m._bTransform=true;
			window.conch.calcMatrixFromScaleSkewRotation(this.data._data["_ptrID"],12*4,13*4,3*4,4*4,5*4,
			6*4,7*4,8*4,9*4,10*4,11*4);
			return m;
		}

		ConchSpriteAdpt.createMatrix=function(a,b,c,d,tx,ty,nums){
			(a===void 0)&& (a=1);
			(b===void 0)&& (b=0);
			(c===void 0)&& (c=0);
			(d===void 0)&& (d=1);
			(tx===void 0)&& (tx=0);
			(ty===void 0)&& (ty=0);
			return new MatrixConch(a,b,c,d,tx,ty,nums);
		}

		ConchSpriteAdpt.init=function(){
			ConchCmdReplace.__init__();
			ConchGraphicsAdpt.__init__();
			var spP=Sprite["prototype"];
			var mP=ConchSpriteAdpt["prototype"];
			var funs=[
			"_createTransform",
			"_setGraphics",
			"_setCacheAs",
			"_setX",
			"_setY",
			"_setPivotX",
			"_getPivotX",
			"_setPivotY",
			"_getPivotY",
			"_setAlpha",
			"_getAlpha",
			"_setScaleX",
			"_setScaleY",
			"_setSkewX",
			"_setSkewY",
			"_setRotation",
			"_adjustTransform",
			"_setRenderType",
			"_setTexture"];
			var i=0,len=0;
			len=funs.length;
			var tFunName;
			for (i=0;i < len;i++){
				tFunName=funs[i];
				spP[tFunName]=mP[tFunName];
			}
			spP["createGLBuffer"]=mP["createData"];
			Matrix._createFun=ConchSpriteAdpt.createMatrix;
			LayaGL.__init__();
		}

		return ConchSpriteAdpt;
	})(Node)


	/**
	*@private
	*audio标签播放声音的音轨控制
	*/
	//class laya.media.h5audio.AudioSoundChannel extends laya.media.SoundChannel
	var AudioSoundChannel=(function(_super){
		function AudioSoundChannel(audio){
			this._audio=null;
			this._onEnd=null;
			this._resumePlay=null;
			AudioSoundChannel.__super.call(this);
			this._onEnd=Utils.bind(this.__onEnd,this);
			this._resumePlay=Utils.bind(this.__resumePlay,this);
			audio.addEventListener("ended",this._onEnd);
			this._audio=audio;
		}

		__class(AudioSoundChannel,'laya.media.h5audio.AudioSoundChannel',_super);
		var __proto=AudioSoundChannel.prototype;
		__proto.__onEnd=function(){
			if (this.loops===1){
				if (this.completeHandler){
					Laya.timer.once(10,this,this.__runComplete,[this.completeHandler],false);
					this.completeHandler=null;
				}
				this.stop();
				this.event("complete");
				return;
			}
			if (this.loops > 0){
				this.loops--;
			}
			this.play();
		}

		__proto.__resumePlay=function(){
			if (this._audio)this._audio.removeEventListener("canplay",this._resumePlay);
			try {
				this._audio.currentTime=this.startTime;
				Browser.container.appendChild(this._audio);
				this._audio.play();
				}catch (e){
				this.event("error");
			}
		}

		/**
		*播放
		*/
		__proto.play=function(){
			this.isStopped=false;
			try {
				this._audio.playbackRate=SoundManager.playbackRate;
				this._audio.currentTime=this.startTime;
				}catch (e){
				this._audio.addEventListener("canplay",this._resumePlay);
				return;
			}
			SoundManager.addChannel(this);
			Browser.container.appendChild(this._audio);
			if ("play" in this._audio)this._audio.play();
		}

		/**
		*停止播放
		*/
		__proto.stop=function(){
			this.isStopped=true;
			SoundManager.removeChannel(this);
			this.completeHandler=null;
			if (!this._audio)return;
			if (Render.isConchApp){
				this._audio.stop();
			}
			if ("pause" in this._audio)this._audio.pause();
			this._audio.removeEventListener("ended",this._onEnd);
			this._audio.removeEventListener("canplay",this._resumePlay);
			if (!Browser.onIE)Pool.recover("audio:"+this.url,this._audio);
			Browser.removeElement(this._audio);
			this._audio=null;
		}

		__proto.pause=function(){
			this.isStopped=true;
			SoundManager.removeChannel(this);
			if ("pause" in this._audio)this._audio.pause();
		}

		__proto.resume=function(){
			if (!this._audio)return;
			this.isStopped=false;
			SoundManager.addChannel(this);
			if ("play" in this._audio)this._audio.play();
		}

		/**
		*当前播放到的位置
		*/
		__getset(0,__proto,'position',function(){
			if (!this._audio)return 0;
			return this._audio.currentTime;
		});

		/**
		*获取总时间。
		*/
		__getset(0,__proto,'duration',function(){
			if (!this._audio)return 0;
			return this._audio.duration;
		});

		/**
		*设置音量
		*/
		/**
		*获取音量
		*/
		__getset(0,__proto,'volume',function(){
			if (!this._audio)return 1;
			return this._audio.volume;
			},function(v){
			if (!this._audio)return;
			this._audio.volume=v;
		});

		return AudioSoundChannel;
	})(SoundChannel)


	/**
	*<code>AnimationTemplet</code> 类用于动画模板资源。
	*/
	//class laya.ani.AnimationTemplet extends laya.resource.Resource
	var AnimationTemplet=(function(_super){
		function AnimationTemplet(){
			//this._aniVersion=null;
			this._aniMap={};
			//this._publicExtData=null;
			//this._useParent=false;
			//this.unfixedCurrentFrameIndexes=null;
			//this.unfixedCurrentTimes=null;
			//this.unfixedKeyframes=null;
			this.unfixedLastAniIndex=-1;
			//this._aniClassName=null;
			//this._animationDatasCache=null;
			AnimationTemplet.__super.call(this);
			this._anis=new Array;
		}

		__class(AnimationTemplet,'laya.ani.AnimationTemplet',_super);
		var __proto=AnimationTemplet.prototype;
		/**
		*@private
		*/
		__proto.parse=function(data){
			var reader=new Byte(data);
			this._aniVersion=reader.readUTFString();
			AnimationParser01.parse(this,reader);
		}

		/**
		*@private
		*/
		__proto._calculateKeyFrame=function(node,keyframeCount,keyframeDataCount){
			var keyFrames=node.keyFrame;
			keyFrames[keyframeCount]=keyFrames[0];
			for (var i=0;i < keyframeCount;i++){
				var keyFrame=keyFrames[i];
				for (var j=0;j < keyframeDataCount;j++){
					keyFrame.dData[j]=(keyFrame.duration===0)? 0 :(keyFrames[i+1].data[j]-keyFrame.data[j])/ keyFrame.duration;
					keyFrame.nextData[j]=keyFrames[i+1].data[j];
				}
			}
			keyFrames.length--;
		}

		/**
		*@inheritDoc
		*/
		__proto.onAsynLoaded=function(data,params){
			var reader=new Byte(data);
			this._aniVersion=reader.readUTFString();
			switch (this._aniVersion){
				case "LAYAANIMATION:02":
					AnimationParser02.parse(this,reader);
					break ;
				default :
					AnimationParser01.parse(this,reader);
				}
		}

		__proto.getAnimationCount=function(){
			return this._anis.length;
		}

		__proto.getAnimation=function(aniIndex){
			return this._anis[aniIndex];
		}

		__proto.getAniDuration=function(aniIndex){
			return this._anis[aniIndex].playTime;
		}

		__proto.getNodes=function(aniIndex){
			return this._anis[aniIndex].nodes;
		}

		__proto.getNodeIndexWithName=function(aniIndex,name){
			return this._anis[aniIndex].bone3DMap[name];
		}

		__proto.getNodeCount=function(aniIndex){
			return this._anis[aniIndex].nodes.length;
		}

		__proto.getTotalkeyframesLength=function(aniIndex){
			return this._anis[aniIndex].totalKeyframeDatasLength;
		}

		__proto.getPublicExtData=function(){
			return this._publicExtData;
		}

		__proto.getAnimationDataWithCache=function(key,cacheDatas,aniIndex,frameIndex){
			var aniDatas=cacheDatas[aniIndex];
			if (!aniDatas){
				return null;
				}else {
				var keyDatas=aniDatas[key];
				if (!keyDatas)
					return null;
				else {
					return keyDatas[frameIndex];
				}
			}
		}

		__proto.setAnimationDataWithCache=function(key,cacheDatas,aniIndex,frameIndex,data){
			var aniDatas=(cacheDatas[aniIndex])|| (cacheDatas[aniIndex]={});
			var aniDatasCache=(aniDatas[key])|| (aniDatas[key]=[]);
			aniDatasCache[frameIndex]=data;
		}

		__proto.getOriginalData=function(aniIndex,originalData,nodesFrameIndices,frameIndex,playCurTime){
			var oneAni=this._anis[aniIndex];
			var nodes=oneAni.nodes;
			var j=0;
			for (var i=0,n=nodes.length,outOfs=0;i < n;i++){
				var node=nodes[i];
				var key;
				key=node.keyFrame[nodesFrameIndices[i][frameIndex]];
				node.dataOffset=outOfs;
				var dt=playCurTime-key.startTime;
				var lerpType=node.lerpType;
				if (lerpType){
					switch (lerpType){
						case 0:
						case 1:
							for (j=0;j < node.keyframeWidth;)
							j+=node.interpolationMethod[j](node,j,originalData,outOfs+j,key.data,dt,key.dData,key.duration,key.nextData);
							break ;
						case 2:;
							var interpolationData=key.interpolationData;
							var interDataLen=interpolationData.length;
							var dataIndex=0;
							for (j=0;j < interDataLen;){
								var type=interpolationData[j];
							switch (type){
								case 6:
									j+=AnimationTemplet.interpolation[type](node,dataIndex,originalData,outOfs+dataIndex,key.data,dt,key.dData,key.duration,key.nextData,interpolationData,j+1);
									break ;
								case 7:
									j+=AnimationTemplet.interpolation[type](node,dataIndex,originalData,outOfs+dataIndex,key.data,dt,key.dData,key.duration,key.nextData,interpolationData,j+1);
									break ;
								default :
									j+=AnimationTemplet.interpolation[type](node,dataIndex,originalData,outOfs+dataIndex,key.data,dt,key.dData,key.duration,key.nextData);
								}
							dataIndex++;
						}
						break ;
					}
					}else {
					for (j=0;j < node.keyframeWidth;)
					j+=node.interpolationMethod[j](node,j,originalData,outOfs+j,key.data,dt,key.dData,key.duration,key.nextData);
				}
				outOfs+=node.keyframeWidth;
			}
		}

		__proto.getNodesCurrentFrameIndex=function(aniIndex,playCurTime){
			var ani=this._anis[aniIndex];
			var nodes=ani.nodes;
			if (aniIndex!==this.unfixedLastAniIndex){
				this.unfixedCurrentFrameIndexes=new Uint32Array(nodes.length);
				this.unfixedCurrentTimes=new Float32Array(nodes.length);
				this.unfixedLastAniIndex=aniIndex;
			}
			for (var i=0,n=nodes.length,outOfs=0;i < n;i++){
				var node=nodes[i];
				if (playCurTime < this.unfixedCurrentTimes[i])
					this.unfixedCurrentFrameIndexes[i]=0;
				this.unfixedCurrentTimes[i]=playCurTime;
				while ((this.unfixedCurrentFrameIndexes[i] < node.keyFrame.length)){
					if (node.keyFrame[this.unfixedCurrentFrameIndexes[i]].startTime > this.unfixedCurrentTimes[i])
						break ;
					this.unfixedCurrentFrameIndexes[i]++;
				}
				this.unfixedCurrentFrameIndexes[i]--;
			}
			return this.unfixedCurrentFrameIndexes;
		}

		__proto.getOriginalDataUnfixedRate=function(aniIndex,originalData,playCurTime){
			var oneAni=this._anis[aniIndex];
			var nodes=oneAni.nodes;
			if (aniIndex!==this.unfixedLastAniIndex){
				this.unfixedCurrentFrameIndexes=new Uint32Array(nodes.length);
				this.unfixedCurrentTimes=new Float32Array(nodes.length);
				this.unfixedKeyframes=__newvec(nodes.length);
				this.unfixedLastAniIndex=aniIndex;
			};
			var j=0;
			for (var i=0,n=nodes.length,outOfs=0;i < n;i++){
				var node=nodes[i];
				if (playCurTime < this.unfixedCurrentTimes[i])
					this.unfixedCurrentFrameIndexes[i]=0;
				this.unfixedCurrentTimes[i]=playCurTime;
				while (this.unfixedCurrentFrameIndexes[i] < node.keyFrame.length){
					if (node.keyFrame[this.unfixedCurrentFrameIndexes[i]].startTime > this.unfixedCurrentTimes[i])
						break ;
					this.unfixedKeyframes[i]=node.keyFrame[this.unfixedCurrentFrameIndexes[i]];
					this.unfixedCurrentFrameIndexes[i]++;
				};
				var key=this.unfixedKeyframes[i];
				node.dataOffset=outOfs;
				var dt=playCurTime-key.startTime;
				var lerpType=node.lerpType;
				if (lerpType){
					switch (node.lerpType){
						case 0:
						case 1:
							for (j=0;j < node.keyframeWidth;)
							j+=node.interpolationMethod[j](node,j,originalData,outOfs+j,key.data,dt,key.dData,key.duration,key.nextData);
							break ;
						case 2:;
							var interpolationData=key.interpolationData;
							var interDataLen=interpolationData.length;
							var dataIndex=0;
							for (j=0;j < interDataLen;){
								var type=interpolationData[j];
							switch (type){
								case 6:
									j+=AnimationTemplet.interpolation[type](node,dataIndex,originalData,outOfs+dataIndex,key.data,dt,key.dData,key.duration,key.nextData,interpolationData,j+1);
									break ;
								case 7:
									j+=AnimationTemplet.interpolation[type](node,dataIndex,originalData,outOfs+dataIndex,key.data,dt,key.dData,key.duration,key.nextData,interpolationData,j+1);
									break ;
								default :
									j+=AnimationTemplet.interpolation[type](node,dataIndex,originalData,outOfs+dataIndex,key.data,dt,key.dData,key.duration,key.nextData);
								}
							dataIndex++;
						}
						break ;
					}
					}else {
					for (j=0;j < node.keyframeWidth;)
					j+=node.interpolationMethod[j](node,j,originalData,outOfs+j,key.data,dt,key.dData,key.duration,key.nextData);
				}
				outOfs+=node.keyframeWidth;
			}
		}

		AnimationTemplet._LinearInterpolation_0=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData){
			out[outOfs]=data[index]+dt *dData[index];
			return 1;
		}

		AnimationTemplet._QuaternionInterpolation_1=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData){
			var amount=duration===0 ? 0 :dt / duration;
			MathUtil.slerpQuaternionArray(data,index,nextData,index,amount,out,outOfs);
			return 4;
		}

		AnimationTemplet._AngleInterpolation_2=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData){
			return 0;
		}

		AnimationTemplet._RadiansInterpolation_3=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData){
			return 0;
		}

		AnimationTemplet._Matrix4x4Interpolation_4=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData){
			for (var i=0;i < 16;i++,index++)
			out[outOfs+i]=data[index]+dt *dData[index];
			return 16;
		}

		AnimationTemplet._NoInterpolation_5=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData){
			out[outOfs]=data[index];
			return 1;
		}

		AnimationTemplet._BezierInterpolation_6=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData,offset){
			(offset===void 0)&& (offset=0);
			out[outOfs]=data[index]+(nextData[index]-data[index])*BezierLerp.getBezierRate(dt / duration,interData[offset],interData[offset+1],interData[offset+2],interData[offset+3]);
			return 5;
		}

		AnimationTemplet._BezierInterpolation_7=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData,offset){
			(offset===void 0)&& (offset=0);
			out[outOfs]=interData[offset+4]+interData[offset+5] *BezierLerp.getBezierRate((dt *0.001+interData[offset+6])/ interData[offset+7],interData[offset],interData[offset+1],interData[offset+2],interData[offset+3]);
			return 9;
		}

		AnimationTemplet.load=function(url){
			return Laya.loader.create(url,null,null,AnimationTemplet);
		}

		AnimationTemplet.interpolation=[AnimationTemplet._LinearInterpolation_0,AnimationTemplet._QuaternionInterpolation_1,AnimationTemplet._AngleInterpolation_2,AnimationTemplet._RadiansInterpolation_3,AnimationTemplet._Matrix4x4Interpolation_4,AnimationTemplet._NoInterpolation_5,AnimationTemplet._BezierInterpolation_6,AnimationTemplet._BezierInterpolation_7];
		return AnimationTemplet;
	})(Resource)


	/**
	*@private
	*web audio api方式播放声音的音轨控制
	*/
	//class laya.media.webaudio.WebAudioSoundChannel extends laya.media.SoundChannel
	var WebAudioSoundChannel=(function(_super){
		function WebAudioSoundChannel(){
			this.audioBuffer=null;
			this.gain=null;
			this.bufferSource=null;
			this._currentTime=0;
			this._volume=1;
			this._startTime=0;
			this._pauseTime=0;
			this._onPlayEnd=null;
			WebAudioSoundChannel.__super.call(this);
			this.context=WebAudioSound.ctx;
			this._onPlayEnd=Utils.bind(this.__onPlayEnd,this);
			if (this.context["createGain"]){
				this.gain=this.context["createGain"]();
				}else {
				this.gain=this.context["createGainNode"]();
			}
		}

		__class(WebAudioSoundChannel,'laya.media.webaudio.WebAudioSoundChannel',_super);
		var __proto=WebAudioSoundChannel.prototype;
		/**
		*播放声音
		*/
		__proto.play=function(){
			SoundManager.addChannel(this);
			this.isStopped=false;
			this._clearBufferSource();
			if (!this.audioBuffer)return;
			var context=this.context;
			var gain=this.gain;
			var bufferSource=context.createBufferSource();
			this.bufferSource=bufferSource;
			bufferSource.buffer=this.audioBuffer;
			bufferSource.connect(gain);
			if (gain)gain.disconnect();
			gain.connect(context.destination);
			bufferSource.onended=this._onPlayEnd;
			if (this.startTime >=this.duration)this.startTime=0;
			this._startTime=Browser.now();
			this.gain.gain.value=this._volume;
			if (this.loops==0){
				bufferSource.loop=true;
			}
			bufferSource.playbackRate.value=SoundManager.playbackRate;
			bufferSource.start(0,this.startTime);
			this._currentTime=0;
		}

		__proto.__onPlayEnd=function(){
			if (this.loops===1){
				if (this.completeHandler){
					Laya.timer.once(10,this,this.__runComplete,[this.completeHandler],false);
					this.completeHandler=null;
				}
				this.stop();
				this.event("complete");
				return;
			}
			if (this.loops > 0){
				this.loops--;
			}
			this.play();
		}

		__proto._clearBufferSource=function(){
			if (this.bufferSource){
				var sourceNode=this.bufferSource;
				if (sourceNode.stop){
					sourceNode.stop(0);
					}else {
					sourceNode.noteOff(0);
				}
				sourceNode.disconnect(0);
				sourceNode.onended=null;
				if (!WebAudioSoundChannel._tryCleanFailed)this._tryClearBuffer(sourceNode);
				this.bufferSource=null;
			}
		}

		__proto._tryClearBuffer=function(sourceNode){
			if (!Browser.onIOS){
				WebAudioSoundChannel._tryCleanFailed=true;
				return;
			}
			try {
				sourceNode.buffer=WebAudioSound._miniBuffer;
				}catch (e){
				WebAudioSoundChannel._tryCleanFailed=true;
			}
		}

		/**
		*停止播放
		*/
		__proto.stop=function(){
			this._clearBufferSource();
			this.audioBuffer=null;
			if (this.gain)this.gain.disconnect();
			this.isStopped=true;
			SoundManager.removeChannel(this);
			this.completeHandler=null;
		}

		__proto.pause=function(){
			if (!this.isStopped){
				this._pauseTime=this.position;
			}
			this._clearBufferSource();
			if (this.gain)this.gain.disconnect();
			this.isStopped=true;
			SoundManager.removeChannel(this);
		}

		__proto.resume=function(){
			this.startTime=this._pauseTime;
			this.play();
		}

		/**
		*获取当前播放位置
		*/
		__getset(0,__proto,'position',function(){
			if (this.bufferSource){
				return (Browser.now()-this._startTime)/ 1000+this.startTime;
			}
			return 0;
		});

		__getset(0,__proto,'duration',function(){
			if (this.audioBuffer){
				return this.audioBuffer.duration;
			}
			return 0;
		});

		/**
		*设置音量
		*/
		/**
		*获取音量
		*/
		__getset(0,__proto,'volume',function(){
			return this._volume;
			},function(v){
			if (this.isStopped)return;
			this._volume=v;
			this.gain.gain.value=v;
		});

		WebAudioSoundChannel._tryCleanFailed=false;
		return WebAudioSoundChannel;
	})(SoundChannel)


	//class laya.webgl.resource.CharPageTexture extends laya.resource.Resource
	var CharPageTexture=(function(_super){
		function CharPageTexture(mgr){
			this.texture=null;
			this._source=null;
			this._used=null;
			this._startFindPos=0;
			this._mgr=null;
			this.charMap={};
			this._score=0;
			this._scoreTick=0;
			CharPageTexture.__super.call(this);
			this._mgr=mgr;
			this.texture=new CharInternalTexture(this);
			this._used=new Uint8Array(mgr._gridNum);
		}

		__class(CharPageTexture,'laya.webgl.resource.CharPageTexture',_super);
		var __proto=CharPageTexture.prototype;
		/**
		*找一个空余的格子。只操作格子相关变量
		*@return
		*/
		__proto.findAGrid=function(){
			var gridNum=this._mgr._gridNum;
			for (var i=this._startFindPos;i < gridNum;i++){
				if (this._used[i]==0){
					this._startFindPos=i+1;
					this._used[i]=1;
					return i;
				}
			}
			return null;
		}

		__proto.removeGrid=function(pos){
			this._used[pos]=0;
			if (pos < this._startFindPos)
				this._startFindPos=pos;
		}

		/**
		*把tm之前使用的都去掉。
		*@param tm
		*@return
		*/
		__proto.removeOld=function(tm){
			var num=0;
			for (var m in this.charMap){
				var ci=this.charMap[m];
				if (ci.touchTick < tm){
					this.removeGrid(ci.pos);
					console.log('remove char '+m);
					delete this.charMap[m];
					num++;
				}
			}
			return num;
		}

		//以后再考虑换成每个bit表示
		__proto.recreateResource=function(){
			if (this._source)
				return;
			var gl=WebGL.mainContext;
			var glTex=this._source=gl.createTexture();
			gl.bindTexture(0x0DE1,glTex);
			gl.texImage2D(0x0DE1,0,0x1908,this._mgr._textureWidth,this._mgr._textureWidth,0,0x1908,0x1401,null);
			gl.texParameteri(0x0DE1,0x2801,0x2601);
			gl.texParameteri(0x0DE1,0x2800,0x2601);
			gl.texParameteri(0x0DE1,0x2802,0x812F);
			gl.texParameteri(0x0DE1,0x2803,0x812F);
		}

		/**
		*
		*@param data
		*@param x 拷贝位置。
		*@param y
		*/
		__proto.addChar=function(data,x,y){
			!this._source && this.recreateResource();
			var gl=WebGL.mainContext;
			gl.bindTexture(0x0DE1,this._source);
			gl.pixelStorei(0x9241,true);
			gl.texSubImage2D(0x0DE1,0,x,y,0x1908,0x1401,data);
			gl.pixelStorei(0x9241,false);
		}

		__proto.destroy=function(){
			console.log('destroy CharPageTexture');
			var gl=WebGL.mainContext;
			this._source && gl.deleteTexture(this._source);
		}

		return CharPageTexture;
	})(Resource)


	/**
	*...
	*@author ...
	*/
	//class laya.webgl.shader.BaseShader extends laya.resource.Resource
	var BaseShader=(function(_super){
		//��ǰ�󶨵�shader
		function BaseShader(){
			BaseShader.__super.call(this);
		}

		__class(BaseShader,'laya.webgl.shader.BaseShader',_super);
		BaseShader.activeShader=null
		BaseShader.bindShader=null
		return BaseShader;
	})(Resource)


	//class laya.webgl.utils.Buffer extends laya.resource.Resource
	var Buffer=(function(_super){
		function Buffer(){
			this._glBuffer=null;
			this._buffer=null;
			this._bufferType=0;
			this._bufferUsage=0;
			this._byteLength=0;
			Buffer.__super.call(this);
			this._glBuffer=LayaGL.instance.createBuffer()
		}

		__class(Buffer,'laya.webgl.utils.Buffer',_super);
		var __proto=Buffer.prototype;
		/**
		*给vao使用的bind。不再判断是否与前一个相同。因为vao是局部的，必须要重设。
		*/
		__proto._bindForVAO=function(){
			switch (this._bufferType){
				case 0x8892:
					LayaGL.instance.bindBuffer(0x8892,this._glBuffer);
					break ;
				case 0x8893:
					LayaGL.instance.bindBuffer(0x8893,this._glBuffer);
					break ;
				default :
					console.error('error! unknown buffer type:'+this._bufferType);
				}
		}

		__proto.bind=function(){
			switch (this._bufferType){
				case 0x8892:
					if (Buffer._bindedVertexBuffer!==this._glBuffer){
						LayaGL.instance.bindBuffer(0x8892,this._glBuffer);
						Buffer._bindedVertexBuffer=this._glBuffer;
						return true;
					}
					break ;
				case 0x8893:
					if (Buffer._bindedIndexBuffer!==this._glBuffer){
						LayaGL.instance.bindBuffer(0x8893,this._glBuffer);
						Buffer._bindedIndexBuffer=this._glBuffer;
						return true;
					}
					break ;
				default :
					console.error('error! unknown buffer type:'+this._bufferType);
				}
			return false;
		}

		__proto.disposeResource=function(){
			if (this._glBuffer){
				LayaGL.instance.deleteBuffer(this._glBuffer);
				this._glBuffer=null;
			}
			this.memorySize=0;
		}

		__getset(0,__proto,'bufferUsage',function(){
			return this._bufferUsage;
		});

		Buffer._bindedVertexBuffer=null
		Buffer._bindedIndexBuffer=null
		__static(Buffer,
		['_bindedAtributeBuffer',function(){return this._bindedAtributeBuffer=new Array(16);},'_bindedAttributeDeclaration',function(){return this._bindedAttributeDeclaration=new Array(16);}
		]);
		return Buffer;
	})(Resource)


	/**
	*<code>KeyframeAnimation</code> 类用于帧动画组件的父类。
	*/
	//class laya.d3.component.animation.KeyframeAnimations extends laya.d3.component.Component3D
	var KeyframeAnimations=(function(_super){
		function KeyframeAnimations(){
			this._player=null;
			this._templet=null;
			KeyframeAnimations.__super.call(this);
			this._player=new AnimationPlayer();
		}

		__class(KeyframeAnimations,'laya.d3.component.animation.KeyframeAnimations',_super);
		var __proto=KeyframeAnimations.prototype;
		/**
		*@inheritDoc
		*/
		__proto._initialize=function(owner){
			_super.prototype._initialize.call(this,owner);
		}

		__proto._uninitialize=function(){
			this._player._destroy();
			this._player=null;
			this._templet=null;
			_super.prototype._uninitialize.call(this);
		}

		/**
		*设置url地址。
		*@param value 地址。
		*/
		__getset(0,__proto,'url',null,function(value){
			console.log("Warning: discard property,please use templet property instead.");
			var templet=Laya.loader.create(value,null,null,AnimationTemplet);
			if (this._templet!==templet){
				if (this._player.state!==0)
					this._player.stop(true);
				this._templet=templet;
				this._player.templet=templet;
				this.event("animationchanged",this);
			}
		});

		/**
		*获取动画播放器。
		*@return 动画播放器。
		*/
		__getset(0,__proto,'player',function(){
			return this._player;
		});

		/**
		*设置动画模板。
		*@param value 设置动画模板。
		*/
		/**
		*获取动画模板。
		*@return value 动画模板。
		*/
		__getset(0,__proto,'templet',function(){
			return this._templet;
			},function(value){
			if (this._templet!==value){
				if (this._player.state!==0)
					this._player.stop(true);
				this._templet=value;
				this._player.templet=value;
				this.event("animationchanged",this);
			}
		});

		/**
		*获取播放器帧数。
		*@return 播放器帧数。
		*/
		__getset(0,__proto,'currentFrameIndex',function(){
			return this._player.currentKeyframeIndex;
		});

		/**
		*获取播放器的动画索引。
		*@return 动画索引。
		*/
		__getset(0,__proto,'currentAnimationClipIndex',function(){
			return this._player.currentAnimationClipIndex;
		});

		/**
		*获取播放器当前动画的节点数量。
		*@return 节点数量。
		*/
		__getset(0,__proto,'nodeCount',function(){
			return this._templet.getNodeCount(this._player.currentAnimationClipIndex);
		});

		return KeyframeAnimations;
	})(Component3D)


	/**
	*<code>Animations</code> 类用于创建动画组件。
	*/
	//class laya.d3.component.Animator extends laya.d3.component.Component3D
	var Animator=(function(_super){
		function Animator(){
			//this._updateTransformPropertyLoopCount=0;
			//this._cacheFrameRateInterval=NaN;
			//this._cacheFrameRate=0;
			//this._cachePlayRate=NaN;
			//this._currentPlayClip=null;
			//this._currentPlayClipIndex=0;
			//this._stoped=false;
			//this._currentTime=NaN;
			//this._currentFrameTime=NaN;
			//this._currentFrameIndex=0;
			//this._elapsedPlaybackTime=NaN;
			//this._startUpdateLoopCount=NaN;
			//this._clipNames=null;
			//this._clips=null;
			//this._playStartFrames=null;
			//this._playEndFrames=null;
			//this._playEventIndex=0;
			//this._defaultClipIndex=0;
			//this._avatar=null;
			//this._cacheNodesDefaultlValues=null;
			//this._cacheNodesSpriteOwners=null;
			//this._cacheNodesAvatarOwners=null;
			//this._lastPlayAnimationClip=null;
			//this._lastPlayAnimationClipIndex=0;
			//this._publicClipsDatas=null;
			//this._publicAvatarNodeDatas=null;
			//this._curAvatarNodeDatas=null;
			//this._curAvatarNodeDatasBuffer=null;
			//this._cacheNodesToSpriteMap=null;
			//this._cacheSpriteToNodesMap=null;
			//this._cacheFullFrames=null;
			//this._avatarNodeMap=null;
			//this._avatarNodes=null;
			//this._canCache=false;
			//this._lastFrameIndex=0;
			//this.isCache=false;
			//this.playbackRate=NaN;
			//this.playOnWake=false;
			Animator.__super.call(this);
			this._clipNames=[];
			this._clips=[];
			this._playStartFrames=[];
			this._playEndFrames=[];
			this._cacheNodesSpriteOwners=[];
			this._cacheNodesAvatarOwners=[];
			this._cacheNodesDefaultlValues=[];
			this._cacheNodesToSpriteMap=[];
			this._cacheSpriteToNodesMap=[];
			this._cacheFullFrames=[];
			this._publicClipsDatas=[];
			this._playEventIndex=-1;
			this._updateTransformPropertyLoopCount=-1;
			this._lastFrameIndex=-1;
			this._defaultClipIndex=-1;
			this._cachePlayRate=1.0;
			this._currentPlayClip=null;
			this._currentFrameIndex=-1;
			this._currentTime=0.0;
			this._elapsedPlaybackTime=0;
			this._startUpdateLoopCount=-1;
			this.isCache=true;
			this._canCache=true;
			this.cacheFrameRate=60;
			this.playbackRate=1.0;
			this.playOnWake=true;
		}

		__class(Animator,'laya.d3.component.Animator',_super);
		var __proto=Animator.prototype;
		Laya.imps(__proto,{"laya.resource.IDestroy":true})
		/**
		*@private
		*/
		__proto._onRootNodeHierarchyLoaded=function(animator,linkSprites){
			for (var k in linkSprites){
				var nodeOwner=this._owner;
				var path=linkSprites[k];
				for (var j=0,m=path.length;j < m;j++){
					var p=path[j];
					if (p===""){
						break ;
						}else {
						nodeOwner=nodeOwner.getChildByName(p);
						if (!nodeOwner)
							break ;
					}
				}
				(nodeOwner)&& (animator.linkSprite3DToAvatarNode(k,nodeOwner));
			}
		}

		/**
		*@private
		*/
		__proto._getAvatarOwnersByClip=function(clipIndex){
			var frameNodes=this._clips[clipIndex]._nodes;
			var frameNodesCount=frameNodes.length;
			var owners=this._cacheNodesAvatarOwners[clipIndex];
			owners.length=frameNodesCount;
			var defaultValues=this._cacheNodesDefaultlValues[clipIndex];
			defaultValues.length=frameNodesCount;
			for (var i=0;i < frameNodesCount;i++){
				var nodeOwner=this._avatarNodes[0];
				var node=frameNodes[i];
				var path=node.path;
				for (var j=0,m=path.length;j < m;j++){
					var p=path[j];
					if (p===""){
						break ;
						}else {
						nodeOwner=nodeOwner.getChildByName(p);
						if (!nodeOwner)
							break ;
					}
				}
				if (!nodeOwner)
					continue ;
				owners[i]=nodeOwner;
				var datas=AnimationNode._propertyGetFuncs[node.propertyNameID](nodeOwner);
				if (datas){
					var cacheDatas=new Float32Array(node.keyFrameWidth);
					defaultValues[i]=cacheDatas;
					for (j=0,m=datas.length;j < m;j++)
					cacheDatas[j]=datas[j];
				}
			}
		}

		/**
		*@private
		*/
		__proto._handleSpriteOwnersByClip=function(clipIndex){
			var frameNodes=this._clips[clipIndex]._nodes;
			var frameNodesCount=frameNodes.length;
			var owners=this._cacheNodesSpriteOwners[clipIndex];
			owners.length=frameNodesCount;
			var defaultValues=this._cacheNodesDefaultlValues[clipIndex];
			defaultValues.length=frameNodesCount;
			for (var i=0;i < frameNodesCount;i++){
				var nodeOwner=this._owner;
				var node=frameNodes[i];
				var path=node.path;
				var j=0,m=0;
				for (j=0,m=path.length;j < m;j++){
					var p=path[j];
					if (p===""){
						break ;
						}else {
						nodeOwner=nodeOwner.getChildByName(p);
						if (!nodeOwner)
							break ;
					}
				}
				if (nodeOwner){
					owners[i]=nodeOwner;
					var datas=AnimationNode._propertyGetFuncs[node.propertyNameID](null,nodeOwner);
					if (datas){
						var cacheDatas=new Float32Array(node.keyFrameWidth);
						defaultValues[i]=cacheDatas;
						for (j=0,m=datas.length;j < m;j++)
						cacheDatas[j]=datas[j];
					}
				}
			}
		}

		/**
		*@private
		*/
		__proto._offClipAndAvatarRelateEvent=function(avatar,clip){
			if (avatar.loaded){
				if (!clip.loaded)
					clip.off("loaded",this,this._getAvatarOwnersByClip);
				}else {
				avatar.off("loaded",this,this._getAvatarOwnersAndInitDatasAsync);
			}
		}

		/**
		*@private
		*/
		__proto._getAvatarOwnersByClipAsync=function(clipIndex,clip){
			if (clip.loaded)
				this._getAvatarOwnersByClip(clipIndex);
			else
			clip.once("loaded",this,this._getAvatarOwnersByClip,[clipIndex]);
		}

		/**
		*@private
		*/
		__proto._offGetSpriteOwnersByClipAsyncEvent=function(clip){
			if (!clip.loaded)
				clip.off("loaded",this,this._getSpriteOwnersByClipAsync);
		}

		/**
		*@private
		*/
		__proto._getSpriteOwnersByClipAsync=function(clipIndex,clip){
			if (clip.loaded)
				this._handleSpriteOwnersByClip(clipIndex);
			else
			clip.once("loaded",this,this._handleSpriteOwnersByClip,[clipIndex]);
		}

		/**
		*@private
		*/
		__proto._getAvatarOwnersAndInitDatasAsync=function(){
			for (var i=0,n=this._clips.length;i < n;i++)
			this._getAvatarOwnersByClipAsync(i,this._clips[i]);
			this._avatar._cloneDatasToAnimator(this);
			for (i=0,n=this._avatarNodes.length;i < n;i++)
			this._checkAnimationNode(this._avatarNodes[i],this._owner);
		}

		/**
		*@private
		*/
		__proto._offGetClipCacheFullKeyframeIndicesEvent=function(clip){
			(clip.loaded)|| (clip.off("loaded",this,this._computeCacheFullKeyframeIndices));
		}

		/**
		*@private
		*/
		__proto._computeCacheFullKeyframeIndices=function(clipIndex){
			var clip=this._clips[clipIndex];
			var cacheInterval=this._cacheFrameRateInterval *this._cachePlayRate;
			var clipCacheFullFrames=clip._getFullKeyframeIndicesWithCache(cacheInterval);
			if (clipCacheFullFrames){
				this._cacheFullFrames[clipIndex]=clipCacheFullFrames;
				return;
				}else {
				clipCacheFullFrames=this._cacheFullFrames[clipIndex]=[];
				var nodes=clip._nodes;
				var nodeCount=nodes.length;
				clipCacheFullFrames.length=nodeCount;
				var frameCount=Math.ceil(clip._duration / cacheInterval-0.00001)+1;
				for (var i=0;i < nodeCount;i++){
					var node=nodes[i];
					var nodeFullFrames=new Int32Array(frameCount);
					(nodeFullFrames).fill(-1);
					var keyFrames=node.keyFrames;
					for (var j=0,n=keyFrames.length;j < n;j++){
						var keyFrame=keyFrames[j];
						var startTime=keyFrame.startTime;
						var endTime=startTime+keyFrame.duration;
						while (startTime <=endTime){
							var frameIndex=Math.ceil(startTime / cacheInterval-0.00001);
							nodeFullFrames[frameIndex]=j;
							startTime+=cacheInterval;
						}
					}
					clipCacheFullFrames[i]=nodeFullFrames;
				}
				clip._cacheFullKeyframeIndices(cacheInterval,clipCacheFullFrames);
			}
		}

		/**
		*@private
		*/
		__proto._eventScript=function(from,to){
			var events=this._currentPlayClip._events;
			for (var n=events.length;this._playEventIndex < n;this._playEventIndex++){
				var eve=events[this._playEventIndex];
				var eventTime=eve.time;
				if (from <=eventTime && eventTime < to){
					var scripts=this._owner._scripts;
					for (var j=0,m=scripts.length;j < m;j++){
						var script=scripts[j];
						var fun=script[eve.eventName];
						(fun)&& (fun.apply(script,eve.params));
					}
					}else {
					break ;
				}
			}
		}

		/**
		*@private
		*/
		__proto._setPlayParams=function(time,cacheFrameInterval){
			var lastTime=this._currentTime;
			this._currentTime=time;
			this._currentFrameIndex=Math.max(Math.floor(this.currentPlayTime / cacheFrameInterval-0.00001),0);
			this._currentFrameTime=this._currentFrameIndex *cacheFrameInterval;
			this._eventScript(lastTime,time);
		}

		/**
		*@private
		*/
		__proto._setPlayParamsWhenStop=function(aniClipPlayDuration,cacheFrameInterval){
			var lastTime=this._currentTime;
			this._currentTime=aniClipPlayDuration;
			this._currentFrameIndex=Math.max(Math.floor(aniClipPlayDuration / cacheFrameInterval-0.00001),0);
			this._currentFrameTime=this._currentFrameIndex *cacheFrameInterval;
			this._eventScript(lastTime,aniClipPlayDuration);
			this._currentPlayClip=null;
		}

		/**
		*@private
		*/
		__proto._revertKeyframeNodes=function(clip,clipIndex){
			if (this._avatar){
				var originalValues=this._cacheNodesDefaultlValues[clipIndex];
				var frameNodes=clip._nodes;
				var nodeOwners=this._cacheNodesAvatarOwners[clipIndex];
				for (var i=0,n=nodeOwners.length;i < n;i++){
					var owner=nodeOwners[i];
					(owner)&& (AnimationNode._propertySetFuncs[frameNodes[i].propertyNameID](owner,null,originalValues[i]));
				}
			}else {}
		}

		/**
		*@private
		*/
		__proto._onAnimationStop=function(){
			var i=0,n=0;
			var frameNode,keyFrames,endKeyframeData;
			this._lastFrameIndex=-1;
			var frameNodes=this._currentPlayClip._nodes;
			if (this._avatar){
				var avatarOwners=this._cacheNodesAvatarOwners[this._currentPlayClipIndex];
				for (i=0,n=avatarOwners.length;i < n;i++){
					var nodeOwner=avatarOwners[i];
					frameNode=frameNodes[i];
					keyFrames=frameNode.keyFrames;
					endKeyframeData=keyFrames[keyFrames.length-1].data;
					(nodeOwner)&& (AnimationNode._propertySetFuncs[frameNode.propertyNameID](nodeOwner,null,endKeyframeData));
				}
				}else {
				var spriteOwners=this._cacheNodesSpriteOwners[this._currentPlayClipIndex];
				for (i=0,n=spriteOwners.length;i < n;i++){
					var spriteOwner=spriteOwners[i];
					frameNode=frameNodes[i];
					keyFrames=frameNode.keyFrames;
					endKeyframeData=keyFrames[keyFrames.length-1].data;
					(spriteOwner)&& (AnimationNode._propertySetFuncs[frameNode.propertyNameID](null,spriteOwner,endKeyframeData));
				}
			}
		}

		/**
		*@private
		*/
		__proto._setAnimationClipPropertyToAnimationNode=function(nodeOwners,propertyMap,clipDatas){
			for (var i=0,n=propertyMap.length;i < n;i++){
				var nodexIndex=propertyMap[i];
				var owner=nodeOwners[nodexIndex];
				if (owner){
					var ketframeNode=this._currentPlayClip._nodes[nodexIndex];
					var datas=clipDatas[nodexIndex];
					(datas)&& (AnimationNode._propertySetFuncs[ketframeNode.propertyNameID](owner,null,datas));
				}
			}
		}

		/**
		*@private
		*/
		__proto._setAnimationClipPropertyToSprite3D=function(nodeOwners,curClipAnimationDatas){
			for (var i=0,n=nodeOwners.length;i < n;i++){
				var owner=nodeOwners[i];
				if (owner){
					var ketframeNode=this._currentPlayClip._nodes[i];
					var datas=curClipAnimationDatas[i];
					(datas)&& (AnimationNode._propertySetFuncs[ketframeNode.propertyNameID](null,owner,datas));
				}
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._onActive=function(){
			Animator._componentPool.add(this);
			(this.playOnWake && this.clip)&& (this.play());
		}

		/**
		*@inheritDoc
		*/
		__proto._onInActive=function(){
			Animator._componentPool.remove(this);
			(this.playState!==0)&& (this._stoped=true);
		}

		/**
		*@private
		*/
		__proto._handleSpriteOwnersBySprite=function(clipIndex,isLink,path,sprite){
			var clip=this._clips[clipIndex];
			var nodePath=path.join("/");
			var ownersNodes=clip._nodesMap[nodePath];
			if (ownersNodes){
				var owners=this._cacheNodesSpriteOwners[clipIndex];
				var nodes=clip._nodes;
				var defaultValues=this._cacheNodesDefaultlValues[clipIndex];
				for (var i=0,n=ownersNodes.length;i < n;i++){
					var node=ownersNodes[i];
					var index=nodes.indexOf(node);
					if (isLink){
						owners[index]=sprite;
						var datas=AnimationNode._propertyGetFuncs[node.propertyNameID](null,sprite);
						if (datas){
							var cacheDatas=defaultValues[index];
							(cacheDatas)|| (defaultValues[index]=cacheDatas=new Float32Array(node.keyFrameWidth));
							for (var j=0,m=datas.length;j < m;j++)
							cacheDatas[j]=datas[j];
						}
						}else {
						owners[index]=null;
					}
				}
			}
		}

		/**
		*@private
		*/
		__proto._evaluateAvatarNodesCacheMode=function(avatarOwners,clip,publicClipDatas,avatarNodeDatas,unCacheMap){
			clip._evaluateAnimationlDatasCacheMode(avatarOwners,this._cacheFullFrames[this._currentPlayClipIndex],this,publicClipDatas,unCacheMap);
			this._setAnimationClipPropertyToAnimationNode(avatarOwners,unCacheMap,publicClipDatas);
			for (var i=0,n=this._avatarNodes.length;i < n;i++){
				var node=this._avatarNodes[i];
				var nodeTransform=node.transform;
				if (nodeTransform._worldUpdate){
					var nodeMatrix=new Float32Array(this._curAvatarNodeDatasBuffer,i *16 *4,16);
					avatarNodeDatas[i]=nodeMatrix;
					nodeTransform._setWorldMatrixAndUpdate(nodeMatrix);
					}else {
					avatarNodeDatas[i]=Animator.deafaultMatrix;
				}
			}
		}

		/**
		*@private
		*/
		__proto._evaluateAvatarNodesRealTime=function(avatarOwners,clip,publicClipDatas,avatarNodeDatas,unCacheMap){
			clip._evaluateAnimationlDatasRealTime(avatarOwners,this.currentPlayTime,publicClipDatas,unCacheMap);
			this._setAnimationClipPropertyToAnimationNode(avatarOwners,unCacheMap,publicClipDatas);
			for (var i=0,n=this._avatarNodes.length;i < n;i++){
				var transform=this._avatarNodes[i].transform;
				if (transform._worldUpdate)
					transform._setWorldMatrixNoUpdate(avatarNodeDatas[i]);
				else
				avatarNodeDatas[i]=Animator.deafaultMatrix;
			}
		}

		/**
		*@private
		*/
		__proto._updateAvatarNodesToSpriteCacheMode=function(clip,avatarNodeDatas){
			for (var i=0,n=this._cacheSpriteToNodesMap.length;i < n;i++){
				var nodeIndex=this._cacheSpriteToNodesMap[i];
				var nodeMatrix=avatarNodeDatas[nodeIndex];
				if (nodeMatrix!==Animator.deafaultMatrix){
					var spriteTransform=this._avatarNodes[nodeIndex].transform._entity;
					var spriteWorldMatrix=spriteTransform.worldMatrix;
					Utils3D.matrix4x4MultiplyMFM((this._owner)._transform.worldMatrix,nodeMatrix,spriteWorldMatrix);
					spriteTransform.worldMatrix=spriteWorldMatrix;
				}
			}
		}

		/**
		*@private
		*/
		__proto._updateAvatarNodesToSpriteRealTime=function(){
			for (var i=0,n=this._cacheSpriteToNodesMap.length;i < n;i++){
				var node=this._avatarNodes[this._cacheSpriteToNodesMap[i]];
				var spriteTransform=node.transform._entity;
				var nodeTransform=node.transform;
				if (nodeTransform._worldUpdate){
					var nodeMatrix=Animator._tempMatrix4x40;
					nodeTransform._setWorldMatrixAndUpdate(nodeMatrix);
					var spriteWorldMatrix=spriteTransform.worldMatrix;
					Utils3D.matrix4x4MultiplyMFM((this._owner)._transform.worldMatrix,nodeMatrix,spriteWorldMatrix);
					spriteTransform.worldMatrix=spriteWorldMatrix;
				}
			}
		}

		/**
		*@private
		*/
		__proto._updatePlayer=function(elapsedTime){
			if (this._currentPlayClip==null || this._stoped || !this._currentPlayClip.loaded)
				return;
			var cacheFrameInterval=this._cacheFrameRateInterval *this._cachePlayRate;
			var time=0;
			(this._startUpdateLoopCount!==Stat.loopCount)&& (time=elapsedTime *this.playbackRate,this._elapsedPlaybackTime+=time);
			var frameRate=this._currentPlayClip._frameRate;
			var playStart=this._playStartFrames[this._currentPlayClipIndex] / frameRate;
			var playEnd=Math.min(this._playEndFrames[this._currentPlayClipIndex] / frameRate,this._currentPlayClip._duration);
			var aniClipPlayDuration=playEnd-playStart;
			if ((!this._currentPlayClip.islooping && this._elapsedPlaybackTime >=aniClipPlayDuration)){
				this._onAnimationStop();
				this._setPlayParamsWhenStop(aniClipPlayDuration,cacheFrameInterval);
				return;
			}
			time+=this._currentTime;
			if (aniClipPlayDuration > 0){
				if (time >=aniClipPlayDuration){
					do {
						time-=aniClipPlayDuration;
						if (time < aniClipPlayDuration){
							this._setPlayParams(time,cacheFrameInterval);
						}
						this._playEventIndex=0;
						this._eventScript(0,time);
					}while (time >=aniClipPlayDuration)
					}else {
					this._setPlayParams(time,cacheFrameInterval);
				}
				}else {
				this._currentTime=this._currentFrameTime=this._currentFrameIndex=this._playEventIndex=0;
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._parse=function(rootNode,innerResouMap,data){
			var avatarData=data.avatar;
			if (avatarData){
				this.avatar=Loader.getRes(innerResouMap[avatarData.path]);
				var linkSprites=avatarData.linkSprites;
				(linkSprites)&& (rootNode.once("hierarchyloaded",this,this._onRootNodeHierarchyLoaded,[this,linkSprites]));
			};
			var clipPaths=data.clipPaths;
			var clipCount=clipPaths.length;
			for (var i=0;i < clipCount;i++)
			this.addClip(Loader.getRes(innerResouMap[clipPaths[i]]));
			this.clip=Loader.getRes(innerResouMap[clipPaths[0]]);
			var play=data.playOnWake;
			(play!==undefined)&& (this.playOnWake=play);
		}

		/**
		*@private
		*更新蒙皮动画组件。
		*@param state 渲染状态参数。
		*/
		__proto._update=function(){
			this._updatePlayer(Laya.timer.delta / 1000.0);
			var clip=this._currentPlayClip;
			if (this.playState!==2 || !clip || !clip.loaded)
				return;
			var rate=this.playbackRate *Laya.timer.scale;
			var cacheRate=this._cachePlayRate;
			this._canCache=this.isCache && rate >=cacheRate;
			var frameIndex=-1;
			var clipDatas;
			if (this._canCache){
				frameIndex=this._currentFrameIndex;
				if (this._lastFrameIndex===frameIndex)
					return;
				clipDatas=clip._getAnimationDataWithCache(cacheRate,frameIndex);
				if (this._avatar){
					var avatarOwners=this._cacheNodesAvatarOwners[this._currentPlayClipIndex];
					var cacheMap=clip._cachePropertyMap;
					var cacheMapCount=cacheMap.length;
					if (cacheMapCount > 0){
						if (!clipDatas){
							clipDatas=[];
							clipDatas.length=cacheMapCount;
							clip._cacheAnimationData(cacheRate,frameIndex,clipDatas);
							clip._evaluateAnimationlDatasCacheMode(avatarOwners,this._cacheFullFrames[this._currentPlayClipIndex],this,clipDatas,cacheMap);
						}
						this._setAnimationClipPropertyToAnimationNode(avatarOwners,cacheMap,clipDatas);
					}
					this._curAvatarNodeDatas=clip._getAvatarDataWithCache(this._avatar,this._cachePlayRate,frameIndex);
					this._curAvatarNodeDatasBuffer=clip._getAvatarDataWithCacheBuffer(this._avatar,this._cachePlayRate,frameIndex);
					if (!this._curAvatarNodeDatas){
						this._curAvatarNodeDatas=[];
						this._curAvatarNodeDatas.length=this._avatarNodes.length;
						this._curAvatarNodeDatasBuffer=new ArrayBuffer(this._avatarNodes.length *16 *4);
						clip._cacheAvatarData(this._avatar,this._cachePlayRate,frameIndex,this._curAvatarNodeDatas);
						clip._cacheAvatarDataBuffer(this._avatar,this._cachePlayRate,frameIndex,this._curAvatarNodeDatasBuffer);
						this._evaluateAvatarNodesCacheMode(avatarOwners,clip,clip._publicClipDatas,this._curAvatarNodeDatas,clip._unCachePropertyMap);
					}
					this._updateAvatarNodesToSpriteCacheMode(clip,this._curAvatarNodeDatas);
					}else {
					var spriteOwners=this._cacheNodesSpriteOwners[this._currentPlayClipIndex];
					if (!clipDatas){
						clipDatas=[];
						clipDatas.length=this._currentPlayClip._nodes.length;
						clip._evaluateAnimationlDatasCacheMode(spriteOwners,this._cacheFullFrames[this._currentPlayClipIndex],this,clipDatas,null);
						clip._cacheAnimationData(cacheRate,frameIndex,clipDatas);
					}
					this._setAnimationClipPropertyToSprite3D(spriteOwners,clipDatas);
				}
				}else {
				clipDatas=clip._publicClipDatas;
				if (this._avatar){
					clip._evaluateAnimationlDatasRealTime(this._cacheNodesAvatarOwners[this._currentPlayClipIndex],this.currentPlayTime,clipDatas,clip._cachePropertyMap);
					if (!this._publicAvatarNodeDatas){
						this._publicAvatarNodeDatas=[];
						var count=this._avatarNodes.length;
						this._publicAvatarNodeDatas.length=count;
						for (var i=1;i < count;i++)
						this._publicAvatarNodeDatas[i]=new Float32Array(16);
					}
					this._curAvatarNodeDatas=this._publicAvatarNodeDatas;
					this._evaluateAvatarNodesRealTime(this._cacheNodesAvatarOwners[this._currentPlayClipIndex],clip,clipDatas,this._curAvatarNodeDatas,clip._unCachePropertyMap);
					this._updateAvatarNodesToSpriteRealTime();
					}else {
					clip._evaluateAnimationlDatasRealTime(this._cacheNodesSpriteOwners[this._currentPlayClipIndex],this.currentPlayTime,clipDatas,null);
				}
			}
			this._lastFrameIndex=frameIndex;
		}

		/**
		*@private
		*/
		__proto._checkAnimationNode=function(node,sprite){
			if (node.name===sprite.name && !sprite._transform.dummy)
				sprite._isLinkSpriteToAnimationNode(this,node,true);
			for (var i=0,n=sprite._children.length;i < n;i++)
			this._checkAnimationNode(node,sprite.getChildAt(i));
		}

		/**
		*@inheritDoc
		*/
		__proto._initialize=function(owner){
			var parent=owner._parent;
			owner._setHierarchyAnimator(this,parent ? (parent)._hierarchyAnimator :null);
			owner._setAnimatorToLinkSprite3DNoAvatar(this,true,[]);
			_super.prototype._initialize.call(this,owner);
		}

		/**
		*@inheritDoc
		*/
		__proto._uninitialize=function(){
			var parent=this._owner._parent;
			this._owner._clearHierarchyAnimator(this,parent ? (parent)._hierarchyAnimator :null);
			this._curAvatarNodeDatas=null;
			_super.prototype._uninitialize.call(this);
		}

		/**
		*@private
		*/
		__proto.destroy=function(){
			_super.prototype.destroy();
			for (var i=0,n=this._clips.length;i < n;i++)
			this._clips[i]._removeReference();
			this._currentPlayClip=null;
			this._clipNames=null;
			this._cacheNodesSpriteOwners=null;
			this._cacheNodesAvatarOwners=null;
			this._cacheNodesDefaultlValues=null;
			this._clips=null;
			this._cacheFullFrames=null;
		}

		/**
		*@private
		*/
		__proto._cloneTo=function(dest){
			var animator=dest;
			animator.avatar=this.avatar;
			var clipCount=this._clips.length;
			for (var i=0,n=this._clips.length;i < n;i++)
			animator.addClip(this._clips[i]);
			if (this.clip){
				animator.clip=this.clip;
			}
		}

		/**
		*添加动画片段。
		*@param clip 动画片段。
		*@param playName 动画片段播放名称，如果为null,则使用clip.name作为播放名称。
		*@param 开始帧率。
		*@param 结束帧率。
		*/
		__proto.addClip=function(clip,playName,startFrame,endFrame){
			(startFrame===void 0)&& (startFrame=0);
			(endFrame===void 0)&& (endFrame=4294967295);
			playName=playName || clip.name;
			var index=this._clipNames.indexOf(playName);
			if (index!==-1){
				if (this._clips[index]!==clip)
					throw new Error("Animation:this playName has exist with another clip.");
				}else {
				var clipIndex=this._clips.indexOf(clip);
				if (startFrame < 0 || endFrame < 0)
					throw new Error("Animator:startFrame and endFrame must large than zero.");
				if (startFrame > endFrame)
					throw new Error("Animator:startFrame must less than endFrame.");
				this._clipNames.push(playName);
				this._clips.push(clip);
				this._playStartFrames.push(startFrame);
				this._playEndFrames.push(endFrame);
				this._cacheNodesSpriteOwners.push([]);
				this._cacheNodesAvatarOwners.push([]);
				this._cacheNodesDefaultlValues.push([]);
				this._publicClipsDatas.push([]);
				clip._addReference();
				clipIndex=this._clips.length-1;
				if (this._avatar){
					if (this._avatar.loaded)
						this._getAvatarOwnersByClipAsync(clipIndex,clip);
					else
					this._avatar.once("loaded",this,this._getAvatarOwnersByClipAsync,[clipIndex,clip]);
					}else {
					this._getSpriteOwnersByClipAsync(clipIndex,clip);
				}
				if (clip.loaded)
					this._computeCacheFullKeyframeIndices(clipIndex);
				else
				clip.once("loaded",this,this._computeCacheFullKeyframeIndices,[clipIndex]);
			}
		}

		/**
		*移除动画片段。
		*@param clip 动画片段。
		*/
		__proto.removeClip=function(clip){
			var index=this._clips.indexOf(clip);
			if (index!==-1){
				if (this._avatar)
					this._offClipAndAvatarRelateEvent(this._avatar,clip)
				else
				this._offGetSpriteOwnersByClipAsyncEvent(clip);
				this._offGetClipCacheFullKeyframeIndicesEvent(clip);
				this._clipNames.splice(index,1);
				this._clips.splice(index,1);
				this._playStartFrames.splice(index,1);
				this._playEndFrames.splice(index,1);
				this._cacheNodesSpriteOwners.splice(index,1);
				this._cacheNodesAvatarOwners.splice(index,1);
				this._cacheNodesDefaultlValues.splice(index,1);
				this._publicClipsDatas.splice(index,1);
				clip._removeReference();
			}
		}

		/**
		*通过播放名字移除动画片段。
		*@param playName 播放名字。
		*/
		__proto.removeClipByName=function(playName){
			var index=this._clipNames.indexOf(playName);
			if (index!==-1){
				var clip=this._clips[index];
				if (this._avatar)
					this._offClipAndAvatarRelateEvent(this._avatar,clip);
				else
				this._offGetSpriteOwnersByClipAsyncEvent(clip);
				this._offGetClipCacheFullKeyframeIndicesEvent(clip);
				this._clipNames.splice(index,1);
				this._clips.splice(index,1);
				this._playStartFrames.splice(index,1);
				this._playEndFrames.splice(index,1);
				this._cacheNodesSpriteOwners.splice(index,1);
				this._cacheNodesAvatarOwners.splice(index,1);
				this._cacheNodesDefaultlValues.splice(index,1);
				this._publicClipsDatas.splice(index,1);
			}
		}

		/**
		*通过播放名字获取动画片段。
		*@param playName 播放名字。
		*@return 动画片段。
		*/
		__proto.getClip=function(playName){
			var index=this._clipNames.indexOf(playName);
			if (index!==-1){
				return this._clips[index];
				}else {
				return null;
			}
		}

		/**
		*获取动画片段个数。
		*@return 动画个数。
		*/
		__proto.getClipCount=function(){
			return this._clips.length;
		}

		/**
		*播放动画。
		*@param name 如果为null则播放默认动画，否则按名字播放动画片段。
		*@param playbackRate 播放速率。
		*@param startFrame 开始帧率。
		*@param endFrame 结束帧率.-1表示为最大结束帧率。
		*/
		__proto.play=function(name,playbackRate){
			(playbackRate===void 0)&& (playbackRate=1.0);
			if (!name && this._defaultClipIndex==-1)
				throw new Error("Animator:must have  default clip value,please set clip property.");
			if (name){
				this._currentPlayClipIndex=this._clipNames.indexOf(name);
				this._currentPlayClip=this._clips[this._currentPlayClipIndex];
				}else {
				this._currentPlayClipIndex=this._defaultClipIndex;
				this._currentPlayClip=this._clips[this._defaultClipIndex];
			}
			this._currentTime=0;
			this._currentFrameTime=0;
			this._elapsedPlaybackTime=0;
			this._playEventIndex=0;
			this.playbackRate=playbackRate;
			this._stoped=false;
			this._currentFrameIndex=0;
			this._startUpdateLoopCount=Stat.loopCount;
			if (this._lastPlayAnimationClip){
				(this._lastPlayAnimationClip!==this._currentPlayClip)&& (this._revertKeyframeNodes(this._lastPlayAnimationClip,this._lastPlayAnimationClipIndex));
			}
			this._updatePlayer(0);
			this._lastPlayAnimationClip=this._currentPlayClip;
			this._lastPlayAnimationClipIndex=this._currentPlayClipIndex;
		}

		/**
		*停止播放当前动画
		*/
		__proto.stop=function(){
			if (this.playState!==0)
				this._stoped=true;
		}

		/**
		*关联精灵节点到Avatar节点,此Animator必须有Avatar文件。
		*@param nodeName 关联节点的名字。
		*@param sprite3D 精灵节点。
		*@return 是否关联成功。
		*/
		__proto.linkSprite3DToAvatarNode=function(nodeName,sprite3D){
			if (this._avatar){
				var node=this._avatarNodeMap[nodeName];
				if (node){
					sprite3D._isLinkSpriteToAnimationNode(this,node,true);
					return true;
					}else {
					return false;
				}
				}else {
				return false;
			}
		}

		/**
		*解除精灵节点到Avatar节点的关联,此Animator必须有Avatar文件。
		*@param sprite3D 精灵节点。
		*@return 是否解除关联成功。
		*/
		__proto.unLinkSprite3DToAvatarNode=function(sprite3D){
			if (this._avatar){
				var dummy=sprite3D.transform.dummy;
				if (dummy){
					var node=this._avatarNodeMap[dummy._owner.name];
					sprite3D._isLinkSpriteToAnimationNode(this,node,false);
					return true;
					}else {
					return false;
				}
				}else {
				return false;
			}
		}

		/**
		*获取当前播放状态
		*@return 当前播放状态
		*/
		__getset(0,__proto,'playState',function(){
			if (this._currentPlayClip==null)
				return 0;
			if (this._stoped)
				return 0;
			return 2;
		});

		/**
		*设置avatar。
		*@param value avatar。
		*/
		/**
		*获取avatar。
		*@return avator。
		*/
		__getset(0,__proto,'avatar',function(){
			return this._avatar;
			},function(value){
			if (this._avatar!==value){
				var lastAvatar=this._avatar;
				this._avatar=value;
				var clipLength=this._clips.length;
				for (var i=0;i < clipLength;i++)
				this._offClipAndAvatarRelateEvent(lastAvatar,this._clips[i]);
				if (value){
					if (value.loaded)
						this._getAvatarOwnersAndInitDatasAsync();
					else
					value.once("loaded",this,this._getAvatarOwnersAndInitDatasAsync);
				}
			}
		});

		/**
		*设置缓存播放帧率，缓存模式下生效。注意：修改此值会有计算开销。*
		*@return value 缓存播放帧率
		*/
		/**
		*获取缓存播放帧，缓存模式下生效。
		*@return value 缓存播放帧率。
		*/
		__getset(0,__proto,'cacheFrameRate',function(){
			return this._cacheFrameRate;
			},function(value){
			if (this._cacheFrameRate!==value){
				this._cacheFrameRate=value;
				this._cacheFrameRateInterval=1.0 / this._cacheFrameRate;
				for (var i=0,n=this._clips.length;i < n;i++)
				(this._clips[i].loaded)&& (this._computeCacheFullKeyframeIndices(i));
			}
		});

		/**
		*设置默认动画片段,AnimationClip名称为默认playName。
		*@param value 默认动画片段。
		*/
		/**
		*获取默认动画片段。
		*@return 默认动画片段。
		*/
		__getset(0,__proto,'clip',function(){
			return this._clips[this._defaultClipIndex];
			},function(value){
			var index=value ? this._clips.indexOf(value):-1;
			if (this._defaultClipIndex!==index){
				(this._defaultClipIndex!==-1)&& (this.removeClip(this._clips[this._defaultClipIndex]));
				(index!==-1)&& (this.addClip(value,value.name));
				this._defaultClipIndex=index;
			}
		});

		/**
		*获取当前帧数
		*@return 当前帧数
		*/
		__getset(0,__proto,'currentFrameIndex',function(){
			return this._currentFrameIndex;
		});

		/**
		*设置缓存播放速率，缓存模式下生效。注意：修改此值会有计算开销。*
		*@return value 缓存播放速率。
		*/
		/**
		*获取缓存播放速率，缓存模式下生效。*
		*@return 缓存播放速率。
		*/
		__getset(0,__proto,'cachePlayRate',function(){
			return this._cachePlayRate;
			},function(value){
			if (this._cachePlayRate!==value){
				this._cachePlayRate=value;
				for (var i=0,n=this._clips.length;i < n;i++)
				(this._clips[i].loaded)&& (this._computeCacheFullKeyframeIndices(i));
			}
		});

		/**
		*获取当前帧时间，不包括重播时间
		*@return value 当前时间
		*/
		__getset(0,__proto,'currentFrameTime',function(){
			return this._currentFrameTime;
		});

		/**
		*获取当前动画索引
		*@return value 当前动画索引
		*/
		__getset(0,__proto,'currentPlayClip',function(){
			return this._currentPlayClip;
		});

		/**
		*获取当前精确时间，不包括重播时间
		*@return value 当前时间
		*/
		__getset(0,__proto,'currentPlayTime',function(){
			return this._currentTime+(this._playStartFrames[this._currentPlayClipIndex] / this._currentPlayClip._frameRate);
		});

		/**
		*设置当前播放位置
		*@param value 当前时间
		*/
		__getset(0,__proto,'playbackTime',null,function(value){
			if (this._currentPlayClip==null || !this._currentPlayClip || !this._currentPlayClip.loaded)
				return;
			this._startUpdateLoopCount=Stat.loopCount;
			var cacheFrameInterval=this._cacheFrameRateInterval *this._cachePlayRate;
			this._currentTime=value;
			this._currentFrameIndex=Math.floor(this.currentPlayTime / cacheFrameInterval);
			this._currentFrameTime=this._currentFrameIndex *cacheFrameInterval;
		});

		Animator._update=function(){
			var elements=Animator._componentPool.elements;
			for (var i=0;i < elements.length;i++){
				var animator=elements[i];
				(animator && animator.enable)&& (animator._update());
			}
			Animator._componentPool.clear();
		}

		__static(Animator,
		['deafaultMatrix',function(){return this.deafaultMatrix=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);},'_tempMatrix4x40',function(){return this._tempMatrix4x40=new Float32Array(16);},'_componentPool',function(){return this._componentPool=new ComponentPool();}
		]);
		return Animator;
	})(Component3D)


	/**
	*<code>Collider</code> 类用于创建碰撞器的父类，抽象类，不允许实例。
	*/
	//class laya.d3.component.physics.Collider extends laya.d3.component.Component3D
	var Collider=(function(_super){
		function Collider(){
			//this._needUpdate=false;
			//this._isRigidbody=false;
			//this._runtimeCollisonMap=null;
			//this._runtimeCollisonTestMap=null;
			//this._ignoreCollisonMap=null;
			//this.isTrigger=false;
			this.physicsObjectId=0;
			Collider.__super.call(this);
			this._isRigidbody=false;
			this._runtimeCollisonMap={};
			this._runtimeCollisonTestMap={};
			this._ignoreCollisonMap={};
			this.isTrigger=true;
		}

		__class(Collider,'laya.d3.component.physics.Collider',_super);
		var __proto=Collider.prototype;
		/**
		*@inheritDoc
		*/
		__proto._initialize=function(owner){
			_super.prototype._initialize.call(this,owner);
			var spriteOwner=this._owner;
			var rigidbody=spriteOwner.getComponentByType(Rigidbody);
			(rigidbody)&& (this._isRigidbody=true);
			(spriteOwner.displayedInStage)&& (spriteOwner.layer._addCollider(this));
			spriteOwner._colliders.push(this);
		}

		/**
		*@inheritDoc
		*/
		__proto._uninitialize=function(){
			_super.prototype._uninitialize.call(this);
			var spriteOwner=this._owner;
			(spriteOwner.displayedInStage)&& (spriteOwner.layer._removeCollider(this));
			var colliders=(spriteOwner)._colliders;
			colliders.splice(colliders.indexOf(this),1);
			for (var k in this._runtimeCollisonMap){
				var otherCollider=this._runtimeCollisonMap[k];
				delete otherCollider._runtimeCollisonMap[this.id];
				if (otherCollider._isRigidbody)
					delete otherCollider._runtimeCollisonTestMap[this.id];
				delete this._ignoreCollisonMap[k]._ignoreCollisonMap[this.id];
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._onActive=function(){
			(this._owner).layer._addCollider(this);
			this.addPhysicsObject();
		}

		/**
		*@inheritDoc
		*/
		__proto._onInActive=function(){
			this._clearCollsionMap();
			(this._owner).layer._removeCollider(this);
			this.removePhySicsObject();
		}

		/**
		*@private
		*/
		__proto._clearCollsionMap=function(){
			for (var k in this._runtimeCollisonMap){
				var otherCollider=this._runtimeCollisonMap[k];
				delete otherCollider._runtimeCollisonMap[this.id];
				if (otherCollider._isRigidbody)
					delete otherCollider._runtimeCollisonTestMap[this.id];
				var otherID=otherCollider.id;
				delete this._runtimeCollisonMap[otherID];
				if (this._isRigidbody)
					delete this._runtimeCollisonTestMap[otherID];
			}
		}

		/**
		*@private
		*/
		__proto._setIsRigidbody=function(value){
			if (this._isRigidbody!==value){
				this._isRigidbody=value;
				var owner=this._owner;
				if (owner.displayedInStage){
					var layer=owner.layer;
					layer._removeCollider(this);
					layer._addCollider(this);
				}
			}
		}

		/**
		*@private
		*/
		__proto._getType=function(){
			return-1;
		}

		/**
		*@private
		*/
		__proto._collisonTo=function(other){
			return false;
		}

		/**
		*在场景中投下可与球体碰撞器碰撞的一条光线,获取发生碰撞的球体碰撞器信息。
		*@param ray 射线
		*@param outHitInfo 与该射线发生碰撞球体碰撞器的碰撞信息
		*@param distance 射线长度,默认为最大值
		*/
		__proto.raycast=function(ray,hitInfo,maxDistance){
			(maxDistance===void 0)&& (maxDistance=1.79e+308);
			throw new Error("Collider:Must override it.");
		}

		__proto.addPhysicsObject=function(){
			var physicsObject=new Object();
			var owner=this._owner;
			Collider._physicsObjects.push(owner);
			if (this._isRigidbody){
				var rigidBody=owner.getComponentByType(Rigidbody);
				if (rigidBody.isKinematic){
					physicsObject.mass=0;
				}
				else{
					physicsObject.mass=rigidBody.mass;
				}
			}
			else{
				physicsObject.mass=0;
			}
			this.physicsObjectId=Collider._physicsObjectIndex++;
			physicsObject.id=this.physicsObjectId;
			owner.physicsObjectId=this.physicsObjectId;
			var transform=owner.transform;
			var position=transform.position;
			var rotation=transform.rotation;
			var scale=transform.scale;
			physicsObject.dirtyPosition=false;
			physicsObject.dirtyRotation=false;
			physicsObject.position={x:-position.x,y:position.y,z:position.z};
			physicsObject.rotation={x:-rotation.x,y:rotation.y,z:rotation.z,w:-rotation.w};
			if (this instanceof BoxCollider){
				var boundBox=(owner).meshFilter.sharedMesh.boundingBox;
				var max=boundBox.max;
				var min=boundBox.min;
				var width=max.x-min.x;
				var height=max.y-min.y;
				var depth=max.z-min.z;
				physicsObject.width=width *scale.x;
				physicsObject.height=height *scale.y;
				physicsObject.depth=depth *scale.z;
				physicsObject.type="box";
				}else if (this instanceof SphereCollider){
				physicsObject.type="sphere";
				}else {
				throw Error("This type is not supported for a while!")
			}
			physicsObject.friction=0.4;
			physicsObject.restitution=0.4;
			(this._owner).scene.physicsWorker.execute("addObject",physicsObject);
			return physicsObject;
		}

		__proto.removePhySicsObject=function(){
			delete Collider._physicsObjects[this.physicsObjectId];
			(this._owner).scene.physicsWorker.execute("removeObject",{id:this.physicsObjectId});
		}

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'enable',_super.prototype._$get_enable,function(value){
			if (this._enable!==value){
				var owner=this._owner;
				if (owner.displayedInStage)
					(value)|| (this._clearCollsionMap());
				this._enable=value;
				this.event("enablechanged",this._enable);
			}
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'isSingleton',function(){
			return Collider._isSingleton;
		});

		Collider._isSingleton=false;
		Collider._physicsObjects=[];
		Collider._physicsObjectIndex=0;
		return Collider;
	})(Component3D)


	/**
	*<code>Rigidbody</code> 类用于创建动画组件。
	*/
	//class laya.d3.component.Rigidbody extends laya.d3.component.Component3D
	var Rigidbody=(function(_super){
		function Rigidbody(){
			this._mass=NaN;
			this._isKinematic=false;
			Rigidbody.__super.call(this);
			this._mass=0;
		}

		__class(Rigidbody,'laya.d3.component.Rigidbody',_super);
		var __proto=Rigidbody.prototype;
		/**
		*@inheritDoc
		*/
		__proto._onActive=function(){}
		__proto._onInActive=function(){}
		/**
		*@inheritDoc
		*/
		__proto._parse=function(rootNode,innerResouMap,data){
			this._mass=data.mass;
			this._isKinematic=data.isKinematic;
		}

		/**
		*@inheritDoc
		*/
		__proto._initialize=function(owner){
			_super.prototype._initialize.call(this,owner);
			var colliders=(this._owner)._colliders;
			for (var i=0,n=colliders.length;i < n;i++)
			colliders[i]._setIsRigidbody(true);
		}

		/**
		*@inheritDoc
		*/
		__proto._uninitialize=function(){
			_super.prototype._uninitialize.call(this);
			var colliders=(this._owner)._colliders;
			for (var i=0,n=colliders.length;i < n;i++){
				var collider=colliders[i];
				collider._setIsRigidbody(false);
				var runtimeCollisonMap=collider._runtimeCollisonMap;
				var runtimeCollisonTestMap=collider._runtimeCollisonTestMap;
				for (var k in runtimeCollisonMap)
				delete runtimeCollisonTestMap[k];
			}
		}

		/**
		*设置质量。
		*@param value 质量。
		*/
		/**
		*获取质量。
		*@return 质量。
		*/
		__getset(0,__proto,'mass',function(){
			return this._mass;
			},function(value){
			this._mass=Math.max(0.0,value);
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'enable',_super.prototype._$get_enable,function(value){
			if (this._enable!==value){
				var colliders=(this._owner)._colliders;
				for (var i=0,n=colliders.length;i < n;i++){
					var collider=colliders[i];
					collider._setIsRigidbody(value);
					var runtimeCollisonMap=collider._runtimeCollisonMap;
					var runtimeCollisonTestMap=collider._runtimeCollisonTestMap;
					if (!value){
						for (var k in runtimeCollisonMap)
						delete runtimeCollisonTestMap[k];
					}
				}
				this._enable=value;
				this.event("enablechanged",this._enable);
			}
		});

		/**
		*设置是否受物理世界影响
		*@param value 是否受物理世界影响
		*/
		/**
		*获取是否受物理世界影响
		*@return 是否受物理世界影响
		*/
		__getset(0,__proto,'isKinematic',function(){
			return this._isKinematic;
			},function(value){
			this._isKinematic=value
		});

		return Rigidbody;
	})(Component3D)


	/**
	*<code>AnimationClip</code> 类用于动画片段资源。
	*/
	//class laya.d3.animation.AnimationClip extends laya.resource.Resource
	var AnimationClip=(function(_super){
		function AnimationClip(){
			this._realTimeCurrentFrameIndexes=null;
			this._realTimeCurrentTimes=null;
			this._fullKeyframeIndicesCache=null;
			this._animationDatasCache=null;
			this._avatarDatasCache=null;
			this._avatarDatasCacheBuffer=null;
			this._skinnedDatasCache=null;
			this._version=null;
			this._nodes=null;
			this._nodesMap=null;
			this._cachePropertyMap=null;
			this._nodeToCachePropertyMap=null;
			this._unCachePropertyMap=null;
			this._duration=NaN;
			this._frameRate=0;
			this._events=null;
			this._publicClipDatas=null;
			this.islooping=false;
			AnimationClip.__super.call(this);
			this._fullKeyframeIndicesCache={};
			this._animationDatasCache=[];
			this._avatarDatasCache=[];
			this._avatarDatasCacheBuffer=[];
			this._skinnedDatasCache=[];
			this._events=[];
		}

		__class(AnimationClip,'laya.d3.animation.AnimationClip',_super);
		var __proto=AnimationClip.prototype;
		/**
		*获取动画片段时长。
		*/
		__proto.duration=function(){
			return this._duration;
		}

		/**
		*@private
		*/
		__proto._hermiteInterpolate=function(frame,t,dur,out){
			var p0=frame.data;
			var tan0=frame.outTangent;
			var nextFrame=frame.next;
			var p1=nextFrame.data;
			var tan1=nextFrame.inTangent;
			var isComputeParams=false;
			var a=NaN,b=NaN,c=NaN,d=NaN;
			for (var i=0,n=out.length;i < n;i++){
				var t0=tan0[i],t1=tan1[i];
				if (Number.isFinite(t0)&& Number.isFinite(t1)){
					if (!isComputeParams){
						var t2=t *t;
						var t3=t2 *t;
						a=2.0 *t3-3.0 *t2+1.0;
						b=t3-2.0 *t2+t;
						c=t3-t2;
						d=-2.0 *t3+3.0 *t2;
						isComputeParams=true;
					}
					out[i]=a *p0[i]+b *t0 *dur+c *t1 *dur+d *p1[i];
				}else
				out[i]=p0[i];
			}
		}

		/**
		*@private
		*/
		__proto._getFullKeyframeIndicesWithCache=function(cacheInterval){
			return this._fullKeyframeIndicesCache[cacheInterval];
		}

		/**
		*@private
		*/
		__proto._cacheFullKeyframeIndices=function(cacheInterval,datas){
			this._fullKeyframeIndicesCache[cacheInterval]=datas;
		}

		/**
		*@private
		*/
		__proto._getAnimationDataWithCache=function(cacheRate,frameIndex){
			var cacheDatas=this._animationDatasCache[cacheRate];
			if (!cacheDatas)
				return null;
			else {
				return cacheDatas[frameIndex];
			}
		}

		/**
		*@private
		*/
		__proto._cacheAnimationData=function(cacheRate,frameIndex,datas){
			var aniDatasCache=(this._animationDatasCache[cacheRate])|| (this._animationDatasCache[cacheRate]=[]);
			aniDatasCache[frameIndex]=datas;
		}

		/**
		*@private
		*/
		__proto._getAvatarDataWithCache=function(avatar,cacheRate,frameIndex){
			var clipCache=this._avatarDatasCache[avatar.id];
			if (!clipCache){
				return null;
				}else {
				var rateCache=clipCache[cacheRate];
				if (!rateCache)
					return null;
				else {
					return rateCache[frameIndex];
				}
			}
		}

		/**
		*@private
		*/
		__proto._cacheAvatarData=function(avatar,cacheRate,frameIndex,datas){
			var clipCache=(this._avatarDatasCache[avatar.id])|| (this._avatarDatasCache[avatar.id]=[]);
			var rateCache=(clipCache[cacheRate])|| (clipCache[cacheRate]=[]);
			rateCache[frameIndex]=datas;
		}

		/**
		*@private
		*/
		__proto._getAvatarDataWithCacheBuffer=function(avatar,cacheRate,frameIndex){
			var clipCache=this._avatarDatasCacheBuffer[avatar.id];
			if (!clipCache){
				return null;
				}else {
				var rateCache=clipCache[cacheRate];
				if (!rateCache)
					return null;
				else {
					return rateCache[frameIndex];
				}
			}
		}

		/**
		*@private
		*/
		__proto._cacheAvatarDataBuffer=function(avatar,cacheRate,frameIndex,datas){
			var clipCache=(this._avatarDatasCacheBuffer[avatar.id])|| (this._avatarDatasCacheBuffer[avatar.id]=[]);
			var rateCache=(clipCache[cacheRate])|| (clipCache[cacheRate]=[]);
			rateCache[frameIndex]=datas;
		}

		/**
		*@private
		*/
		__proto._evaluateAnimationlDatasCacheMode=function(nodeOwners,nodesFrameIndices,animator,clipDatas,propertyMap){
			var j=0,m=0;
			for (var i=0,n=propertyMap ? propertyMap.length :this._nodes.length;i < n;i++){
				var nodeIndex=propertyMap ? propertyMap[i] :i;
				var node=this._nodes[nodeIndex];
				var cacheProperty=node._cacheProperty;
				if (!nodeOwners[nodeIndex])
					continue ;
				var frameIndices=nodesFrameIndices[nodeIndex];
				var realFrameIndex=frameIndices[animator.currentFrameIndex];
				var outDatas;
				var lastFrameIndex=0;
				if (realFrameIndex!==-1){
					var frame=node.keyFrames[realFrameIndex];
					var nextKeyFrame=frame.next;
					if (nextKeyFrame){
						if (propertyMap && !cacheProperty){
							outDatas=clipDatas[nodeIndex];
							(outDatas)|| (outDatas=clipDatas[nodeIndex]=new Float32Array(node.keyFrameWidth));
							}else {
							outDatas=new Float32Array(node.keyFrameWidth);
							clipDatas[i]=outDatas;
						};
						var t=NaN;
						var d=frame.duration;
						if (d!==0)
							t=(animator.currentFrameTime-frame.startTime)/ d;
						else
						t=0;
						this._hermiteInterpolate(frame,t,d,outDatas);
						}else {
						if (propertyMap && !cacheProperty){
							outDatas=clipDatas[nodeIndex];
							(outDatas)|| (outDatas=clipDatas[nodeIndex]=new Float32Array(node.keyFrameWidth));
							}else {
							lastFrameIndex=animator._lastFrameIndex;
							if (lastFrameIndex!==-1 && frameIndices[lastFrameIndex]===realFrameIndex)
								continue ;
							outDatas=new Float32Array(node.keyFrameWidth);
							clipDatas[i]=outDatas;
						};
						var frameData=frame.data;
						for (j=0,m=outDatas.length;j < m;j++)
						outDatas[j]=frameData[j];
					}
					}else {
					if (propertyMap && !cacheProperty){
						outDatas=clipDatas[nodeIndex];
						(outDatas)|| (outDatas=clipDatas[nodeIndex]=new Float32Array(node.keyFrameWidth));
						}else {
						lastFrameIndex=animator._lastFrameIndex;
						if (lastFrameIndex!==-1 && frameIndices[lastFrameIndex]===realFrameIndex)
							continue ;
						outDatas=new Float32Array(node.keyFrameWidth);
						clipDatas[i]=outDatas;
					};
					var firstFrameDatas=node.keyFrames[0].data;
					for (j=0,m=outDatas.length;j < m;j++)
					outDatas[j]=firstFrameDatas[j];
				}
			}
		}

		/**
		*@private
		*/
		__proto._evaluateAnimationlDatasRealTime=function(nodeOwners,playCurTime,outAnimationDatas,propertyMap){
			var i=0,n=0;
			var nodes=this._nodes;
			if (!this._realTimeCurrentFrameIndexes){
				this._realTimeCurrentFrameIndexes=new Int32Array(nodes.length);
				for (i=0,n=nodes.length;i < n;i++)
				this._realTimeCurrentFrameIndexes[i]=-1;
				this._realTimeCurrentTimes=new Float32Array(nodes.length);
			}
			for (i=0,n=propertyMap ? propertyMap.length :this._nodes.length;i < n;i++){
				var index=propertyMap ? propertyMap[i] :i;
				var node=nodes[index];
				if (playCurTime < this._realTimeCurrentTimes[index])
					this._realTimeCurrentFrameIndexes[index]=-1;
				this._realTimeCurrentTimes[index]=playCurTime;
				var nextFrameIndex=this._realTimeCurrentFrameIndexes[index]+1;
				var keyFrames=node.keyFrames;
				var keyFramesCount=keyFrames.length;
				while (nextFrameIndex < keyFramesCount){
					if (keyFrames[nextFrameIndex].startTime > playCurTime){
						this._realTimeCurrentFrameIndexes[index]=nextFrameIndex-1;
						break ;
					}
					nextFrameIndex++;
				}
				(nextFrameIndex===keyFramesCount)&& (this._realTimeCurrentFrameIndexes[index]=keyFramesCount-1);
				var j=0,m=0;
				var outDatas=outAnimationDatas[index];
				(outDatas)|| (outDatas=outAnimationDatas[index]=new Float32Array(node.keyFrameWidth));
				var frame=keyFrames[this._realTimeCurrentFrameIndexes[index]];
				if (frame){
					var nextFarme=frame.next;
					if (nextFarme){
						var d=frame.duration;
						var t=NaN;
						if (d!==0)
							t=(playCurTime-frame.startTime)/ d;
						else
						t=0;
						this._hermiteInterpolate(frame,t,d,outDatas);
						}else {
						var frameData=frame.data;
						for (j=0,m=outDatas.length;j < m;j++)
						outDatas[j]=frameData[j];
					}
					}else {
					var firstFrameDatas=node.keyFrames[0].data;
					for (j=0,m=outDatas.length;j < m;j++)
					outDatas[j]=firstFrameDatas[j];
				};
				var owner=nodeOwners[index];
				if (owner){
					if (propertyMap)
						AnimationNode._propertySetFuncs[node.propertyNameID](owner,null,outDatas);
					else
					AnimationNode._propertySetFuncs[node.propertyNameID](null,owner,outDatas);
				}
			}
		}

		/**
		*@private
		*/
		__proto._binarySearchEventIndex=function(time){
			var start=0;
			var end=this._events.length-1;
			var mid=0;
			while (start <=end){
				mid=Math.floor((start+end)/ 2);
				var midValue=this._events[mid].time;
				if (midValue==time)
					return mid;
				else if (midValue > time)
				end=mid-1;
				else
				start=mid+1;
			}
			return start;
		}

		/**
		*添加动画事件。
		*/
		__proto.addEvent=function(event){
			var index=this._binarySearchEventIndex(event.time);
			this._events.splice(index,0,event);
		}

		/**
		*@inheritDoc
		*/
		__proto.onAsynLoaded=function(data,params){
			var reader=new Byte(data);
			this._version=reader.readUTFString();
			switch (this._version){
				case "LAYAANIMATION:01":
					AnimationClipParser01.parse(this,reader);
					break ;
				case "LAYAANIMATION:02":
					AnimationClipParser02.parse(this,reader);
					break ;
				}
		}

		/**
		*@inheritDoc
		*/
		__proto.disposeResource=function(){
			this._realTimeCurrentFrameIndexes=null;
			this._realTimeCurrentTimes=null;
			this._fullKeyframeIndicesCache=null;
			this._animationDatasCache=null;
			this._avatarDatasCache=null;
			this._avatarDatasCacheBuffer=null;
			this._skinnedDatasCache=null;
			this._version=null;
			this._nodes=null;
			this._nodesMap=null;
			this._cachePropertyMap=null;
			this._nodeToCachePropertyMap=null;
			this._unCachePropertyMap=null;
			this._publicClipDatas=null;
		}

		AnimationClip.load=function(url){
			return Laya.loader.create(url,null,null,AnimationClip);
		}

		return AnimationClip;
	})(Resource)


	/**
	*<code>Avatar</code> 类用于创建Avatar。
	*/
	//class laya.d3.core.Avatar extends laya.resource.Resource
	var Avatar=(function(_super){
		function Avatar(){
			//this._rootNode=null;
			Avatar.__super.call(this);
		}

		__class(Avatar,'laya.d3.core.Avatar',_super);
		var __proto=Avatar.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*@private
		*/
		__proto._initCloneToAnimator=function(destNode,destAnimator){
			destAnimator._avatarNodeMap[destNode.name]=destNode;
			destAnimator._avatarNodes.push(destNode);
			for (var i=0,n=destNode.getChildCount();i < n;i++)
			this._initCloneToAnimator(destNode.getChildByIndex(i),destAnimator);
		}

		/**
		*@private
		*/
		__proto._parseNode=function(nodaData,node){
			var name=nodaData.props.name;
			node.name=name;
			if (node._parent){
				var customProps=nodaData.customProps;
				var transform=node.transform;
				transform._localRotationEuler=new Float32Array(3);
				transform.setLocalPosition(new Float32Array(customProps.translate));
				transform.setLocalRotation(new Float32Array(customProps.rotation));
				transform.setLocalScale(new Float32Array(customProps.scale));
				transform._setWorldMatrixAndUpdate(new Float32Array(16));
			};
			var childrenData=nodaData.child;
			for (var i=0,n=childrenData.length;i < n;i++){
				var childData=childrenData[i];
				var childBone=new AnimationNode();
				node.addChild(childBone);
				this._parseNode(childData,childBone);
			}
		}

		/**
		*@inheritDoc
		*/
		__proto.onAsynLoaded=function(data,params){
			this._rootNode=new AnimationNode();
			if (data.version){
				var rootNode=data.rootNode;
				(rootNode)&& (this._parseNode(rootNode,this._rootNode));
				}else {
				this._parseNode(data,this._rootNode);
			}
		}

		/**
		*克隆数据到Avatr。
		*@param destObject 克隆源。
		*/
		__proto._cloneDatasToAnimator=function(destAnimator){
			var destRoot=this._rootNode.clone();
			destRoot.transform._setWorldMatrixIgnoreUpdate(null);
			var avatarNodes=[];
			destAnimator._avatarNodeMap={};
			destAnimator._avatarNodes=avatarNodes;
			this._initCloneToAnimator(destRoot,destAnimator);
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destAvatar=destObject;
			var destRoot=this._rootNode.clone();
			destAvatar._rootNode=destRoot;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		Avatar.load=function(url){
			return Laya.loader.create(url,null,null,Avatar);
		}

		return Avatar;
	})(Resource)


	/**
	*@private
	*<code>ComponentNode</code> 类用于实现组件精灵,该类为抽象类。
	*/
	//class laya.d3.core.ComponentNode extends laya.display.Node
	var ComponentNode=(function(_super){
		function ComponentNode(){
			this.__loaded=false;
			this._componentsMap=null;
			this._typeComponentsIndices=null;
			this._components=null;
			this._scripts=null;
			ComponentNode.__super.call(this);
			this.__loaded=true;
			this._componentsMap=[];
			this._typeComponentsIndices=[];
			this._components=[];
			this._scripts=[];
		}

		__class(ComponentNode,'laya.d3.core.ComponentNode',_super);
		var __proto=ComponentNode.prototype;
		/**
		*@private
		*/
		__proto._parseCustomComponent=function(rootNode,innerResouMap,componentsData){}
		/**
		*@private
		*/
		__proto._addChild3D=function(sprite3D){}
		/**
		*@private
		*/
		__proto._removeChild3D=function(sprite3D){}
		/**
		*@private
		*/
		__proto._completeLoad=function(){
			this.__loaded=true;
			this.event("hierarchyloaded",[this]);
		}

		/**
		*@private
		*/
		__proto._removeComponent=function(mapIndex,index){
			var componentIndices=this._typeComponentsIndices[mapIndex];
			var componentIndex=componentIndices[index];
			var component=this._components[componentIndex];
			this._components.splice(componentIndex,1);
			if ((component instanceof laya.d3.component.Script ))
				this._scripts.splice(this._scripts.indexOf(component),1);
			componentIndices.splice(index,1);
			(componentIndices.length===0)&& (this._typeComponentsIndices.splice(mapIndex,1),this._componentsMap.splice(mapIndex,1));
			for (var i=0,n=this._componentsMap.length;i < n;i++){
				componentIndices=this._typeComponentsIndices[i];
				for (var j=componentIndices.length-1;j >=0;j--){
					var oldComponentIndex=componentIndices[j];
					if (oldComponentIndex > componentIndex)
						componentIndices[j]=--oldComponentIndex;
					else
					break ;
				}
			}
			component._uninitialize();
		}

		/**
		*添加指定类型组件。
		*@param type 组件类型。
		*@return 组件。
		*/
		__proto.addComponent=function(type){
			var typeComponentIndex;
			var index=this._componentsMap.indexOf(type);
			if (index===-1){
				typeComponentIndex=[];
				this._componentsMap.push(type);
				this._typeComponentsIndices.push(typeComponentIndex);
				}else {
				typeComponentIndex=this._typeComponentsIndices[index];
				if (this._components[typeComponentIndex[0]].isSingleton)
					throw new Error("无法单实例创建"+type+"组件"+"，"+type+"组件已存在！");
			};
			var component=ClassUtils.getInstance(type);
			typeComponentIndex.push(this._components.length);
			this._components.push(component);
			if ((component instanceof laya.d3.component.Script ))
				this._scripts.push(component);
			component._initialize(this);
			return component;
		}

		/**
		*通过指定类型和类型索引获得组件。
		*@param type 组件类型。
		*@param typeIndex 类型索引。
		*@return 组件。
		*/
		__proto.getComponentByType=function(type,typeIndex){
			(typeIndex===void 0)&& (typeIndex=0);
			var mapIndex=this._componentsMap.indexOf(type);
			if (mapIndex===-1)
				return null;
			return this._components[this._typeComponentsIndices[mapIndex][typeIndex]];
		}

		/**
		*通过指定类型获得所有组件。
		*@param type 组件类型。
		*@param components 组件输出队列。
		*/
		__proto.getComponentsByType=function(type,components){
			var index=this._componentsMap.indexOf(type);
			if (index===-1){
				components.length=0;
				return;
			};
			var typeComponents=this._typeComponentsIndices[index];
			var count=typeComponents.length;
			components.length=count;
			for (var i=0;i < count;i++)
			components[i]=this._components[typeComponents[i]];
		}

		/**
		*通过指定索引获得组件。
		*@param index 索引。
		*@return 组件。
		*/
		__proto.getComponentByIndex=function(index){
			return this._components[index];
		}

		/**
		*通过指定类型和类型索引移除组件。
		*@param type 组件类型。
		*@param typeIndex 类型索引。
		*/
		__proto.removeComponentByType=function(type,typeIndex){
			(typeIndex===void 0)&& (typeIndex=0);
			var mapIndex=this._componentsMap.indexOf(type);
			if (mapIndex===-1)
				return;
			this._removeComponent(mapIndex,typeIndex);
		}

		/**
		*通过指定类型移除所有组件。
		*@param type 组件类型。
		*/
		__proto.removeComponentsByType=function(type){
			var mapIndex=this._componentsMap.indexOf(type);
			if (mapIndex===-1)
				return;
			var componentIndices=this._typeComponentsIndices[mapIndex];
			for (var i=0,n=componentIndices.length;i < n;componentIndices.length < n ? n--:i++)
			this._removeComponent(mapIndex,i);
		}

		/**
		*移除全部组件。
		*/
		__proto.removeAllComponent=function(){
			for (var i=0,n=this._componentsMap.length;i < n;this._componentsMap.length < n ? n--:i++)
			this.removeComponentsByType(this._componentsMap[i]);
		}

		/**
		*@inheritDoc
		*/
		__proto.addChildAt=function(node,index){
			if (!((node instanceof laya.d3.core.Sprite3D )))
				throw new Error("Sprite3D:Node type must Sprite3D.");
			if (!node || this.destroyed || node===this)return node;
			if ((node)._zOrder)this._setBit(0x02,true);
			if (index >=0 && index <=this._children.length){
				if (node._parent===this){
					var oldIndex=this.getChildIndex(node);
					this._children.splice(oldIndex,1);
					this._children.splice(index,0,node);
					this._childChanged();
					}else {
					node._parent && node._parent.removeChild(node);
					this._children===Node.ARRAY_EMPTY && (this._children=[]);
					this._children.splice(index,0,node);
					node._setParent(this);
					this._addChild3D(node);
				}
				return node;
				}else {
				throw new Error("appendChildAt:The index is out of bounds");
			}
		}

		/**
		*@inheritDoc
		*/
		__proto.addChild=function(node){
			if (!((node instanceof laya.d3.core.Sprite3D )))
				throw new Error("Sprite3D:Node type must Sprite3D.");
			if (!node || this.destroyed || node===this)return node;
			if ((node)._zOrder)this._setBit(0x02,true);
			if (node._parent===this){
				var index=this.getChildIndex(node);
				if (index!==this._children.length-1){
					this._children.splice(index,1);
					this._children.push(node);
					this._childChanged();
				}
				}else {
				node._parent && node._parent.removeChild(node);
				this._children===Node.ARRAY_EMPTY && (this._children=[]);
				this._children.push(node);
				node._setParent(this);
				this._childChanged();
				this._addChild3D(node);
			}
			return node;
		}

		/**
		*@inheritDoc
		*/
		__proto.removeChildAt=function(index){
			var node=this.getChildAt(index);
			if (node){
				this._removeChild3D(node);
				this._children.splice(index,1);
				node._setParent(null);
			}
			return node;
		}

		/**
		*@inheritDoc
		*/
		__proto.removeChildren=function(beginIndex,endIndex){
			(beginIndex===void 0)&& (beginIndex=0);
			(endIndex===void 0)&& (endIndex=0x7fffffff);
			if (this._children && this._children.length > 0){
				var childs=this._children;
				if (beginIndex===0 && endIndex >=childs.length-1){
					var arr=childs;
					this._children=Node.ARRAY_EMPTY;
					}else {
					arr=childs.splice(beginIndex,endIndex-beginIndex);
				}
				for (var i=0,n=arr.length;i < n;i++){
					this._removeChild3D(arr [i]);
					arr[i]._setParent(null);
				}
			}
			return this;
		}

		/**
		*获取在场景中是否激活。
		*@return 在场景中是否激活。
		*/
		__getset(0,__proto,'activeInHierarchy',function(){
			throw new Error("must override it.");
		});

		/**
		*@private
		*/
		__getset(0,__proto,'_loaded',null,function(value){
			this.__loaded=value;
		});

		/**
		*获取是否已加载完成。
		*/
		__getset(0,__proto,'loaded',function(){
			return this.__loaded;
		});

		return ComponentNode;
	})(Node)


	/**
	*<code>BaseMesh</code> 类用于创建网格,抽象类,不允许实例。
	*/
	//class laya.d3.resource.models.BaseMesh extends laya.resource.Resource
	var BaseMesh=(function(_super){
		function BaseMesh(){
			this._subMeshCount=0;
			this._boundingBox=null;
			this._boundingSphere=null;
			this._boundingBoxCorners=null;
			this._positions=null;
			BaseMesh.__super.call(this);
			this._boundingBoxCorners=__newvec(8,null);
		}

		__class(BaseMesh,'laya.d3.resource.models.BaseMesh',_super);
		var __proto=BaseMesh.prototype;
		/**
		*获取网格顶点,请重载此方法。
		*@return 网格顶点。
		*/
		__proto._getPositions=function(){
			throw new Error("未Override,请重载该属性！");
		}

		/**
		*@private
		*/
		__proto._generateBoundingObject=function(){
			this._boundingSphere=new BoundSphere(new Vector3(),0);
			BoundSphere.createfromPoints(this._positions,this._boundingSphere);
			this._boundingBox=new BoundBox(new Vector3(),new Vector3());
			BoundBox.createfromPoints(this._positions,this._boundingBox);
			this._boundingBox.getCorners(this._boundingBoxCorners);
		}

		/**
		*@private
		*/
		__proto._getSubMesh=function(index){
			throw new Error("未Override,请重载该属性！");
		}

		/**
		*获取SubMesh的个数。
		*@return SubMesh的个数。
		*/
		__getset(0,__proto,'subMeshCount',function(){
			return this._subMeshCount;
		});

		/**
		*获取AABB包围盒,禁止修改其数据。
		*@return AABB包围盒。
		*/
		__getset(0,__proto,'boundingBox',function(){
			return this._boundingBox;
		});

		/**
		*获取包围球顶点,禁止修改其数据。
		*@return 包围球。
		*/
		__getset(0,__proto,'boundingBoxCorners',function(){
			return this._boundingBoxCorners;
		});

		/**
		*获取包围球,禁止修改其数据。
		*@return 包围球。
		*/
		__getset(0,__proto,'boundingSphere',function(){
			return this._boundingSphere;
		});

		return BaseMesh;
	})(Resource)


	/**
	*@private
	*<code>ShaderInstance</code> 类用于实现ShaderInstance。
	*/
	//class laya.d3.shader.ShaderInstance extends laya.resource.Resource
	var ShaderInstance=(function(_super){
		function ShaderInstance(vs,ps,attributeMap,uniformMap){
			//this._attributeMap=null;
			//this._uniformMap=null;
			//this._vs=null;
			//this._ps=null;
			//this._curActTexIndex=0;
			//this._vshader=null;
			//this._pshader=null;
			//this._program=null;
			//this._shaderParamsIDs=null;
			//this._attributeParamsMap=null;
			//this._sceneUniformParamsMap=null;
			//this._cameraUniformParamsMap=null;
			//this._spriteUniformParamsMap=null;
			//this._materialUniformParamsMap=null;
			//this._customUniformParamsMap=null;
			//this._uploadLoopCount=0;
			//this._uploadMaterial=null;
			//this._uploadRender=null;
			//this._uploadCamera=null;
			//this._uploadScene=null;
			ShaderInstance.__super.call(this);
			if (!vs || !ps)
				throw "Shader Error";
			this._vs=vs;
			this._ps=ps;
			this._attributeMap=attributeMap;
			this._uniformMap=uniformMap;
			this._create();
		}

		__class(ShaderInstance,'laya.d3.shader.ShaderInstance',_super);
		var __proto=ShaderInstance.prototype;
		/**
		*@private
		*/
		__proto._create=function(){
			var customCompile=ShaderCompile.customCompile;
			var customCompileData;
			var gl=LayaGL.instance;
			this._program=gl.createProgram();
			this._vshader=this._createShader(gl,this._vs,0x8B31);
			this._pshader=this._createShader(gl,this._ps,0x8B30);
			gl.attachShader(this._program,this._vshader);
			gl.attachShader(this._program,this._pshader);
			gl.linkProgram(this._program);
			if (Shader3D.debugMode && !customCompile && !gl.getProgramParameter(this._program,0x8B82))
				throw gl.getProgramInfoLog(this._program);
			var one,i=0,n=0;
			if (customCompile)
				customCompileData=ShaderCompile.preGetParams(this._vs,this._ps);
			var attribNum=customCompile ? customCompileData.attributes.length :gl.getProgramParameter(this._program,0x8B89);
			this._attributeParamsMap=LayaGL.instance.createCommandEncoder(attribNum *4 *4+4,64,true);
			for (i=0;i < attribNum;i++){
				var attribData=customCompile ? customCompileData.attributes[i] :gl.getActiveAttrib(this._program,i);
				var attName=attribData.name;
				one=new ShaderVariable();
				one.location=gl.getAttribLocation(this._program,attName);
				one.name=attName;
				one.type=attribData.type;
				if (this._attributeMap[attName] !=null){
					one.dataOffset=this._attributeMap[attName];
					this._addShaderAttribute(this._attributeParamsMap,one);
					}else {
					console.log("Shader:can't find uinform name:"+attName+" in shader file.");
				}
			};
			var sceneParms=[];
			var cameraParms=[];
			var spriteParms=[];
			var materialParms=[];
			var customParms=[];
			this._customUniformParamsMap=[];
			var nUniformNum=customCompile ? customCompileData.uniforms.length :gl.getProgramParameter(this._program,0x8B86);
			WebGLContext.useProgram(gl,this._program);
			this._curActTexIndex=0;
			for (i=0;i < nUniformNum;i++){
				var uniformData=customCompile ? customCompileData.uniforms[i] :gl.getActiveUniform(this._program,i);
				var uniName=uniformData.name;
				one=new ShaderVariable();
				one.location=gl.getUniformLocation(this._program,uniName);
				if (uniName.indexOf('[0]')> 0){
					one.name=uniName=uniName.substr(0,uniName.length-3);
					one.isArray=true;
					}else {
					one.name=uniName;
					one.isArray=false;
				}
				one.type=uniformData.type;
				this._addShaderUnifiormFun(one);
				var uniform=this._uniformMap[uniName];
				if (uniform !=null){
					one.dataOffset=uniform[0];
					switch (uniform[1]){
						case 0:
							customParms.push(one);
							break ;
						case 1:
							materialParms.push(one);
							break ;
						case 2:
							spriteParms.push(one);
							break ;
						case 3:
							cameraParms.push(one);
							break ;
						case 4:
							sceneParms.push(one);
							break ;
						default :
							throw new Error("Shader3D: period is unkonw.");
						}
					}else {
					console.log("Shader3D:can't find uinform name:"+this._uniformMap[one.name]+" in shader file.");
				}
			}
			this._sceneUniformParamsMap=LayaGL.instance.createCommandEncoder(sceneParms.length *4 *5+4,64,true);
			for (i=0,n=sceneParms.length;i < n;i++)
			this._sceneUniformParamsMap.addShaderUniform(sceneParms[i]);
			this._cameraUniformParamsMap=LayaGL.instance.createCommandEncoder(cameraParms.length *4 *5+4,64,true);
			for (i=0,n=cameraParms.length;i < n;i++)
			this._cameraUniformParamsMap.addShaderUniform(cameraParms[i]);
			this._spriteUniformParamsMap=LayaGL.instance.createCommandEncoder(spriteParms.length *4 *5+4,64,true);
			for (i=0,n=spriteParms.length;i < n;i++)
			this._spriteUniformParamsMap.addShaderUniform(spriteParms[i]);
			this._materialUniformParamsMap=LayaGL.instance.createCommandEncoder(materialParms.length *4 *5+4,64,true);
			for (i=0,n=materialParms.length;i < n;i++)
			this._materialUniformParamsMap.addShaderUniform(materialParms[i]);
			this._customUniformParamsMap.length=customParms.length;
			for (i=0,n=customParms.length;i < n;i++){
				var custom=customParms[i];
				this._customUniformParamsMap[custom.dataOffset]=custom;
			}
			if (Render.isConchApp){
				this._shaderParamsIDs=new Int32Array(5);
				LayaGL.createArrayBufferRef(this._shaderParamsIDs,0,true);
				this._shaderParamsIDs[0]=this._attributeParamsMap._buffer["_ptrID"];
				this._shaderParamsIDs[1]=this._sceneUniformParamsMap._buffer["_ptrID"];
				this._shaderParamsIDs[2]=this._cameraUniformParamsMap._buffer["_ptrID"];
				this._shaderParamsIDs[3]=this._spriteUniformParamsMap._buffer["_ptrID"];
				this._shaderParamsIDs[4]=this._materialUniformParamsMap._buffer["_ptrID"];
			}
		}

		/**
		*@inheritDoc
		*/
		__proto.disposeResource=function(){
			LayaGL.instance.deleteShader(this._vshader);
			LayaGL.instance.deleteShader(this._pshader);
			LayaGL.instance.deleteProgram(this._program);
			this._vshader=this._pshader=this._program=null;
			this.memorySize=0;
			this._curActTexIndex=0;
		}

		/**
		*@private
		*/
		__proto._addShaderAttribute=function(attribureMap,one){
			one.caller=this;
			one.fun=this._attribute;
			attribureMap.addShaderAttribute(one);
		}

		/**
		*@private
		*/
		__proto._addShaderUnifiormFun=function(one){
			var gl=LayaGL.instance;
			one.caller=this;
			var isArray=one.isArray;
			switch (one.type){
				case 0x8B56:
					one.fun=this._uniform1i;
					one.uploadedValue=new Array(1);
					break ;
				case 0x1404:
					one.fun=isArray ? this._uniform1iv :this._uniform1i;
					one.uploadedValue=new Array(1);
					break ;
				case 0x1406:
					one.fun=isArray ? this._uniform1fv :this._uniform1f;
					one.uploadedValue=new Array(1);
					break ;
				case 0x8B50:
					one.fun=isArray ? this._uniform_vec2v :this._uniform_vec2;
					one.uploadedValue=new Array(2);
					break ;
				case 0x8B51:
					one.fun=isArray ? this._uniform_vec3v :this._uniform_vec3;
					one.uploadedValue=new Array(3);
					break ;
				case 0x8B52:
					one.fun=isArray ? this._uniform_vec4v :this._uniform_vec4;
					one.uploadedValue=new Array(4);
					break ;
				case 0x8B5A:
					one.fun=this._uniformMatrix2fv;
					break ;
				case 0x8B5B:
					one.fun=this._uniformMatrix3fv;
					break ;
				case 0x8B5C:
					one.fun=isArray ? this._uniformMatrix4fv :this._uniformMatrix4f;
					break ;
				case 0x8B5E:
					gl.uniform1i(one.location,this._curActTexIndex);
					one.textureID=WebGLContext._glTextureIDs[this._curActTexIndex++];
					one.fun=this._uniform_sampler2D;
					break ;
				case 0x8B60:
					gl.uniform1i(one.location,this._curActTexIndex);
					one.textureID=WebGLContext._glTextureIDs[this._curActTexIndex++];
					one.fun=this._uniform_samplerCube;
					break ;
				default :
					throw new Error("compile shader err!");
					break ;
				}
		}

		/**
		*@private
		*/
		__proto._createShader=function(gl,str,type){
			var shader=gl.createShader(type);
			gl.shaderSource(shader,str);
			gl.compileShader(shader);
			if (Shader3D.debugMode && !gl.getShaderParameter(shader,0x8B81))
				throw gl.getShaderInfoLog(shader);
			return shader;
		}

		/**
		*@private
		*/
		__proto._attribute=function(one,value){
			var gl=LayaGL.instance;
			var bindedAttributeBuffer=Buffer._bindedAtributeBuffer;
			var bindedAttributeDeclaration=Buffer._bindedAttributeDeclaration;
			var location=one.location;
			var verBuf=Buffer._bindedVertexBuffer;
			var verDec=verBuf._vertexDeclaration;
			(bindedAttributeBuffer[location])|| (gl.enableVertexAttribArray(location));
			if (bindedAttributeBuffer[location]!==verBuf || bindedAttributeDeclaration[location]!==verDec){
				gl.vertexAttribPointer(location,value[0],value[1],value[2],value[3],value[4]);
				bindedAttributeBuffer[location]=verBuf;
				bindedAttributeDeclaration[location]=verDec;
				return 1;
			}
			return 0;
		}

		/**
		*@private
		*/
		__proto._uniform1f=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value){
				LayaGL.instance.uniform1f(one.location,uploadedValue[0]=value);
				return 1;
			}
			return 0;
		}

		/**
		*@private
		*/
		__proto._uniform1fv=function(one,value){
			if (value.length < 4){
				var uploadedValue=one.uploadedValue;
				if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
					LayaGL.instance.uniform1fv(one.location,value);
					uploadedValue[0]=value[0];
					uploadedValue[1]=value[1];
					uploadedValue[2]=value[2];
					uploadedValue[3]=value[3];
					return 1;
				}
				return 0;
				}else {
				LayaGL.instance.uniform1fv(one.location,value);
				return 1;
			}
		}

		/**
		*@private
		*/
		__proto._uniform_vec2=function(one,v){
			var value=v.elements;
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1]){
				LayaGL.instance.uniform2f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1]);
				return 1;
			}
			return 0;
		}

		/**
		*@private
		*/
		__proto._uniform_vec2v=function(one,value){
			if (value.length < 2){
				var uploadedValue=one.uploadedValue;
				if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
					LayaGL.instance.uniform2fv(one.location,value);
					uploadedValue[0]=value[0];
					uploadedValue[1]=value[1];
					uploadedValue[2]=value[2];
					uploadedValue[3]=value[3];
					return 1;
				}
				return 0;
				}else {
				LayaGL.instance.uniform2fv(one.location,value);
				return 1;
			}
		}

		/**
		*@private
		*/
		__proto._uniform_vec3=function(one,v){
			var value=v.elements;
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2]){
				LayaGL.instance.uniform3f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2]);
				return 1;
			}
			return 0;
		}

		/**
		*@private
		*/
		__proto._uniform_vec3v=function(one,v){
			LayaGL.instance.uniform3fv(one.location,v);
			return 1;
		}

		/**
		*@private
		*/
		__proto._uniform_vec4=function(one,v){
			var value=v.elements;
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
				LayaGL.instance.uniform4f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2],uploadedValue[3]=value[3]);
				return 1;
			}
			return 0;
		}

		/**
		*@private
		*/
		__proto._uniform_vec4v=function(one,v){
			LayaGL.instance.uniform4fv(one.location,v);
			return 1;
		}

		/**
		*@private
		*/
		__proto._uniformMatrix2fv=function(one,value){
			LayaGL.instance.uniformMatrix2fv(one.location,false,value);
			return 1;
		}

		/**
		*@private
		*/
		__proto._uniformMatrix3fv=function(one,value){
			LayaGL.instance.uniformMatrix3fv(one.location,false,value);
			return 1;
		}

		/**
		*@private
		*/
		__proto._uniformMatrix4f=function(one,m){
			var value=m.elements;
			LayaGL.instance.uniformMatrix4fv(one.location,false,value);
			return 1;
		}

		/**
		*@private
		*/
		__proto._uniformMatrix4fv=function(one,m){
			LayaGL.instance.uniformMatrix4fv(one.location,false,m);
			return 1;
		}

		/**
		*@private
		*/
		__proto._uniform1i=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value){
				LayaGL.instance.uniform1i(one.location,uploadedValue[0]=value);
				return 1;
			}
			return 0;
		}

		/**
		*@private
		*/
		__proto._uniform1iv=function(one,value){
			LayaGL.instance.uniform1iv(one.location,value);
			return 1;
		}

		/**
		*@private
		*/
		__proto._uniform_ivec2=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1]){
				LayaGL.instance.uniform2i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1]);
				return 1;
			}
			return 0;
		}

		/**
		*@private
		*/
		__proto._uniform_ivec2v=function(one,value){
			LayaGL.instance.uniform2iv(one.location,value);
			return 1;
		}

		/**
		*@private
		*/
		__proto._uniform_vec3i=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2]){
				LayaGL.instance.uniform3i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2]);
				return 1;
			}
			return 0;
		}

		/**
		*@private
		*/
		__proto._uniform_vec3vi=function(one,value){
			LayaGL.instance.uniform3iv(one.location,value);
			return 1;
		}

		/**
		*@private
		*/
		__proto._uniform_vec4i=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
				LayaGL.instance.uniform4i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2],uploadedValue[3]=value[3]);
				return 1;
			}
			return 0;
		}

		/**
		*@private
		*/
		__proto._uniform_vec4vi=function(one,value){
			LayaGL.instance.uniform4iv(one.location,value);
			return 1;
		}

		/**
		*@private
		*/
		__proto._uniform_sampler2D=function(one,texture){
			var value=texture._getSource()|| texture.defaulteTexture._getSource();
			var gl=LayaGL.instance;
			WebGLContext.activeTexture(gl,one.textureID);
			WebGLContext.bindTexture(gl,0x0DE1,value);
			return 0;
		}

		/**
		*@private
		*/
		__proto._uniform_samplerCube=function(one,texture){
			var value=texture._getSource()|| texture.defaulteTexture._getSource();
			var gl=LayaGL.instance;
			WebGLContext.activeTexture(gl,one.textureID);
			WebGLContext.bindTexture(gl,0x8513,value);
			return 0;
		}

		/**
		*@private
		*/
		__proto.bind=function(){
			return WebGLContext.useProgram(LayaGL.instance,this._program);
		}

		/**
		*@private
		*/
		__proto.uploadAttributes=function(shaderDatas){
			Stat.shaderCall+=LayaGLRunner.uploadShaderAttributes(LayaGL.instance,this._attributeParamsMap,shaderDatas._data);
		}

		/**
		*@private
		*/
		__proto.uploadUniforms=function(shaderUniform,shaderDatas,uploadUnTexture){
			Stat.shaderCall+=LayaGLRunner.uploadShaderUniforms(LayaGL.instance,shaderUniform,shaderDatas._data,uploadUnTexture);
		}

		/**
		*@private
		*/
		__proto.uploadCustomUniform=function(index,data){
			Stat.shaderCall+=LayaGLRunner.uploadCustomUniform(LayaGL.instance,this._customUniformParamsMap,index,data);
		}

		/**
		*@private
		*[NATIVE]
		*/
		__proto._uniformMatrix2fvForNative=function(one,value){
			LayaGL.instance.uniformMatrix2fvEx(one.location,false,value);
			return 1;
		}

		/**
		*@private
		*[NATIVE]
		*/
		__proto._uniformMatrix3fvForNative=function(one,value){
			LayaGL.instance.uniformMatrix3fvEx(one.location,false,value);
			return 1;
		}

		/**
		*@private
		*[NATIVE]
		*/
		__proto._uniformMatrix4fvForNative=function(one,m){
			LayaGL.instance.uniformMatrix4fvEx(one.location,false,m);
			return 1;
		}

		/**
		*@private
		*[NATIVE]
		*/
		__proto.uploadShaderParamForNative=function(attrValue,sceneValue,cameraValue,spriteValue,materialValue){
			Stat.shaderCall+=LayaGL.instance.uploadShaderParamForNative(this._shaderParamsIDs,attrValue,sceneValue,cameraValue,spriteValue,materialValue);
		}

		return ShaderInstance;
	})(Resource)


	/**
	*<code>TerrainHeightData</code> 类用于描述地形高度信息。
	*/
	//class laya.d3.terrain.TerrainHeightData extends laya.resource.Resource
	var TerrainHeightData=(function(_super){
		function TerrainHeightData(){
			this._terrainHeightData=null;
			this._width=0;
			this._height=0;
			this._bitType=0;
			this._value=NaN;
			TerrainHeightData.__super.call(this);
		}

		__class(TerrainHeightData,'laya.d3.terrain.TerrainHeightData',_super);
		var __proto=TerrainHeightData.prototype;
		/**
		*异步回调
		*/
		__proto.onAsynLoaded=function(data,params){
			this._width=params[0];
			this._height=params[1];
			this._bitType=params[2];
			this._value=params[3];
			var buffer;
			var ratio=NaN;
			if (this._bitType==8){
				buffer=new Uint8Array(data);
				ratio=1.0 / 255.0;
			}
			else if (this._bitType==16){
				buffer=new Int16Array(data);
				ratio=1.0 / 32766.0;
			}
			this._terrainHeightData=new Float32Array(this._height *this._width);
			for (var i=0,n=this._height *this._width;i < n;i++){
				this._terrainHeightData[i]=(buffer[i] *ratio *this._value)/2;
			}
		}

		TerrainHeightData.load=function(url,widht,height,bitType,value){
			return Laya.loader.create(url,null,null,TerrainHeightData,[widht,height,bitType,value],1,false);
		}

		return TerrainHeightData;
	})(Resource)


	/**
	*<code>TerrainRes</code> 类用于描述地形信息。
	*/
	//class laya.d3.terrain.TerrainRes extends laya.resource.Resource
	var TerrainRes=(function(_super){
		function TerrainRes(){
			this._version=NaN;
			this._cameraCoordinateInverse=false;
			this._gridSize=NaN;
			this._chunkNumX=0;
			this._chunkNumZ=0;
			this._heightDataX=0;
			this._heightDataZ=0;
			this._heightDataBitType=0;
			this._heightDataValue=NaN;
			this._heightDataUrl=null;
			this._detailTextureInfos=null;
			this._chunkInfos=null;
			this._heightData=null;
			this._materialInfo=null;
			this._alphaMaps=null;
			this._normalMaps=null;
			TerrainRes.__super.call(this);
		}

		__class(TerrainRes,'laya.d3.terrain.TerrainRes',_super);
		var __proto=TerrainRes.prototype;
		__proto.parseData=function(data){
			var json=data[0];
			var resouMap=data[1];
			this._version=json.version;
			if (this._version==1.0){
				this._cameraCoordinateInverse=json.cameraCoordinateInverse;
				this._gridSize=json.gridSize;
				this._chunkNumX=json.chunkNumX;
				this._chunkNumZ=json.chunkNumZ;
				var heightData=json.heightData;
				this._heightDataX=heightData.numX;
				this._heightDataZ=heightData.numZ;
				this._heightDataBitType=heightData.bitType;
				this._heightDataValue=heightData.value;
				this._heightDataUrl=resouMap[heightData.url];
				this._materialInfo=new MaterialInfo();
				if (json.material){
					var ambient=json.material.ambient;
					var diffuse=json.material.diffuse;
					var specular=json.material.specular;
					this._materialInfo.ambientColor=new Vector3(ambient[0],ambient[1],ambient[2]);
					this._materialInfo.diffuseColor=new Vector3(diffuse[0],diffuse[1],diffuse[2]);
					this._materialInfo.specularColor=new Vector4(specular[0],specular[1],specular[2],specular[3]);
				};
				var detailTextures=json.detailTexture;
				this._detailTextureInfos=__newvec(detailTextures.length);
				for (var i=0;i < detailTextures.length;i++){
					var detail=detailTextures[i];
					var info=new DetailTextureInfo();
					info.diffuseTexture=resouMap[detail.diffuse];
					info.normalTexture=detail.normal ? resouMap[detail.normal] :null;
					if (detail.scale){
						info.scale=new Vector2(detail.scale[0],detail.scale[1]);
						}else {
						info.scale=new Vector2(1,1);
					}
					if (detail.offset){
						info.offset=new Vector2(detail.offset[0],detail.offset[1]);
						}else {
						info.offset=new Vector2(0,0);
					}
					this._detailTextureInfos[i]=info;
				};
				var alphaMaps=json.alphaMap;
				this._alphaMaps=__newvec(alphaMaps.length);
				for (i=0;i < this._alphaMaps.length;i++){
					this._alphaMaps[i]=json.alphaMap[i];
				};
				var normalMaps=json.normalMap;
				this._normalMaps=__newvec(normalMaps.length);
				for (i=0;i < this._normalMaps.length;i++){
					this._normalMaps[i]=json.normalMap[i];
				};
				var jchunks=json.chunkInfo;
				if (this._chunkNumX *this._chunkNumZ !=jchunks.length){
					alert("terrain data error");
					return false;
				}
				this._chunkInfos=__newvec(jchunks.length);
				for (i=0;i < jchunks.length;i++){
					var jchunk=jchunks[i];
					var chunkinfo=new ChunkInfo();
					var nAlphaMapNum=jchunk.alphaMap.length;
					var nDetailIDNum=jchunk.detailID.length;
					if (nAlphaMapNum !=nDetailIDNum){
						alert("terrain chunk data error");
						return false;
					}
					chunkinfo.alphaMap=__newvec(nAlphaMapNum);
					chunkinfo.detailID=__newvec(nDetailIDNum);
					chunkinfo.normalMap=resouMap[this._normalMaps[jchunk.normalMap]];
					for (var j=0;j < nAlphaMapNum;j++){
						chunkinfo.alphaMap[j]=resouMap[this._alphaMaps[jchunk.alphaMap[j]]];
						var jid=jchunk.detailID[j];
						var nIDNum=jid.length;
						chunkinfo.detailID[j]=new Uint8Array(nIDNum);
						for (var k=0;k < nIDNum;k++){
							chunkinfo.detailID[j][k]=jid[k];
						}
					}
					this._chunkInfos[i]=chunkinfo;
				}
				this._heightData=Loader.getRes(this._heightDataUrl);
				this.onLoadTerrainComplete(this._heightData);
			}
			return true;
		}

		__proto.onLoadTerrainComplete=function(heightData){}
		/**
		*异步回调
		*/
		__proto.onAsynLoaded=function(data,params){
			this.parseData(data);
		}

		TerrainRes.load=function(url){
			return Laya.loader.create(url,null,null,TerrainRes,null,1,false);
		}

		return TerrainRes;
	})(Resource)


	/**
	*@private
	*将mesh元素缓存到canvas中并进行绘制
	*/
	//class laya.ani.bone.canvasmesh.CacheAbleSkinMesh extends laya.ani.bone.canvasmesh.SkinMeshCanvas
	var CacheAbleSkinMesh=(function(_super){
		function CacheAbleSkinMesh(){
			this.isCached=false;
			this.canvas=null;
			this.tex=null;
			this.rec=null;
			CacheAbleSkinMesh.__super.call(this);
		}

		__class(CacheAbleSkinMesh,'laya.ani.bone.canvasmesh.CacheAbleSkinMesh',_super);
		var __proto=CacheAbleSkinMesh.prototype;
		__proto.getCanvasPic=function(){
			var canvas=new HTMLCanvas("2D");
			var ctx=canvas.getContext('2d');
			this.rec=this.mesh.getBounds();
			debugger;
			canvas.size(this.rec.width,this.rec.height);
			var preTransform;
			preTransform=this.transform;
			this.transform=CacheAbleSkinMesh.tempMt;
			this.transform.identity();
			this.transform.translate(-this.rec.x,-this.rec.y);
			this.renderToContext(ctx);
			this.transform.translate(+this.rec.x,+this.rec.y);
			this.transform=preTransform;
			return new Texture(canvas);
		}

		__proto.render=function(context,x,y){
			if (!this.mesh.texture)return;
			if (!this.isCached){
				this.isCached=true;
				this.tex=this.getCanvasPic();
			}
			if(!this.transform){
				this.transform=SkinMeshCanvas._tempMatrix;
				this.transform.identity();
				this.transform.translate(x,y);
				this._renderTextureToContext(context);
				this.transform.translate(-x,-y);
				this.transform=null;
				}else{
				this.transform.translate(x,y);
				this._renderTextureToContext(context);
				this.transform.translate(-x,-y);
			}
		}

		__proto._renderTextureToContext=function(context){
			this.context=context.ctx || context;
			context.save();
			var texture;
			texture=this.tex;
			if (this.transform){
				var mt=this.transform;
				context.transform(mt.a,mt.b,mt.c,mt.d,mt.tx,mt.ty);
			}
			this.rec=this.mesh.getBounds();
			context.translate(this.rec.x,this.rec.y);
			context.drawImage(texture,0,0,texture.width,texture.height,0,0);
			context.restore();
		}

		__static(CacheAbleSkinMesh,
		['tempMt',function(){return this.tempMt=new Matrix();}
		]);
		return CacheAbleSkinMesh;
	})(SkinMeshCanvas)


	/**
	*<code>MeshRender</code> 类用于网格渲染器。
	*/
	//class laya.d3.core.MeshRender extends laya.d3.core.render.BaseRender
	var MeshRender=(function(_super){
		function MeshRender(owner,shaderDataSize){
			//this._projectionViewWorldMatrix=null;
			MeshRender.__super.call(this,owner,shaderDataSize);
			this._projectionViewWorldMatrix=new Matrix4x4();
			(owner)&&((owner).meshFilter.on("meshchanged",this,this._onMeshChanged));
		}

		__class(MeshRender,'laya.d3.core.MeshRender',_super);
		var __proto=MeshRender.prototype;
		/**
		*@private
		*/
		__proto._onMeshChanged=function(meshFilter,oldMesh,mesh){
			if (mesh.loaded){
				this._boundingSphereNeedChange=this._boundingBoxNeedChange=this._boundingBoxCenterNeedChange=this._octreeNodeNeedChange=true;
				}else {
				mesh.once("loaded",this,this._onMeshLoaed);
			}
		}

		/**
		*@private
		*/
		__proto._onMeshLoaed=function(sender,enable){
			this._boundingSphereNeedChange=this._boundingBoxNeedChange=this._boundingBoxCenterNeedChange=this._octreeNodeNeedChange=true;
		}

		/**
		*@private
		*/
		__proto._calculateBoundingSphereByInitSphere=function(boundSphere){
			var maxScale=NaN;
			var transform=this._owner.transform;
			var scaleE=transform.scale.elements;
			var scaleX=scaleE[0];
			scaleX || (scaleX=-scaleX);
			var scaleY=scaleE[1];
			scaleY || (scaleY=-scaleY);
			var scaleZ=scaleE[2];
			scaleZ || (scaleZ=-scaleZ);
			if (scaleX >=scaleY && scaleX >=scaleZ)
				maxScale=scaleX;
			else
			maxScale=scaleY >=scaleZ ? scaleY :scaleZ;
			Vector3.transformCoordinate(boundSphere.center,transform.worldMatrix,this._boundingSphere.center);
			this._boundingSphere.radius=boundSphere.radius *maxScale;
		}

		/**
		*@private
		*/
		__proto._calculateBoundBoxByInitCorners=function(corners){
			var worldMat=(this._owner).transform.worldMatrix;
			for (var i=0;i < 8;i++)
			BoundBox.createfromPoints(BaseRender._tempBoundBoxCorners,this._boundingBox);
			Vector3.transformCoordinate(corners[i],worldMat,BaseRender._tempBoundBoxCorners[i]);
		}

		/**
		*@inheritDoc
		*/
		__proto._calculateBoundingSphere=function(){
			var sharedMesh=(this._owner).meshFilter.sharedMesh;
			if (sharedMesh==null || sharedMesh.boundingSphere==null)
				this._boundingSphere.toDefault();
			else
			this._calculateBoundingSphereByInitSphere(sharedMesh.boundingSphere);
		}

		/**
		*@inheritDoc
		*/
		__proto._calculateBoundingBox=function(){
			var sharedMesh=(this._owner).meshFilter.sharedMesh;
			if (sharedMesh==null || sharedMesh.boundingBox==null)
				this._boundingBox.toDefault();
			else
			this._calculateBoundBoxByInitCorners(sharedMesh.boundingBoxCorners);
		}

		/**
		*@inheritDoc
		*/
		__proto._needRender=function(boundFrustum){
			if (boundFrustum)
				return boundFrustum.containsBoundSphere(this.boundingSphere)!==0;
			else
			return true;
		}

		/**
		*@inheritDoc
		*/
		__proto._renderUpdate=function(context,transform){
			var projectionView=context.projectionViewMatrix;
			var sv=this._shaderValues;
			if (transform){
				var worldMat=transform.worldMatrix;
				sv.setMatrix4x4(0,worldMat);
				Matrix4x4.multiply(projectionView,worldMat,this._projectionViewWorldMatrix);
				sv.setMatrix4x4(1,this._projectionViewWorldMatrix);
				}else {
				sv.setMatrix4x4(0,Matrix4x4.DEFAULT);
				sv.setMatrix4x4(1,projectionView);
			}
			if (Laya3D.debugMode)
				this._renderRenderableBoundBox();
		}

		return MeshRender;
	})(BaseRender)


	/**
	*<code>ShurikenParticleRender</code> 类用于创建3D粒子渲染器。
	*/
	//class laya.d3.core.particleShuriKen.ShurikenParticleRender extends laya.d3.core.render.BaseRender
	var ShurikenParticleRender=(function(_super){
		function ShurikenParticleRender(owner){
			//this._defaultBoundBox=null;
			//this._renderMode=0;
			//this._mesh=null;
			//this.stretchedBillboardCameraSpeedScale=NaN;
			//this.stretchedBillboardSpeedScale=NaN;
			//this.stretchedBillboardLengthScale=NaN;
			this._finalGravity=new Vector3();
			this._tempRotationMatrix=new Matrix4x4();
			ShurikenParticleRender.__super.call(this,owner);
			this._defaultBoundBox=new BoundBox(new Vector3(),new Vector3());
			this._renderMode=-1;
			this.stretchedBillboardCameraSpeedScale=0.0;
			this.stretchedBillboardSpeedScale=0.0;
			this.stretchedBillboardLengthScale=1.0;
		}

		__class(ShurikenParticleRender,'laya.d3.core.particleShuriKen.ShurikenParticleRender',_super);
		var __proto=ShurikenParticleRender.prototype;
		/**
		*@inheritDoc
		*/
		__proto._calculateBoundingBox=function(){
			var minE=this._boundingBox.min.elements;
			minE[0]=-Number.MAX_VALUE;
			minE[1]=-Number.MAX_VALUE;
			minE[2]=-Number.MAX_VALUE;
			var maxE=this._boundingBox.min.elements;
			maxE[0]=Number.MAX_VALUE;
			maxE[1]=Number.MAX_VALUE;
			maxE[2]=Number.MAX_VALUE;
		}

		/**
		*@inheritDoc
		*/
		__proto._calculateBoundingSphere=function(){
			var oriBoundSphere=(this._owner).particleSystem._boundingSphere;
			var maxScale=NaN;
			var transform=this._owner.transform;
			var scaleE=transform.scale.elements;
			var scaleX=Math.abs(scaleE[0]);
			var scaleY=Math.abs(scaleE[1]);
			var scaleZ=Math.abs(scaleE[2]);
			if (scaleX >=scaleY && scaleX >=scaleZ)
				maxScale=scaleX;
			else
			maxScale=scaleY >=scaleZ ? scaleY :scaleZ;
			Vector3.transformCoordinate(oriBoundSphere.center,transform.worldMatrix,this._boundingSphere.center);
			this._boundingSphere.radius=oriBoundSphere.radius *maxScale;
		}

		/**
		*@inheritDoc
		*/
		__proto._needRender=function(boundFrustum){
			if (boundFrustum){
				if (boundFrustum.containsBoundSphere(this.boundingSphere)!==0){
					if (!(this._owner).particleSystem.isAlive)
						return false;
					else
					return true;
					}else {
					return false;
				}
				}else {
				return true;
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._renderUpdate=function(context,transfrom){
			var projectionView=context.projectionViewMatrix;
			var particleSystem=(this._owner).particleSystem;
			var sv=this._shaderValues;
			var transform=this._owner.transform;
			switch (particleSystem.simulationSpace){
				case 0:
					break ;
				case 1:
					sv.setVector(0,transform.position);
					sv.setQuaternion(1,transform.rotation);
					break ;
				default :
					throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
				}
			switch (particleSystem.scaleMode){
				case 0:;
					var scale=transform.scale;
					sv.setVector(4,scale);
					sv.setVector(5,scale);
					break ;
				case 1:;
					var localScale=transform.localScale;
					sv.setVector(4,localScale);
					sv.setVector(5,localScale);
					break ;
				case 2:
					sv.setVector(4,transform.scale);
					sv.setVector(5,Vector3.ONE);
					break ;
				}
			Vector3.scale(Physics.gravity,particleSystem.gravityModifier,this._finalGravity);
			sv.setVector(7,this._finalGravity);
			sv.setInt(11,particleSystem.simulationSpace);
			sv.setBool(8,particleSystem.threeDStartRotation);
			sv.setInt(6,particleSystem.scaleMode);
			sv.setInt(9,this.stretchedBillboardLengthScale);
			sv.setInt(10,this.stretchedBillboardSpeedScale);
			sv.setNumber(12,particleSystem._currentTime);
			if (Laya3D.debugMode)
				this._renderRenderableBoundBox();
		}

		/**
		*@inheritDoc
		*/
		__proto._destroy=function(){
			_super.prototype._destroy.call(this);
			(this._mesh)&& (this._mesh._removeReference(),this._mesh=null);
		}

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'boundingBox',function(){
			if (!(this._owner).particleSystem.isAlive){
				return this._defaultBoundBox;
				}else {
				if (this._boundingBoxNeedChange){
					this._calculateBoundingBox();
					this._boundingBoxNeedChange=false;
				}
				return this._boundingBox;
			}
		});

		/**
		*设置渲染模式,0为BILLBOARD、1为STRETCHEDBILLBOARD、2为HORIZONTALBILLBOARD、3为VERTICALBILLBOARD、4为MESH。
		*@param value 渲染模式。
		*/
		/**
		*获取渲染模式。
		*@return 渲染模式。
		*/
		__getset(0,__proto,'renderMode',function(){
			return this._renderMode;
			},function(value){
			if (this._renderMode!==value){
				var defineDatas=this._defineDatas;
				switch (this._renderMode){
					case 0:
						defineDatas.remove(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_BILLBOARD);
						break ;
					case 1:
						defineDatas.remove(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
						break ;
					case 2:
						defineDatas.remove(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
						break ;
					case 3:
						defineDatas.remove(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
						break ;
					case 4:
						defineDatas.remove(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_MESH);
						break ;
					}
				this._renderMode=value;
				switch (value){
					case 0:
						defineDatas.add(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_BILLBOARD);
						break ;
					case 1:
						defineDatas.add(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
						break ;
					case 2:
						defineDatas.add(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
						break ;
					case 3:
						defineDatas.add(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
						break ;
					case 4:
						defineDatas.add(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_MESH);
						break ;
					default :
						throw new Error("ShurikenParticleRender: unknown renderMode Value.");
					}
				(this._owner).particleSystem._initBufferDatas();
			}
		});

		/**
		*设置网格渲染模式所使用的Mesh,rendderMode为4时生效。
		*@param value 网格模式所使用Mesh。
		*/
		/**
		*获取网格渲染模式所使用的Mesh,rendderMode为4时生效。
		*@return 网格模式所使用Mesh。
		*/
		__getset(0,__proto,'mesh',function(){
			return this._mesh
			},function(value){
			if (this._mesh!==value){
				(this._mesh)&& (this._mesh._removeReference());
				this._mesh=value;
				(value)&& (value._addReference());
				(this._owner).particleSystem._initBufferDatas();
			}
		});

		return ShurikenParticleRender;
	})(BaseRender)


	//class laya.webgl.shader.d2.value.TextSV extends laya.webgl.shader.d2.value.TextureSV
	var TextSV=(function(_super){
		function TextSV(args){
			TextSV.__super.call(this,0x40);
			this.defines.add(0x40);
		}

		__class(TextSV,'laya.webgl.shader.d2.value.TextSV',_super);
		var __proto=TextSV.prototype;
		__proto.release=function(){
			TextSV.pool[TextSV._length++]=this;
			this.clear();
		}

		__proto.clear=function(){
			_super.prototype.clear.call(this);
		}

		TextSV.create=function(){
			if (TextSV._length)return TextSV.pool[--TextSV._length];
			else return new TextSV(null);
		}

		TextSV.pool=[];
		TextSV._length=0;
		return TextSV;
	})(TextureSV)


	/**
	*<code>MeshRender</code> 类用于网格渲染器。
	*/
	//class laya.d3.terrain.TerrainRender extends laya.d3.core.render.BaseRender
	var TerrainRender=(function(_super){
		function TerrainRender(owner){
			this._terrainSprite3DOwner=null;
			TerrainRender.__super.call(this,owner);
			this._terrainSprite3DOwner=owner;
		}

		__class(TerrainRender,'laya.d3.terrain.TerrainRender',_super);
		var __proto=TerrainRender.prototype;
		__proto._calculateBoundingSphere=function(){
			var terrainFilter=this._terrainSprite3DOwner.terrainFilter;
			if (terrainFilter==null){
				this._boundingSphere.toDefault();
				}else {
				var meshBoundingSphere=terrainFilter._originalBoundingSphere;
				var maxScale=NaN;
				var transform=this._terrainSprite3DOwner.transform;
				var scale=transform.scale;
				if (scale.x >=scale.y && scale.x >=scale.z)
					maxScale=scale.x;
				else
				maxScale=scale.y >=scale.z ? scale.y :scale.z;
				Vector3.transformCoordinate(meshBoundingSphere.center,transform.worldMatrix,this._boundingSphere.center);
				this._boundingSphere.radius=meshBoundingSphere.radius *maxScale;
				terrainFilter.calcLeafBoudingSphere(transform.worldMatrix,maxScale);
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._needRender=function(boundFrustum){
			if (boundFrustum)
				return boundFrustum.containsBoundSphere(this.boundingSphere)!==0;
			else
			return true;
		}

		/**
		*@inheritDoc
		*/
		__proto._calculateBoundingBox=function(){
			var terrainFilter=this._terrainSprite3DOwner.terrainFilter;
			if (terrainFilter==null){
				this._boundingBox.toDefault();
				}else {
				var worldMat=this._terrainSprite3DOwner.transform.worldMatrix;
				var corners=terrainFilter._boundingBoxCorners;
				for (var i=0;i < 8;i++)
				Vector3.transformCoordinate(corners[i],worldMat,BaseRender._tempBoundBoxCorners[i]);
				BoundBox.createfromPoints(BaseRender._tempBoundBoxCorners,this._boundingBox);
				terrainFilter.calcLeafBoudingBox(worldMat);
			}
		}

		/**
		*@private
		*/
		__proto._renderUpdate=function(context,transfrom){
			var projectionView=context.projectionViewMatrix;
			var sv=this._shaderValues;
			sv.setMatrix4x4(0,this._owner.transform.worldMatrix);
			var projViewWorld=this._owner.getProjectionViewWorldMatrix(projectionView);
			sv.setMatrix4x4(1,projViewWorld);
		}

		/**
		*@private
		*/
		__proto._destroy=function(){
			_super.prototype._destroy.call(this);
			this._terrainSprite3DOwner=null;
		}

		return TerrainRender;
	})(BaseRender)


	/**
	*@private
	*<code>SubMeshDynamicBatch</code> 类用于网格动态合并。
	*/
	//class laya.d3.graphics.SubMeshDynamicBatch extends laya.d3.graphics.DynamicBatch
	var SubMeshDynamicBatch=(function(_super){
		function SubMeshDynamicBatch(){
			this._vertices=null;
			this._indexBuffer=null;
			this._indices=null;
			this._positionOffset=0;
			this._normalOffset=0;
			this._colorOffset=0;
			this._uv0Offset=0;
			this._uv1Offset=0;
			this._sTangentOffset=0;
			SubMeshDynamicBatch.__super.call(this);
			var maxVerDec=VertexPositionNormalColorTexture0Texture1STangent.vertexDeclaration;
			var maxByteCount=maxVerDec.vertexStride *32000;
			this._vertices=new Float32Array(maxByteCount / 4);
			this._vertexBuffer=new VertexBuffer3D(maxByteCount,0x88E8);
			this._indices=new Int16Array(32000);
			this._indexBuffer=new IndexBuffer3D("ushort",this._indices.length,0x88E8);
		}

		__class(SubMeshDynamicBatch,'laya.d3.graphics.SubMeshDynamicBatch',_super);
		var __proto=SubMeshDynamicBatch.prototype;
		/**
		*@private
		*/
		__proto._getBatchVertices=function(vertexDeclaration,batchVertices,batchOffset,transform,render,subMesh){
			var vertexFloatCount=vertexDeclaration.vertexStride / 4;
			var oriVertexes=subMesh._vertexBuffer.getData();
			var worldMat=transform.worldMatrix;
			var rotation=transform.rotation;
			var lightmapScaleOffset=render.lightmapScaleOffset;
			var vertexStart=subMesh._vertexStart;
			var vertexCount=subMesh._vertexCount;
			for (var i=0;i < vertexCount;i++){
				var oriOffset=(i+vertexStart)*vertexFloatCount;
				var bakeOffset=(i+batchOffset)*vertexFloatCount;
				Utils3D.transformVector3ArrayToVector3ArrayCoordinate(oriVertexes,oriOffset+this._positionOffset,worldMat,batchVertices,bakeOffset+this._positionOffset);
				if (this._normalOffset!==-1)
					Utils3D.transformVector3ArrayByQuat(oriVertexes,oriOffset+this._normalOffset,rotation,batchVertices,bakeOffset+this._normalOffset);
				var bakOff=0,oriOff=0;
				if (this._colorOffset!==-1){
					bakOff=bakeOffset+this._colorOffset;
					oriOff=oriOffset+this._colorOffset;
					batchVertices[bakOff]=oriVertexes[oriOff];
					batchVertices[bakOff+1]=oriVertexes[oriOff+1];
					batchVertices[bakOff+2]=oriVertexes[oriOff+2];
					batchVertices[bakOff+3]=oriVertexes[oriOff+3];
				}
				if (this._uv0Offset!==-1){
					bakOff=bakeOffset+this._uv0Offset;
					oriOff=oriOffset+this._uv0Offset;
					batchVertices[bakOff]=oriVertexes[oriOff];
					batchVertices[bakOff+1]=oriVertexes[oriOff+1];
				}
				if (this._sTangentOffset!==-1){
					bakOff=bakeOffset+this._sTangentOffset;
					oriOff=oriOffset+this._sTangentOffset;
					batchVertices[bakOff]=oriVertexes[oriOff];
					batchVertices[bakOff+1]=oriVertexes[oriOff+1];
					batchVertices[bakOff+2]=oriVertexes[oriOff+2];
					batchVertices[bakOff+3]=oriVertexes[oriOff+3];
				}
			}
		}

		/**
		*@private
		*/
		__proto._getBatchIndices=function(batchIndices,batchIndexCount,transform,subMesh,indexOffset){
			var subIndices=subMesh._indices;
			var k=0,m=0,batchOffset=0;
			var isInvert=transform._isFrontFaceInvert;
			if (isInvert){
				for (k=0,m=subIndices.length;k < m;k+=3){
					batchOffset=batchIndexCount+k;
					batchIndices[batchOffset]=indexOffset+subIndices[k];
					batchIndices[batchOffset+1]=indexOffset+subIndices[k+2];
					batchIndices[batchOffset+2]=indexOffset+subIndices[k+1];
				}
				}else {
				for (k=m,m=subIndices.length;k < m;k+=3){
					batchOffset=batchIndexCount+k;
					batchIndices[batchOffset]=indexOffset+subIndices[k];
					batchIndices[batchOffset+1]=indexOffset+subIndices[k+1];
					batchIndices[batchOffset+2]=indexOffset+subIndices[k+2];
				}
			}
		}

		/**
		*@private
		*/
		__proto._flush=function(vertexCount,indexCount){
			this._vertexBuffer.setData(this._vertices,0,0,vertexCount *(this._vertexBuffer.vertexDeclaration.vertexStride / 4));
			this._indexBuffer.setData(this._indices,0,0,indexCount);
			LayaGL.instance.drawElements(0x0004,indexCount,0x1403,0);
			Stat.drawCall++;
			Stat.trianglesFaces+=indexCount / 3;
		}

		/**
		*@inheritDoc
		*/
		__proto._prepareRender=function(state){
			var element=state.renderElement;
			var vertexDeclaration=element.dynamicVertexDeclaration;
			this._vertexBuffer.vertexDeclaration=vertexDeclaration;
			this._setVertexBuffer(this._vertexBuffer);
			this._positionOffset=vertexDeclaration.getVertexElementByUsage(0).offset / 4;
			var normalElement=vertexDeclaration.getVertexElementByUsage(3);
			this._normalOffset=normalElement ? normalElement.offset / 4 :-1;
			var colorElement=vertexDeclaration.getVertexElementByUsage(1);
			this._colorOffset=colorElement ? colorElement.offset / 4 :-1;
			var uv0Element=vertexDeclaration.getVertexElementByUsage(2);
			this._uv0Offset=uv0Element ? uv0Element.offset / 4 :-1;
			var uv1Element=vertexDeclaration.getVertexElementByUsage(15);
			this._uv1Offset=uv1Element ? uv1Element.offset / 4 :-1;
			var tangentElement=vertexDeclaration.getVertexElementByUsage(5);
			this._sTangentOffset=tangentElement ? tangentElement.offset / 4 :-1;
			return true;
		}

		/**
		*@inheritDoc
		*/
		__proto._render=function(context){
			var element=context.renderElement;
			var vertexDeclaration=element.dynamicVertexDeclaration;
			var batchElements=element.dynamicBatchElementList;
			var batchVertexCount=0;
			var batchIndexCount=0;
			var floatStride=vertexDeclaration.vertexStride / 4;
			for (var i=0,n=batchElements.length;i < n;i++){
				var element=batchElements [i];
				var subMesh=element.geometry;
				var vertexCount=subMesh._vertexCount;
				var indexCount=subMesh._indexCount;
				if (batchIndexCount+indexCount > 32000){
					this._flush(batchVertexCount,batchIndexCount);
					batchVertexCount=batchIndexCount=0;
				};
				var transform=element.transform;
				this._getBatchVertices(vertexDeclaration,this._vertices,batchVertexCount,transform,(element.render),subMesh);
				var indexOffset=batchVertexCount-subMesh._vertexStart;
				this._getBatchIndices(this._indices,batchIndexCount,transform,subMesh,indexOffset);
				batchVertexCount+=vertexCount;
				batchIndexCount+=indexCount;
			}
			this._flush(batchVertexCount,batchIndexCount);
		}

		SubMeshDynamicBatch.instance=null
		return SubMeshDynamicBatch;
	})(DynamicBatch)


	/**
	*@private
	*<code>SubMeshStaticBatch</code> 类用于网格静态合并。
	*/
	//class laya.d3.graphics.SubMeshStaticBatch extends laya.d3.graphics.StaticBatch
	var SubMeshStaticBatch=(function(_super){
		function SubMeshStaticBatch(key,manager,rootOwner,vertexDeclaration){
			this._vertexDeclaration=null;
			this._currentBatchVertexCount=0;
			this._currentBatchIndexCount=0;
			this._indexBuffer=null;
			SubMeshStaticBatch.__super.call(this,key,manager,rootOwner);
			this._currentBatchVertexCount=0;
			this._currentBatchIndexCount=0;
			this._vertexDeclaration=vertexDeclaration;
		}

		__class(SubMeshStaticBatch,'laya.d3.graphics.SubMeshStaticBatch',_super);
		var __proto=SubMeshStaticBatch.prototype;
		/**
		*@private
		*/
		__proto._getStaticBatchBakedVertexs=function(batchVertices,batchOffset,batchOwnerTransform,transform,render,subMesh){
			var vertexBuffer=subMesh._vertexBuffer;
			var vertexDeclaration=vertexBuffer.vertexDeclaration;
			var positionOffset=vertexDeclaration.getVertexElementByUsage(0).offset / 4;
			var normalElement=vertexDeclaration.getVertexElementByUsage(3);
			var normalOffset=normalElement ? normalElement.offset / 4 :-1;
			var colorElement=vertexDeclaration.getVertexElementByUsage(1);
			var colorOffset=colorElement ? colorElement.offset / 4 :-1;
			var uv0Element=vertexDeclaration.getVertexElementByUsage(2);
			var uv0Offset=uv0Element ? uv0Element.offset / 4 :-1;
			var uv1Element=vertexDeclaration.getVertexElementByUsage(15);
			var uv1Offset=uv1Element ? uv1Element.offset / 4 :-1;
			var tangentElement=vertexDeclaration.getVertexElementByUsage(5);
			var sTangentOffset=tangentElement ? tangentElement.offset / 4 :-1;
			var bakeVertexFloatCount=18;
			var oriVertexFloatCount=vertexDeclaration.vertexStride / 4;
			var oriVertexes=vertexBuffer.getData();
			var worldMat;
			if (batchOwnerTransform){
				var rootMat=batchOwnerTransform.worldMatrix;
				rootMat.invert(SubMeshStaticBatch._tempMatrix4x40);
				worldMat=SubMeshStaticBatch._tempMatrix4x41;
				Matrix4x4.multiply(SubMeshStaticBatch._tempMatrix4x40,transform.worldMatrix,worldMat);
				}else {
				worldMat=transform.worldMatrix;
			};
			var rotation=SubMeshStaticBatch._tempQuaternion0;
			worldMat.decomposeTransRotScale(SubMeshStaticBatch._tempVector30,rotation,SubMeshStaticBatch._tempVector31);
			var lightmapScaleOffset=render.lightmapScaleOffset;
			var vertexStart=subMesh._vertexStart;
			var vertexCount=subMesh._vertexCount;
			for (var i=0;i < vertexCount;i++){
				var oriOffset=(i+vertexStart)*oriVertexFloatCount;
				var bakeOffset=(i+batchOffset)*bakeVertexFloatCount;
				Utils3D.transformVector3ArrayToVector3ArrayCoordinate(oriVertexes,oriOffset+positionOffset,worldMat,batchVertices,bakeOffset+0);
				if (normalOffset!==-1)
					Utils3D.transformVector3ArrayByQuat(oriVertexes,oriOffset+normalOffset,rotation,batchVertices,bakeOffset+3);
				var j=0,m=0;
				var bakOff=bakeOffset+6;
				if (colorOffset!==-1){
					var oriOff=oriOffset+colorOffset;
					for (j=0,m=4;j < m;j++)
					batchVertices[bakOff+j]=oriVertexes[oriOff+j];
					}else {
					for (j=0,m=4;j < m;j++)
					batchVertices[bakOff+j]=1.0;
				}
				if (uv0Offset!==-1){
					var absUv0Offset=oriOffset+uv0Offset;
					batchVertices[bakeOffset+10]=oriVertexes[absUv0Offset];
					batchVertices[bakeOffset+11]=oriVertexes[absUv0Offset+1];
				}
				if (lightmapScaleOffset){
					if (uv1Offset!==-1)
						Utils3D.transformLightingMapTexcoordByUV1Array(oriVertexes,oriOffset+uv1Offset,lightmapScaleOffset,batchVertices,bakeOffset+12);
					else
					Utils3D.transformLightingMapTexcoordByUV0Array(oriVertexes,oriOffset+uv0Offset,lightmapScaleOffset,batchVertices,bakeOffset+12);
				}
				if (sTangentOffset!==-1){
					var absSTanegntOffset=oriOffset+sTangentOffset;
					batchVertices[bakeOffset+14]=oriVertexes[absSTanegntOffset];
					batchVertices[bakeOffset+15]=oriVertexes[absSTanegntOffset+1];
					batchVertices[bakeOffset+16]=oriVertexes[absSTanegntOffset+2];
					batchVertices[bakeOffset+17]=oriVertexes[absSTanegntOffset+3];
				}
			}
			return vertexCount;
		}

		/**
		*@inheritDoc
		*/
		__proto._compareBatchRenderElement=function(a,b){
			return (a)._batchIndexStart > (b)._batchIndexStart;
		}

		/**
		*@private
		*/
		__proto.addTest=function(renderElement){
			var vertexCount=0;
			var subMeshVertexCount=(renderElement.geometry)._vertexCount;
			vertexCount=this._currentBatchVertexCount+subMeshVertexCount;
			if (vertexCount > 65535)
				return false;
			return true;
		}

		/**
		*@private
		*/
		__proto.add=function(renderElement){
			var oldStaticBatch=renderElement.staticBatch;
			(oldStaticBatch)&& (oldStaticBatch.remove(),console.log("移除"));
			var subMesh=renderElement.geometry;
			var subMeshVertexCount=subMesh._vertexCount;
			this._batchElements.push(renderElement);
			renderElement.staticBatch=this;
			this._currentBatchIndexCount+=subMesh._indexCount;
			this._currentBatchVertexCount+=subMeshVertexCount;
		}

		/**
		*@private
		*/
		__proto.remove=function(renderElement){
			var subMesh=renderElement.geometry;
			var index=this._batchElements.indexOf(renderElement);
			if (index!==-1){
				this._batchElements.splice(index,1);
				renderElement.staticBatch=null;
				var subMeshVertexCount=subMesh._vertexCount;
				this._currentBatchIndexCount=this._currentBatchIndexCount-subMesh._indexCount;
				this._currentBatchVertexCount=this._currentBatchVertexCount-subMeshVertexCount;
			}
		}

		/**
		*@inheritDoc
		*/
		__proto.finishInit=function(){
			if (this._vertexBuffer){
				this._vertexBuffer.destroy();
				this._indexBuffer.destroy();
			};
			var batchVertexCount=0;
			var batchIndexCount=0;
			var floatStride=this._vertexDeclaration.vertexStride / 4;
			var vertexDatas=new Float32Array(floatStride *this._currentBatchVertexCount);
			var indexDatas=new Uint16Array(this._currentBatchIndexCount);
			this._vertexBuffer=new VertexBuffer3D(this._vertexDeclaration.vertexStride *this._currentBatchVertexCount,0x88E4);
			this._vertexBuffer.vertexDeclaration=this._vertexDeclaration;
			this._indexBuffer=IndexBuffer3D.create("ushort",this._currentBatchIndexCount,0x88E4);
			for (var i=0,n=this._batchElements.length;i < n;i++){
				var renderElement=this._batchElements [i];
				var subMesh=renderElement.geometry;
				var subMeshVerCount=this._getStaticBatchBakedVertexs(vertexDatas,batchVertexCount,this.rootOwner ? this.rootOwner._transform :null,renderElement.transform,(renderElement.render),subMesh);
				var subIndices=subMesh.getIndices();
				var indexOffset=batchVertexCount-subMesh._vertexStart;
				var indexEnd=batchIndexCount+subIndices.length;
				renderElement.staticBatchIndexStart=batchIndexCount;
				renderElement.staticBatchIndexEnd=indexEnd;
				indexDatas.set(subIndices,batchIndexCount);
				var k=0;
				var isInvert=this.rootOwner ? (renderElement.transform._isFrontFaceInvert!==this.rootOwner.transform._isFrontFaceInvert):renderElement.transform._isFrontFaceInvert;
				if (isInvert){
					for (k=batchIndexCount;k < indexEnd;k+=3){
						indexDatas[k]=indexOffset+indexDatas[k];
						var index1=indexDatas[k+1];
						var index2=indexDatas[k+2];
						indexDatas[k+1]=indexOffset+index2;
						indexDatas[k+2]=indexOffset+index1;
					}
					}else {
					for (k=batchIndexCount;k < indexEnd;k+=3){
						indexDatas[k]=indexOffset+indexDatas[k];
						indexDatas[k+1]=indexOffset+indexDatas[k+1];
						indexDatas[k+2]=indexOffset+indexDatas[k+2];
					}
				}
				batchIndexCount+=subIndices.length;
				batchVertexCount+=subMeshVerCount;
			}
			this._vertexBuffer.setData(vertexDatas);
			this._indexBuffer.setData(indexDatas);
			this._setVertexBuffer(this._vertexBuffer);
			this._setVertexBuffer(this._vertexBuffer);
		}

		/**
		*@inheritDoc
		*/
		__proto._prepareRender=function(state){
			return true;
		}

		/**
		*@inheritDoc
		*/
		__proto._render=function(state){
			this._indexBuffer.bind();
			var batchElementList=(state.renderElement).staticBatchElementList;
			var from=0;
			var end=0;
			for (var i=1,n=batchElementList.length;i < n;i++){
				var lastElement=batchElementList[i-1];
				var element=batchElementList[i];
				if (lastElement.staticBatchIndexEnd===element.staticBatchIndexStart){
					end++;
					continue ;
					}else {
					var start=batchElementList[from].staticBatchIndexStart;
					var indexCount=batchElementList[end].staticBatchIndexEnd-start;
					LayaGL.instance.drawElements(0x0004,indexCount,0x1403,start *2);
					from=++end;
					Stat.drawCall++;
					Stat.trianglesFaces+=indexCount / 3;
				}
			};
			var start=batchElementList[from].staticBatchIndexStart;
			var indexCount=batchElementList[end].staticBatchIndexEnd-start;
			LayaGL.instance.drawElements(0x0004,indexCount,0x1403,start *2);
			Stat.drawCall++;
			Stat.trianglesFaces+=indexCount / 3;
		}

		/**
		*@inheritDoc
		*/
		__proto.dispose=function(){
			_super.prototype.dispose.call(this);
			this._vertexDeclaration=null;
			this._vertexBuffer.destroy();
			this._indexBuffer.destroy();
		}

		__static(SubMeshStaticBatch,
		['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempQuaternion0',function(){return this._tempQuaternion0=new Quaternion();},'_tempMatrix4x40',function(){return this._tempMatrix4x40=new Matrix4x4();},'_tempMatrix4x41',function(){return this._tempMatrix4x41=new Matrix4x4();}
		]);
		return SubMeshStaticBatch;
	})(StaticBatch)


	/**
	*...
	*@author
	*/
	//class common.CameraMoveScript extends laya.d3.component.Script
	var CameraMoveScript=(function(_super){
		function CameraMoveScript(){
			this.lastMouseX=NaN;
			this.lastMouseY=NaN;
			this.isMouseDown=false;
			this.rotaionSpeed=0.00006;
			this.camera=null;
			this.scene=null;
			CameraMoveScript.__super.call(this);
			this._tempVector3=new Vector3();
			this.yawPitchRoll=new Vector3();
			this.resultRotation=new Quaternion();
			this.tempRotationZ=new Quaternion();
			this.tempRotationX=new Quaternion();
			this.tempRotationY=new Quaternion();
		}

		__class(CameraMoveScript,'common.CameraMoveScript',_super);
		var __proto=CameraMoveScript.prototype;
		__proto._initialize=function(owner){
			_super.prototype._initialize.call(this,owner);
			Laya.stage.on("mousedown",this,this.mouseDown);
			Laya.stage.on("mouseup",this,this.mouseUp);
			Laya.stage.on("mouseout",this,this.mouseOut);
			this.camera=owner;
		}

		__proto._update=function(state){
			_super.prototype._update.call(this,state);
			this.updateCamera(Laya.timer.delta);
		}

		__proto.mouseDown=function(e){
			this.camera.transform.localRotation.getYawPitchRoll(this.yawPitchRoll);
			this.lastMouseX=Laya.stage.mouseX;
			this.lastMouseY=Laya.stage.mouseY;
			this.isMouseDown=true;
		}

		__proto.mouseUp=function(e){
			this.isMouseDown=false;
		}

		__proto.mouseOut=function(e){
			this.isMouseDown=false;
		}

		/**
		*向前移动。
		*@param distance 移动距离。
		*/
		__proto.moveForward=function(distance){
			this._tempVector3.elements[0]=this._tempVector3.elements[1]=0;
			this._tempVector3.elements[2]=distance;
			this.camera.transform.translate(this._tempVector3);
		}

		/**
		*向右移动。
		*@param distance 移动距离。
		*/
		__proto.moveRight=function(distance){
			this._tempVector3.elements[1]=this._tempVector3.elements[2]=0;
			this._tempVector3.elements[0]=distance;
			this.camera.transform.translate(this._tempVector3);
		}

		/**
		*向上移动。
		*@param distance 移动距离。
		*/
		__proto.moveVertical=function(distance){
			this._tempVector3.elements[0]=this._tempVector3.elements[2]=0;
			this._tempVector3.elements[1]=distance;
			this.camera.transform.translate(this._tempVector3,false);
		}

		__proto.updateCamera=function(elapsedTime){
			if (!isNaN(this.lastMouseX)&& !isNaN(this.lastMouseY)){
				var scene=this.owner.scene;
				KeyBoardManager.hasKeyDown(87)&& this.moveForward(-0.005 *elapsedTime);
				KeyBoardManager.hasKeyDown(83)&& this.moveForward(0.005 *elapsedTime);
				KeyBoardManager.hasKeyDown(65)&& this.moveRight(-0.005 *elapsedTime);
				KeyBoardManager.hasKeyDown(68)&& this.moveRight(0.005 *elapsedTime);
				KeyBoardManager.hasKeyDown(81)&& this.moveVertical(0.005 *elapsedTime);
				KeyBoardManager.hasKeyDown(69)&& this.moveVertical(-0.005 *elapsedTime);
				if (this.isMouseDown){
					var offsetX=Laya.stage.mouseX-this.lastMouseX;
					var offsetY=Laya.stage.mouseY-this.lastMouseY;
					var yprElem=this.yawPitchRoll.elements;
					yprElem[0]-=offsetX *this.rotaionSpeed *elapsedTime;
					yprElem[1]-=offsetY *this.rotaionSpeed *elapsedTime;
					this.updateRotation();
				}
			}
			this.lastMouseX=Laya.stage.mouseX;
			this.lastMouseY=Laya.stage.mouseY;
		}

		__proto.updateRotation=function(){
			var yprElem=this.yawPitchRoll.elements;
			if (Math.abs(yprElem[1])< 1.50){
				Quaternion.createFromYawPitchRoll(yprElem[0],yprElem[1],yprElem[2],this.tempRotationZ);
				this.tempRotationZ.cloneTo(this.camera.transform.localRotation);
				this.camera.transform.localRotation=this.camera.transform.localRotation;
			}
		}

		return CameraMoveScript;
	})(Script)


	/**
	*<p> <code>Text</code> 类用于创建显示对象以显示文本。</p>
	*<p>
	*注意：如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。
	*</p>
	*@example
	*package
	*{
		*import laya.display.Text;
		*public class Text_Example
		*{
			*public function Text_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*onInit();
				*}
			*private function onInit():void
			*{
				*var text:Text=new Text();//创建一个 Text 类的实例对象 text 。
				*text.text="这个是一个 Text 文本示例。";
				*text.color="#008fff";//设置 text 的文本颜色。
				*text.font="Arial";//设置 text 的文本字体。
				*text.bold=true;//设置 text 的文本显示为粗体。
				*text.fontSize=30;//设置 text 的字体大小。
				*text.wordWrap=true;//设置 text 的文本自动换行。
				*text.x=100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
				*text.y=100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
				*text.width=300;//设置 text 的宽度。
				*text.height=200;//设置 text 的高度。
				*text.italic=true;//设置 text 的文本显示为斜体。
				*text.borderColor="#fff000";//设置 text 的文本边框颜色。
				*Laya.stage.addChild(text);//将 text 添加到显示列表。
				*}
			*}
		*}
	*@example
	*Text_Example();
	*function Text_Example()
	*{
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*onInit();
		*}
	*function onInit()
	*{
		*var text=new laya.display.Text();//创建一个 Text 类的实例对象 text 。
		*text.text="这个是一个 Text 文本示例。";
		*text.color="#008fff";//设置 text 的文本颜色。
		*text.font="Arial";//设置 text 的文本字体。
		*text.bold=true;//设置 text 的文本显示为粗体。
		*text.fontSize=30;//设置 text 的字体大小。
		*text.wordWrap=true;//设置 text 的文本自动换行。
		*text.x=100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
		*text.y=100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
		*text.width=300;//设置 text 的宽度。
		*text.height=200;//设置 text 的高度。
		*text.italic=true;//设置 text 的文本显示为斜体。
		*text.borderColor="#fff000";//设置 text 的文本边框颜色。
		*Laya.stage.addChild(text);//将 text 添加到显示列表。
		*}
	*@example
	*class Text_Example {
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*this.onInit();
			*}
		*private onInit():void {
			*var text:laya.display.Text=new laya.display.Text();//创建一个 Text 类的实例对象 text 。
			*text.text="这个是一个 Text 文本示例。";
			*text.color="#008fff";//设置 text 的文本颜色。
			*text.font="Arial";//设置 text 的文本字体。
			*text.bold=true;//设置 text 的文本显示为粗体。
			*text.fontSize=30;//设置 text 的字体大小。
			*text.wordWrap=true;//设置 text 的文本自动换行。
			*text.x=100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
			*text.y=100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
			*text.width=300;//设置 text 的宽度。
			*text.height=200;//设置 text 的高度。
			*text.italic=true;//设置 text 的文本显示为斜体。
			*text.borderColor="#fff000";//设置 text 的文本边框颜色。
			*Laya.stage.addChild(text);//将 text 添加到显示列表。
			*}
		*}
	*/
	//class laya.display.Text extends laya.display.Sprite
	var Text=(function(_super){
		function Text(){
			this._clipPoint=null;
			this._text=null;
			this._isChanged=false;
			this._textWidth=0;
			this._textHeight=0;
			this._lines=[];
			this._lineWidths=[];
			this._startX=NaN;
			this._startY=NaN;
			this._words=null;
			this._charSize={};
			this._valign="top";
			this._color="#000000";
			Text.__super.call(this);
			this._fontSize=Text.defaultFontSize;
			this._font=Text.defaultFont;
			this.overflow="visible";
			this._style=TextStyle.EMPTY;
		}

		__class(Text,'laya.display.Text',_super);
		var __proto=Text.prototype;
		/**
		*@private
		*获取样式。
		*@return 样式 Style 。
		*/
		__proto.getStyle=function(){
			this._style===TextStyle.EMPTY && (this._style=TextStyle.create());
			return this._style;
		}

		__proto._getTextStyle=function(){
			if (this._style===TextStyle.EMPTY){
				this._style=TextStyle.create();
			}
			return this._style;
		}

		/**@inheritDoc */
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			_super.prototype.destroy.call(this,destroyChild);
			this._clipPoint=null;
			this._lines=null;
			this._lineWidths=null;
			this._words=null;
			this._charSize=null;
		}

		/**
		*@private
		*@inheritDoc
		*/
		__proto._getBoundPointsM=function(ifRotate){
			(ifRotate===void 0)&& (ifRotate=false);
			var rec=Rectangle.TEMP;
			rec.setTo(0,0,this.width,this.height);
			return rec._getBoundPoints();
		}

		/**
		*@inheritDoc
		*/
		__proto.getGraphicBounds=function(realSize){
			(realSize===void 0)&& (realSize=false);
			var rec=Rectangle.TEMP;
			rec.setTo(0,0,this.width,this.height);
			return rec;
		}

		/**
		*@private
		*/
		__proto._getCSSStyle=function(){
			return this._style;
		}

		/**
		*<p>根据指定的文本，从语言包中取当前语言的文本内容。并对此文本中的{i}文本进行替换。</p>
		*<p>设置Text.langPacks语言包后，即可使用lang获取里面的语言</p>
		*<p>例如：
		*<li>（1）text 的值为“我的名字”，先取到这个文本对应的当前语言版本里的值“My name”，将“My name”设置为当前文本的内容。</li>
		*<li>（2）text 的值为“恭喜你赢得{0}个钻石，{1}经验。”，arg1 的值为100，arg2 的值为200。
		*则先取到这个文本对应的当前语言版本里的值“Congratulations on your winning {0}diamonds,{1}experience.”，
		*然后将文本里的{0}、{1}，依据括号里的数字从0开始替换为 arg1、arg2 的值。
		*将替换处理后的文本“Congratulations on your winning 100 diamonds,200 experience.”设置为当前文本的内容。
		*</li>
		*</p>
		*@param text 文本内容。
		*@param ...args 文本替换参数。
		*/
		__proto.lang=function(text,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10){
			text=Text.langPacks && Text.langPacks[text] ? Text.langPacks[text] :text;
			if (arguments.length < 2){
				this._text=text;
				}else {
				for (var i=0,n=arguments.length;i < n;i++){
					text=text.replace("{"+i+"}",arguments[i+1]);
				}
				this._text=text;
			}
		}

		/**
		*@private
		*/
		__proto._getContextFont=function(){
			return (this.italic ? "italic " :"")+(this.bold ? "bold " :"")+this.fontSize+"px "+(Browser.onIPhone ? (laya.display.Text.fontFamilyMap[this.font] || this.font):this.font);
		}

		/**
		*@private
		*渲染文字。
		*@param begin 开始渲染的行索引。
		*@param visibleLineCount 渲染的行数。
		*/
		__proto._renderText=function(){
			var padding=this.padding;
			var visibleLineCount=this._lines.length;
			if (this.overflow !="visible"){
				visibleLineCount=Math.min(visibleLineCount,Math.floor((this.height-padding[0]-padding[2])/ (this.leading+this._charSize.height))+1);
			};
			var beginLine=this.scrollY / (this._charSize.height+this.leading)| 0;
			var graphics=this.graphics;
			graphics.clear(true);
			var ctxFont=this._getContextFont();
			Browser.context.font=ctxFont;
			var startX=padding[3];
			var textAlgin="left";
			var lines=this._lines;
			var lineHeight=this.leading+this._charSize.height;
			var tCurrBitmapFont=(this._style).currBitmapFont;
			if (tCurrBitmapFont){
				lineHeight=this.leading+tCurrBitmapFont.getMaxHeight();
			};
			var startY=padding[0];
			if ((!tCurrBitmapFont)&& this._width > 0 && this._textWidth <=this._width){
				if (this.align=="right"){
					textAlgin="right";
					startX=this._width-padding[1];
					}else if (this.align=="center"){
					textAlgin="center";
					startX=this._width *0.5+padding[3]-padding[1];
				}
			}
			if (this._height > 0){
				var tempVAlign=(this._textHeight > this._height)? "top" :this.valign;
				if (tempVAlign==="middle")
					startY=(this._height-visibleLineCount *lineHeight)*0.5+padding[0]-padding[2];
				else if (tempVAlign==="bottom")
				startY=this._height-visibleLineCount *lineHeight-padding[2];
			};
			var style=this._style;
			if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize){
				var bitmapScale=tCurrBitmapFont.fontSize / this.fontSize;
			}
			if (this._clipPoint){
				graphics.save();
				if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize){
					var tClipWidth=0;
					var tClipHeight=0;
					this._width ? tClipWidth=(this._width-padding[3]-padding[1]):tClipWidth=this._textWidth;
					this._height ? tClipHeight=(this._height-padding[0]-padding[2]):tClipHeight=this._textHeight;
					tClipWidth *=bitmapScale;
					tClipHeight *=bitmapScale;
					graphics.clipRect(padding[3],padding[0],tClipWidth,tClipHeight);
					}else {
					graphics.clipRect(padding[3],padding[0],this._width ? (this._width-padding[3]-padding[1]):this._textWidth,this._height ? (this._height-padding[0]-padding[2]):this._textHeight);
				}
				this.repaint();
			};
			var password=style.asPassword;
			if (("prompt" in this)&& this['prompt']==this._text)
				password=false;
			var x=0,y=0;
			var end=Math.min(this._lines.length,visibleLineCount+beginLine)|| 1;
			for (var i=beginLine;i < end;i++){
				var word=lines[i];
				var _word;
				if (password){
					var len=word.length;
					word="";
					for (var j=len;j > 0;j--){
						word+="●";
					}
				}
				x=startX-(this._clipPoint ? this._clipPoint.x :0);
				y=startY+lineHeight *i-(this._clipPoint ? this._clipPoint.y :0);
				this.underline && this._drawUnderline(textAlgin,x,y,i);
				if (tCurrBitmapFont){
					var tWidth=this.width;
					if (tCurrBitmapFont.autoScaleSize){
						tWidth=this.width *bitmapScale;
					}
					tCurrBitmapFont._drawText(word,this,x,y,this.align,tWidth);
					}else {
					if (Render.isWebGL){
						this._words || (this._words=[]);
						_word=this._words.length > (i-beginLine)? this._words[i-beginLine] :new WordText();
						_word.setText(word);
						}else {
						_word=word;
					}
					style.stroke ? graphics.fillBorderText(_word,x,y,ctxFont,this.color,style.strokeColor,style.stroke,textAlgin):graphics.fillText(_word,x,y,ctxFont,this.color,textAlgin);
				}
			}
			if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize){
				var tScale=1 / bitmapScale;
				this.scale(tScale,tScale);
			}
			if (this._clipPoint)graphics.restore();
			this._startX=startX;
			this._startY=startY;
		}

		/**
		*@private
		*绘制下划线
		*@param x 本行坐标
		*@param y 本行坐标
		*@param lineIndex 本行索引
		*/
		__proto._drawUnderline=function(align,x,y,lineIndex){
			var lineWidth=this._lineWidths[lineIndex];
			switch (align){
				case 'center':
					x-=lineWidth / 2;
					break ;
				case 'right':
					x-=lineWidth;
					break ;
				case 'left':
				default :
					break ;
				}
			y+=this._charSize.height;
			this._graphics.drawLine(x,y,x+lineWidth,y,this.underlineColor || this.color,1);
		}

		/**
		*<p>排版文本。</p>
		*<p>进行宽高计算，渲染、重绘文本。</p>
		*/
		__proto.typeset=function(){
			this._isChanged=false;
			if (!this._text){
				this._clipPoint=null;
				this._textWidth=this._textHeight=0;
				this.graphics.clear(true);
				return;
			}
			Browser.context.font=this._getContextFont();
			this._lines.length=0;
			this._lineWidths.length=0;
			this._parseLines(this._text);
			this._evalTextSize();
			if (this._checkEnabledViewportOrNot())this._clipPoint || (this._clipPoint=new Point(0,0));
			else this._clipPoint=null;
			this._renderText();
		}

		/**@private */
		__proto._evalTextSize=function(){
			var nw=NaN,nh=NaN;
			nw=Math.max.apply(this,this._lineWidths);
			if ((this._style).currBitmapFont)
				nh=this._lines.length *((this._style).currBitmapFont.getMaxHeight()+this.leading)+this.padding[0]+this.padding[2];
			else
			nh=this._lines.length *(this._charSize.height+this.leading)+this.padding[0]+this.padding[2];
			if (nw !=this._textWidth || nh !=this._textHeight){
				this._textWidth=nw;
				this._textHeight=nh;
			}
		}

		/**@private */
		__proto._checkEnabledViewportOrNot=function(){
			return this.overflow=="scroll" && ((this._width > 0 && this._textWidth > this._width)|| (this._height > 0 && this._textHeight > this._height));
		}

		/**
		*<p>快速更改显示文本。不进行排版计算，效率较高。</p>
		*<p>如果只更改文字内容，不更改文字样式，建议使用此接口，能提高效率。</p>
		*@param text 文本内容。
		*/
		__proto.changeText=function(text){
			if (this._text!==text){
				this.lang(text+"");
				if (this._graphics && this._graphics.replaceText(this._text)){
					}else {
					this.typeset();
				}
			}
		}

		/**
		*@private
		*分析文本换行。
		*/
		__proto._parseLines=function(text){
			var needWordWrapOrTruncate=this.wordWrap || this.overflow=="hidden";
			if (needWordWrapOrTruncate){
				var wordWrapWidth=this._getWordWrapWidth();
			};
			var bitmapFont=(this._style).currBitmapFont;
			if (bitmapFont){
				this._charSize.width=bitmapFont.getMaxWidth();
				this._charSize.height=bitmapFont.getMaxHeight();
				}else {
				var measureResult=Browser.context.measureText(Text._testWord);
				this._charSize.width=measureResult.width;
				this._charSize.height=(measureResult.height || this.fontSize);
			};
			var lines=text.replace(/\r\n/g,"\n").split("\n");
			for (var i=0,n=lines.length;i < n;i++){
				var line=lines[i];
				if (needWordWrapOrTruncate)
					this._parseLine(line,wordWrapWidth);
				else {
					this._lineWidths.push(this._getTextWidth(line));
					this._lines.push(line);
				}
			}
		}

		/**
		*@private
		*解析行文本。
		*@param line 某行的文本。
		*@param wordWrapWidth 文本的显示宽度。
		*/
		__proto._parseLine=function(line,wordWrapWidth){
			var ctx=Browser.context;
			var lines=this._lines;
			var maybeIndex=0;
			var execResult;
			var charsWidth=NaN;
			var wordWidth=NaN;
			var startIndex=0;
			charsWidth=this._getTextWidth(line);
			if (charsWidth <=wordWrapWidth){
				lines.push(line);
				this._lineWidths.push(charsWidth);
				return;
			}
			charsWidth=this._charSize.width;
			maybeIndex=Math.floor(wordWrapWidth / charsWidth);
			(maybeIndex==0)&& (maybeIndex=1);
			charsWidth=this._getTextWidth(line.substring(0,maybeIndex));
			wordWidth=charsWidth;
			for (var j=maybeIndex,m=line.length;j < m;j++){
				charsWidth=this._getTextWidth(line.charAt(j));
				wordWidth+=charsWidth;
				if (wordWidth > wordWrapWidth){
					if (this.wordWrap){
						var newLine=line.substring(startIndex,j);
						if (newLine.charCodeAt(newLine.length-1)< 255){
							execResult=/(?:\w|-)+$/.exec(newLine);
							if (execResult){
								j=execResult.index+startIndex;
								if (execResult.index==0)j+=newLine.length;
								else newLine=line.substring(startIndex,j);
							}
						}
						lines.push(newLine);
						this._lineWidths.push(wordWidth-charsWidth);
						startIndex=j;
						if (j+maybeIndex < m){
							j+=maybeIndex;
							charsWidth=this._getTextWidth(line.substring(startIndex,j));
							wordWidth=charsWidth;
							j--;
							}else {
							lines.push(line.substring(startIndex,m));
							this._lineWidths.push(this._getTextWidth(lines[lines.length-1]));
							startIndex=-1;
							break ;
						}
						}else if (this.overflow=="hidden"){
						lines.push(line.substring(0,j));
						this._lineWidths.push(this._getTextWidth(lines[lines.length-1]));
						return;
					}
				}
			}
			if (this.wordWrap && startIndex !=-1){
				lines.push(line.substring(startIndex,m));
				this._lineWidths.push(this._getTextWidth(lines[lines.length-1]));
			}
		}

		/**@private */
		__proto._getTextWidth=function(text){
			var bitmapFont=(this._style).currBitmapFont;
			if (bitmapFont)return bitmapFont.getTextWidth(text);
			else return Browser.context.measureText(text).width;
		}

		/**
		*@private
		*获取换行所需的宽度。
		*/
		__proto._getWordWrapWidth=function(){
			var p=this.padding;
			var w=NaN;
			var bitmapFont=(this._style).currBitmapFont;
			if (bitmapFont && bitmapFont.autoScaleSize)w=this._width *(bitmapFont.fontSize / this.fontSize);
			else w=this._width;
			if (w <=0){
				w=this.wordWrap ? 100 :Browser.width;
			}
			w <=0 && (w=100);
			return w-p[3]-p[1];
		}

		/**
		*返回字符在本类实例的父坐标系下的坐标。
		*@param charIndex 索引位置。
		*@param out （可选）输出的Point引用。
		*@return Point 字符在本类实例的父坐标系下的坐标。如果out参数不为空，则将结果赋值给指定的Point对象，否则创建一个新的Point对象返回。建议使用Point.TEMP作为out参数，可以省去Point对象创建和垃圾回收的开销，尤其是在需要频繁执行的逻辑中，比如帧循环和MOUSE_MOVE事件回调函数里面。
		*/
		__proto.getCharPoint=function(charIndex,out){
			this._isChanged && Laya.timer.runCallLater(this,this.typeset);
			var len=0,lines=this._lines,startIndex=0;
			for (var i=0,n=lines.length;i < n;i++){
				len+=lines[i].length;
				if (charIndex < len){
					var line=i;
					break ;
				}
				startIndex=len;
			};
			var ctxFont=(this.italic ? "italic " :"")+(this.bold ? "bold " :"")+this.fontSize+"px "+this.font;
			Browser.context.font=ctxFont;
			var width=this._getTextWidth(this._text.substring(startIndex,charIndex));
			var point=out || new Point();
			return point.setTo(this._startX+width-(this._clipPoint ? this._clipPoint.x :0),this._startY+line *(this._charSize.height+this.leading)-(this._clipPoint ? this._clipPoint.y :0));
		}

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'width',function(){
			if (this._width)return this._width;
			return this.textWidth+this.padding[1]+this.padding[3];
			},function(value){
			if (value !=this._width){
				_super.prototype._$set_width.call(this,value);
				this.isChanged=true;
			}
		});

		/**
		*表示文本的宽度，以像素为单位。
		*/
		__getset(0,__proto,'textWidth',function(){
			this._isChanged && Laya.timer.runCallLater(this,this.typeset);
			return this._textWidth;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'height',function(){
			if (this._height)return this._height;
			return this.textHeight+this.padding[0]+this.padding[2];
			},function(value){
			if (value !=this._height){
				_super.prototype._$set_height.call(this,value);
				this.isChanged=true;
			}
		});

		/**
		*表示文本的高度，以像素为单位。
		*/
		__getset(0,__proto,'textHeight',function(){
			this._isChanged && Laya.timer.runCallLater(this,this.typeset);
			return this._textHeight;
		});

		/**
		*<p>边距信息。</p>
		*<p>数据格式：[上边距，右边距，下边距，左边距]（边距以像素为单位）。</p>
		*/
		__getset(0,__proto,'padding',function(){
			return (this._style).padding;
			},function(value){
			this._getTextStyle().padding=value;
			this.isChanged=true;
		});

		/**
		*<p>指定文本是否为粗体字。</p>
		*<p>默认值为 false，这意味着不使用粗体字。如果值为 true，则文本为粗体字。</p>
		*/
		__getset(0,__proto,'bold',function(){
			return (this._style).bold;
			},function(value){
			this._getTextStyle().bold=value;
			this.isChanged=true;
		});

		/**当前文本的内容字符串。*/
		__getset(0,__proto,'text',function(){
			return this._text || "";
			},function(value){
			if (this._text!==value){
				this.lang(value+"");
				this.isChanged=true;
				this.event("change");
			}
		});

		/**
		*<p>表示文本的颜色值。可以通过 <code>Text.defaultColor</code> 设置默认颜色。</p>
		*<p>默认值为黑色。</p>
		*/
		__getset(0,__proto,'color',function(){
			return this._color;
			},function(value){
			if (this._color !=value){
				this._color=value;
				if (!this._isChanged && this._graphics){
					this._graphics.replaceTextColor(this.color)
					}else {
					this.isChanged=true;
				}
			}
		});

		/**
		*<p>文本的字体名称，以字符串形式表示。</p>
		*<p>默认值为："Arial"，可以通过Text.defaultFont设置默认字体。</p>
		*<p>如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。</p>
		*@see laya.display.Text#defaultFont
		*/
		__getset(0,__proto,'font',function(){
			return this._font;
			},function(value){
			if ((this._style).currBitmapFont){
				this._getTextStyle().currBitmapFont=null;
				this.scale(1,1);
			}
			if (Text._bitmapFonts && Text._bitmapFonts[value]){
				this._getTextStyle().currBitmapFont=Text._bitmapFonts[value];
			}
			this._font=value;
			this.isChanged=true;
		});

		/**
		*<p>指定文本的字体大小（以像素为单位）。</p>
		*<p>默认为20像素，可以通过 <code>Text.defaultFontSize</code> 设置默认大小。</p>
		*/
		__getset(0,__proto,'fontSize',function(){
			return this._fontSize;
			},function(value){
			this._fontSize=value;
			this.isChanged=true;
		});

		/**
		*<p>表示使用此文本格式的文本是否为斜体。</p>
		*<p>默认值为 false，这意味着不使用斜体。如果值为 true，则文本为斜体。</p>
		*/
		__getset(0,__proto,'italic',function(){
			return (this._style).italic;
			},function(value){
			this._getTextStyle().italic=value;
			this.isChanged=true;
		});

		/**
		*<p>表示文本的水平显示方式。</p>
		*<p><b>取值：</b>
		*<li>"left"： 居左对齐显示。</li>
		*<li>"center"： 居中对齐显示。</li>
		*<li>"right"： 居右对齐显示。</li>
		*</p>
		*/
		__getset(0,__proto,'align',function(){
			return (this._style).align;
			},function(value){
			this._getTextStyle().align=value;
			this.isChanged=true;
		});

		/**
		*<p>表示文本的垂直显示方式。</p>
		*<p><b>取值：</b>
		*<li>"top"： 居顶部对齐显示。</li>
		*<li>"middle"： 居中对齐显示。</li>
		*<li>"bottom"： 居底部对齐显示。</li>
		*</p>
		*/
		__getset(0,__proto,'valign',function(){
			return this._valign;
			},function(value){
			this._valign=value;
			this.isChanged=true;
		});

		/**
		*<p>表示文本是否自动换行，默认为false。</p>
		*<p>若值为true，则自动换行；否则不自动换行。</p>
		*/
		__getset(0,__proto,'wordWrap',function(){
			return (this._style).wordWrap;
			},function(value){
			this._getTextStyle().wordWrap=value;
			this.isChanged=true;
		});

		/**
		*垂直行间距（以像素为单位）。
		*/
		__getset(0,__proto,'leading',function(){
			return (this._style).leading;
			},function(value){
			this._getTextStyle().leading=value;
			this.isChanged=true;
		});

		/**
		*文本背景颜色，以字符串表示。
		*/
		__getset(0,__proto,'bgColor',function(){
			return (this._style).bgColor;
			},function(value){
			this._getTextStyle().bgColor=value;
			this._renderType |=0x80;
			this.isChanged=true;
		});

		/**
		*文本边框背景颜色，以字符串表示。
		*/
		__getset(0,__proto,'borderColor',function(){
			return (this._style).borderColor;
			},function(value){
			this._getTextStyle().borderColor=value;
			this._renderType |=0x80;
			this.isChanged=true;
		});

		/**
		*<p>描边宽度（以像素为单位）。</p>
		*<p>默认值0，表示不描边。</p>
		*/
		__getset(0,__proto,'stroke',function(){
			return (this._style).stroke;
			},function(value){
			this._getTextStyle().stroke=value;
			this.isChanged=true;
		});

		/**
		*<p>描边颜色，以字符串表示。</p>
		*<p>默认值为 "#000000"（黑色）;</p>
		*/
		__getset(0,__proto,'strokeColor',function(){
			return (this._style).strokeColor;
			},function(value){
			this._getTextStyle().strokeColor=value;
			this.isChanged=true;
		});

		/**
		*@private
		*一个布尔值，表示文本的属性是否有改变。若为true表示有改变。
		*/
		__getset(0,__proto,'isChanged',null,function(value){
			if (this._isChanged!==value){
				this._isChanged=value;
				value && Laya.timer.callLater(this,this.typeset);
			}
		});

		/**
		*<p>设置横向滚动量。</p>
		*<p>即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。</p>
		*/
		/**
		*获取横向滚动量。
		*/
		__getset(0,__proto,'scrollX',function(){
			if (!this._clipPoint)return 0;
			return this._clipPoint.x;
			},function(value){
			if (this.overflow !="scroll" || (this.textWidth < this._width || !this._clipPoint))return;
			value=value < this.padding[3] ? this.padding[3] :value;
			var maxScrollX=this._textWidth-this._width;
			value=value > maxScrollX ? maxScrollX :value;
			this._clipPoint.x=value;
			this._renderText();
		});

		/**
		*设置纵向滚动量（px)。即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。
		*/
		/**
		*获取纵向滚动量。
		*/
		__getset(0,__proto,'scrollY',function(){
			if (!this._clipPoint)return 0;
			return this._clipPoint.y;
			},function(value){
			if (this.overflow !="scroll" || (this.textHeight < this._height || !this._clipPoint))return;
			value=value < this.padding[0] ? this.padding[0] :value;
			var maxScrollY=this._textHeight-this._height;
			value=value > maxScrollY ? maxScrollY :value;
			this._clipPoint.y=value;
			this._renderText();
		});

		/**
		*获取横向可滚动最大值。
		*/
		__getset(0,__proto,'maxScrollX',function(){
			return (this.textWidth < this._width)? 0 :this._textWidth-this._width;
		});

		/**
		*获取纵向可滚动最大值。
		*/
		__getset(0,__proto,'maxScrollY',function(){
			return (this.textHeight < this._height)? 0 :this._textHeight-this._height;
		});

		/**返回文字行信息*/
		__getset(0,__proto,'lines',function(){
			if (this._isChanged)this.typeset();
			return this._lines;
		});

		/**下划线的颜色，为null则使用字体颜色。*/
		__getset(0,__proto,'underlineColor',function(){
			return (this._style).underlineColor;
			},function(value){
			this._getTextStyle().underlineColor=value;
			if (!this._isChanged)this._renderText();
		});

		/**是否显示下划线。*/
		__getset(0,__proto,'underline',function(){
			return (this._style).underline;
			},function(value){
			this._getTextStyle().underline=value;
		});

		Text.defaultFontStr=function(){
			return Text.defaultFontSize+"px "+Text.defaultFont;
		}

		Text.registerBitmapFont=function(name,bitmapFont){
			Text._bitmapFonts || (Text._bitmapFonts={});
			Text._bitmapFonts[name]=bitmapFont;
		}

		Text.unregisterBitmapFont=function(name,destroy){
			(destroy===void 0)&& (destroy=true);
			if (Text._bitmapFonts && Text._bitmapFonts[name]){
				var tBitmapFont=Text._bitmapFonts[name];
				if (destroy)tBitmapFont.destroy();
				delete Text._bitmapFonts[name];
			}
		}

		Text.VISIBLE="visible";
		Text.SCROLL="scroll";
		Text.HIDDEN="hidden";
		Text.defaultFontSize=12;
		Text.defaultFont="Arial";
		Text.langPacks=null
		Text.isComplexText=false;
		Text._testWord="游";
		Text._bitmapFonts=null
		Text.CharacterCache=true;
		__static(Text,
		['fontFamilyMap',function(){return this.fontFamilyMap={"报隶":"报隶-简","黑体":"黑体-简","楷体":"楷体-简","兰亭黑":"兰亭黑-简","隶变":"隶变-简","凌慧体":"凌慧体-简","翩翩体":"翩翩体-简","苹方":"苹方-简","手札体":"手札体-简","宋体":"宋体-简","娃娃体":"娃娃体-简","魏碑":"魏碑-简","行楷":"行楷-简","雅痞":"雅痞-简","圆体":"圆体-简"};}
		]);
		return Text;
	})(Sprite)


	/**
	*<p> <code>Stage</code> 是舞台类，显示列表的根节点，所有显示对象都在舞台上显示。通过 Laya.stage 单例访问。</p>
	*<p>Stage提供几种适配模式，不同的适配模式会产生不同的画布大小，画布越大，渲染压力越大，所以要选择合适的适配方案。</p>
	*<p>Stage提供不同的帧率模式，帧率越高，渲染压力越大，越费电，合理使用帧率甚至动态更改帧率有利于改进手机耗电。</p>
	*/
	//class laya.display.Stage extends laya.display.Sprite
	var Stage=(function(_super){
		function Stage(){
			this.focus=null;
			this.frameRate="fast";
			this.designWidth=0;
			this.designHeight=0;
			this.canvasRotation=false;
			this.canvasDegree=0;
			this.renderingEnabled=true;
			this.screenAdaptationEnabled=true;
			this._screenMode="none";
			this._scaleMode="noscale";
			this._alignV="top";
			this._alignH="left";
			this._bgColor="black";
			this._mouseMoveTime=0;
			this._renderCount=0;
			this._safariOffsetY=0;
			this._frameStartTime=NaN;
			this._isFocused=false;
			this._isVisibility=false;
			this._scenes=null;
			this._wgColor=null;
			Stage.__super.call(this);
			this.offset=new Point();
			this._canvasTransform=new Matrix();
			this._previousOrientation=Browser.window.orientation;
			var _$this=this;
			this.transform=Matrix.create();
			this._scenes=[];
			this.mouseEnabled=true;
			this.hitTestPrior=true;
			this.autoSize=false;
			this._setBit(0x08,true);
			this._isFocused=true;
			this._isVisibility=true;
			var window=Browser.window;
			var _this=this;
			window.addEventListener("focus",function(){
				_$this._isFocused=true;
				_this.event("focus");
				_this.event("focuschange");
			});
			window.addEventListener("blur",function(){
				_$this._isFocused=false;
				_this.event("blur");
				_this.event("focuschange");
				if (_this._isInputting())Input["inputElement"].target.focus=false;
			});
			var hidden="hidden",state="visibilityState",visibilityChange="visibilitychange";
			var document=window.document;
			if (typeof document.hidden!=="undefined"){
				visibilityChange="visibilitychange";
				state="visibilityState";
				}else if (typeof document.mozHidden!=="undefined"){
				visibilityChange="mozvisibilitychange";
				state="mozVisibilityState";
				}else if (typeof document.msHidden!=="undefined"){
				visibilityChange="msvisibilitychange";
				state="msVisibilityState";
				}else if (typeof document.webkitHidden!=="undefined"){
				visibilityChange="webkitvisibilitychange";
				state="webkitVisibilityState";
			}
			window.document.addEventListener(visibilityChange,visibleChangeFun);
			function visibleChangeFun (){
				if (Browser.document[state]=="hidden"){
					_$this._isVisibility=false;
					if (_this._isInputting())Input["inputElement"].target.focus=false;
					}else {
					_$this._isVisibility=true;
				}
				_this.event("visibilitychange");
			}
			window.addEventListener("resize",function(){
				var orientation=Browser.window.orientation;
				if (orientation !=null && orientation !=_$this._previousOrientation && _this._isInputting()){
					Input["inputElement"].target.focus=false;
				}
				_$this._previousOrientation=orientation;
				if (_this._isInputting())return;
				if (Browser.onSafari)
					_this._safariOffsetY=(Browser.window.__innerHeight || Browser.document.body.clientHeight || Browser.document.documentElement.clientHeight)-Browser.window.innerHeight;
				_this._resetCanvas();
			});
			window.addEventListener("orientationchange",function(e){
				_this._resetCanvas();
			});
			this.on("mousemove",this,this._onmouseMove);
			if (Browser.onMobile)this.on("mousedown",this,this._onmouseMove);
		}

		__class(Stage,'laya.display.Stage',_super);
		var __proto=Stage.prototype;
		/**
		*@private
		*在移动端输入时，输入法弹出期间不进行画布尺寸重置。
		*/
		__proto._isInputting=function(){
			return (Browser.onMobile && Input.isInputting);
		}

		/**@private */
		__proto._changeCanvasSize=function(){
			this.setScreenSize(Browser.clientWidth *Browser.pixelRatio,Browser.clientHeight *Browser.pixelRatio);
		}

		/**@private */
		__proto._resetCanvas=function(){
			if (!this.screenAdaptationEnabled)return;
			var canvas=Render._mainCanvas;
			var canvasStyle=canvas.source.style;
			canvas.size(1,1);
			Laya.timer.once(100,this,this._changeCanvasSize);
		}

		/**
		*设置屏幕大小，场景会根据屏幕大小进行适配。可以动态调用此方法，来更改游戏显示的大小。
		*@param screenWidth 屏幕宽度。
		*@param screenHeight 屏幕高度。
		*/
		__proto.setScreenSize=function(screenWidth,screenHeight){
			var rotation=false;
			if (this._screenMode!=="none"){
				var screenType=screenWidth / screenHeight < 1 ? "vertical" :"horizontal";
				rotation=screenType!==this._screenMode;
				if (rotation){
					var temp=screenHeight;
					screenHeight=screenWidth;
					screenWidth=temp;
				}
			}
			this.canvasRotation=rotation;
			var canvas=Render._mainCanvas;
			var canvasStyle=canvas.source.style;
			var mat=this._canvasTransform.identity();
			var scaleMode=this._scaleMode;
			var scaleX=screenWidth / this.designWidth;
			var scaleY=screenHeight / this.designHeight;
			var canvasWidth=this.designWidth;
			var canvasHeight=this.designHeight;
			var realWidth=screenWidth;
			var realHeight=screenHeight;
			var pixelRatio=Browser.pixelRatio;
			this._width=this.designWidth;
			this._height=this.designHeight;
			switch (scaleMode){
				case "noscale":
					scaleX=scaleY=1;
					realWidth=this.designWidth;
					realHeight=this.designHeight;
					break ;
				case "showall":
					scaleX=scaleY=Math.min(scaleX,scaleY);
					canvasWidth=realWidth=Math.round(this.designWidth *scaleX);
					canvasHeight=realHeight=Math.round(this.designHeight *scaleY);
					break ;
				case "noborder":
					scaleX=scaleY=Math.max(scaleX,scaleY);
					realWidth=Math.round(this.designWidth *scaleX);
					realHeight=Math.round(this.designHeight *scaleY);
					break ;
				case "full":
					scaleX=scaleY=1;
					this._width=canvasWidth=screenWidth;
					this._height=canvasHeight=screenHeight;
					break ;
				case "fixedwidth":
					scaleY=scaleX;
					this._height=canvasHeight=Math.round(screenHeight / scaleX);
					break ;
				case "fixedheight":
					scaleX=scaleY;
					this._width=canvasWidth=Math.round(screenWidth / scaleY);
					break ;
				case "fixedauto":
					if ((screenWidth / screenHeight)< (this.designWidth / this.designHeight)){
						scaleY=scaleX;
						this._height=canvasHeight=Math.round(screenHeight / scaleX);
						}else {
						scaleX=scaleY;
						this._width=canvasWidth=Math.round(screenWidth / scaleY);
					}
					break ;
				}
			scaleX *=this.scaleX;
			scaleY *=this.scaleY;
			if (scaleX===1 && scaleY===1){
				this.transform.identity();
				}else {
				this.transform.a=this._formatData(scaleX / (realWidth / canvasWidth));
				this.transform.d=this._formatData(scaleY / (realHeight / canvasHeight));
			}
			canvas.size(canvasWidth,canvasHeight);
			RunDriver.changeWebGLSize(canvasWidth,canvasHeight);
			mat.scale(realWidth / canvasWidth / pixelRatio,realHeight / canvasHeight / pixelRatio);
			if (this._alignH==="left")this.offset.x=0;
			else if (this._alignH==="right")this.offset.x=screenWidth-realWidth;
			else this.offset.x=(screenWidth-realWidth)*0.5 / pixelRatio;
			if (this._alignV==="top")this.offset.y=0;
			else if (this._alignV==="bottom")this.offset.y=screenHeight-realHeight;
			else this.offset.y=(screenHeight-realHeight)*0.5 / pixelRatio;
			this.offset.x=Math.round(this.offset.x);
			this.offset.y=Math.round(this.offset.y);
			mat.translate(this.offset.x,this.offset.y);
			if (this._safariOffsetY)mat.translate(0,this._safariOffsetY);
			this.canvasDegree=0;
			if (rotation){
				if (this._screenMode==="horizontal"){
					mat.rotate(Math.PI / 2);
					mat.translate(screenHeight / pixelRatio,0);
					this.canvasDegree=90;
					}else {
					mat.rotate(-Math.PI / 2);
					mat.translate(0,screenWidth / pixelRatio);
					this.canvasDegree=-90;
				}
			}
			mat.a=this._formatData(mat.a);
			mat.d=this._formatData(mat.d);
			mat.tx=this._formatData(mat.tx);
			mat.ty=this._formatData(mat.ty);
			canvasStyle.transformOrigin=canvasStyle.webkitTransformOrigin=canvasStyle.msTransformOrigin=canvasStyle.mozTransformOrigin=canvasStyle.oTransformOrigin="0px 0px 0px";
			canvasStyle.transform=canvasStyle.webkitTransform=canvasStyle.msTransform=canvasStyle.mozTransform=canvasStyle.oTransform="matrix("+mat.toString()+")";
			if (this._safariOffsetY)mat.translate(0,-this._safariOffsetY);
			mat.translate(parseInt(canvasStyle.left)|| 0,parseInt(canvasStyle.top)|| 0);
			this.visible=true;
			this._repaint |=0x02;
			this.event("resize");
		}

		/**@private */
		__proto._formatData=function(value){
			if (Math.abs(value)< 0.000001)return 0;
			if (Math.abs(1-value)< 0.001)return value > 0 ? 1 :-1;
			return value;
		}

		/**@inheritDoc */
		__proto.getMousePoint=function(){
			return Point.TEMP.setTo(this.mouseX,this.mouseY);
		}

		/**@inheritDoc */
		__proto.repaint=function(type){
			(type===void 0)&& (type=0x02);
			this._repaint=type;
		}

		/**@inheritDoc */
		__proto.parentRepaint=function(type){
			(type===void 0)&& (type=0x02);
		}

		/**@private */
		__proto._loop=function(){
			this.render(Render._context,0,0);
			return true;
		}

		/**@private */
		__proto._onmouseMove=function(e){
			this._mouseMoveTime=Browser.now();
		}

		/**
		*<p>获得距当前帧开始后，过了多少时间，单位为毫秒。</p>
		*<p>可以用来判断函数内时间消耗，通过合理控制每帧函数处理消耗时长，避免一帧做事情太多，对复杂计算分帧处理，能有效降低帧率波动。</p>
		*/
		__proto.getTimeFromFrameStart=function(){
			return Browser.now()-this._frameStartTime;
		}

		/**@inheritDoc */
		__proto.render=function(context,x,y){
			if (this.frameRate==="sleep"){
				var now=Browser.now();
				if (now-this._frameStartTime >=1000)this._frameStartTime=now;
				else return;
			}
			this._renderCount++;
			if (!this._visible){
				if (this._renderCount % 5===0){
					Stat.loopCount++;
					MouseManager.instance.runEvent();
					Laya.timer._update();
				}
				return;
			}
			this._frameStartTime=Browser.now();
			var frameMode=this.frameRate==="mouse" ? (((this._frameStartTime-this._mouseMoveTime)< 2000)? "fast" :"slow"):this.frameRate;
			var isFastMode=(frameMode!=="slow");
			var isDoubleLoop=(this._renderCount % 2===0);
			Stat.renderSlow=!isFastMode;
			Stat.mesh2DNum=0;
			if (isFastMode || isDoubleLoop){
				Stat.loopCount++;
				MouseManager.instance.runEvent();
				Laya.timer._update();
				RunDriver.update3DLoop();
				var scene;
				var i=0,n=0;
				for (i=0,n=this._scenes.length;i < n;i++){
					scene=this._scenes[i];
					(scene)&& (scene._updateScene());
				}
				if (Render.isWebGL && this.renderingEnabled){
					context.clear();
					_super.prototype.render.call(this,context,x,y);
				}
			}
			if (this.renderingEnabled && (isFastMode || !isDoubleLoop)){
				if (Render.isWebGL){
					RunDriver.clear(this._bgColor);
					context.flush();
					var cbook=CharBook.charbookInst;
					cbook.GC();
					VectorGraphManager.instance && VectorGraphManager.getInstance().endDispose();
					}else {
					RunDriver.clear(this._bgColor);
					_super.prototype.render.call(this,context,x,y);
					Render.isConchApp && context.commit();
				}
			}
		}

		/**@private */
		__proto._requestFullscreen=function(){
			var element=Browser.document.documentElement;
			if (element.requestFullscreen){
				element.requestFullscreen();
				}else if (element.mozRequestFullScreen){
				element.mozRequestFullScreen();
				}else if (element.webkitRequestFullscreen){
				element.webkitRequestFullscreen();
				}else if (element.msRequestFullscreen){
				element.msRequestFullscreen();
			}
		}

		/**@private */
		__proto._fullScreenChanged=function(){
			Laya.stage.event("fullscreenchange");
		}

		/**退出全屏模式*/
		__proto.exitFullscreen=function(){
			var document=Browser.document;
			if (document.exitFullscreen){
				document.exitFullscreen();
				}else if (document.mozCancelFullScreen){
				document.mozCancelFullScreen();
				}else if (document.webkitExitFullscreen){
				document.webkitExitFullscreen();
			}
		}

		/**当前视窗由缩放模式导致的 Y 轴缩放系数。*/
		__getset(0,__proto,'clientScaleY',function(){
			return this._transform ? this._transform.getScaleY():1;
		});

		__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
			this.designWidth=value;
			_super.prototype._$set_width.call(this,value);
			Laya.timer.callLater(this,this._changeCanvasSize);
		});

		/**
		*舞台是否获得焦点。
		*/
		__getset(0,__proto,'isFocused',function(){
			return this._isFocused;
		});

		/**
		*<p>水平对齐方式。默认值为"left"。</p>
		*<p><ul>取值范围：
		*<li>"left" ：居左对齐；</li>
		*<li>"center" ：居中对齐；</li>
		*<li>"right" ：居右对齐；</li>
		*</ul></p>
		*/
		__getset(0,__proto,'alignH',function(){
			return this._alignH;
			},function(value){
			this._alignH=value;
			Laya.timer.callLater(this,this._changeCanvasSize);
		});

		__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
			this.designHeight=value;
			_super.prototype._$set_height.call(this,value);
			Laya.timer.callLater(this,this._changeCanvasSize);
		});

		__getset(0,__proto,'transform',function(){
			if (this._tfChanged)this._adjustTransform();
			return this._transform=this._transform|| this._createTransform();
		},_super.prototype._$set_transform);

		/**
		*舞台是否处于可见状态(是否进入后台)。
		*/
		__getset(0,__proto,'isVisibility',function(){
			return this._isVisibility;
		});

		/**
		*<p>缩放模式。默认值为 "noscale"。</p>
		*<p><ul>取值范围：
		*<li>"noscale" ：不缩放；</li>
		*<li>"exactfit" ：全屏不等比缩放；</li>
		*<li>"showall" ：最小比例缩放；</li>
		*<li>"noborder" ：最大比例缩放；</li>
		*<li>"full" ：不缩放，stage的宽高等于屏幕宽高；</li>
		*<li>"fixedwidth" ：宽度不变，高度根据屏幕比缩放；</li>
		*<li>"fixedheight" ：高度不变，宽度根据屏幕比缩放；</li>
		*<li>"fixedauto" ：根据宽高比，自动选择使用fixedwidth或fixedheight；</li>
		*</ul></p>
		*/
		__getset(0,__proto,'scaleMode',function(){
			return this._scaleMode;
			},function(value){
			this._scaleMode=value;
			Laya.timer.callLater(this,this._changeCanvasSize);
		});

		/**
		*<p>垂直对齐方式。默认值为"top"。</p>
		*<p><ul>取值范围：
		*<li>"top" ：居顶部对齐；</li>
		*<li>"middle" ：居中对齐；</li>
		*<li>"bottom" ：居底部对齐；</li>
		*</ul></p>
		*/
		__getset(0,__proto,'alignV',function(){
			return this._alignV;
			},function(value){
			this._alignV=value;
			Laya.timer.callLater(this,this._changeCanvasSize);
		});

		/**舞台的背景颜色，默认为黑色，null为透明。*/
		__getset(0,__proto,'bgColor',function(){
			return this._bgColor;
			},function(value){
			this._bgColor=value;
			if (Render.isWebGL){
				if (value && value!=="black" && value!=="#000000"){
					this._wgColor=Color.create(value).arrColor;
					}else {
					this._wgColor=null;
				}
			}
			if (value){
				Render.canvas.style.background=value;
				}else {
				Render.canvas.style.background="none";
			}
		});

		/**鼠标在 Stage 上的 X 轴坐标。*/
		__getset(0,__proto,'mouseX',function(){
			return Math.round(MouseManager.instance.mouseX / this.clientScaleX);
		});

		/**鼠标在 Stage 上的 Y 轴坐标。*/
		__getset(0,__proto,'mouseY',function(){
			return Math.round(MouseManager.instance.mouseY / this.clientScaleY);
		});

		/**当前视窗由缩放模式导致的 X 轴缩放系数。*/
		__getset(0,__proto,'clientScaleX',function(){
			return this._transform ? this._transform.getScaleX():1;
		});

		/**
		*<p>场景布局类型。</p>
		*<p><ul>取值范围：
		*<li>"none" ：不更改屏幕</li>
		*<li>"horizontal" ：自动横屏</li>
		*<li>"vertical" ：自动竖屏</li>
		*</ul></p>
		*/
		__getset(0,__proto,'screenMode',function(){
			return this._screenMode;
			},function(value){
			this._screenMode=value;
		});

		__getset(0,__proto,'visible',_super.prototype._$get_visible,function(value){
			if (this.visible!==value){
				_super.prototype._$set_visible.call(this,value);
				var style=Render._mainCanvas.source.style;
				style.visibility=value ? "visible" :"hidden";
			}
		});

		/**
		*<p>是否开启全屏，用户点击后进入全屏。</p>
		*<p>兼容性提示：部分浏览器不允许点击进入全屏，比如Iphone等。</p>
		*/
		__getset(0,__proto,'fullScreenEnabled',null,function(value){
			var document=Browser.document;
			var canvas=Render.canvas;
			if (value){
				canvas.addEventListener('mousedown',this._requestFullscreen);
				canvas.addEventListener('touchstart',this._requestFullscreen);
				document.addEventListener("fullscreenchange",this._fullScreenChanged);
				document.addEventListener("mozfullscreenchange",this._fullScreenChanged);
				document.addEventListener("webkitfullscreenchange",this._fullScreenChanged);
				document.addEventListener("msfullscreenchange",this._fullScreenChanged);
				}else {
				canvas.removeEventListener('mousedown',this._requestFullscreen);
				canvas.removeEventListener('touchstart',this._requestFullscreen);
				document.removeEventListener("fullscreenchange",this._fullScreenChanged);
				document.removeEventListener("mozfullscreenchange",this._fullScreenChanged);
				document.removeEventListener("webkitfullscreenchange",this._fullScreenChanged);
				document.removeEventListener("msfullscreenchange",this._fullScreenChanged);
			}
		});

		Stage.SCALE_NOSCALE="noscale";
		Stage.SCALE_EXACTFIT="exactfit";
		Stage.SCALE_SHOWALL="showall";
		Stage.SCALE_NOBORDER="noborder";
		Stage.SCALE_FULL="full";
		Stage.SCALE_FIXED_WIDTH="fixedwidth";
		Stage.SCALE_FIXED_HEIGHT="fixedheight";
		Stage.SCALE_FIXED_AUTO="fixedauto";
		Stage.ALIGN_LEFT="left";
		Stage.ALIGN_RIGHT="right";
		Stage.ALIGN_CENTER="center";
		Stage.ALIGN_TOP="top";
		Stage.ALIGN_MIDDLE="middle";
		Stage.ALIGN_BOTTOM="bottom";
		Stage.SCREEN_NONE="none";
		Stage.SCREEN_HORIZONTAL="horizontal";
		Stage.SCREEN_VERTICAL="vertical";
		Stage.FRAME_FAST="fast";
		Stage.FRAME_SLOW="slow";
		Stage.FRAME_MOUSE="mouse";
		Stage.FRAME_SLEEP="sleep";
		return Stage;
	})(Sprite)


	/**
	*<code>HTMLCanvas</code> 是 Html Canvas 的代理类，封装了 Canvas 的属性和方法。。请不要直接使用 new HTMLCanvas！
	*/
	//class laya.resource.HTMLCanvas extends laya.resource.Bitmap
	var HTMLCanvas=(function(_super){
		function HTMLCanvas(type){
			//this._ctx=null;
			this._is2D=false;
			//this._source=null;
			this.getContext=function(contextID,other){
				return _$this._ctx ? _$this._ctx :(_$this._ctx=HTMLCanvas._createContext(this));
			}
			HTMLCanvas.__super.call(this);
			var _$this=this;
			this._source=this;
			if (type==="2D" || (type==="AUTO" && !Render.isWebGL)){
				this._is2D=true;
				this._source=Browser.createElement("canvas");
				var o=this;
				o.getContext=function (contextID,other){
					if (_$this._ctx)return _$this._ctx;
					if (Render.isConchApp){
						_$this._ctx=LayaGL.instance ? LayaGL.instance :new LayaGL(this);
						return _$this._ctx;
					};
					var ctx=_$this._ctx=_$this._source.getContext(contextID,other);
					if (ctx){
						ctx._canvas=o;
						ctx.size=function (w,h){
						};
					}
					return ctx;
				}
			}
		}

		__class(HTMLCanvas,'laya.resource.HTMLCanvas',_super);
		var __proto=HTMLCanvas.prototype;
		/**
		*清空画布内容。
		*/
		__proto.clear=function(){
			this._ctx && this._ctx.clear();
		}

		/**
		*销毁。
		*/
		__proto.destroy=function(){
			this._ctx && this._ctx.destroy();
			this._ctx=null;
		}

		/**
		*释放。
		*/
		__proto.release=function(){}
		/**
		*@private
		*设置 Canvas 渲染上下文。
		*@param context Canvas 渲染上下文。
		*/
		__proto._setContext=function(context){
			this._ctx=context;
		}

		/**
		*获取内存大小。
		*@return 内存大小。
		*/
		__proto.getMemSize=function(){
			return 0;
		}

		/**
		*设置宽高。
		*@param w 宽度。
		*@param h 高度。
		*/
		__proto.size=function(w,h){
			if (this._width !=w || this._height !=h || (this._source && (this._source.width !=w || this._source.height !=h))){
				this._width=w;
				this._height=h;
				this.memorySize=w *h *4;
				this._ctx && this._ctx.size(w,h);
				this._source && (this._source.height=h,this._source.width=w);
			}
		}

		__proto.getCanvas=function(){
			return this._source;
		}

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'source',function(){
			return this._source;
		});

		/**
		*Canvas 渲染上下文。
		*/
		__getset(0,__proto,'context',function(){
			return this._ctx;
		});

		/**
		*是否当作 Bitmap 对象。
		*/
		__getset(0,__proto,'asBitmap',null,function(value){
		});

		HTMLCanvas.create=function(type){
			return new HTMLCanvas(type);
		}

		HTMLCanvas.TYPE2D="2D";
		HTMLCanvas.TYPE3D="3D";
		HTMLCanvas.TYPEAUTO="AUTO";
		HTMLCanvas._createContext=null
		return HTMLCanvas;
	})(Bitmap)


	/**
	*@private
	*<p> <code>HTMLImage</code> 用于创建 HTML Image 元素。</p>
	*<p>请使用 <code>HTMLImage.create()<code>获取新实例，不要直接使用 <code>new HTMLImage<code> 。</p>
	*/
	//class laya.resource.HTMLImage extends laya.resource.Bitmap
	var HTMLImage=(function(_super){
		function HTMLImage(){
			//this._source=null;
			HTMLImage.__super.call(this);
		}

		__class(HTMLImage,'laya.resource.HTMLImage',_super);
		var __proto=HTMLImage.prototype;
		/**
		*通过图片源填充纹理,可为HTMLImageElement、HTMLCanvasElement、HTMLVideoElement、ImageBitmap、ImageData。
		*/
		__proto.setImageSource=function(source){
			var width=source.width;
			var height=source.height;
			if (width <=0 || height <=0)
				throw new Error("HTMLImage:width or height must large than 0.");
			this._width=width;
			this._height=height;
			this._source=source;
			this.memorySize=width *height *4;
			this._activeResource();
		}

		/**
		*@inheritDoc
		*/
		__proto.disposeResource=function(){
			(this._source)&& (this._source=null,this.memorySize=0);
		}

		/**
		*@inheritDoc
		*/
		__proto._getSource=function(){
			return this._source;
		}

		HTMLImage.create=function(){
			return new HTMLImage();
		}

		return HTMLImage;
	})(Bitmap)


	/**
	*<code>BaseTexture</code> 纹理的父类，抽象类，不允许实例。
	*/
	//class laya.webgl.resource.BaseTexture extends laya.resource.Bitmap
	var BaseTexture=(function(_super){
		function BaseTexture(format,mipMap){
			//this._readyed=false;
			//this._glTextureType=0;
			//this._glTexture=null;
			//this._format=0;
			//this._mipmap=false;
			//this._wrapModeU=0;
			//this._wrapModeV=0;
			//this._filterMode=0;
			//this._anisoLevel=0;
			BaseTexture.__super.call(this);
			this._wrapModeU=0;
			this._wrapModeV=0;
			this._filterMode=1;
			this._readyed=false;
			this._width=-1;
			this._height=-1;
			this._format=format;
			this._mipmap=mipMap;
			this._anisoLevel=1;
			this._glTexture=LayaGL.instance.createTexture();
		}

		__class(BaseTexture,'laya.webgl.resource.BaseTexture',_super);
		var __proto=BaseTexture.prototype;
		/**
		*@private
		*/
		__proto._isPot=function(size){
			return (size & (size-1))===0;
		}

		/**
		*@private
		*/
		__proto._getGLFormat=function(){
			var glFormat=0;
			switch (this._format){
				case 0:
					glFormat=0x1907;
					break ;
				case 1:
					glFormat=0x1908;
					break ;
				default :
					throw "BaseTexture: unkonw texture format.";
				}
			return glFormat;
		}

		/**
		*@private
		*/
		__proto._setFilterMode=function(value){
			var gl=LayaGL.instance;
			gl.bindTexture(this._glTextureType,this._glTexture);
			switch (value){
				case 0:
					if (this._mipmap && this._isPot(this._width)&& this._isPot(this._height))
						gl.texParameteri(this._glTextureType,0x2801,0x2700);
					else
					gl.texParameteri(this._glTextureType,0x2801,0x2600);
					gl.texParameteri(this._glTextureType,0x2800,0x2600);
					break ;
				case 1:
					if (this._mipmap && this._isPot(this._width)&& this._isPot(this._height))
						gl.texParameteri(this._glTextureType,0x2801,0x2701);
					else
					gl.texParameteri(this._glTextureType,0x2801,0x2601);
					gl.texParameteri(this._glTextureType,0x2800,0x2601);
					break ;
				case 2:
					if (this._mipmap && this._isPot(this._width)&& this._isPot(this._height))
						gl.texParameteri(this._glTextureType,0x2801,0x2703);
					else
					gl.texParameteri(this._glTextureType,0x2801,0x2601);
					gl.texParameteri(this._glTextureType,0x2800,0x2601);
					break ;
				default :
					throw new Error("BaseTexture:unknown filterMode value.");
				}
		}

		/**
		*@private
		*/
		__proto._setWarpMode=function(orientation,mode){
			var gl=LayaGL.instance;
			gl.bindTexture(this._glTextureType,this._glTexture);
			if (this._isPot(this._width)&&this._isPot(this._height)){
				switch (mode){
					case 0:
						gl.texParameteri(this._glTextureType,orientation,0x2901);
						break ;
					case 1:
						gl.texParameteri(this._glTextureType,orientation,0x812F);
						break ;
					}
				}else {
				gl.texParameteri(this._glTextureType,orientation,0x812F);
			}
		}

		/**
		*@private
		*/
		__proto._setAnisotropy=function(value){
			var gl=LayaGL.instance;
			gl.bindTexture(this._glTextureType,this._glTexture);
			var anisotropic=WebGLContext.extTextureFilterAnisotropic;
			if (anisotropic){
				value=Math.min(gl.getParameter(anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT),value);
				gl.texParameterf(this._glTextureType,anisotropic.TEXTURE_MAX_ANISOTROPY_EXT,value);
			}
		}

		/**
		*@inheritDoc
		*/
		__proto.onAsynLoaded=function(data,params){
			if (params){
				var format=params.format;
				(format!==undefined)&& (this._format=format);
				var mipmap=params.mipmap;
				(mipmap!==undefined)&& (this.mipmap=mipmap);
				var wrapModeU=params.warpModeU;
				(wrapModeU!==undefined)&& (this.wrapModeU=wrapModeU);
				var wrapModeV=params.warpModeV;
				(wrapModeV!==undefined)&& (this.wrapModeV=wrapModeV);
				var filterMode=params.filterMode;
				(filterMode!==undefined)&& (this.filterMode=filterMode);
				var anisoLevel=params.anisoLevel;
				(anisoLevel!==undefined)&& (this.anisoLevel=anisoLevel);
			}
		}

		/**
		*@inheritDoc
		*/
		__proto.disposeResource=function(){
			if (this._glTexture){
				LayaGL.instance.deleteTexture(this._glTexture);
				this._glTexture=null;
				this.memorySize=0;
			}
		}

		/**
		*获取纹理资源。
		*/
		__proto._getSource=function(){
			if (this._readyed)
				return this._glTexture;
			else
			return null;
		}

		/**
		*@private [NATIVE] 临时使用,后期删除。
		*/
		__proto._getGLFormatForNative=function(){
			return 0x1908;
		}

		/**
		*设置纹理横向循环模式。
		*/
		/**
		*获取纹理横向循环模式。
		*/
		__getset(0,__proto,'wrapModeU',function(){
			return this._wrapModeU;
			},function(value){
			if (this._wrapModeU!==value){
				this._wrapModeU=value;
				(this._width!==-1)&& (this._setWarpMode(0x2802,value));
			}
		});

		/**
		*是否使用mipLevel
		*/
		__getset(0,__proto,'mipmap',function(){
			return this._mipmap;
		});

		/**
		*纹理格式
		*/
		__getset(0,__proto,'format',function(){
			return this._format;
		});

		/**
		*设置纹理纵向循环模式。
		*/
		/**
		*获取纹理纵向循环模式。
		*/
		__getset(0,__proto,'wrapModeV',function(){
			return this._wrapModeV;
			},function(value){
			if (this._wrapModeV!==value){
				this._wrapModeV=value;
				(this._height!==-1)&& (this._setWarpMode(0x2803,value));
			}
		});

		/**
		*获取默认纹理资源。
		*/
		__getset(0,__proto,'defaulteTexture',function(){
			throw "BaseTexture:must override it."
		});

		/**
		*缩小过滤器
		*/
		/**
		*缩小过滤器
		*/
		__getset(0,__proto,'filterMode',function(){
			return this._filterMode;
			},function(value){
			if (value!==this._filterMode){
				this._filterMode=value;
				((this._width!==-1)&& (this._height!==-1))&& (this._setFilterMode(value));
			}
		});

		/**
		*各向异性等级
		*/
		/**
		*各向异性等级
		*/
		__getset(0,__proto,'anisoLevel',function(){
			return this._anisoLevel;
			},function(value){
			if (value!==this._anisoLevel){
				this._anisoLevel=Math.max(1,Math.min(16,value));
				((this._width!==-1)&& (this._height!==-1))&& (this._setAnisotropy(value));
			}
		});

		BaseTexture.WARPMODE_REPEAT=0;
		BaseTexture.WARPMODE_CLAMP=1;
		BaseTexture.FILTERMODE_POINT=0;
		BaseTexture.FILTERMODE_BILINEAR=1;
		BaseTexture.FILTERMODE_TRILINEAR=2;
		BaseTexture.FORMAT_RGB_8_8_8=0;
		BaseTexture.FORMAT_RGBA_8_8_8_8=1;
		BaseTexture.FORMAT_DEPTH_16=0;
		BaseTexture.FORMAT_STENCIL_8=1;
		BaseTexture.FORMAT_DEPTHSTENCIL_16_8=2;
		BaseTexture.FORMAT_DEPTHSTENCIL_NONE=3;
		return BaseTexture;
	})(Bitmap)


	//class laya.webgl.resource.WebGLCharImage extends laya.resource.Bitmap
	var WebGLCharImage=(function(_super){
		function WebGLCharImage(content,drawValue){
			this.CborderSize=12;
			//this._ctx=null;
			//this._allowMerageInAtlas=false;
			//this._enableMerageInAtlas=false;
			//this.canvas=null;
			//this.cw=NaN;
			//this.ch=NaN;
			//this.xs=NaN;
			//this.ys=NaN;
			//this.char=null;
			//this.fillColor=null;
			//this.borderColor=null;
			//this.borderSize=0;
			//this.font=null;
			//this.fontSize=0;
			//this.texture=null;
			//this.lineWidth=0;
			//this.UV=null;
			//this.isSpace=false;
			//this.underLine=0;
			WebGLCharImage.__super.call(this);
			this.char=content;
			this.isSpace=content===' ';
			this.xs=drawValue.scaleX;
			this.ys=drawValue.scaleY;
			this.font=drawValue.font.toString();
			this.fontSize=drawValue.font.size;
			this.fillColor=drawValue.fillColor;
			this.borderColor=drawValue.borderColor;
			this.lineWidth=drawValue.lineWidth;
			this.underLine=drawValue.underLine;
			var bIsConchApp=Render.isConchApp;
			var pCanvas;
			if (bIsConchApp){
				pCanvas=ConchTextCanvas;
				pCanvas._source=ConchTextCanvas;
				pCanvas._source.canvas=ConchTextCanvas;
				}else {
				pCanvas=Browser.canvas.source;
			}
			this.canvas=pCanvas;
			this._enableMerageInAtlas=true;
			if (bIsConchApp){
				this._ctx=pCanvas;
				}else {
				this._ctx=this.canvas.getContext('2d',undefined);
			};
			var t=Utils.measureText(this.char,this.font);
			this.cw=t.width *this.xs;
			this.ch=(t.height || this.fontSize)*this.ys;
			this.onresize(this.cw+this.CborderSize *2,this.ch+this.CborderSize *2);
			this.texture=new Texture(this);
		}

		__class(WebGLCharImage,'laya.webgl.resource.WebGLCharImage',_super);
		var __proto=WebGLCharImage.prototype;
		__proto.active=function(){
			this.texture.active();
		}

		__proto.recreateResource=function(){
			var bIsConchApp=Render.isConchApp;
			this.onresize(this.cw+this.CborderSize *2,this.ch+this.CborderSize *2);
			this.canvas && (this.canvas.height=this._height,this.canvas.width=this._width);
			if (bIsConchApp){
				var nFontSize=this.fontSize;
				if (this.xs !=1 || this.ys !=1){
					nFontSize=parseInt(nFontSize *((this.xs > this.ys)? this.xs :this.ys)+"");
				};
				var sFont="normal 100 "+nFontSize+"px Arial";
				if (this.borderColor){
					sFont+=" 1 "+this.borderColor;
				}
				this._ctx.font=sFont;
				this._ctx.textBaseline="top";
				this._ctx.fillStyle=this.fillColor;
				this._ctx.fillText(this.char,this.CborderSize,this.CborderSize,null,null,null);
				}else {
				this._ctx.save();
				(this._ctx).clearRect(0,0,this.cw+this.CborderSize *2,this.ch+this.CborderSize *2);
				this._ctx.font=this.font;
				if (Text.RightToLeft){
					this._ctx.textAlign="end";
				}
				this._ctx.textBaseline="top";
				this._ctx.translate(this.CborderSize,this.CborderSize);
				if (this.xs !=1 || this.ys !=1){
					this._ctx.scale(this.xs,this.ys);
				}
				if (this.fillColor && this.borderColor){
					this._ctx.strokeStyle=this.borderColor;
					this._ctx.lineWidth=this.lineWidth;
					this._ctx.strokeText(this.char,0,0,null,null,0,null);
					this._ctx.fillStyle=this.fillColor;
					this._ctx.fillText(this.char,0,0,null,null,null);
					}else {
					if (this.lineWidth===-1){
						this._ctx.fillStyle=this.fillColor ? this.fillColor :"white";
						this._ctx.fillText(this.char,0,0,null,null,null);
						}else {
						this._ctx.strokeStyle=this.borderColor?this.borderColor:'white';
						this._ctx.lineWidth=this.lineWidth;
						this._ctx.strokeText(this.char,0,0,null,null,0,null);
					}
				}
				if (this.underLine){
					this._ctx.lineWidth=1;
					this._ctx.strokeStyle=this.fillColor;
					this._ctx.beginPath();
					this._ctx.moveTo(0,this.fontSize+1+0.5);
					var nW=this._ctx.measureText(this.char).width+1;
					this._ctx.lineTo(nW,this.fontSize+1+0.5);
					this._ctx.stroke();
				}
				this._ctx.restore();
			}
			this.borderSize=this.CborderSize;
		}

		__proto.onresize=function(w,h){
			this._width=w;
			this._height=h;
			this._allowMerageInAtlas=true
		}

		__proto.clearAtlasSource=function(){}
		/**
		*是否创建私有Source
		*@return 是否创建
		*/
		__getset(0,__proto,'allowMerageInAtlas',function(){
			return this._allowMerageInAtlas;
		});

		__getset(0,__proto,'atlasSource',function(){
			return this.canvas;
		});

		/**
		*是否创建私有Source,通常禁止修改
		*@param value 是否创建
		*/
		/**
		*是否创建私有Source
		*@return 是否创建
		*/
		__getset(0,__proto,'enableMerageInAtlas',function(){
			return this._enableMerageInAtlas;
			},function(value){
			this._enableMerageInAtlas=value;
		});

		WebGLCharImage.createOneChar=function(content,drawValue){
			var char=new WebGLCharImage(content,drawValue);
			return char;
		}

		return WebGLCharImage;
	})(Bitmap)


	/**
	*<code>BlinnPhongMaterial</code> 类用于实现Blinn-Phong材质。
	*/
	//class laya.d3.core.material.BlinnPhongMaterial extends laya.d3.core.material.BaseMaterial
	var BlinnPhongMaterial=(function(_super){
		function BlinnPhongMaterial(){
			//this._albedoColor=null;
			//this._albedoIntensity=NaN;
			//this._enableLighting=false;
			BlinnPhongMaterial.__super.call(this,12);
			this.setShaderName("BLINNPHONG");
			var sv=this._shaderValues;
			this._albedoIntensity=1.0;
			this._albedoColor=new Vector4(1.0,1.0,1.0,1.0);
			sv.setVector(6,new Vector4(1.0,1.0,1.0,1.0));
			sv.setVector(8,new Vector3(1.0,1.0,1.0));
			sv.setNumber(9,0.078125);
			sv.setVector(10,new Vector3(1.0,1.0,1.0));
			sv.setNumber(0,0.5);
			sv.setVector(11,new Vector4(1.0,1.0,0.0,0.0));
			this._enableLighting=true;
			this.renderMode=0;
		}

		__class(BlinnPhongMaterial,'laya.d3.core.material.BlinnPhongMaterial',_super);
		var __proto=BlinnPhongMaterial.prototype;
		/**
		*禁用雾化。
		*/
		__proto.disableFog=function(){
			this._disablePublicDefineDatas.add(Shader3D.SHADERDEFINE_FOG);
		}

		/**
		*设置渲染模式。
		*@return 渲染模式。
		*/
		__getset(0,__proto,'renderMode',null,function(value){
			var renderState=this.getRenderState();
			switch (value){
				case 0:
					this.alphaTest=false;
					this.renderQueue=1;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=0;
					renderState.depthTest=0x0201;
					this._defineDatas.remove(BlinnPhongMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 1:
					this.renderQueue=1;
					this.alphaTest=true;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=0;
					renderState.depthTest=0x0201;
					this._defineDatas.remove(BlinnPhongMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 2:
					this.renderQueue=2;
					this.alphaTest=false;
					renderState.depthWrite=false;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					renderState.depthTest=0x0201;
					this._defineDatas.remove(BlinnPhongMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 3:
					this.renderQueue=2;
					this.alphaTest=false;
					renderState.depthWrite=false;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=1;
					renderState.depthTest=0x0201;
					this._defineDatas.add(BlinnPhongMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				default :
					throw new Error("Material:renderMode value error.");
				}
		});

		/**
		*设置法线贴图。
		*@param value 法线贴图。
		*/
		/**
		*获取法线贴图。
		*@return 法线贴图。
		*/
		__getset(0,__proto,'normalTexture',function(){
			return this._shaderValues.getTexture(2);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_NORMALMAP);
			else
			this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_NORMALMAP);
			this._shaderValues.setTexture(2,value);
		});

		/**
		*设置反射颜色。
		*@param value 反射颜色。
		*/
		/**
		*获取反射颜色。
		*@return value 反射颜色。
		*/
		__getset(0,__proto,'reflectColor',function(){
			return this._shaderValues.getVector(10);
			},function(value){
			this._shaderValues.setVector(10,value);
		});

		/**
		*获取纹理平铺和偏移。
		*@param value 纹理平铺和偏移。
		*/
		/**
		*获取纹理平铺和偏移。
		*@return 纹理平铺和偏移。
		*/
		__getset(0,__proto,'tilingOffset',function(){
			return this._shaderValues.getVector(11);
			},function(value){
			if (value){
				var valueE=value.elements;
				if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
					this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET);
				else
				this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET);
				}else {
				this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET);
			}
			this._shaderValues.setVector(11,value);
		});

		/**
		*设置高光颜色。
		*@param value 高光颜色。
		*/
		/**
		*获取高光颜色。
		*@return 高光颜色。
		*/
		__getset(0,__proto,'specularColor',function(){
			return this._shaderValues.getVector(8);
			},function(value){
			this._shaderValues.setVector(8,value);
		});

		/**
		*设置反照率颜色。
		*@param value 反照率颜色。
		*/
		/**
		*获取反照率颜色。
		*@return 反照率颜色。
		*/
		__getset(0,__proto,'albedoColor',function(){
			return this._albedoColor;
			},function(value){
			var finalAlbedo=this._shaderValues.getVector(6);
			Vector4.scale(value,this._albedoIntensity,finalAlbedo);
			this._albedoColor=value;
		});

		/**
		*设置反照率强度。
		*@param value 反照率强度。
		*/
		/**
		*获取反照率强度。
		*@return 反照率强度。
		*/
		__getset(0,__proto,'albedoIntensity',function(){
			return this._albedoIntensity;
			},function(value){
			if (this._albedoIntensity!==value){
				var finalAlbedo=this._shaderValues.getVector(6);
				Vector4.scale(this._albedoColor,value,finalAlbedo);
				this._albedoIntensity=value;
			}
		});

		/**
		*设置反照率贴图。
		*@param value 反照率贴图。
		*/
		/**
		*获取反照率贴图。
		*@return 反照率贴图。
		*/
		__getset(0,__proto,'albedoTexture',function(){
			return this._shaderValues.getTexture(1);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP);
			else
			this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP);
			this._shaderValues.setTexture(1,value);
		});

		/**
		*设置高光强度,范围为0到1。
		*@param value 高光强度。
		*/
		/**
		*获取高光强度,范围为0到1。
		*@return 高光强度。
		*/
		__getset(0,__proto,'shininess',function(){
			return this._shaderValues.getNumber(9);
			},function(value){
			value=Math.max(0.0,Math.min(1.0,value));
			this._shaderValues.setNumber(9,value);
		});

		/**
		*设置高光贴图，高光强度则从该贴图RGB值中获取,如果该值为空则从漫反射贴图的Alpha通道获取。
		*@param value 高光贴图。
		*/
		/**
		*获取高光贴图。
		*@return 高光贴图。
		*/
		__getset(0,__proto,'specularTexture',function(){
			return this._shaderValues.getTexture(3);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP);
			else
			this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP);
			this._shaderValues.setTexture(3,value);
		});

		/**
		*设置反射贴图。
		*@param value 反射贴图。
		*/
		/**
		*获取反射贴图。
		*@return 反射贴图。
		*/
		__getset(0,__proto,'reflectTexture',function(){
			return this._shaderValues.getTexture(5);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_REFLECTMAP);
			else
			this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_REFLECTMAP);
			this._shaderValues.setTexture(5,value);
		});

		/**
		*设置是否启用光照。
		*@param value 是否启用光照。
		*/
		/**
		*获取是否启用光照。
		*@return 是否启用光照。
		*/
		__getset(0,__proto,'enableLighting',function(){
			return this._enableLighting;
			},function(value){
			if (this._enableLighting!==value){
				if (value)
					this._disablePublicDefineDatas.add(Scene.SHADERDEFINE_POINTLIGHT | Scene.SHADERDEFINE_SPOTLIGHT | Scene.SHADERDEFINE_DIRECTIONLIGHT);
				else
				this._disablePublicDefineDatas.remove(Scene.SHADERDEFINE_POINTLIGHT | Scene.SHADERDEFINE_SPOTLIGHT | Scene.SHADERDEFINE_DIRECTIONLIGHT);
				this._enableLighting=value;
			}
		});

		BlinnPhongMaterial.__init__=function(){
			BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP=BlinnPhongMaterial.shaderDefines.registerDefine("DIFFUSEMAP");
			BlinnPhongMaterial.SHADERDEFINE_NORMALMAP=BlinnPhongMaterial.shaderDefines.registerDefine("NORMALMAP");
			BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP=BlinnPhongMaterial.shaderDefines.registerDefine("SPECULARMAP");
			BlinnPhongMaterial.SHADERDEFINE_REFLECTMAP=BlinnPhongMaterial.shaderDefines.registerDefine("REFLECTMAP");
			BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET=BlinnPhongMaterial.shaderDefines.registerDefine("TILINGOFFSET");
			BlinnPhongMaterial.SHADERDEFINE_ADDTIVEFOG=BlinnPhongMaterial.shaderDefines.registerDefine("ADDTIVEFOG");
		}

		BlinnPhongMaterial.load=function(url){
			return Laya.loader.create(url,null,null,BlinnPhongMaterial);
		}

		BlinnPhongMaterial.SPECULARSOURCE_DIFFUSEMAPALPHA=0;
		BlinnPhongMaterial.SPECULARSOURCE_SPECULARMAP=0;
		BlinnPhongMaterial.RENDERMODE_OPAQUE=0;
		BlinnPhongMaterial.RENDERMODE_CUTOUT=1;
		BlinnPhongMaterial.RENDERMODE_TRANSPARENT=2;
		BlinnPhongMaterial.RENDERMODE_ADDTIVE=3;
		BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP=0;
		BlinnPhongMaterial.SHADERDEFINE_NORMALMAP=0;
		BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP=0;
		BlinnPhongMaterial.SHADERDEFINE_REFLECTMAP=0;
		BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET=0;
		BlinnPhongMaterial.SHADERDEFINE_ADDTIVEFOG=0;
		BlinnPhongMaterial.ALBEDOTEXTURE=1;
		BlinnPhongMaterial.NORMALTEXTURE=2;
		BlinnPhongMaterial.SPECULARTEXTURE=3;
		BlinnPhongMaterial.EMISSIVETEXTURE=4;
		BlinnPhongMaterial.REFLECTTEXTURE=5;
		BlinnPhongMaterial.ALBEDOCOLOR=6;
		BlinnPhongMaterial.MATERIALSPECULAR=8;
		BlinnPhongMaterial.SHININESS=9;
		BlinnPhongMaterial.MATERIALREFLECT=10;
		BlinnPhongMaterial.TILINGOFFSET=11;
		__static(BlinnPhongMaterial,
		['defaultMaterial',function(){return this.defaultMaterial=new BlinnPhongMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
		]);
		return BlinnPhongMaterial;
	})(BaseMaterial)


	/**
	*...
	*@author ...
	*/
	//class laya.d3.core.material.ExtendTerrainMaterial extends laya.d3.core.material.BaseMaterial
	var ExtendTerrainMaterial=(function(_super){
		function ExtendTerrainMaterial(){
			ExtendTerrainMaterial.__super.call(this);
			this.setShaderName("ExtendTerrain",15);
			this.renderMode=1;
		}

		__class(ExtendTerrainMaterial,'laya.d3.core.material.ExtendTerrainMaterial',_super);
		var __proto=ExtendTerrainMaterial.prototype;
		__proto._setDetailNum=function(value){
			switch (value){
				case 1:
					this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
					break ;
				case 2:
					this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
					break ;
				case 3:
					this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
					break ;
				case 4:
					this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
					break ;
				case 5:
					this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
					this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
					break ;
				}
		}

		/**
		*设置禁受光照影响。
		*/
		__proto.disableLight=function(){
			this._disablePublicDefineDatas.add(Scene.SHADERDEFINE_POINTLIGHT | Scene.SHADERDEFINE_SPOTLIGHT | Scene.SHADERDEFINE_DIRECTIONLIGHT);
		}

		__getset(0,__proto,'diffuseScaleOffset2',null,function(scaleOffset2){
			this._shaderValues.setVector(7,scaleOffset2);
		});

		/**
		*设置splatAlpha贴图。
		*@param value splatAlpha贴图。
		*/
		/**
		*获取splatAlpha贴图。
		*@return splatAlpha贴图。
		*/
		__getset(0,__proto,'splatAlphaTexture',function(){
			return this._shaderValues.getTexture(0);
			},function(value){
			this._shaderValues.setTexture(0,value);
		});

		__getset(0,__proto,'diffuseScaleOffset3',null,function(scaleOffset3){
			this._shaderValues.setVector(8,scaleOffset3);
		});

		/**
		*设置第一层贴图。
		*@param value 第一层贴图。
		*/
		__getset(0,__proto,'diffuseTexture1',null,function(value){
			this._shaderValues.setTexture(1,value);
			this._setDetailNum(1);
		});

		/**
		*设置渲染模式。
		*@return 渲染模式。
		*/
		__getset(0,__proto,'renderMode',null,function(value){
			var renderState=this.getRenderState();
			switch (value){
				case 1:
					this.renderQueue=1;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=0;
					renderState.depthTest=0x0201;
					break ;
				case 2:
					this.renderQueue=1;
					renderState.depthWrite=false;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					renderState.depthTest=0x0203;
					break ;
				default :
					throw new Error("ExtendTerrainMaterial:renderMode value error.");
				}
		});

		/**
		*设置第二层贴图。
		*@param value 第二层贴图。
		*/
		/**
		*获取第二层贴图。
		*@return 第二层贴图。
		*/
		__getset(0,__proto,'diffuseTexture2',function(){
			return this._shaderValues.getTexture(2);
			},function(value){
			this._shaderValues.setTexture(2,value);
			this._setDetailNum(2);
		});

		__getset(0,__proto,'diffuseScaleOffset1',null,function(scaleOffset1){
			this._shaderValues.setVector(6,scaleOffset1);
		});

		/**
		*设置第三层贴图。
		*@param value 第三层贴图。
		*/
		/**
		*获取第三层贴图。
		*@return 第三层贴图。
		*/
		__getset(0,__proto,'diffuseTexture3',function(){
			return this._shaderValues.getTexture(3);
			},function(value){
			this._shaderValues.setTexture(3,value);
			this._setDetailNum(3);
		});

		/**
		*设置第四层贴图。
		*@param value 第四层贴图。
		*/
		/**
		*获取第四层贴图。
		*@return 第四层贴图。
		*/
		__getset(0,__proto,'diffuseTexture4',function(){
			return this._shaderValues.getTexture(4);
			},function(value){
			this._shaderValues.setTexture(4,value);
			this._setDetailNum(4);
		});

		/**
		*设置第五层贴图。
		*@param value 第五层贴图。
		*/
		/**
		*获取第五层贴图。
		*@return 第五层贴图。
		*/
		__getset(0,__proto,'diffuseTexture5',function(){
			return this._shaderValues.getTexture(5);
			},function(value){
			this._shaderValues.setTexture(5,value);
			this._setDetailNum(5);
		});

		__getset(0,__proto,'diffuseScaleOffset4',null,function(scaleOffset4){
			this._shaderValues.setVector(9,scaleOffset4);
		});

		__getset(0,__proto,'diffuseScaleOffset5',null,function(scaleOffset5){
			this._shaderValues.setVector(10,scaleOffset5);
		});

		/**
		*设置反射率颜色。
		*@param value 反射率颜色。
		*/
		/**
		*获取反射率颜色。
		*@return 反射率颜色。
		*/
		__getset(0,__proto,'albedo',function(){
			return this._shaderValues.getVector(14);
			},function(value){
			this._shaderValues.setVector(14,value);
		});

		/**
		*设置环境光颜色。
		*@param value 环境光颜色
		*/
		/**
		*获取环境光颜色。
		*@return 环境光颜色。
		*/
		__getset(0,__proto,'ambientColor',function(){
			return this._shaderValues.getVector(11);
			},function(value){
			this._shaderValues.setVector(11,value);
		});

		/**
		*设置漫反射颜色。
		*@param value 漫反射颜色。
		*/
		/**
		*获取漫反射颜色。
		*@return 漫反射颜色。
		*/
		__getset(0,__proto,'diffuseColor',function(){
			return this._shaderValues.getVector(12);
			},function(value){
			this._shaderValues.setVector(12,value);
		});

		/**
		*设置高光颜色。
		*@param value 高光颜色。
		*/
		/**
		*获取高光颜色。
		*@return 高光颜色。
		*/
		__getset(0,__proto,'specularColor',function(){
			return this._shaderValues.getVector(13);
			},function(value){
			this._shaderValues.setVector(13,value);
		});

		ExtendTerrainMaterial.__init__=function(){
			ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1=ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM1");
			ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2=ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM2");
			ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3=ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM3");
			ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4=ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM4");
			ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5=ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM5");
		}

		ExtendTerrainMaterial.RENDERMODE_OPAQUE=1;
		ExtendTerrainMaterial.RENDERMODE_TRANSPARENT=2;
		ExtendTerrainMaterial.SPLATALPHATEXTURE=0;
		ExtendTerrainMaterial.DIFFUSETEXTURE1=1;
		ExtendTerrainMaterial.DIFFUSETEXTURE2=2;
		ExtendTerrainMaterial.DIFFUSETEXTURE3=3;
		ExtendTerrainMaterial.DIFFUSETEXTURE4=4;
		ExtendTerrainMaterial.DIFFUSETEXTURE5=5;
		ExtendTerrainMaterial.DIFFUSESCALEOFFSET1=6;
		ExtendTerrainMaterial.DIFFUSESCALEOFFSET2=7;
		ExtendTerrainMaterial.DIFFUSESCALEOFFSET3=8;
		ExtendTerrainMaterial.DIFFUSESCALEOFFSET4=9;
		ExtendTerrainMaterial.DIFFUSESCALEOFFSET5=10;
		ExtendTerrainMaterial.MATERIALAMBIENT=11;
		ExtendTerrainMaterial.MATERIALDIFFUSE=12;
		ExtendTerrainMaterial.MATERIALSPECULAR=13;
		ExtendTerrainMaterial.MATERIALALBEDO=14;
		ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1=0;
		ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2=0;
		ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3=0;
		ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4=0;
		ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5=0;
		__static(ExtendTerrainMaterial,
		['shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
		]);
		return ExtendTerrainMaterial;
	})(BaseMaterial)


	//class laya.d3.core.material.PBRMaterial extends laya.d3.core.material.BaseMaterial
	var PBRMaterial=(function(_super){
		function PBRMaterial(){
			this._transformUV=null;
			PBRMaterial.__super.call(this,15);
			if (!laya.d3.core.material.PBRMaterial.pbrlutTex){
				var lutdt=Browser.window['__pbrlutdata'];
				if (!lutdt){
					alert('no pbr lutdata, need pbrlut.js');
					throw 'no pbr lutdata, need pbrlut.js';
				};
				var luttex=DataTexture2D.create((new Uint32Array(lutdt)).buffer,256,256,0x2600,0x2600,false);
				laya.d3.core.material.PBRMaterial.pbrlutTex=luttex;
			}
			this._shaderValues.setTexture(4,laya.d3.core.material.PBRMaterial.pbrlutTex);
			this.setShaderName("PBR");
			this._shaderValues.setNumber(0,0.5);
			this.use_groundtruth=false;
		}

		__class(PBRMaterial,'laya.d3.core.material.PBRMaterial',_super);
		var __proto=PBRMaterial.prototype;
		/**
		*禁用灯光。
		*/
		__proto.disableLight=function(){
			this._defineDatas.add(Scene.SHADERDEFINE_POINTLIGHT | Scene.SHADERDEFINE_SPOTLIGHT | Scene.SHADERDEFINE_DIRECTIONLIGHT);
		}

		/**
		*禁用雾化。
		*/
		__proto.disableFog=function(){
			this._defineDatas.add(Shader3D.SHADERDEFINE_FOG);
		}

		/**
		*vdc算法产生的序列。这个比random要均匀一些。
		*/
		__proto.radicalInverse_VdC=function(bits){
			var tmpUint=new Uint32Array(1);
			return (function(bits){
				bits=(bits << 16)| (bits >>> 16);
				bits=((bits & 0x55555555)<< 1)| ((bits & 0xAAAAAAAA)>>> 1);
				bits=((bits & 0x33333333)<< 2)| ((bits & 0xCCCCCCCC)>>> 2);
				bits=((bits & 0x0F0F0F0F)<< 4)| ((bits & 0xF0F0F0F0)>>> 4);
				bits=((bits & 0x00FF00FF)<< 8)| ((bits & 0xFF00FF00)>>> 8);
				tmpUint[0]=bits;
				return tmpUint[0] *2.3283064365386963e-10;
			})(bits);
		}

		/**
		*
		*/
		__proto.createHammersleyTex=function(w,h){
			var ret=new Uint8Array(w *h *4);
			var ri=0;
			var ci=0;
			for (ci=0;ci < w *h;ci++){
				var v=this.radicalInverse_VdC(ci);
				ret[ri++]=v *255;
				ret[ri++]=0;
				ret[ri++]=0;
				ret[ri++]=255;
			}
			return ret;
		}

		/**
		*设置法线贴图。
		*@param value 法线贴图。
		*/
		/**
		*获取法线贴图。
		*@return 法线贴图。
		*/
		__getset(0,__proto,'normalTexture',function(){
			return this._shaderValues.getTexture(2);
			},function(value){
			this._shaderValues.setTexture(2,value);
		});

		__getset(0,__proto,'has_tangent',null,function(v){
			this._defineDatas.add(PBRMaterial.SHADERDEFINE_HAS_TANGENT);
		});

		/**
		*设置粗糙度的值，0为特别光滑，1为特别粗糙。
		*@param value 粗糙度。
		*/
		/**
		*获取粗糙度的值，0为特别光滑，1为特别粗糙。
		*@return 粗糙度的值。
		*/
		__getset(0,__proto,'roughness',function(){
			return this._shaderValues.getNumber(6);
			},function(value){
			this._shaderValues.setNumber(6,value);
			this._defineDatas.add(PBRMaterial.SHADERDEFINE_FIX_ROUGHNESS);
		});

		__getset(0,__proto,'metaless',function(){
			return this._shaderValues.getNumber(7);
			},function(v){
			this._shaderValues.setNumber(7,v);
			this._defineDatas.add(PBRMaterial.SHADERDEFINE_FIX_METALESS);
		});

		/**
		*设置PBRLUT贴图。
		*@param value PBRLUT贴图。
		*/
		/**
		*获取PBRLUT贴图。
		*@return PBRLUT贴图。
		*/
		__getset(0,__proto,'pbrlutTexture',function(){
			return this._shaderValues.getTexture(4);
			},function(value){
			this._shaderValues.setTexture(4,value);
		});

		__getset(0,__proto,'use_groundtruth',null,function(v){
			if (v){
				this._defineDatas.add(PBRMaterial.SHADERDEFINE_USE_GROUNDTRUTH);
				if (!laya.d3.core.material.PBRMaterial.HammersleyNoiseTex){
					var texdata=this.createHammersleyTex(32,32);
					laya.d3.core.material.PBRMaterial.HammersleyNoiseTex=DataTexture2D.create(texdata.buffer,32,32,0x2600,0x2600,false);
				}
				this._shaderValues.setTexture(15,PBRMaterial.HammersleyNoiseTex);
				}else {
				laya.d3.core.material.PBRMaterial.HammersleyNoiseTex=null;
				this._defineDatas.remove(PBRMaterial.SHADERDEFINE_USE_GROUNDTRUTH);
			}
		});

		/**
		*设置UV变换。
		*@param value UV变换。
		*/
		/**
		*获取UV变换。
		*@return UV变换。
		*/
		__getset(0,__proto,'transformUV',function(){
			return this._transformUV;
			},function(value){
			this._transformUV=value;
			this._shaderValues.setMatrix4x4(8,value.matrix);
		});

		/**
		*设置漫反射贴图。
		*@param value 漫反射贴图。
		*/
		/**
		*获取漫反射贴图。
		*@return 漫反射贴图。
		*/
		__getset(0,__proto,'diffuseTexture',function(){
			return this._shaderValues.getTexture(1);
			},function(value){
			this._shaderValues.setTexture(1,value);
		});

		__getset(0,__proto,'renderMode',null,function(value){
			var renderState=this.getRenderState();
			switch (value){
				case 1:
					renderState.renderQueue=1;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=0;
					this.alphaTest=false;
					break ;
				case 2:
					this.renderQueue=1;
					renderState.depthWrite=true;
					renderState.cull=0;
					renderState.blend=0;
					this.alphaTest=false;
					break ;
				case 3:
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=0;
					this.renderQueue=1;
					break ;
				case 13:
					this.renderQueue=2;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					break ;
				default :
					throw new Error("PBRMaterial:renderMode value error.");
				}
		});

		/**
		*设置pbr信息贴图。
		*@param value pbr信息贴图。
		*/
		/**
		*获取pbr信息贴图。
		*@return pbr信息贴图。
		*/
		__getset(0,__proto,'pbrInfoTexture',function(){
			return this._shaderValues.getTexture(3);
			},function(value){
			this._shaderValues.setTexture(3,value);
			this._defineDatas.add(PBRMaterial.SHADERDEFINE_HAS_PBRINFO);
		});

		__getset(0,__proto,'testClipZ',null,function(v){
			this._defineDatas.add(PBRMaterial.SHADERDEFINE_TEST_CLIPZ);
		});

		PBRMaterial.__init__=function(){
			PBRMaterial.SHADERDEFINE_FIX_METALESS=PBRMaterial.shaderDefines.registerDefine("FIX_METALESS");
			PBRMaterial.SHADERDEFINE_FIX_ROUGHNESS=PBRMaterial.shaderDefines.registerDefine("FIX_ROUGHNESS");
			PBRMaterial.SHADERDEFINE_HAS_TANGENT=PBRMaterial.shaderDefines.registerDefine("HAS_TANGENT");
			PBRMaterial.SHADERDEFINE_HAS_PBRINFO=PBRMaterial.shaderDefines.registerDefine("HAS_PBRINFO");
			PBRMaterial.SHADERDEFINE_USE_GROUNDTRUTH=PBRMaterial.shaderDefines.registerDefine("USE_GROUNDTRUTH");
			PBRMaterial.SHADERDEFINE_TEST_CLIPZ=PBRMaterial.shaderDefines.registerDefine("CLIPZ");
		}

		PBRMaterial.load=function(url){
			return Laya.loader.create(url,null,null,PBRMaterial);
		}

		PBRMaterial.DIFFUSETEXTURE=1;
		PBRMaterial.NORMALTEXTURE=2;
		PBRMaterial.PBRINFOTEXTURE=3;
		PBRMaterial.PBRLUTTEXTURE=4;
		PBRMaterial.UVANIAGE=5;
		PBRMaterial.MATERIALROUGHNESS=6;
		PBRMaterial.MATERIALMETALESS=7;
		PBRMaterial.UVMATRIX=8;
		PBRMaterial.UVAGE=9;
		PBRMaterial.AOOBJPOS=14;
		PBRMaterial.HSNOISETEXTURE=15;
		PBRMaterial.SHADERDEFINE_FIX_ROUGHNESS=0;
		PBRMaterial.SHADERDEFINE_FIX_METALESS=0;
		PBRMaterial.SHADERDEFINE_HAS_TANGENT=0;
		PBRMaterial.SHADERDEFINE_TEST_CLIPZ=0;
		PBRMaterial.SHADERDEFINE_HAS_PBRINFO=0;
		PBRMaterial.SHADERDEFINE_USE_GROUNDTRUTH=0;
		PBRMaterial.RENDERMODE_OPAQUE=1;
		PBRMaterial.RENDERMODE_OPAQUEDOUBLEFACE=2;
		PBRMaterial.RENDERMODE_CUTOUT=3;
		PBRMaterial.RENDERMODE_CUTOUTDOUBLEFACE=4;
		PBRMaterial.RENDERMODE_TRANSPARENT=13;
		PBRMaterial.pbrlutTex=null
		PBRMaterial.HammersleyNoiseTex=null
		__static(PBRMaterial,
		['defaultMaterial',function(){return this.defaultMaterial=new PBRMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
		]);
		return PBRMaterial;
	})(BaseMaterial)


	/**
	*...
	*@author WuTaiLang
	*/
	//class laya.d3.core.material.PBRSpecularMaterial extends laya.d3.core.material.BaseMaterial
	var PBRSpecularMaterial=(function(_super){
		function PBRSpecularMaterial(){
			PBRSpecularMaterial.__super.call(this,18);
			this.setShaderName("PBRSpecular");
			this._shaderValues.setVector(7,new Vector4(1.0,1.0,1.0,1.0));
			this._shaderValues.setVector(9,new Vector4(0.0,0.0,0.0,0.0));
			this._shaderValues.setVector(8,new Vector4(0.2,0.2,0.2,0.2));
			this._shaderValues.setNumber(10,0.5);
			this._shaderValues.setNumber(11,1.0);
			this._shaderValues.setNumber(12,0);
			this._shaderValues.setNumber(13,1.0);
			this._shaderValues.setNumber(14,1.0);
			this._shaderValues.setNumber(15,0.001);
			this._shaderValues.setBool(16,false);
			this._shaderValues.setNumber(0,0.5);
		}

		__class(PBRSpecularMaterial,'laya.d3.core.material.PBRSpecularMaterial',_super);
		var __proto=PBRSpecularMaterial.prototype;
		/**
		*设置漫反射颜色。
		*@param value 漫反射颜色。
		*/
		/**
		*获取漫反射颜色。
		*@return 漫反射颜色。
		*/
		__getset(0,__proto,'albedoColor',function(){
			return this._shaderValues.getVector(7);
			},function(value){
			this._shaderValues.setVector(7,value);
		});

		/**
		*设置高光贴图。
		*@param value 高光贴图。
		*/
		/**
		*获取高光贴图。
		*@return 高光贴图。
		*/
		__getset(0,__proto,'specularTexture',function(){
			return this._shaderValues.getTexture(2);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE);
			else
			this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE);
			this._shaderValues.setTexture(2,value);
		});

		/**
		*设置漫反射贴图。
		*@param value 漫反射贴图。
		*/
		/**
		*获取漫反射贴图。
		*@return 漫反射贴图。
		*/
		__getset(0,__proto,'albedoTexture',function(){
			return this._shaderValues.getTexture(1);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_DIFFUSETEXTURE);
			else
			this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_DIFFUSETEXTURE);
			this._shaderValues.setTexture(1,value);
		});

		/**
		*设置遮挡贴图。
		*@param value 遮挡贴图。
		*/
		/**
		*获取遮挡贴图。
		*@return 遮挡贴图。
		*/
		__getset(0,__proto,'occlusionTexture',function(){
			return this._shaderValues.getTexture(5);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
			else
			this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
			this._shaderValues.setTexture(5,value);
		});

		/**
		*设置法线贴图。
		*@param value 法线贴图。
		*/
		/**
		*获取法线贴图。
		*@return 法线贴图。
		*/
		__getset(0,__proto,'normalTexture',function(){
			return this._shaderValues.getTexture(3);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE);
			else
			this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE);
			this._shaderValues.setTexture(3,value);
		});

		/**
		*设置视差贴图。
		*@param value 视察贴图。
		*/
		/**
		*获取视差贴图。
		*@return 视察贴图。
		*/
		__getset(0,__proto,'parallaxTexture',function(){
			return this._shaderValues.getTexture(4);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE);
			else
			this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE);
			this._shaderValues.setTexture(4,value);
		});

		/**
		*设置放射颜色。
		*@param value 放射颜色。
		*/
		/**
		*获取放射颜色。
		*@return 放射颜色。
		*/
		__getset(0,__proto,'emissionColor',function(){
			return this._shaderValues.getVector(9);
			},function(value){
			this._shaderValues.setVector(9,value);
		});

		/**
		*设置法线贴图缩放系数。
		*@param value 法线贴图缩放系数。
		*/
		/**
		*获取法线贴图缩放系数。
		*@return 法线贴图缩放系数。
		*/
		__getset(0,__proto,'normalTextureScale',function(){
			return this._shaderValues.getNumber(14);
			},function(value){
			this._shaderValues.setNumber(14,value);
		});

		/**
		*设置视差贴图缩放系数。
		*@param value 视差缩放系数。
		*/
		/**
		*获取视差贴图缩放系数。
		*@return 视差缩放系数。
		*/
		__getset(0,__proto,'parallaxTextureScale',function(){
			return this._shaderValues.getNumber(15);
			},function(value){
			value=Math.max(0.005,Math.min(0.08,value));
			this._shaderValues.setNumber(15,value);
		});

		/**
		*设置遮挡贴图强度。
		*@param value 遮挡贴图强度,范围为0到1。
		*/
		/**
		*获取遮挡贴图强度。
		*@return 遮挡贴图强度,范围为0到1。
		*/
		__getset(0,__proto,'occlusionTextureStrength',function(){
			return this._shaderValues.getNumber(13);
			},function(value){
			value=Math.max(0.0,Math.min(1.0,value));
			this._shaderValues.setNumber(13,value);
		});

		/**
		*设置高光颜色。
		*@param value 高光颜色。
		*/
		/**
		*获取高光颜色。
		*@return 高光颜色。
		*/
		__getset(0,__proto,'specularColor',function(){
			return this._shaderValues.getVector(8);
			},function(value){
			this._shaderValues.setVector(8,value);
		});

		/**
		*设置光滑度。
		*@param value 光滑度,范围为0到1。
		*/
		/**
		*获取光滑度。
		*@return 光滑度,范围为0到1。
		*/
		__getset(0,__proto,'smoothness',function(){
			return this._shaderValues.getNumber(10);
			},function(value){
			value=Math.max(0.0,Math.min(1.0,value));
			this._shaderValues.setNumber(10,value);
		});

		/**
		*设置光滑度缩放系数。
		*@param value 光滑度缩放系数,范围为0到1。
		*/
		/**
		*获取光滑度缩放系数。
		*@return 光滑度缩放系数,范围为0到1。
		*/
		__getset(0,__proto,'smoothnessTextureScale',function(){
			return this._shaderValues.getNumber(11);
			},function(value){
			value=Math.max(0.0,Math.min(1.0,value));
			this._shaderValues.setNumber(11,value);
		});

		/**
		*设置光滑度数据源。
		*@param value 光滑滑度数据源,0或1。
		*/
		/**
		*获取光滑度数据源
		*@return 光滑滑度数据源,0或1。
		*/
		__getset(0,__proto,'smoothnessSource',function(){
			return this._shaderValues.getNumber(12);
			},function(value){
			if (value==1)
				this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA);
			else {
				this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA);
				value=0;
			}
			this._shaderValues.setNumber(12,value);
		});

		/**
		*设置是否激活放射属性。
		*@param value 是否激活放射属性
		*/
		/**
		*获取是否激活放射属性。
		*@return 是否激活放射属性。
		*/
		__getset(0,__proto,'enableEmission',function(){
			return this._shaderValues.getBool(16);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSION);
			else {
				this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSION);
			}
			this._shaderValues.setBool(16,value);
		});

		/**
		*设置放射贴图。
		*@param value 放射贴图。
		*/
		/**
		*获取放射贴图。
		*@return 放射贴图。
		*/
		__getset(0,__proto,'emissionTexture',function(){
			return this._shaderValues.getTexture(6);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE);
			else
			this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE);
			this._shaderValues.setTexture(6,value);
		});

		/**
		*获取纹理平铺和偏移。
		*@param value 纹理平铺和偏移。
		*/
		__getset(0,__proto,'tilingOffset',null,function(value){
			if (value){
				var valueE=value.elements;
				if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
					this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET);
				else
				this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET);
				}else {
				this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET);
			}
			this._shaderValues.setVector(17,value);
		});

		PBRSpecularMaterial.__init__=function(){
			PBRSpecularMaterial.SHADERDEFINE_DIFFUSETEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("DIFFUSETEXTURE");
			PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("SPECULARTEXTURE");
			PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA=PBRSpecularMaterial.shaderDefines.registerDefine("SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA");
			PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("NORMALTEXTURE");
			PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("PARALLAXTEXTURE");
			PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("OCCLUSIONTEXTURE");
			PBRSpecularMaterial.SHADERDEFINE_EMISSION=PBRSpecularMaterial.shaderDefines.registerDefine("EMISSION");
			PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("EMISSIONTEXTURE");
			PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET=PBRSpecularMaterial.shaderDefines.registerDefine("TILINGOFFSET");
		}

		PBRSpecularMaterial.SmoothnessSource_MetallicGlossTexture_Alpha=0;
		PBRSpecularMaterial.SmoothnessSource_DiffuseTexture_Alpha=1;
		PBRSpecularMaterial.SHADERDEFINE_DIFFUSETEXTURE=0;
		PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE=0;
		PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA=0;
		PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE=0;
		PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE=0;
		PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE=0;
		PBRSpecularMaterial.SHADERDEFINE_EMISSION=0;
		PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE=0;
		PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET=0;
		PBRSpecularMaterial.DIFFUSETEXTURE=1;
		PBRSpecularMaterial.SPECULARTEXTURE=2;
		PBRSpecularMaterial.NORMALTEXTURE=3;
		PBRSpecularMaterial.PARALLAXTEXTURE=4;
		PBRSpecularMaterial.OCCLUSIONTEXTURE=5;
		PBRSpecularMaterial.EMISSIONTEXTURE=6;
		PBRSpecularMaterial.DIFFUSECOLOR=7;
		PBRSpecularMaterial.SPECULARCOLOR=8;
		PBRSpecularMaterial.EMISSIONCOLOR=9;
		PBRSpecularMaterial.SMOOTHNESS=10;
		PBRSpecularMaterial.SMOOTHNESSSCALE=11;
		PBRSpecularMaterial.SMOOTHNESSSOURCE=12;
		PBRSpecularMaterial.OCCLUSIONSTRENGTH=13;
		PBRSpecularMaterial.NORMALSCALE=14;
		PBRSpecularMaterial.PARALLAXSCALE=15;
		PBRSpecularMaterial.ENABLEEMISSION=16;
		PBRSpecularMaterial.TILINGOFFSET=17;
		__static(PBRSpecularMaterial,
		['shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
		]);
		return PBRSpecularMaterial;
	})(BaseMaterial)


	/**
	*...
	*@author WuTaiLang
	*/
	//class laya.d3.core.material.PBRStandardMaterial extends laya.d3.core.material.BaseMaterial
	var PBRStandardMaterial=(function(_super){
		function PBRStandardMaterial(){
			PBRStandardMaterial.__super.call(this,18);
			this.setShaderName("PBRStandard");
			this._shaderValues.setVector(7,new Vector4(1.0,1.0,1.0,1.0));
			this._shaderValues.setVector(8,new Vector4(0.0,0.0,0.0,0.0));
			this._shaderValues.setNumber(9,0.0);
			this._shaderValues.setNumber(10,0.5);
			this._shaderValues.setNumber(11,1.0);
			this._shaderValues.setNumber(12,0);
			this._shaderValues.setNumber(13,1.0);
			this._shaderValues.setNumber(14,1.0);
			this._shaderValues.setNumber(15,0.001);
			this._shaderValues.setBool(16,false);
			this._shaderValues.setNumber(0,0.5);
		}

		__class(PBRStandardMaterial,'laya.d3.core.material.PBRStandardMaterial',_super);
		var __proto=PBRStandardMaterial.prototype;
		/**
		*设置漫反射颜色。
		*@param value 漫反射颜色。
		*/
		/**
		*获取漫反射颜色。
		*@return 漫反射颜色。
		*/
		__getset(0,__proto,'albedoColor',function(){
			return this._shaderValues.getVector(7);
			},function(value){
			this._shaderValues.setVector(7,value);
		});

		/**
		*设置漫反射贴图。
		*@param value 漫反射贴图。
		*/
		/**
		*获取漫反射贴图。
		*@return 漫反射贴图。
		*/
		__getset(0,__proto,'albedoTexture',function(){
			return this._shaderValues.getTexture(1);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_DIFFUSETEXTURE);
			else
			this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_DIFFUSETEXTURE);
			this._shaderValues.setTexture(1,value);
		});

		/**
		*设置是否激活放射属性。
		*@param value 是否激活放射属性
		*/
		/**
		*获取是否激活放射属性。
		*@return 是否激活放射属性。
		*/
		__getset(0,__proto,'enableEmission',function(){
			return this._shaderValues.getBool(16);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSION);
			else {
				this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSION);
			}
			this._shaderValues.setBool(16,value);
		});

		/**
		*设置金属光滑度贴图。
		*@param value 金属光滑度贴图。
		*/
		/**
		*获取金属光滑度贴图。
		*@return 金属光滑度贴图。
		*/
		__getset(0,__proto,'metallicGlossTexture',function(){
			return this._shaderValues.getTexture(2);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE);
			else
			this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE);
			this._shaderValues.setTexture(2,value);
		});

		/**
		*设置遮挡贴图。
		*@param value 遮挡贴图。
		*/
		/**
		*获取遮挡贴图。
		*@return 遮挡贴图。
		*/
		__getset(0,__proto,'occlusionTexture',function(){
			return this._shaderValues.getTexture(5);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
			else
			this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
			this._shaderValues.setTexture(5,value);
		});

		/**
		*设置法线贴图。
		*@param value 法线贴图。
		*/
		/**
		*获取法线贴图。
		*@return 法线贴图。
		*/
		__getset(0,__proto,'normalTexture',function(){
			return this._shaderValues.getTexture(3);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE);
			else
			this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE);
			this._shaderValues.setTexture(3,value);
		});

		/**
		*设置视差贴图。
		*@param value 视察贴图。
		*/
		/**
		*获取视差贴图。
		*@return 视察贴图。
		*/
		__getset(0,__proto,'parallaxTexture',function(){
			return this._shaderValues.getTexture(4);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE);
			else
			this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE);
			this._shaderValues.setTexture(4,value);
		});

		/**
		*设置放射颜色。
		*@param value 放射颜色。
		*/
		/**
		*获取放射颜色。
		*@return 放射颜色。
		*/
		__getset(0,__proto,'emissionColor',function(){
			return this._shaderValues.getVector(8);
			},function(value){
			this._shaderValues.setVector(8,value);
		});

		/**
		*设置法线贴图缩放系数。
		*@param value 法线贴图缩放系数。
		*/
		/**
		*获取法线贴图缩放系数。
		*@return 法线贴图缩放系数。
		*/
		__getset(0,__proto,'normalTextureScale',function(){
			return this._shaderValues.getNumber(14);
			},function(value){
			this._shaderValues.setNumber(14,value);
		});

		/**
		*设置视差贴图缩放系数。
		*@param value 视差缩放系数。
		*/
		/**
		*获取视差贴图缩放系数。
		*@return 视差缩放系数。
		*/
		__getset(0,__proto,'parallaxTextureScale',function(){
			return this._shaderValues.getNumber(15);
			},function(value){
			value=Math.max(0.005,Math.min(0.08,value));
			this._shaderValues.setNumber(15,value);
		});

		/**
		*设置遮挡贴图强度。
		*@param value 遮挡贴图强度,范围为0到1。
		*/
		/**
		*获取遮挡贴图强度。
		*@return 遮挡贴图强度,范围为0到1。
		*/
		__getset(0,__proto,'occlusionTextureStrength',function(){
			return this._shaderValues.getNumber(13);
			},function(value){
			value=Math.max(0.0,Math.min(1.0,value));
			this._shaderValues.setNumber(13,value);
		});

		/**
		*设置金属度。
		*@param value 金属度,范围为0到1。
		*/
		/**
		*获取金属度。
		*@return 金属度,范围为0到1。
		*/
		__getset(0,__proto,'metallic',function(){
			return this._shaderValues.getNumber(9);
			},function(value){
			value=Math.max(0.0,Math.min(1.0,value));
			this._shaderValues.setNumber(9,value);
		});

		/**
		*设置光滑度。
		*@param value 光滑度,范围为0到1。
		*/
		/**
		*获取光滑度。
		*@return 光滑度,范围为0到1。
		*/
		__getset(0,__proto,'smoothness',function(){
			return this._shaderValues.getNumber(10);
			},function(value){
			value=Math.max(0.0,Math.min(1.0,value));
			this._shaderValues.setNumber(10,value);
		});

		/**
		*设置光滑度缩放系数。
		*@param value 光滑度缩放系数,范围为0到1。
		*/
		/**
		*获取光滑度缩放系数。
		*@return 光滑度缩放系数,范围为0到1。
		*/
		__getset(0,__proto,'smoothnessTextureScale',function(){
			return this._shaderValues.getNumber(11);
			},function(value){
			value=Math.max(0.0,Math.min(1.0,value));
			this._shaderValues.setNumber(11,value);
		});

		/**
		*设置光滑度数据源。
		*@param value 光滑滑度数据源,0或1。
		*/
		/**
		*获取光滑度数据源
		*@return 光滑滑度数据源,0或1。
		*/
		__getset(0,__proto,'smoothnessSource',function(){
			return this._shaderValues.getNumber(12);
			},function(value){
			if (value==1)
				this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA);
			else {
				this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA);
				value=0;
			}
			this._shaderValues.setNumber(12,value);
		});

		/**
		*设置放射贴图。
		*@param value 放射贴图。
		*/
		/**
		*获取放射贴图。
		*@return 放射贴图。
		*/
		__getset(0,__proto,'emissionTexture',function(){
			return this._shaderValues.getTexture(6);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE);
			else
			this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE);
			this._shaderValues.setTexture(6,value);
		});

		/**
		*获取纹理平铺和偏移。
		*@param value 纹理平铺和偏移。
		*/
		__getset(0,__proto,'tilingOffset',null,function(value){
			if (value){
				var valueE=value.elements;
				if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
					this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET);
				else
				this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET);
				}else {
				this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET);
			}
			this._shaderValues.setVector(17,value);
		});

		PBRStandardMaterial.__init__=function(){
			PBRStandardMaterial.SHADERDEFINE_DIFFUSETEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("DIFFUSETEXTURE");
			PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("METALLICGLOSSTEXTURE");
			PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA=PBRStandardMaterial.shaderDefines.registerDefine("SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA");
			PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("NORMALTEXTURE");
			PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("PARALLAXTEXTURE");
			PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("OCCLUSIONTEXTURE");
			PBRStandardMaterial.SHADERDEFINE_EMISSION=PBRStandardMaterial.shaderDefines.registerDefine("EMISSION");
			PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("EMISSIONTEXTURE");
			PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET=PBRStandardMaterial.shaderDefines.registerDefine("TILINGOFFSET");
		}

		PBRStandardMaterial.SmoothnessSource_MetallicGlossTexture_Alpha=0;
		PBRStandardMaterial.SmoothnessSource_DiffuseTexture_Alpha=1;
		PBRStandardMaterial.SHADERDEFINE_DIFFUSETEXTURE=0;
		PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE=0;
		PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA=0;
		PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE=0;
		PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE=0;
		PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE=0;
		PBRStandardMaterial.SHADERDEFINE_EMISSION=0;
		PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE=0;
		PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET=0;
		PBRStandardMaterial.DIFFUSETEXTURE=1;
		PBRStandardMaterial.METALLICGLOSSTEXTURE=2;
		PBRStandardMaterial.NORMALTEXTURE=3;
		PBRStandardMaterial.PARALLAXTEXTURE=4;
		PBRStandardMaterial.OCCLUSIONTEXTURE=5;
		PBRStandardMaterial.EMISSIONTEXTURE=6;
		PBRStandardMaterial.DIFFUSECOLOR=7;
		PBRStandardMaterial.EMISSIONCOLOR=8;
		PBRStandardMaterial.METALLIC=9;
		PBRStandardMaterial.SMOOTHNESS=10;
		PBRStandardMaterial.SMOOTHNESSSCALE=11;
		PBRStandardMaterial.SMOOTHNESSSOURCE=12;
		PBRStandardMaterial.OCCLUSIONSTRENGTH=13;
		PBRStandardMaterial.NORMALSCALE=14;
		PBRStandardMaterial.PARALLAXSCALE=15;
		PBRStandardMaterial.ENABLEEMISSION=16;
		PBRStandardMaterial.TILINGOFFSET=17;
		__static(PBRStandardMaterial,
		['shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
		]);
		return PBRStandardMaterial;
	})(BaseMaterial)


	/**
	*<code>SkyBoxMaterial</code> 类用于实现SkyBoxMaterial材质。
	*/
	//class laya.d3.core.material.SkyBoxMaterial extends laya.d3.core.material.BaseMaterial
	var SkyBoxMaterial=(function(_super){
		/**
		*创建一个 <code>SkyBoxMaterial</code> 实例。
		*/
		function SkyBoxMaterial(){
			SkyBoxMaterial.__super.call(this,5);
			this.setShaderName("SkyBox");
		}

		__class(SkyBoxMaterial,'laya.d3.core.material.SkyBoxMaterial',_super);
		var __proto=SkyBoxMaterial.prototype;
		/**
		*设置颜色。
		*@param value 颜色。
		*/
		/**
		*获取颜色。
		*@return 颜色。
		*/
		__getset(0,__proto,'tintColor',function(){
			return this._shaderValues.getVector(1);
			},function(value){
			this._shaderValues.setVector(1,value);
		});

		/**
		*设置曝光强度。
		*@param value 曝光强度。
		*/
		/**
		*获取曝光强度。
		*@return 曝光强度。
		*/
		__getset(0,__proto,'exposure',function(){
			return this._shaderValues.getNumber(2);
			},function(value){
			this._shaderValues.setNumber(2,value);
		});

		/**
		*设置曝光强度。
		*@param value 曝光强度。
		*/
		/**
		*获取曝光强度。
		*@return 曝光强度。
		*/
		__getset(0,__proto,'rotation',function(){
			return this._shaderValues.getNumber(3);
			},function(value){
			this._shaderValues.setNumber(3,value);
		});

		/**
		*设置天空盒纹理。
		*/
		/**
		*获取天空盒纹理。
		*/
		__getset(0,__proto,'textureCube',function(){
			return this._shaderValues.getTexture(4);
			},function(value){
			return this._shaderValues.setTexture(4,value);
		});

		SkyBoxMaterial.load=function(url){
			return Laya.loader.create(url,null,null,SkyBoxMaterial);
		}

		SkyBoxMaterial.TINTCOLOR=1;
		SkyBoxMaterial.EXPOSURE=2;
		SkyBoxMaterial.ROTATION=3;
		SkyBoxMaterial.TEXTURECUBE=4;
		__static(SkyBoxMaterial,
		['defaultMaterial',function(){return this.defaultMaterial=new SkyBoxMaterial();}
		]);
		return SkyBoxMaterial;
	})(BaseMaterial)


	/**
	*...
	*@author ...
	*/
	//class laya.d3.core.material.StandardMaterial extends laya.d3.core.material.BaseMaterial
	var StandardMaterial=(function(_super){
		function StandardMaterial(){
			this._transformUV=null;
			StandardMaterial.__super.call(this,16);
			this.setShaderName("SIMPLE");
			var sv=this._shaderValues;
			sv.setVector(9,new Vector3(0.6,0.6,0.6));
			sv.setVector(10,new Vector3(1.0,1.0,1.0));
			sv.setVector(11,new Vector4(1.0,1.0,1.0,8.0));
			sv.setVector(12,new Vector3(1.0,1.0,1.0));
			sv.setVector(7,new Vector4(1.0,1.0,1.0,1.0));
			sv.setNumber(0,0.5);
			sv.setVector(15,new Vector4(1.0,1.0,0.0,0.0));
			this.renderMode=1;
		}

		__class(StandardMaterial,'laya.d3.core.material.StandardMaterial',_super);
		var __proto=StandardMaterial.prototype;
		/**
		*禁用灯光。
		*/
		__proto.disableLight=function(){
			this._disablePublicDefineDatas.add(Scene.SHADERDEFINE_POINTLIGHT | Scene.SHADERDEFINE_SPOTLIGHT | Scene.SHADERDEFINE_DIRECTIONLIGHT);
		}

		/**
		*禁用雾化。
		*/
		__proto.disableFog=function(){
			this._disablePublicDefineDatas.add(Shader3D.SHADERDEFINE_FOG);
		}

		/**
		*@inheritDoc
		*/
		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var dest=destObject;
			(this._transformUV)&& (dest._transformUV=this._transformUV.clone());
		}

		/**
		*设置环境光颜色。
		*@param value 环境光颜色。
		*/
		__getset(0,__proto,'ambientColor',function(){
			return this._shaderValues.getVector(9);
			},function(value){
			this._shaderValues.setVector(9,value);
		});

		/**
		*获取环境贴图。
		*@return 环境贴图。
		*/
		__getset(0,__proto,'ambientTexture',function(){
			return this._shaderValues.getTexture(5);
		});

		/**
		*设置渲染模式。
		*@return 渲染模式。
		*/
		__getset(0,__proto,'renderMode',null,function(value){
			var renderState=this.getRenderState();
			switch (value){
				case 1:
					this.renderQueue=1;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=0;
					this.alphaTest=false;
					this._defineDatas.remove(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 2:
					this.renderQueue=1;
					renderState.depthWrite=true;
					renderState.cull=0;
					renderState.blend=0;
					this.alphaTest=false;
					this._defineDatas.remove(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 3:
					this.renderQueue=1;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=0;
					this.alphaTest=true;
					this._defineDatas.remove(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 4:
					this.renderQueue=1;
					renderState.depthWrite=true;
					renderState.cull=0;
					renderState.blend=0;
					this.alphaTest=true;
					this._defineDatas.remove(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 13:
					this.renderQueue=2;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					this.alphaTest=false;
					this._defineDatas.remove(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 14:
					this.renderQueue=2;
					renderState.depthWrite=true;
					renderState.cull=0;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					this.alphaTest=false;
					this._defineDatas.remove(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 15:
					this.renderQueue=2;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=1;
					this.alphaTest=false;
					this._defineDatas.add(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 16:
					this.renderQueue=2;
					renderState.depthWrite=true;
					renderState.cull=0;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=1;
					this.alphaTest=false;
					this._defineDatas.add(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 5:
					this.renderQueue=2;
					renderState.depthWrite=false;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					this.alphaTest=false;
					this._defineDatas.remove(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 6:
					this.renderQueue=2;
					renderState.depthWrite=false;
					renderState.cull=0;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					this.alphaTest=false;
					this._defineDatas.remove(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 7:
					this.renderQueue=2;
					renderState.depthWrite=false;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=1;
					this.alphaTest=false;
					this._defineDatas.add(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 8:
					this.renderQueue=2;
					renderState.depthWrite=false;
					renderState.cull=0;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=1;
					renderState.alphaTest=false;
					this._defineDatas.add(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 9:
					this.renderQueue=2;
					renderState.depthTest=0x0201;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					renderState.alphaTest=false;
					this._defineDatas.remove(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 10:
					this.renderQueue=2;
					renderState.depthTest=0x0201;
					renderState.cull=0;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					this.alphaTest=false;
					this._defineDatas.remove(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 11:
					this.renderQueue=2;
					renderState.depthTest=0x0201;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=1;
					this.alphaTest=false;
					this._defineDatas.add(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 12:
					this.renderQueue=2;
					renderState.depthTest=0x0201;
					renderState.cull=0;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=1;
					this.alphaTest=false;
					this._defineDatas.add(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				default :
					throw new Error("Material:renderMode value error.");
				}
		});

		/**
		*设置反射颜色。
		*@param value 反射颜色。
		*/
		__getset(0,__proto,'reflectColor',function(){
			return this._shaderValues.getVector(12);
			},function(value){
			this._shaderValues.setVector(12,value);
		});

		/**
		*获取纹理平铺和偏移。
		*@param value 纹理平铺和偏移。
		*/
		/**
		*获取纹理平铺和偏移。
		*@return 纹理平铺和偏移。
		*/
		__getset(0,__proto,'tilingOffset',function(){
			return this._shaderValues.getVector(15);
			},function(value){
			if (value){
				var valueE=value.elements;
				if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
					this._defineDatas.add(laya.d3.core.material.StandardMaterial.SHADERDEFINE_TILINGOFFSET);
				else
				this._defineDatas.remove(laya.d3.core.material.StandardMaterial.SHADERDEFINE_TILINGOFFSET);
				}else {
				this._defineDatas.remove(laya.d3.core.material.StandardMaterial.SHADERDEFINE_TILINGOFFSET);
			}
			this._shaderValues.setVector(15,value);
		});

		/**
		*设置反射率。
		*@param value 反射率。
		*/
		__getset(0,__proto,'albedo',function(){
			return this._shaderValues.getVector(7);
			},function(value){
			this._shaderValues.setVector(7,value);
		});

		/**
		*设置漫反射光颜色。
		*@param value 漫反射光颜色。
		*/
		__getset(0,__proto,'diffuseColor',function(){
			return this._shaderValues.getVector(10);
			},function(value){
			this._shaderValues.setVector(10,value);
		});

		/**
		*设置反射率。
		*@param value 反射率。
		*/
		__getset(0,__proto,'albedoColor',function(){
			return this._shaderValues.getVector(7);
			},function(value){
			this._shaderValues.setVector(7,value);
		});

		/**
		*设置高光颜色。
		*@param value 高光颜色。
		*/
		__getset(0,__proto,'specularColor',function(){
			return this._shaderValues.getVector(11);
			},function(value){
			this._shaderValues.setVector(11,value);
		});

		/**
		*设置漫反射贴图。
		*@param value 漫反射贴图。
		*/
		/**
		*获取漫反射贴图。
		*@return 漫反射贴图。
		*/
		__getset(0,__proto,'diffuseTexture',function(){
			return this._shaderValues.getTexture(1);
			},function(value){
			if (value){
				this._defineDatas.add(laya.d3.core.material.StandardMaterial.SHADERDEFINE_DIFFUSEMAP);
				}else {
				this._defineDatas.remove(laya.d3.core.material.StandardMaterial.SHADERDEFINE_DIFFUSEMAP);
			}
			this._shaderValues.setTexture(1,value);
		});

		/**
		*设置法线贴图。
		*@param value 法线贴图。
		*/
		/**
		*获取法线贴图。
		*@return 法线贴图。
		*/
		__getset(0,__proto,'normalTexture',function(){
			return this._shaderValues.getTexture(2);
			},function(value){
			if (value){
				this._defineDatas.add(laya.d3.core.material.StandardMaterial.SHADERDEFINE_NORMALMAP);
				}else {
				this._defineDatas.remove(laya.d3.core.material.StandardMaterial.SHADERDEFINE_NORMALMAP);
			}
			this._shaderValues.setTexture(2,value);
		});

		/**
		*设置高光贴图。
		*@param value 高光贴图。
		*/
		/**
		*获取高光贴图。
		*@return 高光贴图。
		*/
		__getset(0,__proto,'specularTexture',function(){
			return this._shaderValues.getTexture(3);
			},function(value){
			if (value){
				this._defineDatas.add(laya.d3.core.material.StandardMaterial.SHADERDEFINE_SPECULARMAP);
				}else {
				this._defineDatas.remove(laya.d3.core.material.StandardMaterial.SHADERDEFINE_SPECULARMAP);
			}
			this._shaderValues.setTexture(3,value);
		});

		/**
		*设置放射贴图。
		*@param value 放射贴图。
		*/
		/**
		*获取放射贴图。
		*@return 放射贴图。
		*/
		__getset(0,__proto,'emissiveTexture',function(){
			return this._shaderValues.getTexture(4);
			},function(value){
			if (value){
				this._defineDatas.add(laya.d3.core.material.StandardMaterial.SHADERDEFINE_EMISSIVEMAP);
				}else {
				this._defineDatas.remove(laya.d3.core.material.StandardMaterial.SHADERDEFINE_EMISSIVEMAP);
			}
			this._shaderValues.setTexture(4,value);
		});

		/**
		*设置反射贴图。
		*@param value 反射贴图。
		*/
		/**
		*获取反射贴图。
		*@return 反射贴图。
		*/
		__getset(0,__proto,'reflectTexture',function(){
			return this._shaderValues.getTexture(6);
			},function(value){
			if (value){
				this._defineDatas.add(laya.d3.core.material.StandardMaterial.SHADERDEFINE_REFLECTMAP);
				}else {
				this._defineDatas.remove(laya.d3.core.material.StandardMaterial.SHADERDEFINE_REFLECTMAP);
			}
			this._shaderValues.setTexture(6,value);
		});

		/**
		*设置UV变换。
		*@param value UV变换。
		*/
		/**
		*获取UV变换。
		*@return UV变换。
		*/
		__getset(0,__proto,'transformUV',function(){
			return this._transformUV;
			},function(value){
			this._transformUV=value;
			this._shaderValues.setMatrix4x4(13,value.matrix);
			if (value)
				this._defineDatas.add(laya.d3.core.material.StandardMaterial.SHADERDEFINE_UVTRANSFORM);
			else
			this._defineDatas.remove(laya.d3.core.material.StandardMaterial.SHADERDEFINE_UVTRANSFORM);
		});

		StandardMaterial.__init__=function(){
			StandardMaterial.SHADERDEFINE_DIFFUSEMAP=StandardMaterial.shaderDefines.registerDefine("DIFFUSEMAP");
			StandardMaterial.SHADERDEFINE_NORMALMAP=StandardMaterial.shaderDefines.registerDefine("NORMALMAP");
			StandardMaterial.SHADERDEFINE_SPECULARMAP=StandardMaterial.shaderDefines.registerDefine("SPECULARMAP");
			StandardMaterial.SHADERDEFINE_EMISSIVEMAP=StandardMaterial.shaderDefines.registerDefine("EMISSIVEMAP");
			StandardMaterial.SHADERDEFINE_REFLECTMAP=StandardMaterial.shaderDefines.registerDefine("REFLECTMAP");
			StandardMaterial.SHADERDEFINE_UVTRANSFORM=StandardMaterial.shaderDefines.registerDefine("UVTRANSFORM");
			StandardMaterial.SHADERDEFINE_TILINGOFFSET=StandardMaterial.shaderDefines.registerDefine("TILINGOFFSET");
			StandardMaterial.SHADERDEFINE_ADDTIVEFOG=StandardMaterial.shaderDefines.registerDefine("ADDTIVEFOG");
		}

		StandardMaterial.load=function(url){
			return Laya.loader.create(url,null,null,StandardMaterial);
		}

		StandardMaterial.RENDERMODE_OPAQUE=1;
		StandardMaterial.RENDERMODE_OPAQUEDOUBLEFACE=2;
		StandardMaterial.RENDERMODE_CUTOUT=3;
		StandardMaterial.RENDERMODE_CUTOUTDOUBLEFACE=4;
		StandardMaterial.RENDERMODE_TRANSPARENT=13;
		StandardMaterial.RENDERMODE_TRANSPARENTDOUBLEFACE=14;
		StandardMaterial.RENDERMODE_ADDTIVE=15;
		StandardMaterial.RENDERMODE_ADDTIVEDOUBLEFACE=16;
		StandardMaterial.RENDERMODE_DEPTHREAD_TRANSPARENT=5;
		StandardMaterial.RENDERMODE_DEPTHREAD_TRANSPARENTDOUBLEFACE=6;
		StandardMaterial.RENDERMODE_DEPTHREAD_ADDTIVE=7;
		StandardMaterial.RENDERMODE_DEPTHREAD_ADDTIVEDOUBLEFACE=8;
		StandardMaterial.RENDERMODE_NONDEPTH_TRANSPARENT=9;
		StandardMaterial.RENDERMODE_NONDEPTH_TRANSPARENTDOUBLEFACE=10;
		StandardMaterial.RENDERMODE_NONDEPTH_ADDTIVE=11;
		StandardMaterial.RENDERMODE_NONDEPTH_ADDTIVEDOUBLEFACE=12;
		StandardMaterial.SHADERDEFINE_DIFFUSEMAP=0;
		StandardMaterial.SHADERDEFINE_NORMALMAP=0;
		StandardMaterial.SHADERDEFINE_SPECULARMAP=0;
		StandardMaterial.SHADERDEFINE_EMISSIVEMAP=0;
		StandardMaterial.SHADERDEFINE_REFLECTMAP=0;
		StandardMaterial.SHADERDEFINE_UVTRANSFORM=0;
		StandardMaterial.SHADERDEFINE_TILINGOFFSET=0;
		StandardMaterial.SHADERDEFINE_ADDTIVEFOG=0;
		StandardMaterial.DIFFUSETEXTURE=1;
		StandardMaterial.NORMALTEXTURE=2;
		StandardMaterial.SPECULARTEXTURE=3;
		StandardMaterial.EMISSIVETEXTURE=4;
		StandardMaterial.AMBIENTTEXTURE=5;
		StandardMaterial.REFLECTTEXTURE=6;
		StandardMaterial.ALBEDO=7;
		StandardMaterial.UVANIAGE=8;
		StandardMaterial.MATERIALAMBIENT=9;
		StandardMaterial.MATERIALDIFFUSE=10;
		StandardMaterial.MATERIALSPECULAR=11;
		StandardMaterial.MATERIALREFLECT=12;
		StandardMaterial.UVMATRIX=13;
		StandardMaterial.UVAGE=14;
		StandardMaterial.TILINGOFFSET=15;
		__static(StandardMaterial,
		['defaultMaterial',function(){return this.defaultMaterial=new StandardMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
		]);
		return StandardMaterial;
	})(BaseMaterial)


	/**
	*...
	*@author ...
	*/
	//class laya.d3.core.material.TerrainMaterial extends laya.d3.core.material.BaseMaterial
	var TerrainMaterial=(function(_super){
		function TerrainMaterial(){
			this._diffuseScale1=null;
			this._diffuseScale2=null;
			this._diffuseScale3=null;
			this._diffuseScale4=null;
			TerrainMaterial.__super.call(this,13);
			this.setShaderName("Terrain");
			this.renderMode=1;
			this._diffuseScale1=new Vector2();
			this._diffuseScale2=new Vector2();
			this._diffuseScale3=new Vector2();
			this._diffuseScale4=new Vector2();
			this.ambientColor=new Vector3(0.6,0.6,0.6);
			this.diffuseColor=new Vector3(1.0,1.0,1.0);
			this.specularColor=new Vector4(0.2,0.2,0.2,32.0);
		}

		__class(TerrainMaterial,'laya.d3.core.material.TerrainMaterial',_super);
		var __proto=TerrainMaterial.prototype;
		__proto.setDiffuseScale1=function(x,y){
			this._diffuseScale1.x=x;
			this._diffuseScale1.y=y;
			this._shaderValues.setVector(6,this._diffuseScale1);
		}

		__proto.setDiffuseScale2=function(x,y){
			this._diffuseScale2.x=x;
			this._diffuseScale2.y=y;
			this._shaderValues.setVector(7,this._diffuseScale2);
		}

		__proto.setDiffuseScale3=function(x,y){
			this._diffuseScale3.x=x;
			this._diffuseScale3.y=y;
			this._shaderValues.setVector(8,this._diffuseScale3);
		}

		__proto.setDiffuseScale4=function(x,y){
			this._diffuseScale4.x=x;
			this._diffuseScale4.y=y;
			this._shaderValues.setVector(9,this._diffuseScale4);
		}

		__proto.setDetailNum=function(value){
			switch (value){
				case 1:
					this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
					this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
					this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
					this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
					break ;
				case 2:
					this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
					this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
					this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
					this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
					break ;
				case 3:
					this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
					this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
					this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
					this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
					break ;
				case 4:
					this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
					this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
					this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
					this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
					break ;
				}
		}

		__proto.disableLight=function(){
			this._disablePublicDefineDatas.add(Scene.SHADERDEFINE_POINTLIGHT | Scene.SHADERDEFINE_SPOTLIGHT | Scene.SHADERDEFINE_DIRECTIONLIGHT);
		}

		/**
		*@inheritDoc
		*/
		__proto.setShaderName=function(name){
			_super.prototype.setShaderName.call(this,name);
		}

		/**
		*设置渲染模式。
		*@return 渲染模式。
		*/
		__getset(0,__proto,'renderMode',null,function(value){
			var renderState=this.getRenderState();
			switch (value){
				case 1:
					this.renderQueue=1;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=0;
					renderState.depthTest=0x0201;
					break ;
				case 2:
					this.renderQueue=1;
					renderState.depthWrite=false;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					renderState.depthTest=0x0203;
					break ;
				default :
					throw new Error("TerrainMaterial:renderMode value error.");
				}
		});

		/**
		*设置第二层贴图。
		*@param value 第二层贴图。
		*/
		/**
		*获取第二层贴图。
		*@return 第二层贴图。
		*/
		__getset(0,__proto,'diffuseTexture2',function(){
			return this._shaderValues.getTexture(3);
			},function(value){
			this._shaderValues.setTexture(3,value);
		});

		__getset(0,__proto,'ambientColor',function(){
			return this._shaderValues.getVector(10);
			},function(value){
			this._shaderValues.setVector(10,value);
		});

		/**
		*设置第四层贴图。
		*@param value 第四层贴图。
		*/
		/**
		*获取第四层贴图。
		*@return 第四层贴图。
		*/
		__getset(0,__proto,'diffuseTexture4',function(){
			return this._shaderValues.getTexture(5);
			},function(value){
			this._shaderValues.setTexture(5,value);
		});

		__getset(0,__proto,'diffuseColor',function(){
			return this._shaderValues.getVector(11);
			},function(value){
			this._shaderValues.setVector(11,value);
		});

		/**
		*设置第一层贴图。
		*@param value 第一层贴图。
		*/
		/**
		*获取第一层贴图。
		*@return 第一层贴图。
		*/
		__getset(0,__proto,'diffuseTexture1',function(){
			return this._shaderValues.getTexture(2);
			},function(value){
			this._shaderValues.setTexture(2,value);
		});

		__getset(0,__proto,'specularColor',function(){
			return this._shaderValues.getVector(12);
			},function(value){
			this._shaderValues.setVector(12,value);
		});

		/**
		*设置第三层贴图。
		*@param value 第三层贴图。
		*/
		/**
		*获取第三层贴图。
		*@return 第三层贴图。
		*/
		__getset(0,__proto,'diffuseTexture3',function(){
			return this._shaderValues.getTexture(4);
			},function(value){
			this._shaderValues.setTexture(4,value);
		});

		/**
		*设置splatAlpha贴图。
		*@param value splatAlpha贴图。
		*/
		/**
		*获取splatAlpha贴图。
		*@return splatAlpha贴图。
		*/
		__getset(0,__proto,'splatAlphaTexture',function(){
			return this._shaderValues.getTexture(0);
			},function(value){
			this._shaderValues.setTexture(0,value);
		});

		__getset(0,__proto,'normalTexture',function(){
			return this._shaderValues.getTexture(1);
			},function(value){
			this._shaderValues.setTexture(1,value);
		});

		TerrainMaterial.__init__=function(){
			TerrainMaterial.SHADERDEFINE_DETAIL_NUM1=TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM1");
			TerrainMaterial.SHADERDEFINE_DETAIL_NUM2=TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM2");
			TerrainMaterial.SHADERDEFINE_DETAIL_NUM4=TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM4");
			TerrainMaterial.SHADERDEFINE_DETAIL_NUM3=TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM3");
		}

		TerrainMaterial.load=function(url){
			return Laya.loader.create(url,null,null,TerrainMaterial);
		}

		TerrainMaterial.RENDERMODE_OPAQUE=1;
		TerrainMaterial.RENDERMODE_TRANSPARENT=2;
		TerrainMaterial.SPLATALPHATEXTURE=0;
		TerrainMaterial.NORMALTEXTURE=1;
		TerrainMaterial.DIFFUSETEXTURE1=2;
		TerrainMaterial.DIFFUSETEXTURE2=3;
		TerrainMaterial.DIFFUSETEXTURE3=4;
		TerrainMaterial.DIFFUSETEXTURE4=5;
		TerrainMaterial.DIFFUSESCALE1=6;
		TerrainMaterial.DIFFUSESCALE2=7;
		TerrainMaterial.DIFFUSESCALE3=8;
		TerrainMaterial.DIFFUSESCALE4=9;
		TerrainMaterial.MATERIALAMBIENT=10;
		TerrainMaterial.MATERIALDIFFUSE=11;
		TerrainMaterial.MATERIALSPECULAR=12;
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM1=0;
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM2=0;
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM3=0;
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM4=0;
		__static(TerrainMaterial,
		['defaultMaterial',function(){return this.defaultMaterial=new TerrainMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
		]);
		return TerrainMaterial;
	})(BaseMaterial)


	//class laya.d3.core.material.WaterMaterial extends laya.d3.core.material.BaseMaterial
	var WaterMaterial=(function(_super){
		function WaterMaterial(){
			this._useVertexDeep=false;
			WaterMaterial.__super.call(this,21);
			this.setShaderName("Water");
		}

		__class(WaterMaterial,'laya.d3.core.material.WaterMaterial',_super);
		var __proto=WaterMaterial.prototype;
		/**
		*禁用雾化。
		*/
		__proto.disableFog=function(){
			this._disablePublicDefineDatas.add(Shader3D.SHADERDEFINE_FOG);
		}

		/**
		*设置漫反射贴图。
		*@param value 漫反射贴图。
		*/
		/**
		*获取漫反射贴图。
		*@return 漫反射贴图。
		*/
		__getset(0,__proto,'diffuseTexture',function(){
			return this._shaderValues.getTexture(1);
			},function(value){
			this._shaderValues.setTexture(1,value);
		});

		/**
		*设置法线贴图。
		*@param value 法线贴图。
		*/
		/**
		*获取法线贴图。
		*@return 法线贴图。
		*/
		__getset(0,__proto,'normalTexture',function(){
			return this._shaderValues.getTexture(2);
			},function(value){
			this._shaderValues.setTexture(2,value);
		});

		__getset(0,__proto,'underWaterTexture',function(){
			return this._shaderValues.getTexture(3);
			},function(value){
			this._shaderValues.setTexture(3,value);
		});

		__getset(0,__proto,'deepColorTexture',function(){
			return this._shaderValues.getTexture(10);
			},function(v){
			this._shaderValues.setTexture(10,v);
		});

		__getset(0,__proto,'useFoam',null,function(v){
			if (v){
				this._defineDatas.add(WaterMaterial.SHADERDEFINE_USE_FOAM);
				}else {
				this._defineDatas.remove(WaterMaterial.SHADERDEFINE_USE_FOAM);
			}
		});

		__getset(0,__proto,'skyTexture',function(){
			return this._shaderValues.getTexture(11);
			},function(v){
			this._shaderValues.setTexture(11,v);
		});

		__getset(0,__proto,'deepScale',function(){
			return this._shaderValues.getNumber(20);
			},function(v){
			this._shaderValues.setNumber(20,v);
		});

		__getset(0,__proto,'detailTexture',function(){
			return this._shaderValues.getTexture(9);
			},function(value){
			this._shaderValues.setTexture(9,value);
		});

		__getset(0,__proto,'foamTexture',function(){
			return this._shaderValues.getTexture(17);
			},function(v){
			this._shaderValues.setTexture(17,v);
		});

		__getset(0,__proto,'waterInfoTexture',function(){
			return this._shaderValues.getTexture(16);
			},function(v){
			this._shaderValues.setTexture(16,v);
		});

		/**
		*对定点进行变换的纹理。现在不用
		*/
		__getset(0,__proto,'vertexDispTexture',function(){
			return this._shaderValues.getTexture(4);
			},function(value){
			this._shaderValues.setTexture(4,value);
		});

		__getset(0,__proto,'currentTm',function(){
			return this._shaderValues.getNumber(8);
			},function(v){
			this._shaderValues.setNumber(8,v);
		});

		__getset(0,__proto,'waveInfo',function(){
			return this._shaderValues.getBuffer(12);
			},function(v){
			this._shaderValues.setBuffer(12,v);
		});

		__getset(0,__proto,'waveInfoD',function(){
			return this._shaderValues.getBuffer(13);
			},function(v){
			this._shaderValues.setBuffer(13,v);
		});

		__getset(0,__proto,'waveMainDir',function(){
			return this._shaderValues.getNumber(14);
			},function(deg){
			this._shaderValues.setNumber(14,deg *Math.PI / 180);
		});

		__getset(0,__proto,'geoWaveUVScale',function(){
			return this._shaderValues.getNumber(18);
			},function(v){
			this._shaderValues.setNumber(18,v);
		});

		__getset(0,__proto,'windSpeed',function(){
			return 0;
			},function(s){
		});

		__getset(0,__proto,'scrsize',null,function(v){
			this._shaderValues.setBuffer(15,v);
		});

		__getset(0,__proto,'seaColor',function(){
			return this._shaderValues.getBuffer(19);
			},function(v){
			this._shaderValues.setBuffer(19,v);
		});

		__getset(0,__proto,'useVertexDeep',function(){
			return this._useVertexDeep;
			},function(v){
			this._useVertexDeep=v;
			if (v)
				this._defineDatas.add(WaterMaterial.SHADERDEFINE_USEVERTEXHEIGHT);
			else {
				this._defineDatas.remove(WaterMaterial.SHADERDEFINE_USEVERTEXHEIGHT);
			}
		});

		__getset(0,__proto,'windDir',function(){
			return 0;
			},function(d){
		});

		__getset(0,__proto,'useRefractTexture',null,function(v){
			if (v){
				this._defineDatas.add(WaterMaterial.SHADERDEFINE_USE_REFRACT_TEX);
				}else {
				this._defineDatas.remove(WaterMaterial.SHADERDEFINE_USE_REFRACT_TEX);
			}
		});

		__getset(0,__proto,'renderMode',null,function(value){
			var renderState=this.getRenderState();
			switch (value){
				case 1:
					this.renderQueue=1;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=0;
					this.alphaTest=false;
					break ;
				case 2:
					this.renderQueue=1;
					renderState.depthWrite=true;
					renderState.cull=0;
					renderState.blend=0;
					this.alphaTest=false;
					break ;
				case 3:
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=0;
					this.renderQueue=1;
					break ;
				case 13:
					this.renderQueue=2;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					break ;
				default :
					throw new Error("PBRMaterial:renderMode value error.");
				}
		});

		WaterMaterial.__init__=function(){
			WaterMaterial.SHADERDEFINE_CUBE_ENV=WaterMaterial.shaderDefines.registerDefine("CUBE_ENV");
			WaterMaterial.SHADERDEFINE_HDR_ENV=WaterMaterial.shaderDefines.registerDefine("HDR_ENV");
			WaterMaterial.SHADERDEFINE_SHOW_NORMAL=WaterMaterial.shaderDefines.registerDefine("SHOW_NORMAL");
			WaterMaterial.SHADERDEFINE_USEVERTEXHEIGHT=WaterMaterial.shaderDefines.registerDefine("USE_VERTEX_DEEPINFO");
			WaterMaterial.SHADERDEFINE_USE_FOAM=WaterMaterial.shaderDefines.registerDefine("USE_FOAM");
			WaterMaterial.SHADERDEFINE_USE_REFRACT_TEX=WaterMaterial.shaderDefines.registerDefine("USE_REFR_TEX");
		}

		WaterMaterial.load=function(url){
			return Laya.loader.create(url,null,null,WaterMaterial);
		}

		WaterMaterial.DIFFUSETEXTURE=1;
		WaterMaterial.NORMALTEXTURE=2;
		WaterMaterial.UNDERWATERTEXTURE=3;
		WaterMaterial.VERTEXDISPTEXTURE=4;
		WaterMaterial.UVANIAGE=5;
		WaterMaterial.UVMATRIX=6;
		WaterMaterial.UVAGE=7;
		WaterMaterial.CURTM=8;
		WaterMaterial.DETAILTEXTURE=9;
		WaterMaterial.DEEPCOLORTEXTURE=10;
		WaterMaterial.SKYTEXTURE=11;
		WaterMaterial.WAVEINFO=12;
		WaterMaterial.WAVEINFOD=13;
		WaterMaterial.WAVEMAINDIR=14;
		WaterMaterial.SCRSIZE=15;
		WaterMaterial.WATERINFO=16;
		WaterMaterial.FOAMTEXTURE=17;
		WaterMaterial.GEOWAVE_UV_SCALE=18;
		WaterMaterial.SEA_COLOR=19;
		WaterMaterial.WAVEINFODEEPSCALE=20;
		WaterMaterial.SHADERDEFINE_SHOW_NORMAL=0;
		WaterMaterial.SHADERDEFINE_CUBE_ENV=0;
		WaterMaterial.SHADERDEFINE_HDR_ENV=0;
		WaterMaterial.SHADERDEFINE_USE_FOAM=0;
		WaterMaterial.SHADERDEFINE_USE_REFRACT_TEX=0;
		WaterMaterial.SHADERDEFINE_USEVERTEXHEIGHT=0;
		WaterMaterial.RENDERMODE_OPAQUE=1;
		WaterMaterial.RENDERMODE_OPAQUEDOUBLEFACE=2;
		WaterMaterial.RENDERMODE_CUTOUT=3;
		WaterMaterial.RENDERMODE_CUTOUTDOUBLEFACE=4;
		WaterMaterial.RENDERMODE_TRANSPARENT=13;
		__static(WaterMaterial,
		['defaultMaterial',function(){return this.defaultMaterial=new WaterMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
		]);
		return WaterMaterial;
	})(BaseMaterial)


	/**
	*...
	*@author ...
	*/
	//class laya.d3.core.particleShuriKen.ShurikenParticleMaterial extends laya.d3.core.material.BaseMaterial
	var ShurikenParticleMaterial=(function(_super){
		function ShurikenParticleMaterial(){
			ShurikenParticleMaterial.__super.call(this,4);
			this.setShaderName("PARTICLESHURIKEN");
			this.renderMode=6;
		}

		__class(ShurikenParticleMaterial,'laya.d3.core.particleShuriKen.ShurikenParticleMaterial',_super);
		var __proto=ShurikenParticleMaterial.prototype;
		/**
		*设置渲染模式。
		*@return 渲染模式。
		*/
		__getset(0,__proto,'renderMode',null,function(value){
			var renderState=this.getRenderState();
			switch (value){
				case 1:
					this.renderQueue=1;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=0;
					this.alphaTest=false;
					this._defineDatas.remove(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 2:
					this.renderQueue=1;
					renderState.depthWrite=true;
					renderState.cull=0;
					renderState.blend=0;
					this.alphaTest=false;
					this._defineDatas.remove(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 3:
					this.renderQueue=1;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=0;
					this.alphaTest=true;
					this._defineDatas.remove(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 4:
					this.renderQueue=1;
					renderState.depthWrite=true;
					renderState.cull=0;
					renderState.blend=0;
					this.alphaTest=true;
					this._defineDatas.remove(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 13:
					this.renderQueue=2;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					this.alphaTest=false;
					this._defineDatas.remove(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 14:
					this.renderQueue=2;
					renderState.depthWrite=true;
					renderState.cull=0;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					this.alphaTest=false;
					this._defineDatas.remove(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 15:
					this.renderQueue=2;
					renderState.depthWrite=true;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=1;
					this.alphaTest=false;
					this._defineDatas.add(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 16:
					this.renderQueue=2;
					renderState.depthWrite=true;
					renderState.cull=0;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=1;
					this.alphaTest=false;
					this._defineDatas.add(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 5:
					this.renderQueue=2;
					renderState.depthWrite=false;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					this.alphaTest=false;
					this._defineDatas.remove(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 6:
					this.renderQueue=2;
					renderState.depthWrite=false;
					renderState.cull=0;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					this.alphaTest=false;
					this._defineDatas.remove(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 7:
					this.renderQueue=2;
					renderState.depthWrite=false;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=1;
					this.alphaTest=false;
					this._defineDatas.add(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 8:
					this.renderQueue=2;
					renderState.depthWrite=false;
					renderState.cull=0;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=1;
					this.alphaTest=false;
					this._defineDatas.add(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 9:
					this.renderQueue=2;
					renderState.depthTest=RenderQueue.DEPTHTEST_LESS;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					this.alphaTest=false;
					this._defineDatas.remove(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 10:
					this.renderQueue=2;
					renderState.depthTest=0x0201;
					renderState.cull=0;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=0x0303;
					this.alphaTest=false;
					this._defineDatas.remove(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 11:
					this.renderQueue=2;
					renderState.depthTest=0x0201;
					renderState.cull=2;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=1;
					this.alphaTest=false;
					this._defineDatas.add(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				case 12:
					this.renderQueue=2;
					renderState.depthTest=RenderQueue.DEPTHTEST_LESS;
					renderState.cull=0;
					renderState.blend=1;
					renderState.srcBlend=0x0302;
					renderState.dstBlend=1;
					this.alphaTest=false;
					this._defineDatas.add(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
					break ;
				default :
					throw new Error("Material:renderMode value error.");
				}
		});

		/**
		*设置颜色。
		*@param value 颜色。
		*/
		/**
		*获取颜色。
		*@return 颜色。
		*/
		__getset(0,__proto,'tintColor',function(){
			return this._shaderValues.getVector(2);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR);
			else
			this._defineDatas.remove(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR);
			this._shaderValues.setVector(2,value);
		});

		/**
		*获取纹理平铺和偏移。
		*@param value 纹理平铺和偏移。
		*/
		/**
		*获取纹理平铺和偏移。
		*@return 纹理平铺和偏移。
		*/
		__getset(0,__proto,'tilingOffset',function(){
			return this._shaderValues.getVector(3);
			},function(value){
			if (value){
				var valueE=value.elements;
				if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
					this._defineDatas.add(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET);
				else
				this._defineDatas.remove(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET);
				}else {
				this._defineDatas.remove(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET);
			}
			this._shaderValues.setVector(3,value);
		});

		/**
		*设置漫反射贴图。
		*@param value 漫反射贴图。
		*/
		/**
		*获取漫反射贴图。
		*@return 漫反射贴图。
		*/
		__getset(0,__proto,'diffuseTexture',function(){
			return this._shaderValues.getTexture(1);
			},function(value){
			if (value)
				this._defineDatas.add(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP);
			else
			this._defineDatas.remove(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP);
			this._shaderValues.setTexture(1,value);
		});

		ShurikenParticleMaterial.__init__=function(){
			ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP=ShurikenParticleMaterial.shaderDefines.registerDefine("DIFFUSEMAP");
			ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR=ShurikenParticleMaterial.shaderDefines.registerDefine("TINTCOLOR");
			ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG=ShurikenParticleMaterial.shaderDefines.registerDefine("ADDTIVEFOG");
			ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET=ShurikenParticleMaterial.shaderDefines.registerDefine("TILINGOFFSET");
		}

		ShurikenParticleMaterial.load=function(url){
			return Laya.loader.create(url,null,null,ShurikenParticleMaterial);
		}

		ShurikenParticleMaterial.RENDERMODE_OPAQUE=1;
		ShurikenParticleMaterial.RENDERMODE_OPAQUEDOUBLEFACE=2;
		ShurikenParticleMaterial.RENDERMODE_CUTOUT=3;
		ShurikenParticleMaterial.RENDERMODE_CUTOUTDOUBLEFACE=4;
		ShurikenParticleMaterial.RENDERMODE_TRANSPARENT=13;
		ShurikenParticleMaterial.RENDERMODE_TRANSPARENTDOUBLEFACE=14;
		ShurikenParticleMaterial.RENDERMODE_ADDTIVE=15;
		ShurikenParticleMaterial.RENDERMODE_ADDTIVEDOUBLEFACE=16;
		ShurikenParticleMaterial.RENDERMODE_DEPTHREAD_TRANSPARENT=5;
		ShurikenParticleMaterial.RENDERMODE_DEPTHREAD_TRANSPARENTDOUBLEFACE=6;
		ShurikenParticleMaterial.RENDERMODE_DEPTHREAD_ADDTIVE=7;
		ShurikenParticleMaterial.RENDERMODE_DEPTHREAD_ADDTIVEDOUBLEFACE=8;
		ShurikenParticleMaterial.RENDERMODE_NONDEPTH_TRANSPARENT=9;
		ShurikenParticleMaterial.RENDERMODE_NONDEPTH_TRANSPARENTDOUBLEFACE=10;
		ShurikenParticleMaterial.RENDERMODE_NONDEPTH_ADDTIVE=11;
		ShurikenParticleMaterial.RENDERMODE_NONDEPTH_ADDTIVEDOUBLEFACE=12;
		ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP=0;
		ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR=0;
		ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET=0;
		ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG=0;
		ShurikenParticleMaterial.DIFFUSETEXTURE=1;
		ShurikenParticleMaterial.TINTCOLOR=2;
		ShurikenParticleMaterial.TILINGOFFSET=3;
		__static(ShurikenParticleMaterial,
		['defaultMaterial',function(){return this.defaultMaterial=new ShurikenParticleMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
		]);
		return ShurikenParticleMaterial;
	})(BaseMaterial)


	//class laya.webgl.shader.Shader extends laya.webgl.shader.BaseShader
	var Shader=(function(_super){
		function Shader(vs,ps,saveName,nameMap){
			this._attribInfo=null;
			this.customCompile=false;
			//this._nameMap=null;
			//this._vs=null;
			//this._ps=null;
			this._curActTexIndex=0;
			//this._reCompile=false;
			this.tag={};
			//this._vshader=null;
			//this._pshader=null;
			this._program=null;
			this._params=null;
			this._paramsMap={};
			//this._id=0;
			Shader.__super.call(this);
			if ((!vs)|| (!ps))throw "Shader Error";
			if (Render.isConchApp || Render.isFlash){
				this.customCompile=true;
			}
			this._id=++Shader._count;
			this._vs=vs;
			this._ps=ps;
			this._nameMap=nameMap ? nameMap :{};
			saveName !=null && (Shader.sharders[saveName]=this);
			this.recreateResource();
		}

		__class(Shader,'laya.webgl.shader.Shader',_super);
		var __proto=Shader.prototype;
		__proto.recreateResource=function(){
			this._compile();
			this.memorySize=0;
		}

		//忽略尺寸尺寸
		__proto.disposeResource=function(){
			WebGL.mainContext.deleteShader(this._vshader);
			WebGL.mainContext.deleteShader(this._pshader);
			WebGL.mainContext.deleteProgram(this._program);
			this._vshader=this._pshader=this._program=null;
			this._params=null;
			this._paramsMap={};
			this.memorySize=0;
			this._curActTexIndex=0;
		}

		__proto._compile=function(){
			if (!this._vs || !this._ps || this._params)
				return;
			this._reCompile=true;
			this._params=[];
			var result;
			if (this.customCompile)
				result=ShaderCompile.preGetParams(this._vs,this._ps);
			var gl=WebGL.mainContext;
			this._program=gl.createProgram();
			this._vshader=Shader._createShader(gl,this._vs,0x8B31);
			this._pshader=Shader._createShader(gl,this._ps,0x8B30);
			gl.attachShader(this._program,this._vshader);
			gl.attachShader(this._program,this._pshader);
			var one,i=0,j=0,n=0,location;
			var attribDescNum=this._attribInfo?this._attribInfo.length:0;
			for (i=0;i < attribDescNum;i+=2){
				gl.bindAttribLocation(this._program,this._attribInfo[i+1],this._attribInfo[i]);
			}
			gl.linkProgram(this._program);
			if (!this.customCompile && !gl.getProgramParameter(this._program,0x8B82)){
				throw gl.getProgramInfoLog(this._program);
			};
			var nUniformNum=this.customCompile ? result.uniforms.length :gl.getProgramParameter(this._program,0x8B86);
			for (i=0;i < nUniformNum;i++){
				var uniform=this.customCompile ? result.uniforms[i] :gl.getActiveUniform(this._program,i);
				location=gl.getUniformLocation(this._program,uniform.name);
				one={vartype:"uniform",glfun:null,ivartype:1,location:location,name:uniform.name,type:uniform.type,isArray:false,isSame:false,preValue:null,indexOfParams:0};
				if (one.name.indexOf('[0]')> 0){
					one.name=one.name.substr(0,one.name.length-3);
					one.isArray=true;
					one.location=gl.getUniformLocation(this._program,one.name);
				}
				this._params.push(one);
			}
			for (i=0,n=this._params.length;i < n;i++){
				one=this._params[i];
				one.indexOfParams=i;
				one.index=1;
				one.value=[one.location,null];
				one.codename=one.name;
				one.name=this._nameMap[one.codename] ? this._nameMap[one.codename] :one.codename;
				this._paramsMap[one.name]=one;
				one._this=this;
				one.uploadedValue=[];
				switch (one.type){
					case 0x1404:
						one.fun=one.isArray ? this._uniform1iv :this._uniform1i;
						break ;
					case 0x1406:
						one.fun=one.isArray ? this._uniform1fv :this._uniform1f;
						break ;
					case 0x8B50:
						one.fun=one.isArray ? this._uniform_vec2v:this._uniform_vec2;
						break ;
					case 0x8B51:
						one.fun=one.isArray ? this._uniform_vec3v:this._uniform_vec3;
						break ;
					case 0x8B52:
						one.fun=one.isArray ? this._uniform_vec4v:this._uniform_vec4;
						break ;
					case 0x8B5E:
						one.fun=this._uniform_sampler2D;
						break ;
					case 0x8B60:
						one.fun=this._uniform_samplerCube;
						break ;
					case 0x8B5C:
						one.glfun=gl.uniformMatrix4fv;
						one.fun=this._uniformMatrix4fv;
						break ;
					case 0x8B56:
						one.fun=this._uniform1i;
						break ;
					case 0x8B5A:
					case 0x8B5B:
						throw new Error("compile shader err!");
						break ;
					default :
						throw new Error("compile shader err!");
						break ;
					}
			}
		}

		/**
		*根据变量名字获得
		*@param name
		*@return
		*/
		__proto.getUniform=function(name){
			return this._paramsMap[name];
		}

		__proto._uniform1f=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value){
				WebGL.mainContext.uniform1f(one.location,uploadedValue[0]=value);
				return 1;
			}
			return 0;
		}

		__proto._uniform1fv=function(one,value){
			if (value.length < 4){
				var uploadedValue=one.uploadedValue;
				if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
					WebGL.mainContext.uniform1fv(one.location,value);
					uploadedValue[0]=value[0];
					uploadedValue[1]=value[1];
					uploadedValue[2]=value[2];
					uploadedValue[3]=value[3];
					return 1;
				}
				return 0;
				}else {
				WebGL.mainContext.uniform1fv(one.location,value);
				return 1;
			}
		}

		__proto._uniform_vec2=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1]){
				WebGL.mainContext.uniform2f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec2v=function(one,value){
			if (value.length < 2){
				var uploadedValue=one.uploadedValue;
				if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
					WebGL.mainContext.uniform2fv(one.location,value);
					uploadedValue[0]=value[0];
					uploadedValue[1]=value[1];
					uploadedValue[2]=value[2];
					uploadedValue[3]=value[3];
					return 1;
				}
				return 0;
				}else {
				WebGL.mainContext.uniform2fv(one.location,value);
				return 1;
			}
		}

		__proto._uniform_vec3=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2]){
				WebGL.mainContext.uniform3f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec3v=function(one,value){
			WebGL.mainContext.uniform3fv(one.location,value);
			return 1;
		}

		__proto._uniform_vec4=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
				WebGL.mainContext.uniform4f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2],uploadedValue[3]=value[3]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec4v=function(one,value){
			WebGL.mainContext.uniform4fv(one.location,value);
			return 1;
		}

		__proto._uniformMatrix2fv=function(one,value){
			WebGL.mainContext.uniformMatrix2fv(one.location,false,value);
			return 1;
		}

		__proto._uniformMatrix3fv=function(one,value){
			WebGL.mainContext.uniformMatrix3fv(one.location,false,value);
			return 1;
		}

		__proto._uniformMatrix4fv=function(one,value){
			WebGL.mainContext.uniformMatrix4fv(one.location,false,value);
			return 1;
		}

		__proto._uniform1i=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value){
				WebGL.mainContext.uniform1i(one.location,uploadedValue[0]=value);
				return 1;
			}
			return 0;
		}

		__proto._uniform1iv=function(one,value){
			WebGL.mainContext.uniform1iv(one.location,value);
			return 1;
		}

		__proto._uniform_ivec2=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1]){
				WebGL.mainContext.uniform2i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_ivec2v=function(one,value){
			WebGL.mainContext.uniform2iv(one.location,value);
			return 1;
		}

		__proto._uniform_vec3i=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2]){
				WebGL.mainContext.uniform3i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec3vi=function(one,value){
			WebGL.mainContext.uniform3iv(one.location,value);
			return 1;
		}

		__proto._uniform_vec4i=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
				WebGL.mainContext.uniform4i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2],uploadedValue[3]=value[3]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec4vi=function(one,value){
			WebGL.mainContext.uniform4iv(one.location,value);
			return 1;
		}

		__proto._uniform_sampler2D=function(one,value){
			var gl=WebGL.mainContext;
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]==null){
				uploadedValue[0]=this._curActTexIndex;
				gl.uniform1i(one.location,this._curActTexIndex);
				WebGLContext.activeTexture(gl,0x84C0+this._curActTexIndex);
				WebGLContext.bindTexture(gl,0x0DE1,value);
				this._curActTexIndex++;
				return 1;
				}else {
				WebGLContext.activeTexture(gl,0x84C0+uploadedValue[0]);
				WebGLContext.bindTexture(gl,0x0DE1,value);
				return 0;
			}
		}

		__proto._uniform_samplerCube=function(one,value){
			var gl=WebGL.mainContext;
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]==null){
				uploadedValue[0]=this._curActTexIndex;
				gl.uniform1i(one.location,this._curActTexIndex);
				WebGLContext.activeTexture(gl,0x84C0+this._curActTexIndex);
				WebGLContext.bindTexture(gl,0x8513,value);
				this._curActTexIndex++;
				return 1;
				}else {
				WebGLContext.activeTexture(gl,0x84C0+uploadedValue[0]);
				WebGLContext.bindTexture(gl,0x8513,value);
				return 0;
			}
		}

		__proto._noSetValue=function(one){
			console.log("no....:"+one.name);
		}

		//throw new Error("upload shader err,must set value:"+one.name);
		__proto.uploadOne=function(name,value){
			WebGLContext.useProgram(WebGL.mainContext,this._program);
			var one=this._paramsMap[name];
			one.fun.call(this,one,value);
		}

		__proto.uploadTexture2D=function(value){
			Stat.shaderCall++;
			var gl=WebGL.mainContext;
			WebGLContext.activeTexture(gl,0x84C0);
			WebGLContext.bindTexture(gl,0x0DE1,value);
		}

		/**
		*提交shader到GPU
		*@param shaderValue
		*/
		__proto.upload=function(shaderValue,params){
			BaseShader.activeShader=BaseShader.bindShader=this;
			var gl=WebGL.mainContext;
			WebGLContext.useProgram(gl,this._program);
			if (this._reCompile){
				params=this._params;
				this._reCompile=false;
				}else {
				params=params || this._params;
			};
			var one,value,n=params.length,shaderCall=0;
			for (var i=0;i < n;i++){
				one=params[i];
				if ((value=shaderValue[one.name])!==null)
					shaderCall+=one.fun.call(this,one,value);
			}
			Stat.shaderCall+=shaderCall;
		}

		/**
		*按数组的定义提交
		*@param shaderValue 数组格式[name,value,...]
		*/
		__proto.uploadArray=function(shaderValue,length,_bufferUsage){
			BaseShader.activeShader=this;
			BaseShader.bindShader=this;
			WebGLContext.useProgram(WebGL.mainContext,this._program);
			var params=this._params,value;
			var one,shaderCall=0;
			for (var i=length-2;i >=0;i-=2){
				one=this._paramsMap[shaderValue[i]];
				if (!one)
					continue ;
				value=shaderValue[i+1];
				if (value !=null){
					_bufferUsage && _bufferUsage[one.name] && _bufferUsage[one.name].bind();
					shaderCall+=one.fun.call(this,one,value);
				}
			}
			Stat.shaderCall+=shaderCall;
		}

		/**
		*得到编译后的变量及相关预定义
		*@return
		*/
		__proto.getParams=function(){
			return this._params;
		}

		/**
		*设置shader里面的attribute绑定到哪个location，必须与mesh2d的对应起来，
		*这个必须在编译之前设置。
		*@param attribDesc 属性描述，格式是 [attributeName,location,attributeName,location ... ]
		*/
		__proto.setAttributesLocation=function(attribDesc){
			this._attribInfo=attribDesc;
		}

		Shader.getShader=function(name){
			return Shader.sharders[name];
		}

		Shader.create=function(vs,ps,saveName,nameMap){
			return new Shader(vs,ps,saveName,nameMap);
		}

		Shader.withCompile=function(nameID,define,shaderName,createShader){
			if (shaderName && Shader.sharders[shaderName])
				return Shader.sharders[shaderName];
			var pre=Shader._preCompileShader[0.0002 *nameID];
			if (!pre)
				throw new Error("withCompile shader err!"+nameID);
			return pre.createShader(define,shaderName,createShader);
		}

		Shader.withCompile2D=function(nameID,mainID,define,shaderName,createShader){
			if (shaderName && Shader.sharders[shaderName])
				return Shader.sharders[shaderName];
			var pre=Shader._preCompileShader[0.0002 *nameID+mainID];
			if (!pre)
				throw new Error("withCompile shader err!"+nameID+" "+mainID);
			return pre.createShader(define,shaderName,createShader);
		}

		Shader.addInclude=function(fileName,txt){
			ShaderCompile.addInclude(fileName,txt);
		}

		Shader.preCompile=function(nameID,vs,ps,nameMap){
			var id=0.0002 *nameID;
			Shader._preCompileShader[id]=new ShaderCompile(vs,ps,nameMap);
		}

		Shader.preCompile2D=function(nameID,mainID,vs,ps,nameMap){
			var id=0.0002 *nameID+mainID;
			Shader._preCompileShader[id]=new ShaderCompile(vs,ps,nameMap);
		}

		Shader._createShader=function(gl,str,type){
			var shader=gl.createShader(type);
			gl.shaderSource(shader,str);
			gl.compileShader(shader);
			if(gl.getShaderParameter(shader,gl.COMPILE_STATUS)){
				return shader;
				}else{
				console.log(gl.getShaderInfoLog(shader));
				return null;
			}
		}

		Shader._count=0;
		Shader._preCompileShader={};
		Shader.SHADERNAME2ID=0.0002;
		Shader.sharders=new Array(0x20);
		__static(Shader,
		['nameKey',function(){return this.nameKey=new StringKey();}
		]);
		return Shader;
	})(BaseShader)


	//class laya.webgl.utils.Buffer2D extends laya.webgl.utils.Buffer
	var Buffer2D=(function(_super){
		function Buffer2D(){
			this._maxsize=0;
			this._upload=true;
			this._uploadSize=0;
			this._bufferSize=0;
			this._u8Array=null;
			Buffer2D.__super.call(this);
			this.lock=true;
		}

		__class(Buffer2D,'laya.webgl.utils.Buffer2D',_super);
		var __proto=Buffer2D.prototype;
		__proto.setByteLength=function(value){
			if (this._byteLength!==value){
				value <=this._bufferSize || (this._resizeBuffer(value *2+256,true));
				this._byteLength=value;
			}
		}

		/**
		*在当前的基础上需要多大空间，单位是byte
		*@param sz
		*@return 增加大小之前的写位置。单位是byte
		*/
		__proto.needSize=function(sz){
			var old=this._byteLength;
			if (sz){
				var needsz=this._byteLength+sz;
				needsz <=this._bufferSize || (this._resizeBuffer(needsz << 1,true));
				this._byteLength=needsz;
			}
			return old;
		}

		__proto._bufferData=function(){
			this._maxsize=Math.max(this._maxsize,this._byteLength);
			if (Stat.loopCount % 30==0){
				if (this._buffer.byteLength > (this._maxsize+64)){
					this.memorySize=this._buffer.byteLength;
					this._buffer=this._buffer.slice(0,this._maxsize+64);
					this._bufferSize=this._buffer.byteLength;
					this._checkArrayUse();
				}
				this._maxsize=this._byteLength;
			}
			if (this._uploadSize < this._buffer.byteLength){
				this._uploadSize=this._buffer.byteLength;
				LayaGL.instance.bufferData(this._bufferType,this._uploadSize,this._bufferUsage);
				this.memorySize=this._uploadSize;
			}
			LayaGL.instance.bufferSubData(this._bufferType,0,this._buffer);
		}

		__proto._bufferSubData=function(offset,dataStart,dataLength){
			(offset===void 0)&& (offset=0);
			(dataStart===void 0)&& (dataStart=0);
			(dataLength===void 0)&& (dataLength=0);
			this._maxsize=Math.max(this._maxsize,this._byteLength);
			if (Stat.loopCount % 30==0){
				if (this._buffer.byteLength > (this._maxsize+64)){
					this.memorySize=this._buffer.byteLength;
					this._buffer=this._buffer.slice(0,this._maxsize+64);
					this._bufferSize=this._buffer.byteLength;
					this._checkArrayUse();
				}
				this._maxsize=this._byteLength;
			}
			if (this._uploadSize < this._buffer.byteLength){
				this._uploadSize=this._buffer.byteLength;
				LayaGL.instance.bufferData(this._bufferType,this._uploadSize,this._bufferUsage);
				this.memorySize=this._uploadSize;
			}
			if (dataStart || dataLength){
				var subBuffer=this._buffer.slice(dataStart,dataLength);
				LayaGL.instance.bufferSubData(this._bufferType,offset,subBuffer);
				}else {
				LayaGL.instance.bufferSubData(this._bufferType,offset,this._buffer);
			}
		}

		/**
		*buffer重新分配了，继承类根据需要做相应的处理。
		*/
		__proto._checkArrayUse=function(){}
		/**
		*给vao使用的 _bind_upload函数。不要与已经绑定的判断是否相同
		*@return
		*/
		__proto._bind_uploadForVAO=function(){
			if (!this._upload)
				return false;
			this._upload=false;
			this._bindForVAO();
			this._bufferData();
			return true;
		}

		__proto._bind_upload=function(){
			if (!this._upload)
				return false;
			this._upload=false;
			this.bind();
			this._bufferData();
			return true;
		}

		__proto._bind_subUpload=function(offset,dataStart,dataLength){
			(offset===void 0)&& (offset=0);
			(dataStart===void 0)&& (dataStart=0);
			(dataLength===void 0)&& (dataLength=0);
			if (!this._upload)
				return false;
			this._upload=false;
			this.bind();
			this._bufferSubData(offset,dataStart,dataLength);
			return true;
		}

		/**
		*重新分配buffer大小，如果nsz比原来的小则什么都不做。
		*@param nsz buffer大小，单位是byte。
		*@param copy 是否拷贝原来的buffer的数据。
		*@return
		*/
		__proto._resizeBuffer=function(nsz,copy){
			if (nsz < this._buffer.byteLength)
				return this;
			this.memorySize=nsz;
			if (copy && this._buffer && this._buffer.byteLength > 0){
				var newbuffer=new ArrayBuffer(nsz);
				var oldU8Arr=(this._u8Array && this._u8Array.buffer==this._buffer)?this._u8Array :new Uint8Array(this._buffer);
				this._u8Array=new Uint8Array(newbuffer);
				this._u8Array.set(oldU8Arr,0);
				this._buffer=newbuffer;
				}else{
				this._buffer=new ArrayBuffer(nsz);
			}
			this._checkArrayUse();
			this._upload=true;
			this._bufferSize=this._buffer.byteLength;
			return this;
		}

		__proto.append=function(data){
			this._upload=true;
			var byteLen=0,n;
			byteLen=data.byteLength;
			if ((data instanceof Uint8Array)){
				this._resizeBuffer(this._byteLength+byteLen,true);
				n=new Uint8Array(this._buffer,this._byteLength);
				}else if ((data instanceof Uint16Array)){
				this._resizeBuffer(this._byteLength+byteLen,true);
				n=new Uint16Array(this._buffer,this._byteLength);
				}else if ((data instanceof Float32Array)){
				this._resizeBuffer(this._byteLength+byteLen,true);
				n=new Float32Array(this._buffer,this._byteLength);
			}
			n.set(data,0);
			this._byteLength+=byteLen;
			this._checkArrayUse();
		}

		/**
		*附加Uint16Array的数据。数据长度是len。byte的话要*2
		*@param data
		*@param len
		*/
		__proto.appendU16Array=function(data,len){
			this._resizeBuffer(this._byteLength+len*2,true);
			var u=new Uint16Array(this._buffer,this._byteLength,len);
			for (var i=0;i < len;i++){
				u[i]=data[i];
			}
			this._byteLength+=len *2;
			this._checkArrayUse();
		}

		__proto.appendEx=function(data,type){
			this._upload=true;
			var byteLen=0,n;
			byteLen=data.byteLength;
			this._resizeBuffer(this._byteLength+byteLen,true);
			n=new type(this._buffer,this._byteLength);
			n.set(data,0);
			this._byteLength+=byteLen;
			this._checkArrayUse();
		}

		__proto.appendEx2=function(data,type,dataLen,perDataLen){
			(perDataLen===void 0)&& (perDataLen=1);
			this._upload=true;
			var byteLen=0,n;
			byteLen=dataLen*perDataLen;
			this._resizeBuffer(this._byteLength+byteLen,true);
			n=new type(this._buffer,this._byteLength);
			var i=0;
			for (i=0;i < dataLen;i++){
				n[i]=data[i];
			}
			this._byteLength+=byteLen;
			this._checkArrayUse();
		}

		__proto.getBuffer=function(){
			return this._buffer;
		}

		__proto.setNeedUpload=function(){
			this._upload=true;
		}

		__proto.getNeedUpload=function(){
			return this._upload;
		}

		__proto.upload=function(){
			var scuess=this._bind_upload();
			LayaGL.instance.bindBuffer(this._bufferType,null);
			if(this._bufferType==0x8892)Buffer._bindedVertexBuffer=null;
			if(this._bufferType==0x8893)Buffer._bindedIndexBuffer=null;
			BaseShader.activeShader=null
			return scuess;
		}

		__proto.subUpload=function(offset,dataStart,dataLength){
			(offset===void 0)&& (offset=0);
			(dataStart===void 0)&& (dataStart=0);
			(dataLength===void 0)&& (dataLength=0);
			var scuess=this._bind_subUpload();
			LayaGL.instance.bindBuffer(this._bufferType,null);
			if(this._bufferType==0x8892)Buffer._bindedVertexBuffer=null;
			if(this._bufferType==0x8893)Buffer._bindedIndexBuffer=null;
			BaseShader.activeShader=null
			return scuess;
		}

		__proto.disposeResource=function(){
			_super.prototype.disposeResource.call(this);
			this._upload=true;
			this._uploadSize=0;
		}

		/**
		*清理数据。保留ArrayBuffer
		*/
		__proto.clear=function(){
			this._byteLength=0;
			this._upload=true;
		}

		//反正常常要拷贝老的数据，所以保留这个可以提高效率
		__getset(0,__proto,'bufferLength',function(){
			return this._buffer.byteLength;
		});

		__getset(0,__proto,'byteLength',null,function(value){
			this.setByteLength(value);
		});

		Buffer2D.__int__=function(gl){
			IndexBuffer2D.QuadrangleIB=IndexBuffer2D.create(0x88E4);
			GlUtils.fillIBQuadrangle(IndexBuffer2D.QuadrangleIB,16);
		}

		Buffer2D.FLOAT32=4;
		Buffer2D.SHORT=2;
		return Buffer2D;
	})(Buffer)


	/**
	*<code>SkinAnimations</code> 类用于创建蒙皮动画组件。
	*/
	//class laya.d3.component.animation.SkinAnimations extends laya.d3.component.animation.KeyframeAnimations
	var SkinAnimations=(function(_super){
		function SkinAnimations(){
			this._tempCurAnimationData=null;
			this._tempCurBonesData=null;
			this._curOriginalData=null;
			this._lastFrameIndex=-1;
			this._curMeshAnimationData=null;
			this._curBonesDatas=null;
			this._curAnimationDatas=null;
			this._ownerMesh=null;
			this._boneIndexToMeshList=null;
			this._oldVersion=false;
			SkinAnimations.__super.call(this);
			this._boneIndexToMeshList=[];
		}

		__class(SkinAnimations,'laya.d3.component.animation.SkinAnimations',_super);
		var __proto=SkinAnimations.prototype;
		/**
		*@private
		*/
		__proto._computeBoneIndexToMeshOnTemplet=function(){
			if (this._templet.loaded)
				this._computeBoneIndexToMeshOnMesh();
			else
			this._templet.once("loaded",this,this._computeBoneIndexToMeshOnMesh);
		}

		/**
		*@private
		*/
		__proto._computeBoneIndexToMeshOnMesh=function(){
			if (this._templet._aniVersion==="LAYAANIMATION:02")
				this._oldVersion=false;
			else
			this._oldVersion=true;
			var mesh=(this._owner).meshFilter.sharedMesh;
			if (mesh.loaded)
				this._computeBoneIndexToMesh(mesh);
			else
			mesh.on("loaded",this,this._computeBoneIndexToMesh);
		}

		/**
		*@private
		*/
		__proto._computeBoneIndexToMesh=function(mesh){
			var meshBoneNames=mesh._boneNames;
			if (meshBoneNames){
				var binPoseCount=meshBoneNames.length;
				var anis=this._templet._anis;
				for (var i=0,n=anis.length;i < n;i++){
					var boneIndexToMesh=this._boneIndexToMeshList[i];
					(boneIndexToMesh)|| (boneIndexToMesh=this._boneIndexToMeshList[i]=[]);
					boneIndexToMesh.length=binPoseCount;
					var ani=anis[i];
					for (var j=0;j < binPoseCount;j++)
					boneIndexToMesh[j]=ani.bone3DMap[meshBoneNames[j]];
				}
			}
		}

		/**@private */
		__proto._getAnimationDatasWithCache=function(rate,mesh,cacheDatas,aniIndex,frameIndex){
			var aniDatas=cacheDatas[aniIndex];
			if (!aniDatas){
				return null;
				}else {
				var rateDatas=aniDatas[rate];
				if (!rateDatas)
					return null;
				else {
					var meshDatas=rateDatas[mesh.id];
					if (!meshDatas)
						return null;
					else
					return meshDatas[frameIndex];
				}
			}
		}

		/**@private */
		__proto._setAnimationDatasWithCache=function(rate,mesh,cacheDatas,aniIndex,frameIndex,animationDatas){
			var aniDatas=(cacheDatas[aniIndex])|| (cacheDatas[aniIndex]={});
			var rateDatas=(aniDatas[rate])|| (aniDatas[rate]={});
			var meshDatas=(rateDatas[mesh.id])|| (rateDatas[mesh.id]=[]);
			meshDatas[frameIndex]=animationDatas;
		}

		/**@private */
		__proto._onAnimationPlayMeshLoaded=function(){
			var renderElements=this._ownerMesh.meshRender._renderElements;
			for (var i=0,n=renderElements.length;i < n;i++)
			renderElements[i]._canDynamicBatch=false;
		}

		/**@private */
		__proto._onAnimationPlay=function(){
			this._ownerMesh._render._defineDatas.add(SkinnedMeshSprite3D.SHADERDEFINE_BONE);
			var mesh=this._ownerMesh.meshFilter.sharedMesh;
			if (mesh.loaded)
				this._onAnimationPlayMeshLoaded();
			else
			mesh.once("loaded",this,this._onAnimationPlayMeshLoaded);
		}

		/**@private */
		__proto._onAnimationStop=function(){
			this._lastFrameIndex=-1;
			if (this._player.returnToZeroStopped){
				this._curBonesDatas=null;
				this._curAnimationDatas=null;
				this._ownerMesh._render._defineDatas.remove(SkinnedMeshSprite3D.SHADERDEFINE_BONE);
			};
			var renderElements=this._ownerMesh.meshRender._renderElements;
			for (var i=0,n=renderElements.length;i < n;i++)
			renderElements[i]._canDynamicBatch=true;
		}

		/**
		*@inheritDoc
		*/
		__proto._onActive=function(){
			SkinAnimations._componentPool.add(this);
		}

		/**
		*@inheritDoc
		*/
		__proto._onInActive=function(){
			SkinAnimations._componentPool.remove(this);
		}

		/**
		*@inheritDoc
		*/
		__proto._initialize=function(owner){
			_super.prototype._initialize.call(this,owner);
			this._ownerMesh=(owner);
			this._player.on("played",this,this._onAnimationPlay);
			this._player.on("stopped",this,this._onAnimationStop);
			(this._owner).meshFilter.on("meshchanged",this,this._computeBoneIndexToMeshOnTemplet);
		}

		/**
		*@private
		*更新蒙皮动画组件。
		*@param state 渲染状态参数。
		*/
		__proto._update=function(state){
			this._player._update(Laya.timer.delta);
			var mesh=this._ownerMesh.meshFilter.sharedMesh;
			if (this._player.state!==2 || !this._templet || !this._templet.loaded || !mesh.loaded)
				return;
			var rate=this._player.playbackRate *Laya.timer.scale;
			var cachePlayRate=this._player.cachePlayRate;
			var isCache=this._player.isCache && rate >=cachePlayRate;
			var frameIndex=isCache ? this.currentFrameIndex :-1;
			if (frameIndex!==-1 && this._lastFrameIndex===frameIndex)
				return;
			var animationClipIndex=this.currentAnimationClipIndex;
			var boneDatasCache=this._templet._animationDatasCache[0];
			var animationDatasCache=this._templet._animationDatasCache[1];
			if (isCache){
				var cacheAnimationDatas=this._getAnimationDatasWithCache(cachePlayRate,mesh,animationDatasCache,animationClipIndex,frameIndex);
				if (cacheAnimationDatas){
					this._curAnimationDatas=cacheAnimationDatas;
					this._curBonesDatas=this._templet.getAnimationDataWithCache(cachePlayRate,boneDatasCache,animationClipIndex,frameIndex);
					this._lastFrameIndex=frameIndex;
					return;
				}
			};
			var isCacheBonesDatas=false;
			if (isCache){
				this._curBonesDatas=this._templet.getAnimationDataWithCache(cachePlayRate,boneDatasCache,animationClipIndex,frameIndex);
				isCacheBonesDatas=this._curBonesDatas ? true :false;
			};
			var bones=this._templet.getNodes(animationClipIndex);
			var boneFloatCount=bones.length *16;
			var inverseAbsoluteBindPoses=mesh.inverseAbsoluteBindPoses;
			if (this._oldVersion)
				(this._curMeshAnimationData)|| (this._curMeshAnimationData=new Float32Array(boneFloatCount));
			else
			(this._curMeshAnimationData)|| (this._curMeshAnimationData=new Float32Array(inverseAbsoluteBindPoses.length *16));
			var i=0,n=0,j=0;
			var curSubAnimationDatas,subMesh,boneIndicesCount=0;
			var subMeshCount=mesh.subMeshCount;
			if (isCache){
				this._curAnimationDatas=[];
				this._curAnimationDatas.length=subMeshCount;
				for (i=0;i < subMeshCount;i++){
					curSubAnimationDatas=this._curAnimationDatas[i]=[];
					subMesh=mesh._getSubMesh(i);
					boneIndicesCount=subMesh._boneIndicesList.length;
					curSubAnimationDatas.length=boneIndicesCount;
					for (j=0;j < boneIndicesCount;j++)
					curSubAnimationDatas[j]=new Float32Array(subMesh._boneIndicesList[j].length *16);
				}
				(isCacheBonesDatas)|| (this._curBonesDatas=new Float32Array(boneFloatCount));
				}else {
				if (!this._tempCurAnimationData){
					this._tempCurAnimationData=[];
					this._tempCurAnimationData.length=subMeshCount;
					for (i=0;i < subMeshCount;i++){
						curSubAnimationDatas=this._tempCurAnimationData[i]=[];
						subMesh=mesh._getSubMesh(i);
						boneIndicesCount=subMesh._boneIndicesList.length;
						curSubAnimationDatas.length=boneIndicesCount;
						for (j=0;j < boneIndicesCount;j++)
						curSubAnimationDatas[j]=new Float32Array(subMesh._boneIndicesList[j].length *16);
					}
				}
				(this._tempCurBonesData)|| (this._tempCurBonesData=new Float32Array(boneFloatCount));
				this._curAnimationDatas=this._tempCurAnimationData;
				this._curBonesDatas=this._tempCurBonesData;
			}
			this._curOriginalData || (this._curOriginalData=new Float32Array(this._templet.getTotalkeyframesLength(animationClipIndex)));
			if (isCache)
				this._templet.getOriginalData(animationClipIndex,this._curOriginalData,this._player._fullFrames[animationClipIndex],frameIndex,this._player.currentFrameTime);
			else
			this._templet.getOriginalDataUnfixedRate(animationClipIndex,this._curOriginalData,this._player.currentPlayTime);
			if (this._oldVersion){
				if (isCache && isCacheBonesDatas)
					Utils3D._computeAnimationDatasByArrayAndMatrixFastOld(inverseAbsoluteBindPoses,this._curBonesDatas,this._curMeshAnimationData);
				else
				Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxixOld(bones,this._curOriginalData,inverseAbsoluteBindPoses,this._curBonesDatas,this._curMeshAnimationData);
				}else {
				var boneIndexToMesh=this._boneIndexToMeshList[animationClipIndex];
				if (isCache && isCacheBonesDatas)
					Utils3D._computeAnimationDatasByArrayAndMatrixFast(inverseAbsoluteBindPoses,this._curBonesDatas,this._curMeshAnimationData,boneIndexToMesh);
				else
				Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxix(bones,this._curOriginalData,inverseAbsoluteBindPoses,this._curBonesDatas,this._curMeshAnimationData,boneIndexToMesh);
			}
			for (i=0;i < subMeshCount;i++){
				var boneIndicesList=mesh._getSubMesh(i)._boneIndicesList;
				boneIndicesCount=boneIndicesList.length;
				curSubAnimationDatas=this._curAnimationDatas[i]
				for (j=0;j < boneIndicesCount;j++)
				SkinAnimations._splitAnimationDatas(boneIndicesList[j],this._curMeshAnimationData,curSubAnimationDatas[j]);
			}
			if (isCache){
				this._setAnimationDatasWithCache(cachePlayRate,mesh,animationDatasCache,animationClipIndex,frameIndex,this._curAnimationDatas);
				(isCacheBonesDatas)|| (this._templet.setAnimationDataWithCache(cachePlayRate,boneDatasCache,animationClipIndex,frameIndex,this._curBonesDatas));
			}
			this._lastFrameIndex=frameIndex;
		}

		/**
		*@private
		*在渲染前更新蒙皮动画组件渲染参数。
		*@param state 渲染状态参数。
		*/
		__proto._preRenderUpdate=function(state){
			var subMesh=state.renderElement.geometry;
			if (this._curAnimationDatas)
				subMesh._skinAnimationDatas=this._curAnimationDatas[subMesh._indexInMesh];
			else
			subMesh._skinAnimationDatas=null;
		}

		/**
		*@inheritDoc
		*/
		__proto._uninitialize=function(){
			(this.player.state==2)&& (this._ownerMesh._render._defineDatas.remove(SkinnedMeshSprite3D.SHADERDEFINE_BONE));
			(this._templet && !this._templet.loaded)&& (this._templet.off("loaded",this,this._computeBoneIndexToMeshOnMesh));
			var mesh=this._ownerMesh.meshFilter.sharedMesh;
			(mesh.loaded)|| (mesh.off("loaded",this,this._onAnimationPlayMeshLoaded));
			_super.prototype._uninitialize.call(this);
			this._tempCurAnimationData=null;
			this._tempCurBonesData=null;
			this._curOriginalData=null;
			this._curMeshAnimationData=null;
			this._curBonesDatas=null;
			this._curAnimationDatas=null;
			this._ownerMesh=null;
		}

		/**
		*获取骨骼数据。
		*@return 骨骼数据。
		*/
		__getset(0,__proto,'curBonesDatas',function(){
			return this._curBonesDatas;
		});

		__getset(0,__proto,'templet',_super.prototype._$get_templet,function(value){
			if (this._templet!==value){
				if (this._player.state!==0)
					this._player.stop(true);
				this._templet=value;
				this._player.templet=value;
				this._computeBoneIndexToMeshOnTemplet();
				this._curOriginalData=null;
				this._curMeshAnimationData=null;
				this._tempCurBonesData=null;
				this._tempCurAnimationData=null;
				(this._templet._animationDatasCache)|| (this._templet._animationDatasCache=[[],[]]);
				this.event("animationchanged",this);
			}
		});

		SkinAnimations._splitAnimationDatas=function(indices,bonesData,subAnimationDatas){
			for (var i=0,n=indices.length,ii=0;i < n;i++){
				for (var j=0;j < 16;j++,ii++){
					subAnimationDatas[ii]=bonesData[(indices[i] << 4)+j];
				}
			}
		}

		SkinAnimations._update=function(){
			var elements=SkinAnimations._componentPool.elements;
			for (var i=0;i < elements.length;i++){
				var animation=elements[i];
				(animation && animation.enable)&& (animation._update());
			}
			SkinAnimations._componentPool.clear();
		}

		__static(SkinAnimations,
		['_componentPool',function(){return this._componentPool=new ComponentPool();}
		]);
		return SkinAnimations;
	})(KeyframeAnimations)


	/**
	*<code>BoxCollider</code> 类用于创建盒子碰撞器。
	*/
	//class laya.d3.component.physics.BoxCollider extends laya.d3.component.physics.Collider
	var BoxCollider=(function(_super){
		function BoxCollider(){
			this._size=null;
			this._transformOrientedBoundBox=null;
			this.center=null;
			BoxCollider.__super.call(this);
			this._needUpdate=false;
		}

		__class(BoxCollider,'laya.d3.component.physics.BoxCollider',_super);
		var __proto=BoxCollider.prototype;
		/**
		*@private
		*/
		__proto._updateCollider=function(){
			if (this._needUpdate){
				var transform=(this._owner).transform;
				var ownerWorldMatrix=transform.worldMatrix;
				ownerWorldMatrix.cloneTo(this._transformOrientedBoundBox.transformation);
				Vector3.multiply(transform.scale,this.center,BoxCollider._deviationV3);
				Vector3.transformQuat(BoxCollider._deviationV3,transform.rotation,BoxCollider._deviationV3);
				this._transformOrientedBoundBox.getCenter(BoxCollider._obbCenterV3);
				Vector3.add(BoxCollider._obbCenterV3,BoxCollider._deviationV3,BoxCollider._deviationV3);
				this._transformOrientedBoundBox.transformation.setTranslationVector(BoxCollider._deviationV3);
				this._needUpdate=false;
			}
		}

		/**
		*@private
		*/
		__proto._onWorldMatrixChanged=function(){
			this._needUpdate=true;
			for (var k in this._runtimeCollisonMap){
				this._runtimeCollisonTestMap[k]=true;
				this._runtimeCollisonMap[k]._runtimeCollisonTestMap[this.id]=true;
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._parse=function(rootNode,innerResouMap,data){
			this.isTrigger=data.isTrigger;
			this.center.fromArray(data.center);
			var siz=this.size;
			siz.fromArray(data.size);
			this.size=siz;
		}

		/**
		*@inheritDoc
		*/
		__proto._initialize=function(owner){
			_super.prototype._initialize.call(this,owner);
			this._transformOrientedBoundBox=new OrientedBoundBox(new Vector3(),new Matrix4x4());
			this._size=new Vector3();
			this.center=new Vector3();
			(owner).transform.on("worldmatrixneedchanged",this,this._onWorldMatrixChanged);
			this._needUpdate=true;
		}

		/**
		*@inheritDoc
		*/
		__proto._getType=function(){
			return 1;
		}

		/**
		*@inheritDoc
		*/
		__proto._collisonTo=function(other){
			switch (other._getType()){
				case 0:
					return this.boundBox.containsSphere((other).boundSphere)!==0;
					break ;
				case 1:
					return this.boundBox.containsOrientedBoundBox((other).boundBox)!==0;
					break ;
				case 2:;
					var meshCollider=other;
					if (this.boundBox.containsBoundBox(meshCollider._boundBox)!==0){
						var positions=(other).mesh._positions;
						for (var i=0,n=positions.length;i < n;i++){
							if (this.boundBox.containsPoint(positions[i])===1)
								return true
						}
						return false;
						}else {
						return false;
					}
					break ;
				default :
					throw new Error("BoxCollider:unknown collider type.");
				}
		}

		/**
		*@inheritDoc
		*/
		__proto._cloneTo=function(dest){
			var destBoxCollider=dest;
			var destSize=destBoxCollider.size;
			this.size.cloneTo(destSize);
			destBoxCollider.size=destSize;
			this.center.cloneTo(destBoxCollider.center);
		}

		/**
		*@inheritDoc
		*/
		__proto.raycast=function(ray,hitInfo,maxDistance){
			(maxDistance===void 0)&& (maxDistance=1.79e+308);
			this._updateCollider();
			var distance=this._transformOrientedBoundBox.intersectsRay(ray,hitInfo.position);
			if (distance!==-1 && distance <=maxDistance){
				hitInfo.distance=distance;
				hitInfo.sprite3D=this._owner;
				return true;
				}else {
				hitInfo.distance=-1;
				hitInfo.sprite3D=null;
				return false;
			}
		}

		/**
		*从AABB碰撞盒设置center和Size。
		*@param boundBox 碰撞盒。
		*/
		__proto.setFromBoundBox=function(boundBox){
			OrientedBoundBox.createByBoundBox(boundBox,this._transformOrientedBoundBox);
			var extents=this._transformOrientedBoundBox.extents;
			this._size=new Vector3(extents.x *2,extents.y *2,extents.z *2);
			this.center=new Vector3();
			Vector3.add(boundBox.min,boundBox.max,this.center);
			Vector3.scale(this.center,0.5,this.center);
			this._needUpdate=true;
		}

		/**
		*获取包围盒子,只读,不允许修改。
		*@return 包围球。
		*/
		__getset(0,__proto,'boundBox',function(){
			this._updateCollider();
			return this._transformOrientedBoundBox;
		});

		/**
		*设置盒子碰撞器长宽高的一半。
		*@param 长宽高的一半。
		*/
		/**
		*获取盒子碰撞器长宽高的一半。
		*@return 长宽高的一半。
		*/
		__getset(0,__proto,'size',function(){
			return this._size;
			},function(value){
			this._size=value;
			Vector3.scale(value,0.5,this._transformOrientedBoundBox.extents);
		});

		__static(BoxCollider,
		['_deviationV3',function(){return this._deviationV3=new Vector3();},'_obbCenterV3',function(){return this._obbCenterV3=new Vector3();}
		]);
		return BoxCollider;
	})(Collider)


	/**
	*<code>MeshCollider</code> 类用于创建网格碰撞器。
	*/
	//class laya.d3.component.physics.MeshCollider extends laya.d3.component.physics.Collider
	var MeshCollider=(function(_super){
		function MeshCollider(){
			this._transformBoundingBox=null;
			this._mesh=null;
			MeshCollider.__super.call(this);
			this._transformBoundingBox=new BoundBox(new Vector3(),new Vector3());
			this._needUpdate=false;
		}

		__class(MeshCollider,'laya.d3.component.physics.MeshCollider',_super);
		var __proto=MeshCollider.prototype;
		/**
		*@private
		*/
		__proto._updateBoundBoxCollider=function(){
			if (this._needUpdate){
				var worldMat=(this._owner).transform.worldMatrix;
				var corners=this._mesh.boundingBoxCorners;
				for (var i=0;i < 8;i++)
				Vector3.transformCoordinate(corners[i],worldMat,MeshCollider._tempBoundBoxCorners[i]);
				BoundBox.createfromPoints(MeshCollider._tempBoundBoxCorners,this._transformBoundingBox);
				this._needUpdate=false;
			}
		}

		/**
		*@private
		*/
		__proto._raycastMesh=function(ray,sprite3D,outHitInfo,maxDistance){
			(maxDistance===void 0)&& (maxDistance=1.79e+308);
			var worldMatrix=sprite3D.transform.worldMatrix;
			var invertWorldMatrix=MeshCollider._tempMatrix4x40;
			worldMatrix.invert(invertWorldMatrix);
			var rayOrigin=ray.origin;
			var rayDirection=ray.direction;
			var transformRay=MeshCollider._tempRay0;
			Vector3.transformCoordinate(rayOrigin,invertWorldMatrix,transformRay.origin);
			Vector3.TransformNormal(rayDirection,invertWorldMatrix,transformRay.direction);
			var curMinDistance=Number.MAX_VALUE;
			for (var i=0,n=this._mesh.subMeshCount;i < n;i++){
				var renderObj=this._mesh._getSubMesh(i);
				var vertexBuffer=renderObj._vertexBuffers[0];
				var vertexDatas=vertexBuffer.getData();
				var indexDatas=renderObj._indexBuffer.getData();
				var elementRaycastHit=MeshCollider._tempRaycastHit;
				var isHit=Picker.rayIntersectsPositionsAndIndices(transformRay,vertexDatas,vertexBuffer.vertexDeclaration,indexDatas,elementRaycastHit);
				if (isHit){
					Vector3.transformCoordinate(elementRaycastHit.position,worldMatrix,elementRaycastHit.position);
					var rayOriToPos=MeshCollider._tempVector30;
					Vector3.subtract(rayOrigin,elementRaycastHit.position,rayOriToPos);
					var distance=Vector3.scalarLength(rayOriToPos);
					if ((distance < maxDistance)&& (distance < curMinDistance)){
						elementRaycastHit.distance=distance;
						elementRaycastHit.sprite3D=sprite3D;
						var trianglePositions=elementRaycastHit.trianglePositions;
						Vector3.transformCoordinate(trianglePositions[0],worldMatrix,trianglePositions[0]);
						Vector3.transformCoordinate(trianglePositions[1],worldMatrix,trianglePositions[1]);
						Vector3.transformCoordinate(trianglePositions[2],worldMatrix,trianglePositions[2]);
						var triangleNormals=elementRaycastHit.triangleNormals;
						Vector3.transformCoordinate(triangleNormals[0],worldMatrix,triangleNormals[0]);
						Vector3.transformCoordinate(triangleNormals[1],worldMatrix,triangleNormals[1]);
						Vector3.transformCoordinate(triangleNormals[2],worldMatrix,triangleNormals[2]);
						curMinDistance=distance;
						elementRaycastHit.cloneTo(outHitInfo);
						return true;
					}
					return false;
				}
			}
			return false;
		}

		/**
		*@private
		*/
		__proto._onWorldMatrixChanged=function(){
			this._needUpdate=true;
		}

		/**
		*@inheritDoc
		*/
		__proto._initialize=function(owner){
			_super.prototype._initialize.call(this,owner);
			(owner).transform.on("worldmatrixneedchanged",this,this._onWorldMatrixChanged);
			this._needUpdate=true;
		}

		/**
		*@inheritDoc
		*/
		__proto._getType=function(){
			return 2;
		}

		/**
		*@inheritDoc
		*/
		__proto._collisonTo=function(other){
			var i=0,n=0;
			var positions=this.mesh._positions;
			switch (other._getType()){
				case 0:;
					var otherSphere=other;
					if (Collision.sphereContainsBox(otherSphere.boundSphere,this._boundBox)!==0){
						for (i=0,n=positions.length;i < n;i++){
							if (Collision.sphereContainsPoint(otherSphere.boundSphere,positions[i])===1)
								return true
						}
						return false;
						}else {
						return false;
					}
					break ;
				case 1:;
					var otherBox=other;
					if (otherBox.boundBox.containsBoundBox(this._boundBox)!==0){
						for (i=0,n=positions.length;i < n;i++){
							if (otherBox.boundBox.containsPoint(positions[i])===1)
								return true
						}
						return false;
						break ;
						}else {
						return false;
					}
				case 2:;
					var otherMesh=other;
					if (Collision.intersectsBoxAndBox(otherMesh._boundBox,this._boundBox)!==1){
						return true;
						}else {
						return false;
					}
					throw new Error("MeshCollider:unknown collider type.");
					break ;
				default :
					throw new Error("MeshCollider:unknown collider type.");
				}
		}

		/**
		*@inheritDoc
		*/
		__proto._cloneTo=function(dest){
			var destCollider=dest;
			destCollider.mesh=this._mesh;
		}

		/**
		*@inheritDoc
		*/
		__proto.raycast=function(ray,hitInfo,maxDistance){
			(maxDistance===void 0)&& (maxDistance=1.79e+308);
			if (this._mesh==null || !this._mesh.loaded)
				return false;
			var distance=Collision.intersectsRayAndBoxRD(ray,this._boundBox);
			if (distance!==-1 && distance <=maxDistance && this._raycastMesh(ray,this._owner,hitInfo,maxDistance)){
				return true;
				}else {
				hitInfo.distance=-1;
				hitInfo.sprite3D=null;
				return false;
			}
		}

		/**
		*@private 只读,不允许修改。
		*/
		__getset(0,__proto,'_boundBox',function(){
			this._updateBoundBoxCollider();
			return this._transformBoundingBox;
		});

		/**
		*设置碰撞器网格。
		*@param value 碰撞其网格。
		*/
		/**
		*获取碰撞器网格。
		*@return 碰撞其网格。
		*/
		__getset(0,__proto,'mesh',function(){
			return this._mesh;
			},function(value){
			this._mesh=value;
		});

		__static(MeshCollider,
		['_tempRay0',function(){return this._tempRay0=new Ray(new Vector3(),new Vector3());},'_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempMatrix4x40',function(){return this._tempMatrix4x40=new Matrix4x4();},'_tempRaycastHit',function(){return this._tempRaycastHit=new RaycastHit();},'_tempBoundBoxCorners',function(){return this._tempBoundBoxCorners=[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];}
		]);
		return MeshCollider;
	})(Collider)


	/**
	*<code>SphereCollider</code> 类用于创建球碰撞器。
	*/
	//class laya.d3.component.physics.SphereCollider extends laya.d3.component.physics.Collider
	var SphereCollider=(function(_super){
		function SphereCollider(){
			this._originalBoundSphere=null;
			this._transformBoundSphere=null;
			SphereCollider.__super.call(this);
			this._needUpdate=false;
		}

		__class(SphereCollider,'laya.d3.component.physics.SphereCollider',_super);
		var __proto=SphereCollider.prototype;
		/**
		*@private
		*/
		__proto._updateCollider=function(){
			if (this._needUpdate){
				var maxScale=NaN;
				var transform=(this._owner).transform;
				var scale=transform.scale;
				if (scale.x >=scale.y && scale.x >=scale.z)
					maxScale=scale.x;
				else
				maxScale=scale.y >=scale.z ? scale.y :scale.z;
				Vector3.transformCoordinate(this._originalBoundSphere.center,transform.worldMatrix,this._transformBoundSphere.center);
				this._transformBoundSphere.radius=this._originalBoundSphere.radius *maxScale;
				this._needUpdate=false;
			}
		}

		/**
		*@private
		*/
		__proto._onWorldMatrixChanged=function(){
			this._needUpdate=true;
			for (var k in this._runtimeCollisonMap){
				this._runtimeCollisonTestMap[k]=true;
				this._runtimeCollisonMap[k]._runtimeCollisonTestMap[this.id]=true;
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._parse=function(rootNode,innerResouMap,data){
			this.isTrigger=data.isTrigger;
			var cen=this.center;
			cen.fromArray(data.center);
			this.center=cen;
			this.radius=data.radius;
		}

		/**
		*@inheritDoc
		*/
		__proto._initialize=function(owner){
			_super.prototype._initialize.call(this,owner);
			this._originalBoundSphere=new BoundSphere(new Vector3(0,0,0),0.5);
			this._transformBoundSphere=new BoundSphere(new Vector3(0,0,0),0.5);
			(owner).transform.on("worldmatrixneedchanged",this,this._onWorldMatrixChanged);
			this._needUpdate=true;
		}

		/**
		*@inheritDoc
		*/
		__proto._getType=function(){
			return 0;
		}

		/**
		*@inheritDoc
		*/
		__proto._collisonTo=function(other){
			switch (other._getType()){
				case 0:
					return Collision.sphereContainsSphere(this.boundSphere,(other).boundSphere)!==0;
					break ;
				case 1:
					return (other).boundBox.containsSphere(this.boundSphere)!==0;
					break ;
				case 2:;
					var meshCollider=other;
					if (Collision.sphereContainsBox(this.boundSphere,meshCollider._boundBox)!==0){
						var positions=meshCollider.mesh._positions;
						for (var i=0,n=positions.length;i < n;i++){
							if (Collision.sphereContainsPoint(this.boundSphere,positions[i])===1)
								return true
						}
						return false;
						}else {
						return false;
					}
					break ;
				default :
					throw new Error("SphereCollider:unknown collider type.");
				}
		}

		/**
		*@inheritDoc
		*/
		__proto._cloneTo=function(dest){
			var destCollider=dest;
			destCollider.radius=this.radius;
			var destCenter=destCollider.center;
			this.center.cloneTo(destCenter);
			destCollider.center=destCenter;
		}

		/**
		*@inheritDoc
		*/
		__proto.raycast=function(ray,hitInfo,maxDistance){
			(maxDistance===void 0)&& (maxDistance=1.79e+308);
			this._updateCollider();
			var distance=this._transformBoundSphere.intersectsRayPoint(ray,hitInfo.position);
			if (distance!==-1 && distance <=maxDistance){
				hitInfo.distance=distance;
				hitInfo.sprite3D=this._owner;
				return true;
				}else {
				hitInfo.distance=-1;
				hitInfo.sprite3D=null;
				return false;
			}
		}

		/**
		*设置中心点。
		*@param value 中心点。
		*/
		/**
		*获取中心点。
		*@return 中心点。
		*/
		__getset(0,__proto,'center',function(){
			return this._originalBoundSphere.center;
			},function(value){
			this._originalBoundSphere.center=value;
		});

		/**
		*设置半径。
		*@param value 半径。
		*/
		/**
		*获取半径。
		*@return 半径。
		*/
		__getset(0,__proto,'radius',function(){
			return this._originalBoundSphere.radius;
			},function(value){
			this._originalBoundSphere.radius=value;
		});

		/**
		*获取包围球,只读,不允许修改。
		*@return 包围球。
		*/
		__getset(0,__proto,'boundSphere',function(){
			this._updateCollider();
			return this._transformBoundSphere;
		});

		return SphereCollider;
	})(Collider)


	/**
	*<code>IndexBuffer3D</code> 类用于创建索引缓冲。
	*/
	//class laya.d3.graphics.IndexBuffer3D extends laya.webgl.utils.Buffer
	var IndexBuffer3D=(function(_super){
		function IndexBuffer3D(indexType,indexCount,bufferUsage,canRead){
			this._indexType=null;
			this._indexTypeByteCount=0;
			this._indexCount=0;
			this._canRead=false;
			(bufferUsage===void 0)&& (bufferUsage=0x88E4);
			(canRead===void 0)&& (canRead=false);
			IndexBuffer3D.__super.call(this);
			this._indexType=indexType;
			this._indexCount=indexCount;
			this._bufferUsage=bufferUsage;
			this._bufferType=0x8893;
			this._canRead=canRead;
			var byteLength=0;
			if (indexType=="ushort")
				this._indexTypeByteCount=2;
			else if (indexType=="ubyte")
			this._indexTypeByteCount=1;
			else
			throw new Error("unidentification index type.");
			byteLength=this._indexTypeByteCount *indexCount;
			this._byteLength=byteLength;
			this.bind();
			LayaGL.instance.bufferData(this._bufferType,byteLength,this._bufferUsage);
			if (canRead){
				if (indexType=="ushort")
					this._buffer=new Uint16Array(indexCount);
				else if (indexType=="ubyte")
				this._buffer=new Uint8Array(indexCount);
				this.memorySize=byteLength *2;
				}else {
				this.memorySize=byteLength;
			}
		}

		__class(IndexBuffer3D,'laya.d3.graphics.IndexBuffer3D',_super);
		var __proto=IndexBuffer3D.prototype;
		/**
		*设置数据。
		*@param data 索引数据。
		*@param bufferOffset 索引缓冲中的偏移。
		*@param dataStartIndex 索引数据的偏移。
		*@param dataCount 索引数据的数量。
		*/
		__proto.setData=function(data,bufferOffset,dataStartIndex,dataCount){
			(bufferOffset===void 0)&& (bufferOffset=0);
			(dataStartIndex===void 0)&& (dataStartIndex=0);
			(dataCount===void 0)&& (dataCount=4294967295);
			var byteCount=0;
			if (this._indexType=="ushort"){
				byteCount=2;
				if (dataStartIndex!==0 || dataCount!==4294967295)
					data=new Uint16Array(data.buffer,dataStartIndex *byteCount,dataCount);
				}else if (this._indexType=="ubyte"){
				byteCount=1;
				if (dataStartIndex!==0 || dataCount!==4294967295)
					data=new Uint8Array(data.buffer,dataStartIndex *byteCount,dataCount);
			}
			this.bind();
			LayaGL.instance.bufferSubData(this._bufferType,bufferOffset *byteCount,data);
			if (this._canRead){
				if (bufferOffset!==0 || dataStartIndex!==0 || dataCount!==4294967295){
					var maxLength=this._buffer.length-bufferOffset;
					if (dataCount > maxLength)
						dataCount=maxLength;
					for (var i=0;i < dataCount;i++)
					this._buffer[bufferOffset+i]=data[i];
					}else {
					this._buffer=data;
				}
			}
		}

		/**
		*获取索引数据。
		*@return 索引数据。
		*/
		__proto.getData=function(){
			if (this._canRead)
				return this._buffer;
			else
			throw new Error("Can't read data from VertexBuffer with only write flag!");
		}

		/**
		*@inheritDoc
		*/
		__proto.disposeResource=function(){
			_super.prototype.disposeResource.call(this);
			this._buffer=null;
			this.memorySize=0;
		}

		/**
		*获取索引类型。
		*@return 索引类型。
		*/
		__getset(0,__proto,'indexType',function(){
			return this._indexType;
		});

		/**
		*获取索引类型字节数量。
		*@return 索引类型字节数量。
		*/
		__getset(0,__proto,'indexTypeByteCount',function(){
			return this._indexTypeByteCount;
		});

		/**
		*获取索引个数。
		*@return 索引个数。
		*/
		__getset(0,__proto,'indexCount',function(){
			return this._indexCount;
		});

		/**
		*获取是否可读。
		*@return 是否可读。
		*/
		__getset(0,__proto,'canRead',function(){
			return this._canRead;
		});

		IndexBuffer3D.INDEXTYPE_UBYTE="ubyte";
		IndexBuffer3D.INDEXTYPE_USHORT="ushort";
		IndexBuffer3D.create=function(indexType,indexCount,bufferUsage,canRead){
			(bufferUsage===void 0)&& (bufferUsage=0x88E4);
			(canRead===void 0)&& (canRead=false);
			return new IndexBuffer3D(indexType,indexCount,bufferUsage,canRead);
		}

		return IndexBuffer3D;
	})(Buffer)


	/**
	*<code>Sprite3D</code> 类用于实现3D精灵。
	*/
	//class laya.d3.core.Sprite3D extends laya.d3.core.ComponentNode
	var Sprite3D=(function(_super){
		function Sprite3D(name){
			//this._projectionViewWorldUpdateLoopCount=0;
			//this._projectionViewWorldUpdateCamera=null;
			//this._id=0;
			//this._url=null;
			//this._group=null;
			//this._active=false;
			//this._activeInHierarchy=false;
			//this._layer=null;
			//this._colliders=null;
			//this._scene=null;
			//this._transform=null;
			//this._hierarchyAnimator=null;
			//this.isStatic=false;
			Sprite3D.__super.call(this);
			this._projectionViewWorldUpdateLoopCount=-1;
			this._activeInHierarchy=false;
			this._colliders=[];
			this._id=++Sprite3D._uniqueIDCounter;
			this._transform=new Transform3D(this);
			this.name=name ? name :"Sprite3D-"+Sprite3D._nameNumberCounter++;
			this.layer=Layer.currentCreationLayer;
			this.active=true;
		}

		__class(Sprite3D,'laya.d3.core.Sprite3D',_super);
		var __proto=Sprite3D.prototype;
		Laya.imps(__proto,{"laya.resource.ICreateResource":true,"laya.d3.core.IClone":true})
		/**
		*@private
		*/
		__proto._setUrl=function(url){
			this._url=url;
		}

		/**
		*@private
		*/
		__proto._getGroup=function(){
			return this._group;
		}

		/**
		*@private
		*/
		__proto._setGroup=function(value){
			this._group=value;
		}

		/**
		*@private
		*/
		__proto._parseBaseCustomProps=function(customProps){
			var loccalPosition=this.transform.localPosition;
			loccalPosition.fromArray(customProps.translate);
			this.transform.localPosition=loccalPosition;
			var localRotation=this.transform.localRotation;
			localRotation.fromArray(customProps.rotation);
			this.transform.localRotation=localRotation;
			var localScale=this.transform.localScale;
			localScale.fromArray(customProps.scale);
			this.transform.localScale=localScale;
			var layerData=customProps.layer;
			(layerData !=null)&& (this.layer=Layer.getLayerByNumber(layerData));
		}

		/**
		*@private
		*/
		__proto._parseCustomComponent=function(rootNode,innerResouMap,componentsData){
			for (var k in componentsData){
				var component;
				var data=componentsData[k];
				switch (k){
					case "Animator":
						component=this.addComponent(Animator);
						break ;
					case "Rigidbody":
						component=this.addComponent(Rigidbody);
						break ;
					case "SphereCollider":
						component=this.addComponent(SphereCollider);
						break ;
					case "BoxCollider":
						component=this.addComponent(BoxCollider);
						break ;
					case "MeshCollider":
						component=this.addComponent(MeshCollider);
						break ;
					default :
					}
				component._parse(rootNode,innerResouMap,data);
			}
		}

		/**
		*@private
		*/
		__proto._setHierarchyAnimator=function(animator,parentAnimator){
			this._changeHierarchyAnimator(animator);
			for (var i=0,n=this._children.length;i < n;i++){
				var child=this._children[i];
				(child._hierarchyAnimator==parentAnimator)&& (child._setHierarchyAnimator(animator,parentAnimator));
			}
		}

		/**
		*@private
		*/
		__proto._clearHierarchyAnimator=function(animator,parentAnimator){
			this._changeHierarchyAnimator(parentAnimator);
			for (var i=0,n=this._children.length;i < n;i++){
				var child=this._children[i];
				(child._hierarchyAnimator==animator)&& (child._clearHierarchyAnimator(animator,parentAnimator));
			}
		}

		/**
		*@private
		*/
		__proto._getAnimatorToLinkSprite3D=function(sprite3D,isLink,path){
			var animator=this.getComponentByType(Animator);
			if (animator){
				if (!animator.avatar)
					sprite3D._setAnimatorToLinkSprite3DNoAvatar(animator,isLink,path);
			}
			if (this._parent && (this._parent instanceof laya.d3.core.Sprite3D )){
				path.unshift(this._parent.name);
				var p=this._parent;
				(p._hierarchyAnimator)&& (p._getAnimatorToLinkSprite3D(sprite3D,isLink,path));
			}
		}

		/**
		*@private
		*/
		__proto._setAnimatorToLinkSprite3DNoAvatar=function(animator,isLink,path){
			var i=0,n=0;
			for (i=0,n=animator.getClipCount();i < n;i++)
			animator._handleSpriteOwnersBySprite(i,isLink,path,this);
			for (i=0,n=this._children.length;i < n;i++){
				var child=this._children[i];
				var index=path.length;
				path.push(child.name);
				child._setAnimatorToLinkSprite3DNoAvatar(animator,isLink,path);
				path.splice(index,1);
			}
		}

		/**
		*@private
		*/
		__proto._changeHierarchyAnimator=function(animator){
			this._hierarchyAnimator=animator;
		}

		/**
		*@private
		*/
		__proto._addChild3D=function(sprite3D){
			sprite3D.transform.parent=this.transform;
			if (this._hierarchyAnimator){
				(!sprite3D._hierarchyAnimator)&& (sprite3D._setHierarchyAnimator(this._hierarchyAnimator,null));
				this._getAnimatorToLinkSprite3D(sprite3D,true,[sprite3D.name]);
			}
			if (this._scene){
				sprite3D._setBelongScene(this._scene);
				(this._activeInHierarchy && sprite3D._active)&& (sprite3D._activeHierarchy());
			}
		}

		/**
		*@private
		*/
		__proto._removeChild3D=function(sprite3D){
			sprite3D.transform.parent=null;
			if (this._scene){
				(this._activeInHierarchy && sprite3D._active)&& (sprite3D._inActiveHierarchy());
				sprite3D._setUnBelongScene();
			}
			if (this._hierarchyAnimator){
				((sprite3D._hierarchyAnimator==this._hierarchyAnimator))&& (sprite3D._clearHierarchyAnimator(this._hierarchyAnimator,null));
				this._getAnimatorToLinkSprite3D(sprite3D,false,[sprite3D.name]);
			}
		}

		/**
		*@private
		*/
		__proto._isLinkSpriteToAnimationNode=function(animator,node,isLink){
			var nodeIndex=animator._avatarNodes.indexOf(node);
			var cacheSpriteToNodesMap=animator._cacheSpriteToNodesMap;
			if (isLink){
				this._transform.dummy=node.transform;
				animator._cacheNodesToSpriteMap[nodeIndex]=cacheSpriteToNodesMap.length;
				cacheSpriteToNodesMap.push(nodeIndex);
				}else {
				this._transform.dummy=null;
				var index=animator._cacheNodesToSpriteMap[nodeIndex];
				animator._cacheNodesToSpriteMap[nodeIndex]=null;
				cacheSpriteToNodesMap.splice(index,1);
			}
		}

		/**
		*@private
		*/
		__proto._setBelongScene=function(scene){
			this._scene=scene;
			for (var i=0,n=this._children.length;i < n;i++)
			(this._children [i])._setBelongScene(scene);
		}

		/**
		*@private
		*/
		__proto._setUnBelongScene=function(){
			this._scene=null;
			for (var i=0,n=this._children.length;i < n;i++)
			(this._children [i])._setUnBelongScene();
		}

		/**
		*@private
		*/
		__proto._activeHierarchy=function(){
			var i=0,n=0;
			this._activeInHierarchy=true;
			this._addSelfRenderObjects();
			for (i=0,n=this._components.length;i < n;i++)
			this._components[i]._onOwnerActiveChange(true);
			this.event("activeinhierarchychanged",true);
			for (i=0,n=this._children.length;i < n;i++){
				var child=this._children [i];
				(child._active)&& (child._activeHierarchy());
			}
		}

		/**
		*@private
		*/
		__proto._inActiveHierarchy=function(){
			var i=0,n=0;
			this._activeInHierarchy=false;
			this._clearSelfRenderObjects();
			for (i=0,n=this._components.length;i < n;i++)
			this._components[i]._onOwnerActiveChange(false);
			this.event("activeinhierarchychanged",false);
			for (i=0,n=this._children.length;i < n;i++){
				var child=this._children [i];
				(child._active)&& (child._inActiveHierarchy());
			}
		}

		/**
		*清理自身渲染物体，请重载此函数。
		*/
		__proto._clearSelfRenderObjects=function(){}
		/**
		*添加自身渲染物体，请重载此函数。
		*/
		__proto._addSelfRenderObjects=function(){}
		/**
		*@private
		*/
		__proto._parseCustomProps=function(rootNode,innerResouMap,customProps){}
		/**
		*加载层级文件，并作为该节点的子节点。
		*@param url
		*/
		__proto.loadHierarchy=function(url){
			this.addChild(laya.d3.core.Sprite3D.load(url));
		}

		/**
		*@private
		*/
		__proto.onAsynLoaded=function(data,params){
			var json=data[0];
			if (json.type!=="Sprite3D")
				throw new Error("Sprite3D: The .lh file root type must be Sprite3D,please use other function to  load  this file.");
			var innerResouMap=data[1];
			Utils3D._createNodeByJson(this,json,this,innerResouMap,null);
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			if (this.destroyed)
				throw new Error("Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
			var destSprite3D=destObject;
			destSprite3D.name=this.name;
			destSprite3D.destroyed=this.destroyed;
			destSprite3D.timer=this.timer;
			destSprite3D.active=this._active;
			var destLocalPosition=destSprite3D.transform.localPosition;
			this.transform.localPosition.cloneTo(destLocalPosition);
			destSprite3D.transform.localPosition=destLocalPosition;
			var destLocalRotation=destSprite3D.transform.localRotation;
			this.transform.localRotation.cloneTo(destLocalRotation);
			destSprite3D.transform.localRotation=destLocalRotation;
			var destLocalScale=destSprite3D.transform.localScale;
			this.transform.localScale.cloneTo(destLocalScale);
			destSprite3D.transform.localScale=destLocalScale;
			destSprite3D.isStatic=this.isStatic;
			var i=0,n=0;
			for (i=0,n=this._componentsMap.length;i < n;i++){
				var destComponent=destSprite3D.addComponent(this._componentsMap[i]);
				this._components[i]._cloneTo(destComponent);
			}
			for (i=0,n=this._children.length;i < n;i++)
			destSprite3D.addChild(this._children[i].clone());
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destSprite3D=new this.constructor();
			this.cloneTo(destSprite3D);
			return destSprite3D;
		}

		/**
		*@inheritDoc
		*/
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			if (this.destroyed)
				return;
			laya.display.Node.prototype.destroy.call(this,destroyChild);
			var i=0,n=0;
			for (i=0,n=this._components.length;i < n;i++)
			this._components[i]._destroy();
			this._components=null;
			this._componentsMap=null;
			this._typeComponentsIndices=null;
			this._transform=null;
			this._colliders=null;
			Loader.clearRes(this.url);
			(this.loaded)||(Laya3D._cancelLoadByUrl(this.url));
		}

		/**
		*获得组件的数量。
		*@return 组件数量。
		*/
		__getset(0,__proto,'componentsCount',function(){
			return this._components.length;
		});

		/**
		*获取唯一标识ID。
		*@return 唯一标识ID。
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		/**
		*获取在场景中是否激活。
		*@return 在场景中是否激活。
		*/
		__getset(0,__proto,'activeInHierarchy',function(){
			return this._activeInHierarchy;
		});

		/**
		*设置是否激活。
		*@param value 是否激活。
		*/
		/**
		*获取自身是否激活。
		*@return 自身是否激活。
		*/
		__getset(0,__proto,'active',function(){
			return this._active;
			},function(value){
			if (this._active!==value){
				this._active=value;
				if (this._parent){
					if ((this._parent===this._scene && this._parent.displayedInStage)|| (this._parent)._activeInHierarchy){
						if (value)
							this._activeHierarchy();
						else
						this._inActiveHierarchy();
					}
				}
			}
		});

		/**
		*获取资源的URL地址。
		*@return URL地址。
		*/
		__getset(0,__proto,'url',function(){
			return this._url;
		});

		/**
		*设置蒙版。
		*@param value 蒙版。
		*/
		/**
		*获取蒙版。
		*@return 蒙版。
		*/
		__getset(0,__proto,'layer',function(){
			return this._layer;
			},function(value){
			if (value){
				if (this.displayedInStage){
					var i=0,n=this._colliders.length;
					if (this._layer){
						for (i=0;i < n;i++)
						this._layer._removeCollider(this._colliders[i]);
					}
					for (i=0;i < n;i++)
					value._addCollider(this._colliders[i]);
				}
				this._layer=value;
				this.event("layerchanged",value);
				}else {
				throw new Error("Layer value can be null.");
			}
		});

		/**
		*获取精灵变换。
		*/
		__getset(0,__proto,'transform',function(){
			return this._transform;
		});

		/**
		*获得所属场景。
		*@return 场景。
		*/
		__getset(0,__proto,'scene',function(){
			return this._scene;
		});

		Sprite3D.instantiate=function(original,parent,worldPositionStays,position,rotation){
			(worldPositionStays===void 0)&& (worldPositionStays=true);
			var destSprite3D=original.clone();
			(parent)&& (parent.addChild(destSprite3D));
			var transform=destSprite3D.transform;
			if (worldPositionStays){
				var worldMatrix=transform.worldMatrix;
				original.transform.worldMatrix.cloneTo(worldMatrix);
				transform.worldMatrix=worldMatrix;
				}else {
				(position)&& (transform.position=position);
				(rotation)&& (transform.rotation=rotation);
			}
			return destSprite3D;
		}

		Sprite3D.load=function(url){
			return Laya.loader.create(url,null,null,Sprite3D);
		}

		Sprite3D.WORLDMATRIX=0;
		Sprite3D.MVPMATRIX=1;
		Sprite3D._uniqueIDCounter=0;
		Sprite3D._nameNumberCounter=0;
		return Sprite3D;
	})(ComponentNode)


	/**
	*<code>VertexBuffer3D</code> 类用于创建顶点缓冲。
	*/
	//class laya.d3.graphics.VertexBuffer3D extends laya.webgl.utils.Buffer
	var VertexBuffer3D=(function(_super){
		function VertexBuffer3D(byteLength,bufferUsage,canRead){
			this._vertexCount=0;
			this._canRead=false;
			this._vertexDeclaration=null;
			(canRead===void 0)&& (canRead=false);
			VertexBuffer3D.__super.call(this);
			this._vertexCount=-1;
			this._bufferUsage=bufferUsage;
			this._bufferType=0x8892;
			this._canRead=canRead;
			this.memorySize=this._byteLength=byteLength;
			this.bind();
			LayaGL.instance.bufferData(this._bufferType,this._byteLength,this._bufferUsage);
			canRead && (this._buffer=new Float32Array(this._byteLength / 4));
		}

		__class(VertexBuffer3D,'laya.d3.graphics.VertexBuffer3D',_super);
		var __proto=VertexBuffer3D.prototype;
		/**
		*和索引缓冲一起绑定。
		*@param ib 索引缓冲。
		*/
		__proto.bindWithIndexBuffer=function(ib){
			(ib)&& (ib.bind());
			this.bind();
		}

		/**
		*设置数据。
		*@param data 顶点数据。
		*@param bufferOffset 顶点缓冲中的偏移。
		*@param dataStartIndex 顶点数据的偏移。
		*@param dataCount 顶点数据的数量。
		*/
		__proto.setData=function(data,bufferOffset,dataStartIndex,dataCount){
			(bufferOffset===void 0)&& (bufferOffset=0);
			(dataStartIndex===void 0)&& (dataStartIndex=0);
			(dataCount===void 0)&& (dataCount=4294967295);
			if (dataStartIndex!==0 || dataCount!==4294967295)
				data=new Float32Array(data.buffer,dataStartIndex *4,dataCount);
			this.bind();
			LayaGL.instance.bufferSubData(this._bufferType,bufferOffset *4,data);
			if (this._canRead){
				if (bufferOffset!==0 || dataStartIndex!==0 || dataCount!==4294967295){
					var maxLength=this._buffer.length-bufferOffset;
					if (dataCount > maxLength)
						dataCount=maxLength;
					for (var i=0;i < dataCount;i++)
					this._buffer[bufferOffset+i]=data[i];
					}else {
					this._buffer=data;
				}
			}
		}

		/**
		*获取顶点数据。
		*@return 顶点数据。
		*/
		__proto.getData=function(){
			if (this._canRead)
				return this._buffer;
			else
			throw new Error("Can't read data from VertexBuffer with only write flag!");
		}

		/**销毁顶点缓冲。*/
		__proto.disposeResource=function(){
			var gl=LayaGL.instance;
			var elements=this._vertexDeclaration.vertexElements;
			var enableAtributes=Buffer._bindedAtributeBuffer;
			for (var i=0,n=elements.length;i < n;i++){
				if (enableAtributes[i]===this._glBuffer){
					gl.disableVertexAttribArray(i);
					enableAtributes[i]=null;
				}
			}
			_super.prototype.disposeResource.call(this);
			this._buffer=null;
			this._vertexDeclaration=null;
			this.memorySize=0;
		}

		/**
		*获取顶点声明。
		*/
		/**
		*获取顶点声明。
		*/
		__getset(0,__proto,'vertexDeclaration',function(){
			return this._vertexDeclaration;
			},function(value){
			if (this._vertexDeclaration!==value){
				this._vertexDeclaration=value;
				this._vertexCount=value ? this._byteLength / value.vertexStride :-1;
			}
		});

		/**
		*获取顶点个数。
		*@return 顶点个数。
		*/
		__getset(0,__proto,'vertexCount',function(){
			return this._vertexCount;
		});

		/**
		*获取是否可读。
		*@return 是否可读。
		*/
		__getset(0,__proto,'canRead',function(){
			return this._canRead;
		});

		return VertexBuffer3D;
	})(Buffer)


	/**
	*<code>BaseScene</code> 类用于实现场景。
	*/
	//class laya.d3.core.scene.Scene extends laya.d3.core.ComponentNode
	var Scene=(function(_super){
		function Scene(){
			//this._url=null;
			//this._group=null;
			//this._glCommandEncoder=null;
			//this._lightmaps=null;
			this._enableLightCount=3;
			//this._renderTargetTexture=null;
			this._customRenderQueneIndex=11;
			//this._lastCurrentTime=NaN;
			//this._enableFog=false;
			//this._enableDepthFog=false;
			//this._shaderValues=null;
			//this._defineDatas=null;
			//this._cullingRendersLength=0;
			//this._renderObjects=null;
			//this._dynamicBatchManager=null;
			this.enableLight=true;
			//this.treeRoot=null;
			//this.treeSize=null;
			//this.treeLevel=0;
			//this.parallelSplitShadowMaps=null;
			this._visible=true;
			this._renderType=0;
			//this.physicsWorker=null;
			Scene.__super.call(this);
			this._renderState=new RenderContext3D();
			this._lights=[];
			this._quenes=[];
			this._cameraPool=[];
			this._key=new SubmitKey();
			if (Render.isConchApp){
				this._glCommandEncoder=LayaGL.instance.createCommandEncoder(102400,2560,false);
				this.data=ParamData.create(22 *4);
				this.data._int32Data[21]=this._glCommandEncoder._buffer["_ptrID"];
				this._renderType |=0x400;
				this.data._int32Data[0]=this._renderType;
			}
			this._lightmaps=[];
			this._defineDatas=new DefineDatas();
			this._shaderValues=new ShaderDatas(null,22);
			this.parallelSplitShadowMaps=[];
			this._dynamicBatchManager=new DynamicBatchManager();
			this._renderObjects=[];
			this._cullingRendersLength=0;
			this.enableFog=false;
			this.fogStart=300;
			this.fogRange=1000;
			this.fogColor=new Vector3(0.7,0.7,0.7);
			this.ambientColor=new Vector3(0.212,0.227,0.259);
			(WebGL.shaderHighPrecision)&& (this._defineDatas.add(Shader3D.SHADERDEFINE_HIGHPRECISION));
			this.on("display",this,this._display);
			this.on("undisplay",this,this._unDisplay);
		}

		__class(Scene,'laya.d3.core.scene.Scene',_super);
		var __proto=Scene.prototype;
		Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true,"laya.resource.ICreateResource":true})
		/**
		*@private
		*/
		__proto._setUrl=function(url){
			this._url=url;
		}

		/**
		*@private
		*/
		__proto._getGroup=function(){
			return this._group;
		}

		/**
		*@private
		*/
		__proto._setGroup=function(value){
			this._group=value;
		}

		/**
		*@private
		*/
		__proto._display=function(){
			Laya.stage._scenes.push(this);
			Laya.stage._scenes.sort(Scene._sortScenes);
			for (var i=0,n=this._children.length;i < n;i++){
				var spr=this._children[i];
				(spr.active)&& (spr._activeHierarchy());
			}
		}

		/**
		*@private
		*/
		__proto._unDisplay=function(){
			var scenes=Laya.stage._scenes;
			scenes.splice(scenes.indexOf(this),1);
			for (var i=0,n=this._children.length;i < n;i++){
				var spr=this._children[i];
				(spr.active)&& (spr._inActiveHierarchy());
			}
		}

		/**
		*@private
		*/
		__proto._setLightMap=function(sprite){
			if ((sprite instanceof laya.d3.core.RenderableSprite3D ))
				(sprite)._render._applyLightMapParams();
			var childs=sprite._children;
			for (var i=0,n=childs.length;i < n;i++){
				this._setLightMap(childs[i]);
			}
		}

		/**
		*@private
		*/
		__proto._addChild3D=function(sprite3D){
			sprite3D.transform._onWorldTransform();
			sprite3D._setBelongScene(this);
			(this.displayedInStage && sprite3D.active)&& (sprite3D._activeHierarchy());
		}

		/**
		*@private
		*/
		__proto._removeChild3D=function(sprite3D){
			sprite3D.transform.parent=null;
			(this.displayedInStage && sprite3D.active)&& (sprite3D._inActiveHierarchy());
			sprite3D._setUnBelongScene();
		}

		/**
		*初始化八叉树。
		*@param width 八叉树宽度。
		*@param height 八叉树高度。
		*@param depth 八叉树深度。
		*@param center 八叉树中心点
		*@param level 八叉树层级。
		*/
		__proto.initOctree=function(width,height,depth,center,level){
			(level===void 0)&& (level=6);
			this.treeSize=new Vector3(width,height,depth);
			this.treeLevel=level;
			this.treeRoot=new OctreeNode(this,0);
			this.treeRoot.init(center,this.treeSize);
		}

		/**
		*@private
		*场景相关渲染准备设置。
		*@param gl WebGL上下文。
		*@return state 渲染状态。
		*/
		__proto._prepareUpdateToRenderState=function(gl,state){
			state.elapsedTime=this._lastCurrentTime ? this.timer.currTimer-this._lastCurrentTime :0;
			this._lastCurrentTime=this.timer.currTimer;
			state.scene=this;
		}

		/**
		*@private
		*/
		__proto._prepareSceneToRender=function(state){
			var lightCount=this._lights.length;
			if (lightCount > 0){
				var renderLightCount=0;
				for (var i=0;i < lightCount;i++){
					if (!this._lights[i]._prepareToScene(state))
						continue ;
					renderLightCount++;
					if (renderLightCount >=this._enableLightCount)
						break ;
				}
			}
		}

		/**
		*@private
		*/
		__proto._preRenderScene=function(gl,state,boundFrustum){
			var i=0,iNum=0;
			var camera=state.camera;
			if (camera.useOcclusionCulling){
				if (this.treeRoot)
					FrustumCulling.renderObjectCullingOctree(boundFrustum,this,state);
				else
				FrustumCulling.renderObjectCulling(boundFrustum,this,state);
				}else {
				FrustumCulling.renderObjectCulling(null,this,state);
			}
			for (i=0,iNum=this._quenes.length;i < iNum;i++)
			(this._quenes[i])&& (this._quenes[i]._preRender(state));
		}

		/**
		*@private
		*/
		__proto._clear=function(gl,state){
			var viewport=state.viewport;
			var camera=state.camera;
			var renderTarget=camera.renderTarget;
			var vpWidth=viewport.width;
			var vpHeight=viewport.height;
			var vpX=viewport.x;
			var vpY=camera._canvasHeight-viewport.y-vpHeight;
			gl.viewport(vpX,vpY,vpWidth,vpHeight);
			var flag=0x00000100;
			switch (camera.clearFlag){
				case 0:;
					var clearColor=camera.clearColor;
					if (clearColor){
						gl.enable(0x0C11);
						gl.scissor(vpX,vpY,vpWidth,vpHeight);
						var clearColorE=clearColor.elements;
						gl.clearColor(clearColorE[0],clearColorE[1],clearColorE[2],clearColorE[3]);
						flag |=0x00004000;
					}
					if (renderTarget){
						(clearColor)|| (flag=0x00004000);
					switch (renderTarget.depthStencilFormat){
						case 0:
							flag |=0x00000100;
							break ;
						case 1:
							flag |=0x00000400;
							break ;
						case 2:
							flag |=0x00000100;
							flag |=0x00000400;
							break ;
						}
				}
				gl.clear(flag);
				if (clearColor)
					gl.disable(0x0C11);
				break ;
				case 1:
				case 2:
				if (renderTarget){
					flag=0x00004000;
					switch (renderTarget.depthStencilFormat){
						case 0:
							flag |=0x00000100;
							break ;
						case 1:
							flag |=0x00000400;
							break ;
						case 2:
							flag |=0x00000100;
							flag |=0x00000400
							break ;
						}
				}
				gl.clear(flag);
				break ;
				case 3:
				break ;
				default :
				throw new Error("BaseScene:camera clearFlag invalid.");
			}
		}

		/**
		*@private
		*/
		__proto._renderScene=function(gl,state){
			var camera=state.camera;
			var position=camera.transform.position;
			var i=0,n=0;
			var queue;
			for (i=0;i < 2;i++){
				queue=this._quenes[i];
				if (queue){
					camera.renderTarget ? queue._render(state,true):queue._render(state,false);
				}
			}
			if (camera.clearFlag===1){
				var sky=camera.sky;
				if (sky){
					var material=sky.sharedMaterial;
					if (material){
						WebGLContext.setCullFace(gl,false);
						WebGLContext.setDepthFunc(gl,0x0203);
						WebGLContext.setDepthMask(gl,false);
						var shader=state.shader=material._shader._passes[0].withCompile(0,0,0);
						var forceUploadParams=shader.bind()|| (Stat.loopCount!==shader._uploadLoopCount);
						var vertexBuffer=sky._vertexBuffer;
						if (ShaderInstance._uploadVertexBuffers!==vertexBuffer){
							vertexBuffer.bind();
							shader.uploadAttributes(vertexBuffer.vertexDeclaration._shaderValues);
							ShaderInstance._uploadVertexBuffers=vertexBuffer;
						}
						sky._indexBuffer.bind();
						if (shader._uploadMaterial!==material || forceUploadParams){
							shader.uploadUniforms(shader._materialUniformParamsMap,material._shaderValues,true);
							shader._uploadMaterial=material;
						}
						if (camera!==shader._uploadCamera || forceUploadParams){
							shader.uploadUniforms(shader._cameraUniformParamsMap,camera._shaderValues,true);
							shader._uploadCamera=camera;
						}
						sky._render(state);
						WebGLContext.setDepthFunc(gl,0x0201);
						WebGLContext.setDepthMask(gl,true);
					}
				}
			}
			for (i=2,n=this._quenes.length;i < n;i++){
				queue=this._quenes[i];
				if (queue){
					camera.renderTarget ? queue._render(state,true):queue._render(state,false);
				}
			}
		}

		/**
		*@private
		*/
		__proto._set2DRenderConfig=function(gl){
			WebGLContext.setBlend(gl,true);
			WebGLContext.setBlendFunc(gl,1,0x0303);
			WebGLContext.setDepthTest(gl,false);
			WebGLContext.setCullFace(gl,false);
			WebGLContext.setDepthMask(gl,true);
			WebGLContext.setFrontFace(gl,0x0901);
			gl.viewport(0,0,RenderState2D.width,RenderState2D.height);
		}

		/**
		*@private
		*/
		__proto._parseCustomProps=function(rootNode,innerResouMap,customProps){
			var lightMapsData=customProps.lightmaps;
			var lightMapCount=lightMapsData.length;
			var lightmaps=this._lightmaps;
			lightmaps.length=lightMapCount;
			for (var i=0;i < lightMapCount;i++)
			lightmaps[i]=Loader.getRes(innerResouMap[lightMapsData[i].replace("exr","png")]);
			this.setlightmaps(lightmaps);
			var ambientColorData=customProps.ambientColor;
			if (ambientColorData){
				var ambCol=this.ambientColor;
				ambCol.fromArray(ambientColorData);
				this.ambientColor=ambCol;
			};
			var fogColorData=customProps.fogColor;
			if (fogColorData){
				var fogCol=this.fogColor;
				fogCol.fromArray(fogColorData);
				this.fogColor=fogCol;
			}
		}

		/**
		*@private
		*/
		__proto._addLight=function(light){
			if (this._lights.indexOf(light)< 0)this._lights.push(light);
		}

		/**
		*@private
		*/
		__proto._removeLight=function(light){
			var index=this._lights.indexOf(light);
			index >=0 && (this._lights.splice(index,1));
		}

		/**
		*@private
		*/
		__proto._updateScene=function(){
			this._prepareUpdateToRenderState(LayaGL.instance,this._renderState);
		}

		/**
		*@private
		*/
		__proto._preRenderShadow=function(state,lightFrustum,shdowQueues,lightViewProjectMatrix,nPSSMNum){
			if (this.treeRoot){
				FrustumCulling.renderShadowObjectCullingOctree(this,lightFrustum,shdowQueues,lightViewProjectMatrix,nPSSMNum);
				}else {
				FrustumCulling.renderShadowObjectCulling(this,lightFrustum,shdowQueues,lightViewProjectMatrix,nPSSMNum);
			}
			for (var i=0,iNum=shdowQueues.length;i < iNum;i++)
			(shdowQueues[i])&& (shdowQueues[i]._preRender(state));
		}

		/**
		*@private
		*/
		__proto._renderShadowMap=function(gl,state,sceneCamera){
			var parallelSplitShadowMap=this.parallelSplitShadowMaps[0];
			parallelSplitShadowMap._calcAllLightCameraInfo(sceneCamera);
			var pssmNum=parallelSplitShadowMap.PSSMNum;
			this._preRenderShadow(state,parallelSplitShadowMap._lightCulling,parallelSplitShadowMap._shadowQuenes,parallelSplitShadowMap._lightVPMatrix[0],pssmNum);
			this._defineDatas.add(ParallelSplitShadowMap.SHADERDEFINE_CAST_SHADOW);
			var renderTarget,shadowQuene,lightCamera;
			if (pssmNum > 1){
				for (var i=0;i < pssmNum;i++){
					renderTarget=parallelSplitShadowMap.getRenderTarget(i+1);
					parallelSplitShadowMap.beginRenderTarget(i+1);
					gl.clearColor(1,1,1,1);
					gl.clear(0x00004000 | 0x00000100);
					gl.viewport(0,0,renderTarget.width,renderTarget.height);
					state.camera=lightCamera=parallelSplitShadowMap.getLightCamera(i);
					lightCamera._prepareCameraToRender();
					lightCamera._prepareCameraViewProject(lightCamera.viewMatrix,lightCamera.projectionMatrix);
					state.projectionViewMatrix=parallelSplitShadowMap._lightVPMatrix[i+1];
					shadowQuene=parallelSplitShadowMap._shadowQuenes[i];
					shadowQuene._preRender(state);
					shadowQuene._renderShadow(state,false);
					parallelSplitShadowMap.endRenderTarget(i+1);
				}
				}else {
				renderTarget=parallelSplitShadowMap.getRenderTarget(1);
				parallelSplitShadowMap.beginRenderTarget(1);
				gl.clearColor(1,1,1,1);
				gl.clear(0x00004000 | 0x00000100);
				gl.viewport(0,0,renderTarget.width,renderTarget.height);
				state.camera=lightCamera=parallelSplitShadowMap.getLightCamera(0);
				lightCamera._prepareCameraToRender();
				lightCamera._prepareCameraViewProject(lightCamera.viewMatrix,lightCamera.projectionMatrix);
				state.projectionViewMatrix=parallelSplitShadowMap._lightVPMatrix[0];
				shadowQuene=parallelSplitShadowMap._shadowQuenes[0];
				shadowQuene._preRender(state);
				shadowQuene._renderShadow(state,true);
				parallelSplitShadowMap.endRenderTarget(1);
			}
			this._defineDatas.remove(ParallelSplitShadowMap.SHADERDEFINE_CAST_SHADOW);
		}

		/**
		*@private
		*/
		__proto.addTreeNode=function(renderObj){
			this.treeRoot.addTreeNode(renderObj);
		}

		/**
		*@private
		*/
		__proto.removeTreeNode=function(renderObj){
			if (!this.treeSize)return;
			if (renderObj._treeNode){
				renderObj._treeNode.removeObject(renderObj);
			}
		}

		/**
		*设置光照贴图。
		*@param value 光照贴图。
		*/
		__proto.setlightmaps=function(value){
			this._lightmaps=value;
			for (var i=0,n=this._children.length;i < n;i++)
			this._setLightMap(this._children[i]);
		}

		/**
		*获取光照贴图。
		*@return 获取光照贴图。
		*/
		__proto.getlightmaps=function(){
			return this._lightmaps;
		}

		/**
		*@inheritDoc
		*/
		__proto.addRenderObject=function(renderObject){
			if (this.treeRoot){
				this.addTreeNode(renderObject);
				}else {
				if (this._cullingRendersLength===this._renderObjects.length)
					this._renderObjects.push(renderObject);
				else
				this._renderObjects[this._cullingRendersLength]=renderObject;
				renderObject._indexInSceneList=this._cullingRendersLength++;
			}
		}

		/**
		*@private
		*/
		__proto.removeRenderObject=function(renderObject){
			if (this.treeRoot){
				this.removeTreeNode(renderObject);
				}else {
				this._cullingRendersLength--;
				var indexInSceneList=renderObject._indexInSceneList;
				if (indexInSceneList!==this._cullingRendersLength){
					var endRender=this._renderObjects[this._cullingRendersLength];
					this._renderObjects[indexInSceneList]=endRender;
					endRender._indexInSceneList=indexInSceneList;
					renderObject._indexInSceneList=-1;
				}
			}
		}

		/**
		*@private
		*/
		__proto.swapRenderObject=function(leftIndex,rightIndex){
			var temp=this._renderObjects[leftIndex];
			temp._indexInSceneList=rightIndex;
			var right=this._renderObjects[rightIndex];
			right._indexInSceneList=leftIndex;
			this._renderObjects[leftIndex]=right;
			this._renderObjects[rightIndex]=temp;
		}

		/**
		*@private
		*/
		__proto._partition=function(items,left,right){
			var pivot=items[Math.floor((right+left)/ 2)]._distanceForSort;
			while (left <=right){
				while (items[left]._distanceForSort < pivot)
				left++;
				while (items[right]._distanceForSort > pivot)
				right--;
				if (left < right){
					this.swapRenderObject(left,right);
					left++;
					right--;
					}else if (left===right){
					left++;
					break ;
				}
			}
			return left;
		}

		/**
		*@private
		*/
		__proto._quickSort=function(items,left,right){
			if (items.length > 1){
				var index=this._partition(items,left,right);
				var leftIndex=index-1;
				if (left < leftIndex)
					this._quickSort(items,left,leftIndex);
				if (index < right)
					this._quickSort(items,index,right);
			}
			return items;
		}

		/**
		*获得某个渲染队列。
		*@param index 渲染队列索引。
		*@return 渲染队列。
		*/
		__proto.getRenderQueue=function(index){
			var queue=this._quenes[index];
			if (!queue){
				if (index===2)
					this._quenes[index]=queue=new RenderQueue(this,false)
				else
				this._quenes[index]=queue=new RenderQueue(this,true);
			}
			return queue;
		}

		/**
		*添加渲染队列。
		*@param renderConfig 渲染队列配置文件。
		*/
		__proto.addRenderQuene=function(){
			this._quenes[this._customRenderQueneIndex++]=new RenderQueue(this);
		}

		/**
		*@private
		*/
		__proto.onAsynLoaded=function(data,params){
			var json=data[0]
			if (json.type!=="Scene")
				throw new Error("Scene: the .lh file root type must be Scene,please use other function to  load  this file.");
			var innerResouMap=data[1];
			var outBatchSprits=[];
			Utils3D._createNodeByJson(this,json,this,innerResouMap,outBatchSprits);
			StaticBatchManager.combine(null,outBatchSprits);
		}

		/**
		*@private
		*/
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			if (this.destroyed)
				return;
			laya.display.Node.prototype.destroy.call(this,destroyChild);
			this._renderState=null;
			this._lights=null;
			this._lightmaps=null;
			this._renderTargetTexture=null;
			this._shaderValues=null;
			this._renderObjects=null;
			this._dynamicBatchManager=null;
			this._quenes=null;
			this._cameraPool=null;
			this.treeRoot=null;
			this.treeSize=null;
			this.parallelSplitShadowMaps=null;
			Loader.clearRes(this.url);
			(this.loaded)||(Laya3D._cancelLoadByUrl(this.url));
		}

		/**
		*@private
		*/
		__proto.render=function(context){
			this._children.length > 0 && context.addRenderObject(this);
		}

		/**
		*@private
		*/
		__proto.renderSubmit=function(){
			var gl=LayaGL.instance;
			if (this._glCommandEncoder)this._glCommandEncoder.clearEncoding();
			gl.beginCommandEncoding(this._glCommandEncoder);
			var renderState=this._renderState;
			this._prepareSceneToRender(this._renderState);
			var i=0,n=0,camera;
			if (Laya3D.debugMode || OctreeNode.debugMode){
				for (i=0,n=this._cameraPool.length;i < n;i++){
					camera=this._cameraPool[i];
					Laya3D._debugPhasorSprite.begin(0x0001,camera);
					(camera.activeInHierarchy)&& (camera._renderCamera(gl,renderState,this));
					Laya3D._debugPhasorSprite.end();
				}
				}else {
				for (i=0,n=this._cameraPool.length;i < n;i++){
					camera=this._cameraPool[i];
					(camera.activeInHierarchy)&& (camera._renderCamera(gl,renderState,this));
				}
			}
			this._set2DRenderConfig(gl);
			gl.endCommandEncoding();
			return 1;
		}

		/**
		*@private
		*/
		__proto.getRenderType=function(){
			return 0;
		}

		/**
		*@private
		*/
		__proto.releaseRender=function(){}
		/**
		*@private [NATIVE]
		*/
		__proto.renderToNative=function(context){
			this.renderSubmit();
			if (!LayaGLTemplate.GLS[this._renderType]){
				LayaGLTemplate.createByRenderType(this._renderType);
			}
			context.block(this.data);
		}

		/**
		*设置雾化颜色。
		*@param value 雾化颜色。
		*/
		/**
		*获取雾化颜色。
		*@return 雾化颜色。
		*/
		__getset(0,__proto,'fogColor',function(){
			return this._shaderValues.getVector(0);
			},function(value){
			this._shaderValues.setVector(0,value);
		});

		/**
		*设置是否允许雾化。
		*@param value 是否允许雾化。
		*/
		/**
		*获取是否允许雾化。
		*@return 是否允许雾化。
		*/
		__getset(0,__proto,'enableFog',function(){
			return this._enableFog;
			},function(value){
			if (this._enableFog!==value){
				this._enableFog=value;
				if (value){
					this._defineDatas.add(Shader3D.SHADERDEFINE_FOG);
					this._defineDatas.remove(Shader3D.SAHDERDEFINE_DEPTHFOG);
				}else
				this._defineDatas.remove(Shader3D.SHADERDEFINE_FOG);
			}
		});

		/**
		*获取资源的URL地址。
		*@return URL地址。
		*/
		__getset(0,__proto,'url',function(){
			return this._url;
		});

		__getset(0,__proto,'enableDepthFog',function(){
			return this._enableDepthFog;
			},function(v){
			if (this._enableDepthFog !=v){
				this._enableDepthFog=v;
				if (v){
					this._defineDatas.add(Shader3D.SAHDERDEFINE_DEPTHFOG);
					this._defineDatas.remove(Shader3D.SHADERDEFINE_FOG);
					}else {
					this._defineDatas.remove(Shader3D.SAHDERDEFINE_DEPTHFOG);
				}
			}
		});

		/**
		*设置雾化起始位置。
		*@param value 雾化起始位置。
		*/
		/**
		*获取雾化起始位置。
		*@return 雾化起始位置。
		*/
		__getset(0,__proto,'fogStart',function(){
			return this._shaderValues.getNumber(1);
			},function(value){
			this._shaderValues.setNumber(1,value);
		});

		/**
		*设置雾化范围。
		*@param value 雾化范围。
		*/
		/**
		*获取雾化范围。
		*@return 雾化范围。
		*/
		__getset(0,__proto,'fogRange',function(){
			return this._shaderValues.getNumber(2);
			},function(value){
			this._shaderValues.setNumber(2,value);
		});

		/**
		*设置环境光颜色。
		*@param value 环境光颜色。
		*/
		/**
		*获取环境光颜色。
		*@return 环境光颜色。
		*/
		__getset(0,__proto,'ambientColor',function(){
			return this._shaderValues.getVector(21);
			},function(value){
			this._shaderValues.setVector(21,value);
		});

		/**
		*获取当前场景。
		*@return 当前场景。
		*/
		__getset(0,__proto,'scene',function(){
			return this;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'activeInHierarchy',function(){
			return this.displayedInStage;
		});

		Scene._sortScenes=function(a,b){
			if (a.parent===Laya.stage && b.parent===Laya.stage){
				var stageChildren=Laya.stage._children;
				return stageChildren.indexOf(a)-stageChildren.indexOf(b);
				}else if (a.parent!==Laya.stage && b.parent!==Laya.stage){
				return Scene._sortScenes(a.parent,b.parent);
				}else {
				return (a.parent===Laya.stage)?-1 :1;
			}
		}

		Scene.load=function(url){
			return Laya.loader.create(url,null,null,Scene);
		}

		Scene.SHADERDEFINE_FOG=0;
		Scene.SHADERDEFINE_DIRECTIONLIGHT=0;
		Scene.SHADERDEFINE_POINTLIGHT=0;
		Scene.SHADERDEFINE_SPOTLIGHT=0;
		Scene.SAHDERDEFINE_DEPTHFOG=0;
		Scene.SHADERDEFINE_CAST_SHADOW=0;
		Scene.SHADERDEFINE_SHADOW_PSSM1=0;
		Scene.SHADERDEFINE_SHADOW_PSSM2=0;
		Scene.SHADERDEFINE_SHADOW_PSSM3=0;
		Scene.SHADERDEFINE_SHADOW_PCF_NO=0;
		Scene.SHADERDEFINE_SHADOW_PCF1=0;
		Scene.SHADERDEFINE_SHADOW_PCF2=0;
		Scene.SHADERDEFINE_SHADOW_PCF3=0;
		Scene.FOGCOLOR=0;
		Scene.FOGSTART=1;
		Scene.FOGRANGE=2;
		Scene.LIGHTDIRECTION=3;
		Scene.LIGHTDIRCOLOR=4;
		Scene.POINTLIGHTPOS=5;
		Scene.POINTLIGHTRANGE=6;
		Scene.POINTLIGHTATTENUATION=7;
		Scene.POINTLIGHTCOLOR=8;
		Scene.SPOTLIGHTPOS=9;
		Scene.SPOTLIGHTDIRECTION=10;
		Scene.SPOTLIGHTSPOT=11;
		Scene.SPOTLIGHTRANGE=12;
		Scene.SPOTLIGHTATTENUATION=13;
		Scene.SPOTLIGHTCOLOR=14;
		Scene.SHADOWDISTANCE=15;
		Scene.SHADOWLIGHTVIEWPROJECT=16;
		Scene.SHADOWMAPPCFOFFSET=17;
		Scene.SHADOWMAPTEXTURE1=18;
		Scene.SHADOWMAPTEXTURE2=19;
		Scene.SHADOWMAPTEXTURE3=20;
		Scene.AMBIENTCOLOR=21;
		return Scene;
	})(ComponentNode)


	/**
	*<code>Mesh</code> 类用于创建文件网格数据模板。
	*/
	//class laya.d3.resource.models.Mesh extends laya.d3.resource.models.BaseMesh
	var Mesh=(function(_super){
		function Mesh(){
			this._subMeshes=null;
			this._vertexBuffers=null;
			this._indexBuffer=null;
			this._boneNames=null;
			this._inverseBindPoses=null;
			this._inverseBindPosesBuffer=null;
			this._bindPoseIndices=null;
			this._skinDataPathMarks=null;
			Mesh.__super.call(this);
			this._subMeshes=[];
			this._vertexBuffers=[];
			this._skinDataPathMarks=[];
		}

		__class(Mesh,'laya.d3.resource.models.Mesh',_super);
		var __proto=Mesh.prototype;
		/**
		*获取网格顶点，并产生数据
		*@return 网格顶点。
		*/
		__proto._getPositions=function(){
			var vertices=[];
			var i=0,j=0,vertexBuffer,positionElement,vertexElements,vertexElement,ofset=0,verticesData;
			var vertexBufferCount=this._vertexBuffers.length;
			for (i=0;i < vertexBufferCount;i++){
				vertexBuffer=this._vertexBuffers[i];
				vertexElements=vertexBuffer.vertexDeclaration.vertexElements;
				for (j=0;j < vertexElements.length;j++){
					vertexElement=vertexElements[j];
					if (vertexElement.elementFormat==="vector3" && vertexElement.elementUsage===0){
						positionElement=vertexElement;
						break ;
					}
				}
				verticesData=vertexBuffer.getData();
				for (j=0;j < verticesData.length;j+=vertexBuffer.vertexDeclaration.vertexStride / 4){
					ofset=j+positionElement.offset / 4;
					vertices.push(new Vector3(verticesData[ofset+0],verticesData[ofset+1],verticesData[ofset+2]));
				}
			}
			return vertices;
		}

		/**
		*@private
		*/
		__proto._setSubMeshes=function(subMeshes){
			this._subMeshes=subMeshes
			this._subMeshCount=subMeshes.length;
			for (var i=0;i < this._subMeshCount;i++)
			subMeshes[i]._indexInMesh=i;
			this._positions=this._getPositions();
			this._generateBoundingObject();
		}

		/**
		*@private
		*/
		__proto.onAsynLoaded=function(data,params){
			var bufferData=data[0];
			var textureMap=data[1];
			MeshReader.read(bufferData,this,this._subMeshes,textureMap);
		}

		/**
		*@inheritDoc
		*/
		__proto._getSubMesh=function(index){
			return this._subMeshes[index];
		}

		/**
		*@inheritDoc
		*/
		__proto.disposeResource=function(){
			for (var i=0;i < this._subMeshes.length;i++)
			this._subMeshes[i].dispose();
			this._subMeshes=null;
			this._vertexBuffers=null;
			this._indexBuffer.destroy();
			this._indexBuffer=null;
			this._boneNames=null;
			this._inverseBindPoses=null;
		}

		/**
		*获取网格的全局默认绑定动作逆矩阵。
		*@return 网格的全局默认绑定动作逆矩阵。
		*/
		__getset(0,__proto,'inverseAbsoluteBindPoses',function(){
			return this._inverseBindPoses;
		});

		Mesh.load=function(url){
			return Laya.loader.create(url,null,null,Mesh);
		}

		return Mesh;
	})(BaseMesh)


	/**
	*<code>SkinMeshRender</code> 类用于蒙皮渲染器。
	*/
	//class laya.d3.core.SkinnedMeshRender extends laya.d3.core.MeshRender
	var SkinnedMeshRender=(function(_super){
		function SkinnedMeshRender(owner,shaderDataSize){
			//this._cacheAvatar=null;
			//this._cacheMesh=null;
			//this._cacheAnimationNode=null;
			//this._cacheAnimationNodeIndex=null;
			//this._skinnedData=null;
			//this._skinnedDataLoopMarks=null;
			//this._localBoundingBoxCorners=null;
			//this._localBoundBox=null;
			//this._cacheAnimator=null;
			//this._rootIndex=0;
			//this._rootBone=null;
			//this.localBoundSphere=null;
			this._hasIndependentBound=true;
			SkinnedMeshRender.__super.call(this,owner,shaderDataSize);
			this._owner.transform.off("worldmatrixneedchanged",this,this._onWorldMatNeedChange);
			this._skinnedDataLoopMarks=[];
			this._cacheAnimationNode=[];
			this._localBoundingBoxCorners=__newvec(8,null);
			(this._owner).meshFilter.on("meshchanged",this,this._$3__onMeshChanged);
		}

		__class(SkinnedMeshRender,'laya.d3.core.SkinnedMeshRender',_super);
		var __proto=SkinnedMeshRender.prototype;
		/**
		*@private
		*/
		__proto._getCacheAnimationNodes=function(){
			var meshBoneNames=this._cacheMesh._boneNames;
			var bindPoseIndices=this._cacheMesh._bindPoseIndices;
			var innerBindPoseCount=bindPoseIndices.length;
			this._cacheAnimationNode.length=innerBindPoseCount;
			if (this._cacheAnimationNodeIndex)
				(this._cacheAnimationNodeIndex.length!==innerBindPoseCount)&& (this._cacheAnimationNodeIndex=new Uint16Array(innerBindPoseCount));
			else
			this._cacheAnimationNodeIndex=new Uint16Array(innerBindPoseCount);
			var avatarNodes=this._cacheAnimator._avatarNodes;
			var nodeMap=this._cacheAnimator._avatarNodeMap;
			for (var i=0;i < innerBindPoseCount;i++){
				var node=nodeMap[meshBoneNames[bindPoseIndices[i]]];
				this._cacheAnimationNode[i]=node;
				this._cacheAnimationNodeIndex[i]=avatarNodes.indexOf(node);
			}
		}

		/**
		*@private
		*/
		__proto._offComputeBoneIndexToMeshEvent=function(avatar,mesh){
			if (avatar.loaded){
				if (!mesh.loaded)
					mesh.off("loaded",this,this._getCacheAnimationNodes);
				}else {
				avatar.off("loaded",this,this._computeBoneIndexToMeshWithAsyncMesh);
			}
		}

		/**
		*@private
		*/
		__proto._computeBoneIndexToMeshWithAsyncAvatar=function(){
			if (this._cacheAvatar.loaded)
				this._computeBoneIndexToMeshWithAsyncMesh();
			else
			this._cacheAvatar.once("loaded",this,this._computeBoneIndexToMeshWithAsyncMesh);
		}

		/**
		*@private
		*/
		__proto._computeBoneIndexToMeshWithAsyncMesh=function(){
			if (this._cacheMesh.loaded)
				this._getCacheAnimationNodes();
			else
			this._cacheMesh.on("loaded",this,this._getCacheAnimationNodes);
		}

		/**
		*@private
		*/
		__proto._$3__onMeshChanged=function(meshFilter,lastMesh,mesh){
			this._cacheMesh=mesh;
			(lastMesh && !lastMesh.loaded)&& (mesh.off("loaded",this,this._onMeshLoaded));
			if (mesh.loaded)
				this._onMeshLoaded(mesh);
			else
			mesh.on("loaded",this,this._onMeshLoaded);
			if (this._cacheAvatar){
				(lastMesh)&& (this._offComputeBoneIndexToMeshEvent(this._cacheAvatar,lastMesh));
				(mesh)&& (this._computeBoneIndexToMeshWithAsyncAvatar());
			}
		}

		/**
		*@private
		*/
		__proto._onMeshLoaded=function(mesh){
			var subMeshCount=mesh.subMeshCount;
			this._skinnedData=__newvec(subMeshCount);
			this._skinnedDataLoopMarks.length=mesh._bindPoseIndices.length;
			for (var i=0;i < subMeshCount;i++){
				var subBoneIndices=mesh._getSubMesh(i)._boneIndicesList;
				var subCount=subBoneIndices.length;
				var subData=this._skinnedData[i]=__newvec(subCount);
				for (var j=0;j < subCount;j++)
				subData[j]=new Float32Array(subBoneIndices[j].length *16);
			}
		}

		/**
		*@private
		*/
		__proto._computeSkinnedData=function(cache,boneIndices,bindPoseInices,data,pathMarks){
			var curAvatarAnimationDatas=this._cacheAnimator._curAvatarNodeDatas;
			var bindPoses=this._cacheMesh._inverseBindPoses;
			for (var k=0,q=boneIndices.length;k < q;k++){
				var index=boneIndices[k];
				if (this._skinnedDataLoopMarks[index]===Stat.loopCount){
					var p=pathMarks[index];
					var preData=this._skinnedData[p[0]][p[1]];
					var srcIndex=p[2] *16;
					var dstIndex=k *16;
					for (var d=0;d < 16;d++)
					data[dstIndex+d]=preData[srcIndex+d];
					}else {
					if (cache)
						Utils3D._mulMatrixArray(curAvatarAnimationDatas[this._cacheAnimationNodeIndex[index]],bindPoses[bindPoseInices[index]],data,k *16);
					else
					Utils3D._mulMatrixArray(this._cacheAnimationNode[index].transform.getWorldMatrix(),bindPoses[bindPoseInices[index]],data,k *16);
					this._skinnedDataLoopMarks[index]=Stat.loopCount;
				}
			}
		}

		/**
		*@private
		*/
		__proto._setCacheAnimator=function(animator){
			this._cacheAnimator=animator;
			(this._rootBone)&& (this._rootIndex=animator._avatarNodes.indexOf(animator._avatarNodeMap[this._rootBone]));
		}

		/**
		*@private
		*/
		__proto._setRootBone=function(name){
			this._rootBone=name;
			(this._cacheAnimator)&& (this._rootIndex=this._cacheAnimator._avatarNodes.indexOf(this._cacheAnimator._avatarNodeMap[name]));
		}

		/**
		*@private
		*/
		__proto._setCacheAvatar=function(value){
			if (this._cacheAvatar!==value){
				if (this._cacheMesh){
					(this._cacheAvatar)&& (this._offComputeBoneIndexToMeshEvent(this._cacheAvatar,this._cacheMesh));
					this._cacheAvatar=value;
					if (value){
						this._defineDatas.add(SkinnedMeshSprite3D.SHADERDEFINE_BONE);
						this._computeBoneIndexToMeshWithAsyncAvatar();
					}
					}else {
					this._cacheAvatar=value;
				}
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._calculateBoundingBox=function(){
			if (this._hasIndependentBound){
				if (this._cacheAnimator){
					var rootBone=this._cacheAnimator._avatarNodeMap[this._rootBone];
					if (rootBone==null || this._localBoundBox==null)
						this._boundingBox.toDefault();
					else
					this._calculateBoundBoxByInitCorners(this._localBoundingBoxCorners);
				}
				}else {
				_super.prototype._calculateBoundingBox.call(this);
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._calculateBoundingSphere=function(){
			if (this._hasIndependentBound){
				if (this._cacheAnimator){
					var rootBone=this._cacheAnimator._avatarNodeMap[this._rootBone];
					if (rootBone==null || this.localBoundSphere==null)
						this._boundingSphere.toDefault();
					else
					this._calculateBoundingSphereByInitSphere(this.localBoundSphere);
				}
				}else {
				_super.prototype._calculateBoundingSphere.call(this);
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._updateOctreeNode=function(){
			var treeNode=this._treeNode;
			if (treeNode){
				treeNode.updateObject(this);
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._renderUpdate=function(context,transform){
			var projectionView=context.projectionViewMatrix;
			var animator=this._cacheAnimator;
			var subMeshCount=this._cacheMesh.subMeshCount;
			var sv=this._shaderValues;
			var worldMat=transform.worldMatrix;
			if (animator){
				var cache=animator._canCache;
				var curAvatarAnimationDatas=this._cacheAnimator._curAvatarNodeDatas;
				if (this._hasIndependentBound){
					if (cache)
						Utils3D.matrix4x4MultiplyMFM((this._cacheAnimator.owner).transform.worldMatrix,curAvatarAnimationDatas[this._rootIndex],worldMat);
					else
					Utils3D.matrix4x4MultiplyMFM((this._cacheAnimator.owner).transform.worldMatrix,animator._avatarNodeMap[this._rootBone].transform.getWorldMatrix(),worldMat);
					transform.worldMatrix=worldMat;
				};
				var aniOwner=animator.owner;
				sv.setMatrix4x4(0,aniOwner._transform.worldMatrix);
				Matrix4x4.multiply(projectionView,aniOwner.transform.worldMatrix,this._projectionViewWorldMatrix);
				sv.setMatrix4x4(1,this._projectionViewWorldMatrix);
				if (this._cacheMesh && this._cacheMesh.loaded && this._cacheAvatar && this._cacheAvatar.loaded){
					var i=0,n=0;
					var bindPoseInices=this._cacheMesh._bindPoseIndices;
					var bindPoses=this._cacheMesh._inverseBindPoses;
					var pathMarks=this._cacheMesh._skinDataPathMarks;
					for (i=0;i < subMeshCount;i++){
						var subBoneIndices=this._cacheMesh._getSubMesh(i)._boneIndicesList;
						var subData=this._skinnedData[i];
						for (var j=0,m=subBoneIndices.length;j < m;j++){
							var boneIndices=subBoneIndices[j];
							var data=subData[j];
							this._computeSkinnedData(cache,boneIndices,bindPoseInices,data,pathMarks);
						}
						(this._renderElements [i]).skinnedDatas=subData;
					}
				}
				}else {
				sv.setMatrix4x4(0,worldMat);
				Matrix4x4.multiply(projectionView,worldMat,this._projectionViewWorldMatrix);
				sv.setMatrix4x4(1,this._projectionViewWorldMatrix);
			}
			if (Laya3D.debugMode)
				this._renderRenderableBoundBox();
		}

		/**
		*@private [NATIVE]
		*/
		__proto._computeSkinnedDataForNative=function(cache,boneIndices,bindPoseInices,data,pathMarks){
			window.conch.calcBoneAnimation(boneIndices,data,this._cacheAnimator._curAvatarNodeDatasBuffer,this._cacheAnimationNodeIndex,this._cacheMesh._inverseBindPosesBuffer,bindPoseInices,cache);
		}

		/**
		*设置包围球。
		*@param value
		*/
		/**
		*获取包围球。
		*@return 包围球。
		*/
		__getset(0,__proto,'localBoundBox',function(){
			return this._localBoundBox;
			},function(value){
			this._localBoundBox=value;
			value.getCorners(this._localBoundingBoxCorners);
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'boundingSphere',function(){
			this._calculateBoundingSphere();
			return this._boundingSphere;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'boundingBox',function(){
			this._calculateBoundingBox();
			return this._boundingBox;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'boundingBoxCenter',function(){
			var boundBox=this.boundingBox;
			Vector3.add(boundBox.min,boundBox.max,this._boundingBoxCenter);
			Vector3.scale(this._boundingBoxCenter,0.5,this._boundingBoxCenter);
			return this._boundingBoxCenter;
		});

		return SkinnedMeshRender;
	})(MeshRender)


	/**
	*<p><code>Input</code> 类用于创建显示对象以显示和输入文本。</p>
	*<p>Input 类封装了原生的文本输入框，由于不同浏览器的差异，会导致此对象的默认文本的位置与用户点击输入时的文本的位置有少许的偏差。</p>
	*/
	//class laya.display.Input extends laya.display.Text
	var Input=(function(_super){
		function Input(){
			this._focus=false;
			this._multiline=false;
			this._editable=true;
			this._restrictPattern=null;
			this._type="text";
			this._prompt='';
			this._promptColor="#A9A9A9";
			this._originColor="#000000";
			this._content='';
			Input.__super.call(this);
			this._maxChars=1E5;
			this._width=100;
			this._height=20;
			this.multiline=false;
			this.overflow="scroll";
			this.on("mousedown",this,this._onMouseDown);
			this.on("undisplay",this,this._onUnDisplay);
		}

		__class(Input,'laya.display.Input',_super);
		var __proto=Input.prototype;
		/**
		*设置光标位置和选取字符。
		*@param startIndex 光标起始位置。
		*@param endIndex 光标结束位置。
		*/
		__proto.setSelection=function(startIndex,endIndex){
			laya.display.Input.inputElement.selectionStart=startIndex;
			laya.display.Input.inputElement.selectionEnd=endIndex;
		}

		__proto._onUnDisplay=function(e){
			this.focus=false;
		}

		__proto._onMouseDown=function(e){
			this.focus=true;
		}

		/**
		*在输入期间，如果 Input 实例的位置改变，调用_syncInputTransform同步输入框的位置。
		*/
		__proto._syncInputTransform=function(){
			var inputElement=this.nativeInput;
			var transform=Utils.getTransformRelativeToWindow(this,this.padding[3],this.padding[0]);
			var inputWid=this._width-this.padding[1]-this.padding[3];
			var inputHei=this._height-this.padding[0]-this.padding[2];
			if (Render.isConchApp){
				inputElement.setScale(transform.scaleX,transform.scaleY);
				inputElement.setSize(inputWid,inputHei);
				inputElement.setPos(transform.x,transform.y);
				}else {
				Input.inputContainer.style.transform=Input.inputContainer.style.webkitTransform="scale("+transform.scaleX+","+transform.scaleY+") rotate("+(Laya.stage.canvasDegree)+"deg)";
				inputElement.style.width=inputWid+'px';
				inputElement.style.height=inputHei+'px';
				Input.inputContainer.style.left=transform.x+'px';
				Input.inputContainer.style.top=transform.y+'px';
			}
		}

		/**选中当前实例的所有文本。*/
		__proto.select=function(){
			this.nativeInput.select();
		}

		__proto._setInputMethod=function(){
			Input.input.parentElement && (Input.inputContainer.removeChild(Input.input));
			Input.area.parentElement && (Input.inputContainer.removeChild(Input.area));
			Input.inputElement=(this._multiline ? Input.area :Input.input);
			Input.inputContainer.appendChild(Input.inputElement);
		}

		__proto._focusIn=function(){
			laya.display.Input.isInputting=true;
			var input=this.nativeInput;
			this._focus=true;
			var cssStyle=input.style;
			cssStyle.whiteSpace=(this.wordWrap ? "pre-wrap" :"nowrap");
			this._setPromptColor();
			input.readOnly=!this._editable;
			if (Render.isConchApp){
				input.setForbidEdit(!this._editable);
			}
			input.maxLength=this._maxChars;
			var padding=this.padding;
			input.type=this._type;
			input.value=this._content;
			input.placeholder=this._prompt;
			Laya.stage.off("keydown",this,this._onKeyDown);
			Laya.stage.on("keydown",this,this._onKeyDown);
			Laya.stage.focus=this;
			this.event("focus");
			if (Browser.onPC)input.focus();
			var temp=this._text;
			this._text=null;
			this.typeset();
			input.setColor(this._originColor);
			input.setFontSize(this.fontSize);
			input.setFontFace(Browser.onIPhone ? (Text.fontFamilyMap[this.font] || this.font):this.font);
			if (Render.isConchApp){
				input.setMultiAble && input.setMultiAble(this._multiline);
			}
			cssStyle.lineHeight=(this.leading+this.fontSize)+"px";
			cssStyle.fontStyle=(this.italic ? "italic" :"normal");
			cssStyle.fontWeight=(this.bold ? "bold" :"normal");
			cssStyle.textAlign=this.align;
			cssStyle.padding="0 0";
			this._syncInputTransform();
			if (!Render.isConchApp && Browser.onPC)
				Laya.timer.frameLoop(1,this,this._syncInputTransform);
		}

		// 设置DOM输入框提示符颜色。
		__proto._setPromptColor=function(){
			Input.promptStyleDOM=Browser.getElementById("promptStyle");
			if (!Input.promptStyleDOM){
				Input.promptStyleDOM=Browser.createElement("style");
				Input.promptStyleDOM.setAttribute("id","promptStyle");
				Browser.document.head.appendChild(Input.promptStyleDOM);
			}
			Input.promptStyleDOM.innerText="input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {"+"color:"+this._promptColor+"}"+"input:-moz-placeholder, textarea:-moz-placeholder {"+"color:"+this._promptColor+"}"+"input::-moz-placeholder, textarea::-moz-placeholder {"+"color:"+this._promptColor+"}"+"input:-ms-input-placeholder, textarea:-ms-input-placeholder {"+"color:"+this._promptColor+"}";
		}

		/**@private */
		__proto._focusOut=function(){
			laya.display.Input.isInputting=false;
			this._focus=false;
			this._text=null;
			this._content=this.nativeInput.value;
			if (!this._content){
				_super.prototype._$set_text.call(this,this._prompt);
				_super.prototype._$set_color.call(this,this._promptColor);
				}else {
				_super.prototype._$set_text.call(this,this._content);
				_super.prototype._$set_color.call(this,this._originColor);
			}
			Laya.stage.off("keydown",this,this._onKeyDown);
			Laya.stage.focus=null;
			this.event("blur");
			if (Render.isConchApp)this.nativeInput.blur();
			Browser.onPC && Laya.timer.clear(this,this._syncInputTransform);
		}

		/**@private */
		__proto._onKeyDown=function(e){
			if (e.keyCode===13){
				if (Browser.onMobile && !this._multiline)this.focus=false;
				this.event("enter");
			}
		}

		__proto.changeText=function(text){
			this._content=text;
			if (this._focus){
				this.nativeInput.value=text || '';
				this.event("change");
			}else
			_super.prototype.changeText.call(this,text);
		}

		/**@inheritDoc */
		__getset(0,__proto,'color',_super.prototype._$get_color,function(value){
			if (this._focus)this.nativeInput.setColor(value);
			_super.prototype._$set_color.call(this,this._content?value:this._promptColor);
			this._originColor=value;
		});

		/**表示是否是多行输入框。*/
		__getset(0,__proto,'multiline',function(){
			return this._multiline;
			},function(value){
			this._multiline=value;
			this.valign=value ? "top" :"middle";
		});

		/**
		*<p>字符数量限制，默认为10000。</p>
		*<p>设置字符数量限制时，小于等于0的值将会限制字符数量为10000。</p>
		*/
		__getset(0,__proto,'maxChars',function(){
			return this._maxChars;
			},function(value){
			if (value <=0)value=1E5;
			this._maxChars=value;
		});

		/**@inheritDoc */
		__getset(0,__proto,'text',function(){
			if (this._focus)return this.nativeInput.value;
			else return this._content || "";
			},function(value){
			_super.prototype._$set_color.call(this,this._originColor);
			value+='';
			if (this._focus){
				this.nativeInput.value=value || '';
				this.event("change");
				}else {
				if (!this._multiline)value=value.replace(/\r?\n/g,'');
				this._content=value;
				if (value)
					_super.prototype._$set_text.call(this,value);
				else {
					_super.prototype._$set_text.call(this,this._prompt);
					_super.prototype._$set_color.call(this,this.promptColor);
				}
			}
		});

		/**
		*获取对输入框的引用实例。
		*/
		__getset(0,__proto,'nativeInput',function(){
			return this._multiline ? Input.area :Input.input;
		});

		/**
		*设置输入提示符。
		*/
		__getset(0,__proto,'prompt',function(){
			return this._prompt;
			},function(value){
			if (!this._text && value)_super.prototype._$set_color.call(this,this._promptColor);
			this.promptColor=this._promptColor;
			if (this._text)_super.prototype._$set_text.call(this,(this._text==this._prompt)?value:this._text);
			else _super.prototype._$set_text.call(this,value);
			this._prompt=Text.langPacks && Text.langPacks[value] ? Text.langPacks[value] :value;
		});

		// 因此 调用focus接口是无法都在移动平台立刻弹出键盘的
		/**
		*表示焦点是否在此实例上。
		*/
		__getset(0,__proto,'focus',function(){
			return this._focus;
			},function(value){
			var input=this.nativeInput;
			if (this._focus!==value){
				if (value){
					if (input.target){
						input.target._focusOut();
						}else {
						this._setInputMethod();
					}
					input.target=this;
					this._focusIn();
					}else {
					input.target=null;
					this._focusOut();
					input.blur();
					if (Render.isConchApp)input.setPos(-10000,-10000);
					else if (Input.inputContainer.contains(input))Input.inputContainer.removeChild(input);
				}
			}
		});

		/**限制输入的字符。*/
		__getset(0,__proto,'restrict',function(){
			if (this._restrictPattern){
				return this._restrictPattern.source;
			}
			return "";
			},function(pattern){
			if (pattern){
				pattern="[^"+pattern+"]";
				if (pattern.indexOf("^^")>-1)pattern=pattern.replace("^^","");
				this._restrictPattern=new RegExp(pattern,"g");
			}else
			this._restrictPattern=null;
		});

		/**
		*是否可编辑。
		*/
		__getset(0,__proto,'editable',function(){
			return this._editable;
			},function(value){
			this._editable=value;
			if (Render.isConchApp){
				Input.input.setForbidEdit(!value);
			}
		});

		/**
		*设置输入提示符颜色。
		*/
		__getset(0,__proto,'promptColor',function(){
			return this._promptColor;
			},function(value){
			this._promptColor=value;
			if (!this._content)_super.prototype._$set_color.call(this,value);
		});

		/**
		*<p>输入框类型为Input静态常量之一。</p>
		*<ul>
		*<li>TYPE_TEXT</li>
		*<li>TYPE_PASSWORD</li>
		*<li>TYPE_EMAIL</li>
		*<li>TYPE_URL</li>
		*<li>TYPE_NUMBER</li>
		*<li>TYPE_DATE</li>
		*<li>TYPE_MONTH</li>
		*<li>TYPE_WEEK</li>
		*<li>TYPE_TIME</li>
		*<li>TYPE_DATE_TIME</li>
		*<li>TYPE_DATE_TIME_LOCAL</li>
		*</ul>
		*<p>平台兼容性参见http://www.w3school.com.cn/html5/html_5_form_input_types.asp。</p>
		*/
		__getset(0,__proto,'type',function(){
			return this._type;
			},function(value){
			if (value==="password")this._getTextStyle().asPassword=true;
			else this._getTextStyle().asPassword=false;
			this._type=value;
		});

		Input.__init__=function(){
			Input._createInputElement();
			if (Browser.onMobile)Render.canvas.addEventListener(Input.IOS_IFRAME ? "click" :"touchend",Input._popupInputMethod);
		}

		Input._popupInputMethod=function(e){
			if (!laya.display.Input.isInputting)return;
			laya.display.Input.inputElement.focus();
		}

		Input._createInputElement=function(){
			Input._initInput(Input.area=Browser.createElement("textarea"));
			Input._initInput(Input.input=Browser.createElement("input"));
			Input.inputContainer=Browser.createElement("div");
			Input.inputContainer.style.position="absolute";
			Input.inputContainer.style.zIndex=1E5;
			Browser.container.appendChild(Input.inputContainer);
			Input.inputContainer.setPos=function (x,y){
				Input.inputContainer.style.left=x+'px';
				Input.inputContainer.style.top=y+'px';
			};
		}

		Input._initInput=function(input){
			var style=input.style;
			style.cssText="position:absolute;overflow:hidden;resize:none;transform-origin:0 0;-webkit-transform-origin:0 0;-moz-transform-origin:0 0;-o-transform-origin:0 0;";
			style.resize='none';
			style.backgroundColor='transparent';
			style.border='none';
			style.outline='none';
			style.zIndex=1;
			input.addEventListener('input',Input._processInputting);
			input.addEventListener('mousemove',Input._stopEvent);
			input.addEventListener('mousedown',Input._stopEvent);
			input.addEventListener('touchmove',Input._stopEvent);
			input.setFontFace=function (fontFace){input.style.fontFamily=fontFace;};
			if(!Render.isConchApp){
				input.setColor=function (color){input.style.color=color;};
				input.setFontSize=function (fontSize){input.style.fontSize=fontSize+'px';};
			}
		}

		Input._processInputting=function(e){
			var input=laya.display.Input.inputElement.target;
			if (!input)return;
			var value=laya.display.Input.inputElement.value;
			if (input._restrictPattern){
				value=value.replace(/\u2006|\x27/g,"");
				if (input._restrictPattern.test(value)){
					value=value.replace(input._restrictPattern,"");
					laya.display.Input.inputElement.value=value;
				}
			}
			input._text=value;
			input.event("input");
		}

		Input._stopEvent=function(e){
			if (e.type=='touchmove')e.preventDefault();
			e.stopPropagation && e.stopPropagation();
		}

		Input.TYPE_TEXT="text";
		Input.TYPE_PASSWORD="password";
		Input.TYPE_EMAIL="email";
		Input.TYPE_URL="url";
		Input.TYPE_NUMBER="number";
		Input.TYPE_DATE="date";
		Input.TYPE_MONTH="month";
		Input.TYPE_WEEK="week";
		Input.TYPE_TIME="time";
		Input.TYPE_DATE_TIME="datetime";
		Input.TYPE_DATE_TIME_LOCAL="datetime-local";
		Input.TYPE_SEARCH="search";
		Input.input=null
		Input.area=null
		Input.inputElement=null
		Input.inputContainer=null
		Input.promptStyleDOM=null
		Input.isInputting=false;
		__static(Input,
		['IOS_IFRAME',function(){return this.IOS_IFRAME=(Browser.onIOS && Browser.window.top !=Browser.window.self);}
		]);
		return Input;
	})(Text)


	/**
	*<code>RenderTexture</code> 类用于创建渲染目标。
	*/
	//class laya.webgl.resource.RenderTexture extends laya.webgl.resource.BaseTexture
	var RenderTexture=(function(_super){
		function RenderTexture(width,height,format,depthStencilFormat){
			//this._lastRT=null;
			//this._lastWidth=NaN;
			//this._lastHeight=NaN;
			//this._frameBuffer=null;
			//this._depthStencilBuffer=null;
			//this._depthStencilFormat=0;
			this._mgrKey=0;
			(format===void 0)&& (format=0);
			(depthStencilFormat===void 0)&& (depthStencilFormat=0);
			RenderTexture.__super.call(this,format,false);
			this._glTextureType=0x0DE1;
			this._width=width;
			this._height=height;
			this._depthStencilFormat=depthStencilFormat;
			this._create(width,height);
		}

		__class(RenderTexture,'laya.webgl.resource.RenderTexture',_super);
		var __proto=RenderTexture.prototype;
		/**
		*@private
		*/
		__proto._create=function(width,height){
			var gl=LayaGL.instance;
			this._frameBuffer=gl.createFramebuffer();
			WebGLContext.bindTexture(gl,this._glTextureType,this._glTexture);
			var glFormat=this._getGLFormat();
			gl.texImage2D(this._glTextureType,0,glFormat,width,height,0,glFormat,0x1401,null);
			this.memorySize=width *height *4;
			gl.bindFramebuffer(0x8D40,this._frameBuffer);
			gl.framebufferTexture2D(0x8D40,0x8CE0,0x0DE1,this._glTexture,0);
			if (this._depthStencilFormat!==3){
				this._depthStencilBuffer=gl.createRenderbuffer();
				gl.bindRenderbuffer(0x8D41,this._depthStencilBuffer);
				switch (this._depthStencilFormat){
					case 0:
						gl.renderbufferStorage(0x8D41,0x81A5,width,height);
						gl.framebufferRenderbuffer(0x8D40,0x8D00,0x8D41,this._depthStencilBuffer);
						break ;
					case 1:
						gl.renderbufferStorage(0x8D41,0x8D48,width,height);
						gl.framebufferRenderbuffer(0x8D40,0x8D20,0x8D41,this._depthStencilBuffer);
						break ;
					case 2:
						gl.renderbufferStorage(0x8D41,0x84F9,width,height);
						gl.framebufferRenderbuffer(0x8D40,0x821A,0x8D41,this._depthStencilBuffer);
						break ;
					default :
						console.log("RenderTexture: unkonw depth format.");
					}
			}
			gl.bindFramebuffer(0x8D40,null);
			gl.bindRenderbuffer(0x8D41,null);
			this._setWarpMode(0x2802,this._wrapModeU);
			this._setWarpMode(0x2803,this._wrapModeV);
			this._setFilterMode(this._filterMode);
			this._setAnisotropy(this._anisoLevel);
			this._readyed=true;
			this._activeResource();
		}

		/**
		*生成mipMap。
		*/
		__proto.generateMipmap=function(){
			if (this._isPot(this.width)&& this._isPot(this.height)){
				this._mipmap=true;
				LayaGL.instance.generateMipmap(this._glTextureType);
				this._setFilterMode(this._filterMode);
				this.memorySize=this.width *this.height *4 *(1+1 / 3);
				}else {
				this._mipmap=false;
				this.memorySize=this.width *this.height *4;
			}
		}

		/**
		*开始绑定。
		*/
		__proto.start=function(){
			var gl=LayaGL.instance;
			LayaGL.instance.bindFramebuffer(0x8D40,this._frameBuffer);
			this._lastRT=RenderTexture._currentActive;
			RenderTexture._currentActive=this;
			this._readyed=true;
			gl.viewport(0,0,this._width,this._height);
			this._lastWidth=RenderState2D.width;
			this._lastHeight=RenderState2D.height;
			RenderState2D.width=this._width;
			RenderState2D.height=this._height;
			BaseShader.activeShader=null;
		}

		/**
		*结束绑定。
		*/
		__proto.end=function(){
			LayaGL.instance.bindFramebuffer(0x8D40,null);
			RenderTexture._currentActive=null;
			this._readyed=true;
		}

		/**
		*恢复上一次的RenderTarge.由于使用自己保存的，所以如果被外面打断了的话，会出错。
		*/
		__proto.restore=function(){
			var gl=LayaGL.instance;
			if (this._lastRT !=RenderTexture._currentActive){
				LayaGL.instance.bindFramebuffer(0x8D40,this._lastRT?this._lastRT._frameBuffer:null);
				RenderTexture._currentActive=this._lastRT;
			}
			this._readyed=true;
			gl.viewport(0,0,this._lastWidth,this._lastHeight);
			RenderState2D.width=this._lastWidth;
			RenderState2D.height=this._lastHeight;
			BaseShader.activeShader=null;
		}

		// gl.viewport(0,0,Laya.stage.width,Laya.stage.height);
		__proto.clear=function(r,g,b,a){
			(r===void 0)&& (r=0.0);
			(g===void 0)&& (g=0.0);
			(b===void 0)&& (b=0.0);
			(a===void 0)&& (a=1.0);
			var gl=LayaGL.instance;
			gl.clearColor(r,g,b,a);
			var clearFlag=0x00004000;
			switch (this._depthStencilFormat){
				case 0x81A5:
					clearFlag |=0x00000100;
					break ;
				case 0x8D48:
					clearFlag |=0x00000400;
					break ;
				case 0x84F9:
					clearFlag |=0x00000100;
					clearFlag |=0x00000400
					break ;
				}
			gl.clear(clearFlag);
		}

		/**
		*获得像素数据。
		*@param x X像素坐标。
		*@param y Y像素坐标。
		*@param width 宽度。
		*@param height 高度。
		*@return 像素数据。
		*/
		__proto.getData=function(x,y,width,height){
			var gl=LayaGL.instance;
			gl.bindFramebuffer(0x8D40,this._frameBuffer);
			var canRead=(gl.checkFramebufferStatus(0x8D40)===0x8CD5);
			if (!canRead){
				gl.bindFramebuffer(0x8D40,null);
				return null;
			};
			var pixels=new Uint8Array(this._width *this._height *4);
			var glFormat=this._getGLFormat();
			gl.readPixels(x,y,width,height,glFormat,0x1401,pixels);
			gl.bindFramebuffer(0x8D40,null);
			return pixels;
		}

		/**
		*@inheritDoc
		*/
		__proto.disposeResource=function(){
			if (this._frameBuffer){
				var gl=LayaGL.instance;
				gl.deleteTexture(this._glTexture);
				gl.deleteFramebuffer(this._frameBuffer);
				gl.deleteRenderbuffer(this._depthStencilBuffer);
				this._glTexture=null;
				this._frameBuffer=null;
				this._depthStencilBuffer=null;
				this.memorySize=0;
			}
		}

		/**
		*获取深度格式。
		*@return 深度格式。
		*/
		__getset(0,__proto,'depthStencilFormat',function(){
			return this._depthStencilFormat;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'defaulteTexture',function(){
			return Texture2D.grayTexture;
		});

		/**
		*获取当前激活的Rendertexture
		*/
		__getset(1,RenderTexture,'currentActive',function(){
			return RenderTexture._currentActive;
		},laya.webgl.resource.BaseTexture._$SET_currentActive);

		RenderTexture.pushRT=function(){
			RenderTexture.rtStack.push({rt:RenderTexture._currentActive,w:RenderState2D.width,h:RenderState2D.height});
		}

		RenderTexture.popRT=function(){
			var gl=LayaGL.instance;
			var top=RenderTexture.rtStack.pop();
			if (top){
				if (RenderTexture._currentActive !=top.rt){
					LayaGL.instance.bindFramebuffer(0x8D40,top.rt?top.rt._frameBuffer:null);
					RenderTexture._currentActive=top.rt;
				}
				gl.viewport(0,0,top.w,top.h);
				RenderState2D.width=top.w;
				RenderState2D.height=top.h;
			}
		}

		RenderTexture._currentActive=null
		RenderTexture.rtStack=[];
		__static(RenderTexture,
		['defuv',function(){return this.defuv=[0,0,1,0,1,1,0,1];},'flipyuv',function(){return this.flipyuv=[0,1,1,1,1,0,0,0];}
		]);
		return RenderTexture;
	})(BaseTexture)


	/**
	*<code>Texture2D</code> 类用于生成2D纹理。
	*/
	//class laya.webgl.resource.Texture2D extends laya.webgl.resource.BaseTexture
	var Texture2D=(function(_super){
		function Texture2D(format,mipmap,canRead){
			//this._canRead=false;
			//this._pixels=null;
			(format===void 0)&& (format=1);
			(mipmap===void 0)&& (mipmap=true);
			(canRead===void 0)&& (canRead=false);
			Texture2D.__super.call(this,format,mipmap);
			this._glTextureType=0x0DE1;
			this._canRead=canRead;
		}

		__class(Texture2D,'laya.webgl.resource.Texture2D',_super);
		var __proto=Texture2D.prototype;
		/**
		*通过图片源填充纹理,可为HTMLImageElement、HTMLCanvasElement、HTMLVideoElement、ImageBitmap、ImageData。
		*/
		__proto.setImageSource=function(source,premultiplyAlpha){
			(premultiplyAlpha===void 0)&& (premultiplyAlpha=false);
			var width=source.width;
			var height=source.height;
			if (width <=0 || height <=0)
				throw new Error("Texture2D:width or height must large than 0.");
			this._width=width;
			this._height=height;
			var gl=LayaGL.instance;
			gl.bindTexture(this._glTextureType,this._glTexture);
			var glFormat=this._getGLFormat();
			if (Render.isConchApp){
				gl.texImage2D(this._glTextureType,0,glFormat,glFormat,0x1401,source);
			}
			else{
				(premultiplyAlpha)&& (gl.pixelStorei(0x9241,true));
				gl.texImage2D(this._glTextureType,0,glFormat,glFormat,0x1401,source);
				(premultiplyAlpha)&& (gl.pixelStorei(0x9241,false));
			}
			if (this._mipmap && this._isPot(width)&& this._isPot(height)){
				gl.generateMipmap(this._glTextureType);
				this.memorySize=width *height *4 *(1+1 / 3);
				}else {
				this.memorySize=width *height *4;
			}
			this._setWarpMode(0x2802,this._wrapModeU);
			this._setWarpMode(0x2803,this._wrapModeV);
			this._setFilterMode(this._filterMode);
			this._setAnisotropy(this._anisoLevel);
			if (this._canRead){
				Browser.canvas.size(width,height);
				Browser.canvas.clear();
				Browser.context.drawImage(source,0,0,width,height);
				this._pixels=new Uint8Array(Browser.context.getImageData(0,0,width,width).data.buffer);
			}
			this._readyed=true;
			this._activeResource();
		}

		/**
		*通过像素填充纹理。
		*@param width 像素宽。
		*@param height 像素高。
		*@param pixels 像素。
		*/
		__proto.setPixels=function(width,height,pixels){
			if (width <=0 || height <=0)
				throw new Error("Texture2D:width or height must large than 0.");
			if (!pixels)
				throw new Error("Texture2D:pixels can't be null.");
			this._width=width;
			this._height=height;
			var gl=LayaGL.instance;
			WebGLContext.bindTexture(gl,this._glTextureType,this._glTexture);
			var glFormat=this._getGLFormat();
			gl.texImage2D(this._glTextureType,0,glFormat,width,height,0,glFormat,0x1401,pixels);
			if (this._mipmap && this._isPot(width)&& this._isPot(height)){
				gl.generateMipmap(this._glTextureType);
				this.memorySize=width *height *4 *(1+1 / 3);
				}else {
				this.memorySize=width *height *4;
			}
			this._setWarpMode(0x2802,this._wrapModeU);
			this._setWarpMode(0x2803,this._wrapModeV);
			this._setFilterMode(this._filterMode);
			this._setAnisotropy(this._anisoLevel);
			if (this._canRead)
				this._pixels=pixels;
			this._readyed=true;
			this._activeResource();
		}

		/**
		*@inheritDoc
		*/
		__proto.onAsynLoaded=function(data,params){
			_super.prototype.onAsynLoaded.call(this,data,params);
			this.setImageSource(data);
		}

		/**
		*@inheritDoc
		*/
		__proto.recoverResource=function(){}
		/**
		*返回图片像素。
		*@return 图片像素。
		*/
		__proto.getPixels=function(){
			if (this._canRead)
				return this._pixels;
			else
			throw new Error("Texture2D: must set texture canRead is true.");
		}

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'defaulteTexture',function(){
			return laya.webgl.resource.Texture2D.grayTexture;
		});

		Texture2D.__init__=function(){
			var pixels=new Uint8Array(3);
			pixels[0]=128;
			pixels[1]=128;
			pixels[2]=128;
			Texture2D.grayTexture.setPixels(1,1,pixels);
		}

		Texture2D.load=function(url){
			return Laya.loader.create(url,null,null,Texture2D);
		}

		__static(Texture2D,
		['grayTexture',function(){return this.grayTexture=new Texture2D(0,false,false);}
		]);
		return Texture2D;
	})(BaseTexture)


	//class laya.webgl.shader.d2.Shader2X extends laya.webgl.shader.Shader
	var Shader2X=(function(_super){
		function Shader2X(vs,ps,saveName,nameMap){
			this._params2dQuick2=null;
			Shader2X.__super.call(this,vs,ps,saveName,nameMap);
		}

		__class(Shader2X,'laya.webgl.shader.d2.Shader2X',_super);
		var __proto=Shader2X.prototype;
		__proto.disposeResource=function(){
			_super.prototype.disposeResource.call(this);
			this._params2dQuick2=null;
		}

		__proto.upload2dQuick2=function(shaderValue){
			this.upload(shaderValue,this._params2dQuick2 || this._make2dQuick2());
		}

		//去掉size的所有的uniform
		__proto._make2dQuick2=function(){
			if (!this._params2dQuick2){
				this._params2dQuick2=[];
				var params=this._params,one;
				for (var i=0,n=params.length;i < n;i++){
					one=params[i];
					if (one.name!=="size")this._params2dQuick2.push(one);
				}
			}
			return this._params2dQuick2;
		}

		Shader2X.create=function(vs,ps,saveName,nameMap){
			return new Shader2X(vs,ps,saveName,nameMap);
		}

		return Shader2X;
	})(Shader)


	//class laya.webgl.utils.IndexBuffer2D extends laya.webgl.utils.Buffer2D
	var IndexBuffer2D=(function(_super){
		function IndexBuffer2D(bufferUsage){
			this._uint16Array=null;
			(bufferUsage===void 0)&& (bufferUsage=0x88E4);
			IndexBuffer2D.__super.call(this);
			this._bufferUsage=bufferUsage;
			this._bufferType=0x8893;
			this._buffer=new ArrayBuffer(8);
		}

		__class(IndexBuffer2D,'laya.webgl.utils.IndexBuffer2D',_super);
		var __proto=IndexBuffer2D.prototype;
		__proto._checkArrayUse=function(){
			this._uint16Array && (this._uint16Array=new Uint16Array(this._buffer));
		}

		__proto.getUint16Array=function(){
			return this._uint16Array || (this._uint16Array=new Uint16Array(this._buffer));
		}

		__proto.destory=function(){
			this._uint16Array=null;
			this._buffer=null;
		}

		IndexBuffer2D.QuadrangleIB=null
		IndexBuffer2D.create=function(bufferUsage){
			(bufferUsage===void 0)&& (bufferUsage=0x88E4);
			return new IndexBuffer2D(bufferUsage);
		}

		return IndexBuffer2D;
	})(Buffer2D)


	//class laya.webgl.utils.VertexBuffer2D extends laya.webgl.utils.Buffer2D
	var VertexBuffer2D=(function(_super){
		function VertexBuffer2D(vertexStride,bufferUsage){
			this._floatArray32=null;
			this._uint32Array=null;
			this._vertexStride=0;
			VertexBuffer2D.__super.call(this);
			this._vertexStride=vertexStride;
			this._bufferUsage=bufferUsage;
			this._bufferType=0x8892;
			this._buffer=new ArrayBuffer(8);
			this._floatArray32=new Float32Array(this._buffer);
			this._uint32Array=new Uint32Array(this._buffer);
		}

		__class(VertexBuffer2D,'laya.webgl.utils.VertexBuffer2D',_super);
		var __proto=VertexBuffer2D.prototype;
		__proto.getFloat32Array=function(){
			return this._floatArray32;
		}

		/**
		*在当前位置插入float数组。
		*@param data
		*@param pos
		*/
		__proto.appendArray=function(data){
			var oldoff=this._byteLength >> 2;
			this.setByteLength(this._byteLength+data.length *4);
			var vbdata=this.getFloat32Array();
			vbdata.set(data,oldoff);
			this._upload=true;
		}

		__proto._checkArrayUse=function(){
			this._floatArray32 && (this._floatArray32=new Float32Array(this._buffer));
			this._uint32Array && (this._uint32Array=new Uint32Array(this._buffer));
		}

		__proto.disposeResource=function(){
			_super.prototype.disposeResource.call(this);
			var enableAtributes=Buffer._bindedAtributeBuffer;
			for (var i=0;i < 10;i++){
				WebGL.mainContext.disableVertexAttribArray(i);
				enableAtributes[i]=null;
			}
		}

		__proto.destroy=function(){
			laya.resource.Resource.prototype.destroy.call(this);
			this._byteLength=0;
			this._upload=true;
			this._buffer=null;
			this._floatArray32=null;
		}

		__getset(0,__proto,'vertexStride',function(){
			return this._vertexStride;
		});

		VertexBuffer2D.create=function(vertexStride,bufferUsage){
			(bufferUsage===void 0)&& (bufferUsage=0x88E8);
			return new VertexBuffer2D(vertexStride,bufferUsage);
		}

		return VertexBuffer2D;
	})(Buffer2D)


	//class laya.d3.resource.DataTexture2D extends laya.webgl.resource.BaseTexture
	var DataTexture2D=(function(_super){
		function DataTexture2D(){
			this.simLodInfo=null;
			this._buffer=null;
			this._mipmaps=null;
			this._recreateLock=false;
			this._needReleaseAgain=false;
			DataTexture2D.__super.call(this);
			this._glTextureType=0x0DE1;
		}

		__class(DataTexture2D,'laya.d3.resource.DataTexture2D',_super);
		var __proto=DataTexture2D.prototype;
		__proto.genDebugMipmaps=function(){
			var ret=[];
			ret.push(new Uint8Array((new Uint32Array(512 *256)).fill(0xff0000ff).buffer));
			ret.push(new Uint8Array((new Uint32Array(256 *128)).fill(0xff0080ff).buffer));
			ret.push(new Uint8Array((new Uint32Array(128 *64)).fill(0xff00ffff).buffer));
			ret.push(new Uint8Array((new Uint32Array(64 *32)).fill(0xff00ff00).buffer));
			ret.push(new Uint8Array((new Uint32Array(32 *16)).fill(0xff804000).buffer));
			ret.push(new Uint8Array((new Uint32Array(16 *8)).fill(0xffff0000).buffer));
			ret.push(new Uint8Array((new Uint32Array(8 *4)).fill(0xffff0080).buffer));
			ret.push(new Uint8Array((new Uint32Array(4 *2)).fill(0x0).buffer));
			ret.push(new Uint8Array((new Uint32Array(2 *1)).fill(0xff808080).buffer));
			ret.push(new Uint8Array((new Uint32Array(1 *1)).fill(0xffffffff).buffer));
			return ret;
		}

		/**
		*@private
		*/
		__proto._onTextureLoaded=function(buff){}
		/**
		*@private
		*/
		__proto._createWebGlTexture=function(){
			if (!this._buffer && !this._mipmaps)
				throw "create GLTextur err:no data";
			var gl=LayaGL.instance;
			gl.getExtension("EXT_shader_texture_lod");
			var w=this._width;
			var h=this._height;
			WebGLContext.bindTexture(gl,this._glTextureType,this._glTexture);
			if (this._mipmaps){
				if (laya.d3.resource.DataTexture2D.lodasatlas){
					var infoi=0;
					gl.texImage2D(this._glTextureType,0,0x1908,this._width,this._height,0,0x1908,0x1401,null);
					for (var i=0;i < this._mipmaps.length;i++){
						if (this._mipmaps[i].byteLength !=cw *ch *4){
							throw "mipmap size error  level:"+i;
						}
						gl.texSubImage2D(this._glTextureType,0,DataTexture2D.simLodRect[infoi++],DataTexture2D.simLodRect[infoi++],DataTexture2D.simLodRect[infoi++],DataTexture2D.simLodRect[infoi++],0x1908,0x1401,new Uint8Array(this._mipmaps[i]));
					}
					this.minFifter=0x2601;
					this.magFifter=0x2601;
					}else {
					var cw=this._width;
					var ch=this._height;
					infoi=0;
					gl.texImage2D(this._glTextureType,0,0x1908,this._width,this._height,0,0x1908,0x1401,null);
					for (i=0;i < this._mipmaps.length;i++){
						if (this._mipmaps[i].byteLength !=cw *ch *4){
							throw "mipmap size error  level:"+i;
						}
						gl.texImage2D(this._glTextureType,i,0x1908,cw,ch,0,0x1908,0x1401,new Uint8Array(this._mipmaps[i]));
						cw /=2;
						ch /=2;
						if (cw < 1)cw=1;
						if (ch < 1)ch=1;
						this.minFifter=0x2703;
						this.magFifter=0x2601;
					}
				}
				this.mipmap=false;
				}else {
				gl.texImage2D(this._glTextureType,0,0x1908,w,h,0,0x1908,0x1401,new Uint8Array(this._buffer));
			};
			var minFifter=this._minFifter;
			var magFifter=this._magFifter;
			var repeat=this._repeat ? 0x2901 :0x812F;
			var isPot=Arith.isPOT(w,h);
			if (isPot){
				if (this._mipmap || this._mipmaps)
					(minFifter!==-1)|| (minFifter=0x2703);
				else
				(minFifter!==-1)|| (minFifter=0x2601);
				(magFifter!==-1)|| (magFifter=0x2601);
				gl.texParameteri(this._glTextureType,0x2801,minFifter);
				gl.texParameteri(this._glTextureType,0x2800,magFifter);
				gl.texParameteri(this._glTextureType,0x2802,repeat);
				if (this._mipmaps)
					gl.texParameteri(this._glTextureType,0x2803,0x812F);
				else
				gl.texParameteri(this._glTextureType,0x2803,repeat);
				this._mipmap && gl.generateMipmap(this._glTextureType);
				}else {
				throw "data texture must be POT";
			}
			if (this.src && this.src.length > 0)
				this._buffer=null;
			if (isPot)
				this.memorySize=w *h *4 *(1+1 / 3);
			else
			this.memorySize=w *h *4;
			this._recreateLock=false;
		}

		/**
		*重新创建资源，如果异步创建中被强制释放再创建，则需等待释放完成后再重新加载创建。
		*/
		__proto.recreateResource=function(){
			if (!this._buffer)
				return;
			this._needReleaseAgain=false;
			if (!this._buffer && !this._mipmaps){
				this._recreateLock=true;
				var _this=this;
				}else {
				if (this._recreateLock){
					return;
				}
				this._createWebGlTexture();
			}
		}

		/**
		*@private
		*/
		__proto.onAsynLoaded=function(data,params){
			var imgdata;
			if (params){
				imgdata=params[0].call(this,data);
			}
			if (imgdata){
				this._width=imgdata.width;
				this._height=imgdata.height;
				this._buffer=imgdata.data;
			}
		}

		/**
		*返回图片像素。
		*@return 图片像素。
		*/
		__proto.getPixels=function(){
			return new Uint8Array(this._buffer);
		}

		/**
		*销毁资源。
		*/
		__proto.disposeResource=function(){
			if (this._recreateLock){
				this._needReleaseAgain=true;
			}
			if (this._glTexture){
				LayaGL.instance.deleteTexture(this._glTexture);
				this._glTexture=null;
				this._buffer=null;
				this.memorySize=0;
			}
		}

		DataTexture2D.create=function(data,w,h,magfilter,minfilter,mipmap){
			(magfilter===void 0)&& (magfilter=0x2601);
			(minfilter===void 0)&& (minfilter=0x2601);
			(mipmap===void 0)&& (mipmap=true);
			if (!data || data.byteLength < (w *h *4))
				throw 'DataTexture2D create error';
			var ret=new DataTexture2D();
			ret._buffer=data;
			ret._width=w;
			ret._height=h;
			ret._mipmap=mipmap;
			ret._magFifter=magfilter;
			ret._minFifter=minfilter;
			if (ret._conchTexture){
				alert('怎么给runtime传递datatexture数据');
			}else
			ret.activeResource();
			return ret;
		}

		DataTexture2D.load=function(url,w,h,magfilter,minfilter){
			(w===void 0)&& (w=0);
			(h===void 0)&& (h=0);
			(magfilter===void 0)&& (magfilter=0x2601);
			(minfilter===void 0)&& (minfilter=0x2601);
			var extension=Utils.getFileExtension(url);
			if (extension==='mipmaps'){
				var ret=Laya.loader.create(url,null,null,DataTexture2D,[function(data){
					this._mipmaps=[];
					var szinfo=new Uint32Array(data);
					this._width=szinfo[0];
					var validw=512;
					if (laya.d3.resource.DataTexture2D.lodasatlas){
						this._width *=2;
						validw=1024;
					}
					if (this._width !=validw){
						console.error("现在只支持512x256的环境贴图。当前的是"+szinfo[0]);
						throw "现在只支持512x256的环境贴图。当前的是"+szinfo[0];
					}
					this._height=szinfo[1];
					var curw=laya.d3.resource.DataTexture2D.lodasatlas ? this._width / 2 :this._width;
					var curh=this._height;
					var cursz=8;
					while (true){
						var curbufsz=curw *curh *4;
						if (cursz+curbufsz > data.byteLength){
							throw "load mipmaps data size error ";
						};
						var tbuf=new Uint8Array(data,cursz,curbufsz);
						this._mipmaps.push(tbuf);
						cursz+=curbufsz;
						if (curw==1 && curh==1){
							break ;
						}
						curw /=2;
						curh /=2;
						if (curw < 1)curw=1;
						if (curh < 1)curh=1;
					}
					return null;
				}]);
				if (laya.d3.resource.DataTexture2D.lodasatlas){
					ret.simLodInfo=new Float32Array(40);
					for (var i=0;i < ret.simLodInfo.length;){
						ret.simLodInfo[i]=(DataTexture2D.simLodRect[i]+0.5)/ 1024;
						i++;
						ret.simLodInfo[i]=(DataTexture2D.simLodRect[i]+0.5)/ 256;
						i++;
						ret.simLodInfo[i]=Math.max(DataTexture2D.simLodRect[i]-1,0.1)/ 1024;
						i++;
						ret.simLodInfo[i]=Math.max(DataTexture2D.simLodRect[i]-1.5,0.1)/ 256;
						i++;
					}
				}
				return ret;
				}else if (typeof(w)=='number'){
				return Laya.loader.create(url,null,null,DataTexture2D,[function(data){
					this._width=w;
					this._height=h;
					this._buffer=data;
					return null;
				}]);
				}else if (typeof(w)=='function'){
				return Laya.loader.create(url,null,null,DataTexture2D,[w]);
				}else {
				throw new Error("unknown params.");
			}
		}

		DataTexture2D.lodasatlas=false;
		__static(DataTexture2D,
		['simLodRect',function(){return this.simLodRect=new Uint32Array([
			0,0,512,256,512,0,256,128,512+256,0,128,64,512+256+128,0,64,32,512+256+128+64,0,32,16,512+256+128+64+32,0,16,8,512+256+128+64+32+16,0,8,4,512+256+128+64+32+16+8,0,4,2,512+256+128+64+32+16+8+4,0,2,1,512+256+128+64+32+16+8+4+2,0,1,1]);}
		]);
		return DataTexture2D;
	})(BaseTexture)


	/**
	*<code>TextureCube</code> 类用于生成立方体纹理。
	*/
	//class laya.d3.resource.TextureCube extends laya.webgl.resource.BaseTexture
	var TextureCube=(function(_super){
		function TextureCube(format,mipmap){
			//this._premultiplyAlpha=0;
			(format===void 0)&& (format=0);
			(mipmap===void 0)&& (mipmap=false);
			TextureCube.__super.call(this,format,mipmap);
			this._glTextureType=0x8513;
		}

		__class(TextureCube,'laya.d3.resource.TextureCube',_super);
		var __proto=TextureCube.prototype;
		/**
		*通过六张图片源填充纹理。
		*@param 图片源数组。
		*/
		__proto.setSixSideImageSources=function(source,premultiplyAlpha){
			(premultiplyAlpha===void 0)&& (premultiplyAlpha=false);
			var width=0;
			var height=0;
			for (var i=0;i < 6;i++){
				var nextWidth=source[i].width;
				var nextHeight=source[i].height;
				if (i > 0){
					if (width!==nextWidth)
						throw "TextureCube: each side image's width and height must same.";
				}
				width=nextWidth;
				height=nextHeight;
				if (width!==height)
					throw "TextureCube: each side image's width and height must same.";
			}
			this._width=width;
			this._height=height;
			var gl=LayaGL.instance;
			WebGLContext.bindTexture(gl,this._glTextureType,this._glTexture);
			var glFormat=this._getGLFormat();
			(premultiplyAlpha)&& (gl.pixelStorei(0x9241,true));
			gl.texImage2D(0x8519,0,glFormat,glFormat,0x1401,source[0]);
			gl.texImage2D(0x851A,0,glFormat,glFormat,0x1401,source[1]);
			gl.texImage2D(0x8515,0,glFormat,glFormat,0x1401,source[2]);
			gl.texImage2D(0x8516,0,glFormat,glFormat,0x1401,source[3]);
			gl.texImage2D(0x8517,0,glFormat,glFormat,0x1401,source[4]);
			gl.texImage2D(0x8518,0,glFormat,glFormat,0x1401,source[5]);
			(premultiplyAlpha)&& (gl.pixelStorei(0x9241,false));
			if (this._mipmap && this._isPot(width)&& this._isPot(height)){
				gl.generateMipmap(this._glTextureType);
				this.memorySize=width *height *4 *(1+1 / 3)*6;
				}else {
				this.memorySize=width *height *4 *6;
			}
			this._setWarpMode(0x2802,this._wrapModeU);
			this._setWarpMode(0x2803,this._wrapModeV);
			this._setFilterMode(this._filterMode);
			this._readyed=true;
			this._activeResource();
		}

		/**
		*通过六张图片源填充纹理。
		*@param 图片源数组。
		*/
		__proto.setSixSidePixels=function(width,height,pixels){
			if (width <=0 || height <=0)
				throw new Error("TextureCube:width or height must large than 0.");
			if (!pixels)
				throw new Error("TextureCube:pixels can't be null.");
			this._width=width;
			this._height=height;
			var gl=LayaGL.instance;
			WebGLContext.bindTexture(gl,this._glTextureType,this._glTexture);
			var glFormat=this._getGLFormat();
			gl.texImage2D(0x8519,0,glFormat,width,height,0,glFormat,0x1401,pixels[0]);
			gl.texImage2D(0x851A,0,glFormat,width,height,0,glFormat,0x1401,pixels[1]);
			gl.texImage2D(0x8515,0,glFormat,width,height,0,glFormat,0x1401,pixels[2]);
			gl.texImage2D(0x8516,0,glFormat,width,height,0,glFormat,0x1401,pixels[3]);
			gl.texImage2D(0x8517,0,glFormat,width,height,0,glFormat,0x1401,pixels[4]);
			gl.texImage2D(0x8518,0,glFormat,width,height,0,glFormat,0x1401,pixels[5]);
			if (this._mipmap && this._isPot(width)&& this._isPot(height)){
				gl.generateMipmap(this._glTextureType);
				this.memorySize=width *height *4 *(1+1 / 3)*6;
				}else {
				this.memorySize=width *height *4 *6;
			}
			this._setWarpMode(0x2802,this._wrapModeU);
			this._setWarpMode(0x2803,this._wrapModeV);
			this._setFilterMode(this._filterMode);
			this._readyed=true;
			this._activeResource();
		}

		/**
		*@inheritDoc
		*/
		__proto.onAsynLoaded=function(data,params){
			_super.prototype.onAsynLoaded.call(this,data,params);
			this.setSixSideImageSources(data);
		}

		/**
		*@inheritDoc
		*/
		__proto.recoverResource=function(){}
		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'defaulteTexture',function(){
			return TextureCube.grayTexture;
		});

		TextureCube.__init__=function(){
			var pixels=new Uint8Array(3);
			pixels[0]=128;
			pixels[1]=128;
			pixels[2]=128;
			TextureCube.grayTexture.setSixSidePixels(1,1,[pixels,pixels,pixels,pixels,pixels,pixels]);
		}

		TextureCube.load=function(url){
			return Laya.loader.create(url,null,null,TextureCube);
		}

		__static(TextureCube,
		['grayTexture',function(){return this.grayTexture=new TextureCube(0,false);}
		]);
		return TextureCube;
	})(BaseTexture)


	/**
	*<code>BaseCamera</code> 类用于创建摄像机的父类。
	*/
	//class laya.d3.core.BaseCamera extends laya.d3.core.Sprite3D
	var BaseCamera=(function(_super){
		function BaseCamera(nearPlane,farPlane){
			//this._tempVector3=null;
			//this._renderingOrder=0;
			//this._nearPlane=NaN;
			//this._farPlane=NaN;
			//this._fieldOfView=NaN;
			//this._orthographicVerticalSize=NaN;
			//this._sky=null;
			//this._orthographic=false;
			//this._renderTarget=null;
			//this._useUserProjectionMatrix=false;
			//this._shaderValues=null;
			//this._canvasWidth=NaN;
			//this._canvasHeight=NaN;
			//this.clearFlag=0;
			//this.clearColor=null;
			//this.cullingMask=0;
			//this.useOcclusionCulling=false;
			BaseCamera.__super.call(this);
			(nearPlane===void 0)&& (nearPlane=0.3);
			(farPlane===void 0)&& (farPlane=1000);
			this._shaderValues=new ShaderDatas(null,14);
			this._tempVector3=new Vector3();
			this._fieldOfView=60;
			this._useUserProjectionMatrix=false;
			this._orthographic=false;
			this._orthographicVerticalSize=10;
			this.renderingOrder=0;
			this._nearPlane=nearPlane;
			this._farPlane=farPlane;
			this.cullingMask=2147483647;
			this.clearFlag=0;
			this.useOcclusionCulling=true;
			this._calculateProjectionMatrix();
			Laya.stage.on("resize",this,this._onScreenSizeChanged);
		}

		__class(BaseCamera,'laya.d3.core.BaseCamera',_super);
		var __proto=BaseCamera.prototype;
		/**
		*通过RenderingOrder属性对摄像机机型排序。
		*/
		__proto._sortCamerasByRenderingOrder=function(){
			if (this.displayedInStage){
				var cameraPool=this.scene._cameraPool;
				var n=cameraPool.length-1;
				for (var i=0;i < n;i++){
					if (cameraPool[i].renderingOrder > cameraPool[n].renderingOrder){
						var tempCamera=cameraPool[i];
						cameraPool[i]=cameraPool[n];
						cameraPool[n]=tempCamera;
					}
				}
			}
		}

		/**
		*@private
		*/
		__proto._calculateProjectionMatrix=function(){}
		/**
		*@private
		*/
		__proto._onScreenSizeChanged=function(){
			this._calculateProjectionMatrix();
		}

		/**
		*@private
		*/
		__proto._prepareCameraToRender=function(){
			Layer._currentCameraCullingMask=this.cullingMask;
			var cameraSV=this._shaderValues;
			cameraSV.setVector(0,this.transform.position);
			cameraSV.setVector(5,this.transform.forward);
			cameraSV.setVector(6,this.transform.up);
		}

		/**
		*@private
		*/
		__proto._prepareCameraViewProject=function(vieMat,proMat,vieProNoTraSca){
			var cameraSV=this._shaderValues;
			cameraSV.setMatrix4x4(1,vieMat);
			cameraSV.setMatrix4x4(2,proMat);
			this.transform.worldMatrix.cloneTo(BaseCamera._tempMatrix4x40);
			BaseCamera._tempMatrix4x40.transpose();
			Matrix4x4.multiply(proMat,BaseCamera._tempMatrix4x40,vieProNoTraSca);
			cameraSV.setMatrix4x4(4,vieProNoTraSca);
		}

		/**
		*@private
		*/
		__proto._renderCamera=function(gl,state,scene){}
		/**
		*增加可视图层。
		*@param layer 图层。
		*/
		__proto.addLayer=function(layer){
			this.cullingMask=this.cullingMask | layer.mask;
		}

		/**
		*移除可视图层。
		*@param layer 图层。
		*/
		__proto.removeLayer=function(layer){
			this.cullingMask=this.cullingMask & ~layer.mask;
		}

		/**
		*增加所有图层。
		*/
		__proto.addAllLayers=function(){
			this.cullingMask=2147483647;
		}

		/**
		*移除所有图层。
		*/
		__proto.removeAllLayers=function(){
			this.cullingMask=0;
		}

		__proto.resetProjectionMatrix=function(){
			this._useUserProjectionMatrix=false;
			this._calculateProjectionMatrix();
		}

		//}// BoundingFrustumWorldSpace
		__proto._addSelfRenderObjects=function(){
			var cameraPool=this.scene._cameraPool;
			var cmaeraCount=cameraPool.length;
			if (cmaeraCount > 0){
				for (var i=cmaeraCount-1;i >=0;i--){
					if (this.renderingOrder <=cameraPool[i].renderingOrder){
						cameraPool.splice(i+1,0,this);
						break ;
					}
				}
				}else {
				cameraPool.push(this);
			}
		}

		__proto._clearSelfRenderObjects=function(){
			var cameraPool=this.scene._cameraPool;
			cameraPool.splice(cameraPool.indexOf(this),1);
		}

		/**
		*@inheritDoc
		*/
		__proto._parseCustomProps=function(rootNode,innerResouMap,customProps){
			var color=customProps.clearColor;
			this.clearColor=new Vector4(color[0],color[1],color[2],color[3]);
			var skyBox=customProps.skyBox;
			if (skyBox){
				this.sky=new SkyBox();
				this.sky.sharedMaterial=Loader.getRes(innerResouMap[skyBox.sharedMaterial.path]);
			}
		}

		/**
		*@inheritDoc
		*/
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			(this._sky)&& (this._sky.destroy());
			this.renderTarget=null;
			Laya.stage.off("resize",this,this._onScreenSizeChanged);
			_super.prototype.destroy.call(this,destroyChild);
		}

		/**设置天空。*/
		/**获取天空。*/
		__getset(0,__proto,'sky',function(){
			return this._sky;
			},function(value){
			this._sky=value;
			value._ownerCamera=this;
		});

		/**
		*设置远裁面。
		*@param value 远裁面。
		*/
		/**
		*获取远裁面。
		*@return 远裁面。
		*/
		__getset(0,__proto,'farPlane',function(){
			return this._farPlane;
			},function(vaule){
			this._farPlane=vaule;
			this._calculateProjectionMatrix();
		});

		/**
		*设置渲染场景的渲染目标。
		*@param value 渲染场景的渲染目标。
		*/
		/**
		*获取渲染场景的渲染目标。
		*@return 渲染场景的渲染目标。
		*/
		__getset(0,__proto,'renderTarget',function(){
			return this._renderTarget;
			},function(value){
			this._renderTarget=value;
		});

		/**
		*设置是否正交投影矩阵。
		*@param 是否正交投影矩阵。
		*/
		/**
		*获取是否正交投影矩阵。
		*@return 是否正交投影矩阵。
		*/
		__getset(0,__proto,'orthographic',function(){
			return this._orthographic;
			},function(vaule){
			this._orthographic=vaule;
			this._calculateProjectionMatrix();
		});

		/**
		*设置视野。
		*@param value 视野。
		*/
		/**
		*获取视野。
		*@return 视野。
		*/
		__getset(0,__proto,'fieldOfView',function(){
			return this._fieldOfView;
			},function(value){
			this._fieldOfView=value;
			this._calculateProjectionMatrix();
		});

		/**
		*设置近裁面。
		*@param value 近裁面。
		*/
		/**
		*获取近裁面。
		*@return 近裁面。
		*/
		__getset(0,__proto,'nearPlane',function(){
			return this._nearPlane;
			},function(value){
			this._nearPlane=value;
			this._calculateProjectionMatrix();
		});

		/**
		*设置正交投影垂直矩阵尺寸。
		*@param 正交投影垂直矩阵尺寸。
		*/
		/**
		*获取正交投影垂直矩阵尺寸。
		*@return 正交投影垂直矩阵尺寸。
		*/
		__getset(0,__proto,'orthographicVerticalSize',function(){
			return this._orthographicVerticalSize;
			},function(vaule){
			this._orthographicVerticalSize=vaule;
			this._calculateProjectionMatrix();
		});

		__getset(0,__proto,'renderingOrder',function(){
			return this._renderingOrder;
			},function(value){
			this._renderingOrder=value;
			this._sortCamerasByRenderingOrder();
		});

		BaseCamera.CAMERAPOS=0;
		BaseCamera.VIEWMATRIX=1;
		BaseCamera.PROJECTMATRIX=2;
		BaseCamera.VPMATRIX=3;
		BaseCamera.VPMATRIX_NO_TRANSLATE=4;
		BaseCamera.CAMERADIRECTION=5;
		BaseCamera.CAMERAUP=6;
		BaseCamera.ENVIRONMENTDIFFUSE=7;
		BaseCamera.ENVIRONMENTSPECULAR=8;
		BaseCamera.SIMLODINFO=9;
		BaseCamera.DIFFUSEIRRADMATR=10;
		BaseCamera.DIFFUSEIRRADMATG=11;
		BaseCamera.DIFFUSEIRRADMATB=12;
		BaseCamera.HDREXPOSURE=13;
		BaseCamera.RENDERINGTYPE_DEFERREDLIGHTING="DEFERREDLIGHTING";
		BaseCamera.RENDERINGTYPE_FORWARDRENDERING="FORWARDRENDERING";
		BaseCamera.CLEARFLAG_SOLIDCOLOR=0;
		BaseCamera.CLEARFLAG_SKY=1;
		BaseCamera.CLEARFLAG_DEPTHONLY=2;
		BaseCamera.CLEARFLAG_NONE=3;
		__static(BaseCamera,
		['_tempMatrix4x40',function(){return this._tempMatrix4x40=new Matrix4x4();},'_invertYScaleMatrix',function(){return this._invertYScaleMatrix=new Matrix4x4(1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1);},'_invertYProjectionMatrix',function(){return this._invertYProjectionMatrix=new Matrix4x4();},'_invertYProjectionViewMatrix',function(){return this._invertYProjectionViewMatrix=new Matrix4x4();}
		]);
		return BaseCamera;
	})(Sprite3D)


	/**
	*<code>LightSprite</code> 类用于创建灯光的父类。
	*/
	//class laya.d3.core.light.LightSprite extends laya.d3.core.Sprite3D
	var LightSprite=(function(_super){
		function LightSprite(){
			this._intensityColor=null;
			this._intensity=NaN;
			this._shadow=false;
			this._shadowFarPlane=0;
			this._shadowMapSize=0;
			this._shadowMapCount=0;
			this._shadowMapPCFType=0;
			this._parallelSplitShadowMap=null;
			this._lightmapBakedType=0;
			this.color=null;
			LightSprite.__super.call(this);
			this._intensity=1.0;
			this._intensityColor=new Vector3();
			this.color=new Vector3(1.0,1.0,1.0);
			this._shadow=false;
			this._shadowFarPlane=8;
			this._shadowMapSize=512;
			this._shadowMapCount=1;
			this._shadowMapPCFType=0;
			this._lightmapBakedType=LightSprite.LIGHTMAPBAKEDTYPE_REALTIME;
		}

		__class(LightSprite,'laya.d3.core.light.LightSprite',_super);
		var __proto=LightSprite.prototype;
		/**
		*@inheritDoc
		*/
		__proto._parseCustomProps=function(rootNode,innerResouMap,customProps){
			var colorData=customProps.color;
			this.color.fromArray(colorData);
		}

		/**
		*@inheritDoc
		*/
		__proto._addSelfRenderObjects=function(){
			(this.lightmapBakedType!==LightSprite.LIGHTMAPBAKEDTYPE_BAKED)&& (this._scene._addLight(this));
		}

		/**
		*@inheritDoc
		*/
		__proto._clearSelfRenderObjects=function(){
			(this.lightmapBakedType!==LightSprite.LIGHTMAPBAKEDTYPE_BAKED)&& (this._scene._removeLight(this));
		}

		/**
		*更新灯光相关渲染状态参数。
		*@param state 渲染状态参数。
		*/
		__proto._prepareToScene=function(state){
			return false;
		}

		/**
		*设置灯光烘培类型。
		*/
		/**
		*获取灯光烘培类型。
		*/
		__getset(0,__proto,'lightmapBakedType',function(){
			return this._lightmapBakedType;
			},function(value){
			if (this._lightmapBakedType!==value){
				this._lightmapBakedType=value;
				if (this._activeInHierarchy){
					if (value!==LightSprite.LIGHTMAPBAKEDTYPE_BAKED)
						this._scene._addLight(this);
					else
					this._scene._removeLight(this);
				}
			}
		});

		/**
		*设置阴影PCF类型。
		*@param value PCF类型。
		*/
		/**
		*获取阴影PCF类型。
		*@return PCF类型。
		*/
		__getset(0,__proto,'shadowPCFType',function(){
			return this._shadowMapPCFType;
			},function(value){
			this._shadowMapPCFType=value;
			(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.setPCFType(value));
		});

		/**
		*设置灯光强度。
		*@param value 灯光强度
		*/
		/**
		*获取灯光强度。
		*@return 灯光强度
		*/
		__getset(0,__proto,'intensity',function(){
			return this._intensity;
			},function(value){
			this._intensity=value;
		});

		/**
		*设置是否产生阴影。
		*@param value 是否产生阴影。
		*/
		/**
		*获取是否产生阴影。
		*@return 是否产生阴影。
		*/
		__getset(0,__proto,'shadow',function(){
			return this._shadow;
			},function(value){
			throw new Error("LightSprite: must override it.");
		});

		/**
		*设置阴影最远范围。
		*@param value 阴影最远范围。
		*/
		/**
		*获取阴影最远范围。
		*@return 阴影最远范围。
		*/
		__getset(0,__proto,'shadowDistance',function(){
			return this._shadowFarPlane;
			},function(value){
			this._shadowFarPlane=value;
			(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.setFarDistance(value));
		});

		/**
		*设置阴影分段数。
		*@param value 阴影分段数。
		*/
		/**
		*获取阴影分段数。
		*@return 阴影分段数。
		*/
		__getset(0,__proto,'shadowPSSMCount',function(){
			return this._shadowMapCount;
			},function(value){
			this._shadowMapCount=value;
			(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.PSSMNum=value);
		});

		/**
		*设置阴影贴图尺寸。
		*@param value 阴影贴图尺寸。
		*/
		/**
		*获取阴影贴图尺寸。
		*@return 阴影贴图尺寸。
		*/
		__getset(0,__proto,'shadowResolution',function(){
			return this._shadowMapSize;
			},function(value){
			this._shadowMapSize=value;
			(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.setShadowMapTextureSize(value));
		});

		/**
		*设置灯光的漫反射颜色。
		*@param value 灯光的漫反射颜色。
		*/
		/**
		*获取灯光的漫反射颜色。
		*@return 灯光的漫反射颜色。
		*/
		__getset(0,__proto,'diffuseColor',function(){
			console.log("LightSprite: discard property,please use color property instead.");
			return this.color;
			},function(value){
			console.log("LightSprite: discard property,please use color property instead.");
			this.color=value;
		});

		LightSprite.LIGHTMAPBAKEDTYPE_REALTIME=0;
		LightSprite.LIGHTMAPBAKEDTYPE_MIXED=1;
		LightSprite.LIGHTMAPBAKEDTYPE_BAKED=2;
		return LightSprite;
	})(Sprite3D)


	/**
	*<code>RenderableSprite3D</code> 类用于可渲染3D精灵的父类，抽象类不允许实例。
	*/
	//class laya.d3.core.RenderableSprite3D extends laya.d3.core.Sprite3D
	var RenderableSprite3D=(function(_super){
		function RenderableSprite3D(name){
			this._render=null;
			RenderableSprite3D.__super.call(this,name)
		}

		__class(RenderableSprite3D,'laya.d3.core.RenderableSprite3D',_super);
		var __proto=RenderableSprite3D.prototype;
		/**@private */
		__proto._clearSelfRenderObjects=function(){
			this._scene.removeRenderObject(this._render);
		}

		/**@private */
		__proto._addSelfRenderObjects=function(){
			this._scene.addRenderObject(this._render);
		}

		/**
		*@private
		*/
		__proto._addToInitStaticBatchManager=function(){}
		/**
		*@inheritDoc
		*/
		__proto._setBelongScene=function(scene){
			_super.prototype._setBelongScene.call(this,scene);
			this._render._setBelongScene(scene);
		}

		/**
		*@inheritDoc
		*/
		__proto._setUnBelongScene=function(){
			this._render._defineDatas.remove(laya.d3.core.RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
			_super.prototype._setUnBelongScene.call(this);
		}

		/**
		*@inheritDoc
		*/
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			_super.prototype.destroy.call(this,destroyChild);
			this._render._destroy();
			this._render=null;
		}

		RenderableSprite3D.__init__=function(){
			RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW=RenderableSprite3D.shaderDefines.registerDefine("RECEIVESHADOW");
			RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV=RenderableSprite3D.shaderDefines.registerDefine("SCALEOFFSETLIGHTINGMAPUV");
			RenderableSprite3D.SAHDERDEFINE_LIGHTMAP=RenderableSprite3D.shaderDefines.registerDefine("LIGHTMAP");
		}

		RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW=0;
		RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV=0;
		RenderableSprite3D.SAHDERDEFINE_LIGHTMAP=0;
		RenderableSprite3D.LIGHTMAPSCALEOFFSET=2;
		RenderableSprite3D.LIGHTMAP=3;
		__static(RenderableSprite3D,
		['shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1();}
		]);
		return RenderableSprite3D;
	})(Sprite3D)


	/**
	*<code>Terrain</code> 类用于创建地块。
	*/
	//class laya.d3.terrain.Terrain extends laya.d3.core.Sprite3D
	var Terrain=(function(_super){
		function Terrain(terrainRes){
			this._terrainRes=null;
			this._lightmapScaleOffset=null;
			Terrain.__super.call(this);
			this._lightmapScaleOffset=new Vector4(1,1,0,0);
			if (terrainRes){
				this._terrainRes=terrainRes;
				if (terrainRes.loaded)
					this.buildTerrain(terrainRes);
				else
				terrainRes.once("loaded",this,this.buildTerrain);
			}
		}

		__class(Terrain,'laya.d3.terrain.Terrain',_super);
		var __proto=Terrain.prototype;
		/**
		*@inheritDoc
		*/
		__proto._parseCustomProps=function(rootNode,innerResouMap,customProps){
			this.terrainRes=Loader.getRes(innerResouMap[customProps.dataPath]);
			var lightmapIndex=customProps.lightmapIndex;
			if (lightmapIndex !=null)
				this.setLightmapIndex(lightmapIndex);
			var lightmapScaleOffsetArray=customProps.lightmapScaleOffset;
			if (lightmapScaleOffsetArray)
				this.setLightmapScaleOffset(new Vector4(lightmapScaleOffsetArray[0],lightmapScaleOffsetArray[1],lightmapScaleOffsetArray[2],lightmapScaleOffsetArray[3]));
		}

		__proto.setLightmapIndex=function(value){
			for (var i=0;i < this._children.length;i++){
				var terrainChunk=this._children[i];
				terrainChunk.terrainRender.lightmapIndex=value;
			}
		}

		__proto.setLightmapScaleOffset=function(value){
			if (!value)return;
			value.cloneTo(this._lightmapScaleOffset);
			for (var i=0;i < this._children.length;i++){
				var terrainChunk=this._children[i];
				terrainChunk.terrainRender.lightmapScaleOffset=this._lightmapScaleOffset;
			}
		}

		__proto.disableLight=function(){
			for (var i=0,n=this._children.length;i < n;i++){
				var terrainChunk=this._children[i];
				for (var j=0,m=terrainChunk._render.sharedMaterials.length;j < m;j++){
					var terrainMaterial=terrainChunk._render.sharedMaterials [j];
					terrainMaterial.disableLight();
				}
			}
		}

		__proto.buildTerrain=function(terrainRes){
			var chunkNumX=terrainRes._chunkNumX;
			var chunkNumZ=terrainRes._chunkNumZ;
			var heightData=terrainRes._heightData;
			var n=0;
			for (var i=0;i < chunkNumZ;i++){
				for (var j=0;j < chunkNumX;j++){
					var terrainChunk=new TerrainChunk(j,i,terrainRes._gridSize,heightData._terrainHeightData,heightData._width,heightData._height,terrainRes._cameraCoordinateInverse);
					var chunkInfo=terrainRes._chunkInfos[n++];
					for (var k=0;k < chunkInfo.alphaMap.length;k++){
						var nNum=chunkInfo.detailID[k].length;
						var sDetialTextureUrl1=(nNum > 0)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][0]].diffuseTexture :null;
						var sDetialTextureUrl2=(nNum > 1)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][1]].diffuseTexture :null;
						var sDetialTextureUrl3=(nNum > 2)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][2]].diffuseTexture :null;
						var sDetialTextureUrl4=(nNum > 3)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][3]].diffuseTexture :null;
						var detialScale1=(nNum > 0)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][0]].scale :null;
						var detialScale2=(nNum > 1)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][1]].scale :null;
						var detialScale3=(nNum > 2)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][2]].scale :null;
						var detialScale4=(nNum > 3)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][3]].scale :null;
						terrainChunk.buildRenderElementAndMaterial(nNum,chunkInfo.normalMap,chunkInfo.alphaMap[k],sDetialTextureUrl1,sDetialTextureUrl2,sDetialTextureUrl3,sDetialTextureUrl4,terrainRes._materialInfo.ambientColor,terrainRes._materialInfo.diffuseColor,terrainRes._materialInfo.specularColor,detialScale1 ? detialScale1.x :1,detialScale1 ? detialScale1.y :1,detialScale2 ? detialScale2.x :1,detialScale2 ? detialScale2.y :1,detialScale3 ? detialScale3.x :1,detialScale3 ? detialScale3.y :1,detialScale4 ? detialScale4.x :1,detialScale4 ? detialScale4.y :1);
					}
					terrainChunk.terrainRender.receiveShadow=true;
					terrainChunk.terrainRender.lightmapScaleOffset=this._lightmapScaleOffset;
					this.addChild(terrainChunk);
				}
			}
		}

		/**
		*获取地形X轴长度。
		*@return 地形X轴长度。
		*/
		__proto.width=function(){
			return this._terrainRes._chunkNumX *TerrainLeaf.CHUNK_GRID_NUM *this._terrainRes._gridSize;
		}

		/**
		*获取地形Z轴长度。
		*@return 地形Z轴长度。
		*/
		__proto.depth=function(){
			return this._terrainRes._chunkNumZ *TerrainLeaf.CHUNK_GRID_NUM *this._terrainRes._gridSize;
		}

		/**
		*获取地形高度。
		*@param x X轴坐标。
		*@param z Z轴坐标。
		*/
		__proto.getHeightXZ=function(x,z){
			if (!this._terrainRes || !this._terrainRes.loaded)
				return NaN;
			x-=this.transform.position.x;
			z-=this.transform.position.z;
			if (!Terrain.__VECTOR3__){
				Terrain.__VECTOR3__=new Vector3();
			}
			Terrain.__VECTOR3__.elements[0]=x;
			Terrain.__VECTOR3__.elements[1]=0;
			Terrain.__VECTOR3__.elements[2]=z;
			Vector3.transformV3ToV3(Terrain.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX_INV__,Terrain.__VECTOR3__);
			x=Terrain.__VECTOR3__.elements[0];
			z=Terrain.__VECTOR3__.elements[2];
			if (x < 0 || x > this.width()|| z < 0 || z > this.depth())
				return NaN;
			var gridSize=this._terrainRes._gridSize;
			var nIndexX=parseInt(""+x / gridSize);
			var nIndexZ=parseInt(""+z / gridSize);
			var offsetX=x-nIndexX *gridSize;
			var offsetZ=z-nIndexZ *gridSize;
			var h1=NaN;
			var h2=NaN;
			var h3=NaN;
			var u=NaN;
			var v=NaN;
			var heightData=this._terrainRes._heightData;
			if (offsetX+offsetZ > gridSize){
				h1=heightData._terrainHeightData[(nIndexZ+1-1)*heightData._width+nIndexX+1];
				h2=heightData._terrainHeightData[(nIndexZ+1-1)*heightData._width+nIndexX];
				h3=heightData._terrainHeightData[(nIndexZ-1)*heightData._width+nIndexX+1];
				u=(gridSize-offsetX)/ gridSize;
				v=(gridSize-offsetZ)/ gridSize;
				return h1+(h2-h1)*u+(h3-h1)*v;
				}else {
				h1=heightData._terrainHeightData[Math.max(0.0,nIndexZ-1)*heightData._width+nIndexX];
				h2=heightData._terrainHeightData[Math.min(heightData._width *heightData._height-1,(nIndexZ+1-1)*heightData._width+nIndexX)];
				h3=heightData._terrainHeightData[Math.min(heightData._width *heightData._height-1,Math.max(0.0,nIndexZ-1)*heightData._width+nIndexX+1)];
				u=offsetX / gridSize;
				v=offsetZ / gridSize;
				return h1+(h2-h1)*v+(h3-h1)*u;
			}
		}

		__getset(0,__proto,'terrainRes',null,function(value){
			if (value){
				this._terrainRes=value;
				if (value.loaded)
					this.buildTerrain(value);
				else
				value.once("loaded",this,this.buildTerrain);
			}
		});

		Terrain.load=function(url){
			return Laya.loader.create(url,null,null,Terrain,null,1,false);
		}

		Terrain.RENDER_LINE_MODEL=false;
		Terrain.LOD_TOLERANCE_VALUE=4;
		Terrain.LOD_DISTANCE_FACTOR=2.0;
		Terrain.__VECTOR3__=null
		return Terrain;
	})(Sprite3D)


	/**
	*<code>Camera</code> 类用于创建摄像机。
	*/
	//class laya.d3.core.Camera extends laya.d3.core.BaseCamera
	var Camera=(function(_super){
		function Camera(aspectRatio,nearPlane,farPlane){
			//this._aspectRatio=NaN;
			//this._viewport=null;
			//this._normalizedViewport=null;
			//this._viewMatrix=null;
			//this._projectionMatrix=null;
			//this._projectionViewMatrix=null;
			//this._projectionViewMatrixNoTranslateScale=null;
			//this._boundFrustumUpdate=false;
			//this._boundFrustum=null;
			//this._orientedBoundBox=null;
			(aspectRatio===void 0)&& (aspectRatio=0);
			(nearPlane===void 0)&& (nearPlane=0.3);
			(farPlane===void 0)&& (farPlane=1000);
			this._viewMatrix=new Matrix4x4();
			this._projectionMatrix=new Matrix4x4();
			this._projectionViewMatrix=new Matrix4x4();
			this._projectionViewMatrixNoTranslateScale=new Matrix4x4();
			this._viewport=new Viewport(0,0,0,0);
			this._normalizedViewport=new Viewport(0,0,1,1);
			this._aspectRatio=aspectRatio;
			this._boundFrustumUpdate=true;
			this._boundFrustum=new BoundFrustum(Matrix4x4.DEFAULT);
			Camera.__super.call(this,nearPlane,farPlane);
			this.transform.on("worldmatrixneedchanged",this,this._onWorldMatrixChanged);
		}

		__class(Camera,'laya.d3.core.Camera',_super);
		var __proto=Camera.prototype;
		/**
		*@private
		*/
		__proto._calculationViewport=function(normalizedViewport,width,height){
			this._viewport.x=Math.min(Math.max(normalizedViewport.x *width,0),width);
			this._viewport.y=Math.min(Math.max(normalizedViewport.y *height,0),height);
			this._viewport.width=Math.min(Math.max(normalizedViewport.width *width,0),width);
			this._viewport.height=Math.min(Math.max(normalizedViewport.height *height,0),height);
		}

		/**
		*@private
		*/
		__proto._onWorldMatrixChanged=function(){
			this._boundFrustumUpdate=true;
		}

		/**
		*@inheritDoc
		*/
		__proto._parseCustomProps=function(rootNode,innerResouMap,customProps){
			_super.prototype._parseCustomProps.call(this,rootNode,innerResouMap,customProps);
			var viewport=customProps.viewport;
			this.normalizedViewport=new Viewport(viewport[0],viewport[1],viewport[2],viewport[3]);
		}

		/**
		*@inheritDoc
		*/
		__proto._calculateProjectionMatrix=function(){
			if (!this._useUserProjectionMatrix){
				if (this._orthographic){
					var halfWidth=this.orthographicVerticalSize *this.aspectRatio *0.5;
					var halfHeight=this.orthographicVerticalSize *0.5;
					Matrix4x4.createOrthoOffCenterRH(-halfWidth,halfWidth,-halfHeight,halfHeight,this.nearPlane,this.farPlane,this._projectionMatrix);
					}else {
					Matrix4x4.createPerspective(3.1416 *this.fieldOfView / 180.0,this.aspectRatio,this.nearPlane,this.farPlane,this._projectionMatrix);
				}
			}
			this._boundFrustumUpdate=true;
		}

		/**
		*@inheritDoc
		*/
		__proto._renderCamera=function(gl,state,scene){
			(scene.parallelSplitShadowMaps[0])&& (scene._renderShadowMap(gl,state,this));
			state.camera=this;
			this._prepareCameraToRender();
			Script._preRender();
			var viewMat,projectMat;
			viewMat=state.viewMatrix=this.viewMatrix;
			var renderTar=this._renderTarget;
			if (renderTar){
				renderTar.start();
				Matrix4x4.multiply(BaseCamera._invertYScaleMatrix,this._projectionMatrix,BaseCamera._invertYProjectionMatrix);
				Matrix4x4.multiply(BaseCamera._invertYScaleMatrix,this.projectionViewMatrix,BaseCamera._invertYProjectionViewMatrix);
				projectMat=state.projectionMatrix=BaseCamera._invertYProjectionMatrix;
				state.projectionViewMatrix=BaseCamera._invertYProjectionViewMatrix;
				}else {
				projectMat=state.projectionMatrix=this._projectionMatrix;
				state.projectionViewMatrix=this.projectionViewMatrix;
			}
			this._prepareCameraViewProject(viewMat,projectMat,this._projectionViewMatrixNoTranslateScale);
			state.viewport=this.viewport;
			scene._preRenderScene(gl,state,this.boundFrustum);
			scene._clear(gl,state);
			scene._renderScene(gl,state);
			Script._postRender();
			(renderTar)&& (renderTar.end());
		}

		/**
		*计算从屏幕空间生成的射线。
		*@param point 屏幕空间的位置位置。
		*@return out 输出射线。
		*/
		__proto.viewportPointToRay=function(point,out){
			Picker.calculateCursorRay(point,this.viewport,this._projectionMatrix,this.viewMatrix,null,out);
		}

		/**
		*计算从裁切空间生成的射线。
		*@param point 裁切空间的位置。。
		*@return out 输出射线。
		*/
		__proto.normalizedViewportPointToRay=function(point,out){
			var finalPoint=Camera._tempVector20;
			var vp=this.viewport;
			var nVpPosE=point.elements;
			var vpPosE=finalPoint.elements;
			vpPosE[0]=nVpPosE[0] *vp.width;
			vpPosE[1]=nVpPosE[1] *vp.height;
			Picker.calculateCursorRay(finalPoint,this.viewport,this._projectionMatrix,this.viewMatrix,null,out);
		}

		/**
		*计算从世界空间准换三维坐标到屏幕空间。
		*@param position 世界空间的位置。
		*@return out 输出位置。
		*/
		__proto.worldToViewportPoint=function(position,out){
			Matrix4x4.multiply(this._projectionMatrix,this._viewMatrix,this._projectionViewMatrix);
			this.viewport.project(position,this._projectionViewMatrix,out);
			var outE=out.elements;
			if (out.z < 0.0 || out.z > 1.0){
				outE[0]=outE[1]=outE[2]=NaN;
				}else {
				outE[0]=outE[0] / Laya.stage.clientScaleX;
				outE[1]=outE[1] / Laya.stage.clientScaleY;
			}
		}

		/**
		*计算从世界空间准换三维坐标到裁切空间。
		*@param position 世界空间的位置。
		*@return out 输出位置。
		*/
		__proto.worldToNormalizedViewportPoint=function(position,out){
			Matrix4x4.multiply(this._projectionMatrix,this._viewMatrix,this._projectionViewMatrix);
			this.normalizedViewport.project(position,this._projectionViewMatrix,out);
			var outE=out.elements;
			if (out.z < 0.0 || out.z > 1.0){
				outE[0]=outE[1]=outE[2]=NaN;
				}else {
				outE[0]=outE[0] / Laya.stage.clientScaleX;
				outE[1]=outE[1] / Laya.stage.clientScaleY;
			}
		}

		/**
		*转换2D屏幕坐标系统到3D正交投影下的坐标系统，注:只有正交模型下有效。
		*@param source 源坐标。
		*@param out 输出坐标。
		*@return 是否转换成功。
		*/
		__proto.convertScreenCoordToOrthographicCoord=function(source,out){
			if (this._orthographic){
				var clientWidth=RenderContext3D.clientWidth;
				var clientHeight=RenderContext3D.clientHeight;
				var ratioX=this.orthographicVerticalSize *this.aspectRatio / clientWidth;
				var ratioY=this.orthographicVerticalSize / clientHeight;
				var sE=source.elements;
				var oE=out.elements;
				oE[0]=(-clientWidth / 2+sE[0])*ratioX;
				oE[1]=(clientHeight / 2-sE[1])*ratioY;
				oE[2]=(this.nearPlane-this.farPlane)*(sE[2]+1)/ 2-this.nearPlane;
				Vector3.transformCoordinate(out,this.transform.worldMatrix,out);
				return true;
				}else {
				return false;
			}
		}

		/**
		*获取视图投影矩阵。
		*@return 视图投影矩阵。
		*/
		__getset(0,__proto,'projectionViewMatrix',function(){
			Matrix4x4.multiply(this.projectionMatrix,this.viewMatrix,this._projectionViewMatrix);
			return this._projectionViewMatrix;
		});

		/**
		*设置横纵比。
		*@param value 横纵比。
		*/
		/**
		*获取横纵比。
		*@return 横纵比。
		*/
		__getset(0,__proto,'aspectRatio',function(){
			if (this._aspectRatio===0){
				var vp=this.viewport;
				return vp.width / vp.height;
			}
			return this._aspectRatio;
			},function(value){
			if (value < 0)
				throw new Error("Camera: the aspect ratio has to be a positive real number.");
			this._aspectRatio=value;
			this._calculateProjectionMatrix();
		});

		/**
		*获取摄像机视锥。
		*/
		__getset(0,__proto,'boundFrustum',function(){
			if (this._boundFrustumUpdate)
				this._boundFrustum.matrix=this.projectionViewMatrix;
			return this._boundFrustum;
		});

		/**
		*设置屏幕空间的视口。
		*@param 屏幕空间的视口。
		*/
		/**
		*获取屏幕空间的视口。
		*@return 屏幕空间的视口。
		*/
		__getset(0,__proto,'viewport',function(){
			var width=0;
			var height=0;
			if (this._renderTarget){
				width=this._renderTarget.width;
				height=this._renderTarget.height;
				}else {
				width=RenderContext3D.clientWidth;
				height=RenderContext3D.clientHeight;
			}
			if (width!==this._canvasWidth || height!==this._canvasHeight){
				this._calculationViewport(this._normalizedViewport,width,height);
				this._canvasWidth=width;
				this._canvasHeight=height;
			}
			return this._viewport;
			},function(value){
			var width=0;
			var height=0;
			if (this._renderTarget){
				width=this._canvasWidth=this._renderTarget.width;
				height=this._canvasHeight=this._renderTarget.height;
				}else {
				width=this._canvasWidth=RenderContext3D.clientWidth;
				height=this._canvasHeight=RenderContext3D.clientHeight;
			}
			this._normalizedViewport.x=value.x / width;
			this._normalizedViewport.y=value.y / height;
			this._normalizedViewport.width=value.width / width;
			this._normalizedViewport.height=value.height / height;
			this._calculationViewport(this._normalizedViewport,width,height);
			this._calculateProjectionMatrix();
		});

		/**
		*设置裁剪空间的视口。
		*@return 裁剪空间的视口。
		*/
		/**
		*获取裁剪空间的视口。
		*@return 裁剪空间的视口。
		*/
		__getset(0,__proto,'normalizedViewport',function(){
			return this._normalizedViewport;
			},function(value){
			var width=0;
			var height=0;
			if (this._renderTarget){
				width=this._canvasWidth=this._renderTarget.width;
				height=this._canvasHeight=this._renderTarget.height;
				}else {
				width=this._canvasWidth=RenderContext3D.clientWidth;
				height=this._canvasHeight=RenderContext3D.clientHeight;
			}
			this._normalizedViewport=value;
			this._calculationViewport(value,width,height);
			this._calculateProjectionMatrix();
		});

		/**设置投影矩阵。*/
		/**获取投影矩阵。*/
		__getset(0,__proto,'projectionMatrix',function(){
			return this._projectionMatrix;
			},function(value){
			this._projectionMatrix=value;
			this._useUserProjectionMatrix=true;
		});

		/**
		*获取视图矩阵。
		*@return 视图矩阵。
		*/
		__getset(0,__proto,'viewMatrix',function(){
			this.transform.worldMatrix.invert(this._viewMatrix);
			return this._viewMatrix;
		});

		__static(Camera,
		['_tempVector20',function(){return this._tempVector20=new Vector2();}
		]);
		return Camera;
	})(BaseCamera)


	/**
	*<code>DirectionLight</code> 类用于创建平行光。
	*/
	//class laya.d3.core.light.DirectionLight extends laya.d3.core.light.LightSprite
	var DirectionLight=(function(_super){
		function DirectionLight(){
			this._direction=null;
			DirectionLight.__super.call(this);
			this._direction=new Vector3();
		}

		__class(DirectionLight,'laya.d3.core.light.DirectionLight',_super);
		var __proto=DirectionLight.prototype;
		/**
		*@private
		*/
		__proto._initShadow=function(){
			if (this._shadow){
				this._parallelSplitShadowMap=new ParallelSplitShadowMap();
				this.scene.parallelSplitShadowMaps.push(this._parallelSplitShadowMap);
				this.transform.worldMatrix.getForward(this._direction);
				Vector3.normalize(this._direction,this._direction);
				this._parallelSplitShadowMap.setInfo(this.scene,this._shadowFarPlane,this._direction,this._shadowMapSize,this._shadowMapCount,this._shadowMapPCFType);
				}else {
				var defineDatas=this._scene._defineDatas;
				var parallelSplitShadowMaps=this.scene.parallelSplitShadowMaps;
				parallelSplitShadowMaps.splice(parallelSplitShadowMaps.indexOf(this._parallelSplitShadowMap),1);
				this._parallelSplitShadowMap.disposeAllRenderTarget();
				this._parallelSplitShadowMap=null;
				defineDatas.remove(Scene.SHADERDEFINE_SHADOW_PSSM1);
				defineDatas.remove(Scene.SHADERDEFINE_SHADOW_PSSM2);
				defineDatas.remove(Scene.SHADERDEFINE_SHADOW_PSSM3);
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._addSelfRenderObjects=function(){
			_super.prototype._addSelfRenderObjects.call(this);
			this._shadow && (this._initShadow());
		}

		/**
		*@inheritDoc
		*/
		__proto._clearSelfRenderObjects=function(){
			var shaderValue=this._scene._shaderValues;
			shaderValue.setVector(4,null);
			shaderValue.setVector(3,null);
			this._scene._defineDatas.remove(Scene.SHADERDEFINE_DIRECTIONLIGHT);
		}

		/**
		*更新平行光相关渲染状态参数。
		*@param state 渲染状态参数。
		*/
		__proto._prepareToScene=function(state){
			var scene=state.scene;
			if (scene.enableLight && this._activeInHierarchy){
				var defineDatas=scene._defineDatas;
				var shaderValue=scene._shaderValues;
				defineDatas.add(Scene.SHADERDEFINE_DIRECTIONLIGHT);
				Vector3.scale(this.color,this._intensity,this._intensityColor);
				shaderValue.setVector(4,this._intensityColor);
				this.transform.worldMatrix.getForward(this._direction);
				Vector3.normalize(this._direction,this._direction);
				shaderValue.setVector(3,this._direction);
				return true;
				}else {
				defineDatas.remove(Scene.SHADERDEFINE_DIRECTIONLIGHT);
				return false;
			}
		}

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'shadow',_super.prototype._$get_shadow,function(value){
			if (this._shadow!==value){
				this._shadow=value;
				(this.scene)&& (this._initShadow());
			}
		});

		return DirectionLight;
	})(LightSprite)


	/**
	*<code>MeshSprite3D</code> 类用于创建网格。
	*/
	//class laya.d3.core.MeshSprite3D extends laya.d3.core.RenderableSprite3D
	var MeshSprite3D=(function(_super){
		function MeshSprite3D(mesh,name){
			//this._meshFilter=null;
			MeshSprite3D.__super.call(this,name);
			this._meshFilter=new MeshFilter(this);
			this._render=new MeshRender(this,4);
			this._meshFilter.on("meshchanged",this,this._onMeshChanged);
			(mesh)&& (this._meshFilter.sharedMesh=mesh);
		}

		__class(MeshSprite3D,'laya.d3.core.MeshSprite3D',_super);
		var __proto=MeshSprite3D.prototype;
		/**
		*@private
		*/
		__proto._changeRenderObjectByMesh=function(index){
			var renderObjects=this._render._renderElements;
			var renderElement=renderObjects[index];
			(renderElement)|| (renderElement=renderObjects[index]=new SubMeshRenderElement());
			var material=this._render.sharedMaterials[index];
			(material)|| (material=StandardMaterial.defaultMaterial);
			var renderObj=this._meshFilter.sharedMesh._getSubMesh(index);
			renderElement.transform=this._transform;
			renderElement.render=this._render;
			renderElement.geometry=renderObj;
			renderElement.material=material;
			return renderElement;
		}

		/**
		*@private
		*/
		__proto._changeRenderObjectsByMesh=function(){
			var renderElementsCount=this._meshFilter.sharedMesh.subMeshCount;
			this._render._renderElements.length=renderElementsCount;
			for (var i=0;i < renderElementsCount;i++)
			this._changeRenderObjectByMesh(i);
		}

		/**
		*@private
		*/
		__proto._onMeshChanged=function(meshFilter){
			var mesh=meshFilter.sharedMesh;
			if (mesh.loaded)
				this._changeRenderObjectsByMesh();
			else
			mesh.once("loaded",this,this._onMeshLoaded);
		}

		/**
		*@private
		*/
		__proto._onMeshLoaded=function(sender){
			(sender===this.meshFilter.sharedMesh)&& (this._changeRenderObjectsByMesh());
		}

		/**
		*@inheritDoc
		*/
		__proto._parseCustomProps=function(rootNode,innerResouMap,customProps){
			var render=this.meshRender;
			var lightmapIndex=customProps.lightmapIndex;
			(lightmapIndex !=null)&& (render.lightmapIndex=lightmapIndex);
			var lightmapScaleOffsetArray=customProps.lightmapScaleOffset;
			(lightmapScaleOffsetArray)&& (render.lightmapScaleOffset=new Vector4(lightmapScaleOffsetArray[0],lightmapScaleOffsetArray[1],lightmapScaleOffsetArray[2],lightmapScaleOffsetArray[3]));
			var meshPath,mesh;
			meshPath=customProps.meshPath;
			if (meshPath){
				mesh=Loader.getRes(innerResouMap[meshPath]);
				this.meshFilter.sharedMesh=mesh;
			};
			var materials=customProps.materials;
			if (materials){
				var sharedMaterials=render.sharedMaterials;
				var materialCount=materials.length;
				sharedMaterials.length=materialCount;
				for (var i=0;i < materialCount;i++)
				sharedMaterials[i]=Loader.getRes(innerResouMap[materials[i].path]);
				render.sharedMaterials=sharedMaterials;
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._addToInitStaticBatchManager=function(){
			MeshSprite3DStaticBatchManager.instance._addBatchSprite(this);
		}

		/**
		*@inheritDoc
		*/
		__proto.cloneTo=function(destObject){
			var meshSprite3D=destObject;
			meshSprite3D._meshFilter.sharedMesh=this._meshFilter.sharedMesh;
			var meshRender=this._render;
			var destMeshRender=meshSprite3D._render;
			destMeshRender.enable=meshRender.enable;
			destMeshRender.sharedMaterials=meshRender.sharedMaterials;
			destMeshRender.castShadow=meshRender.castShadow;
			var lightmapScaleOffset=meshRender.lightmapScaleOffset;
			lightmapScaleOffset && (destMeshRender.lightmapScaleOffset=lightmapScaleOffset.clone());
			destMeshRender.lightmapIndex=meshRender.lightmapIndex;
			destMeshRender.receiveShadow=meshRender.receiveShadow;
			destMeshRender.sortingFudge=meshRender.sortingFudge;
			laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
		}

		/**
		*@inheritDoc
		*/
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			if (this.destroyed)
				return;
			_super.prototype.destroy.call(this,destroyChild);
			this._meshFilter._destroy();
		}

		/**
		*获取网格过滤器。
		*@return 网格过滤器。
		*/
		__getset(0,__proto,'meshFilter',function(){
			return this._meshFilter;
		});

		/**
		*获取网格渲染器。
		*@return 网格渲染器。
		*/
		__getset(0,__proto,'meshRender',function(){
			return this._render;
		});

		MeshSprite3D.__init__=function(){
			StaticBatchManager._registerManager(MeshSprite3DStaticBatchManager.instance);
			DynamicBatchManager._registerManager(MeshSprite3DDynamicBatchManager.instance);
		}

		MeshSprite3D.load=function(url){
			return Laya.loader.create(url,null,null,MeshSprite3D);
		}

		return MeshSprite3D;
	})(RenderableSprite3D)


	/**
	*<code>ShuriKenParticle3D</code> 3D粒子。
	*/
	//class laya.d3.core.particleShuriKen.ShuriKenParticle3D extends laya.d3.core.RenderableSprite3D
	var ShuriKenParticle3D=(function(_super){
		function ShuriKenParticle3D(){
			//this._particleSystem=null;
			ShuriKenParticle3D.__super.call(this,null);
			this._render=new ShurikenParticleRender(this,52);
			this._particleSystem=new ShurikenParticleSystem(this);
			var elements=this._render._renderElements;
			var element=elements[0]=new RenderElement();
			element.transform=this._transform;
			element.render=this._render;
			element.geometry=this._particleSystem;
			element.material=ShurikenParticleMaterial.defaultMaterial;
		}

		__class(ShuriKenParticle3D,'laya.d3.core.particleShuriKen.ShuriKenParticle3D',_super);
		var __proto=ShuriKenParticle3D.prototype;
		/**
		*@private
		*/
		__proto._initParticleVelocity=function(gradientData){
			var gradient=new GradientDataNumber();
			var velocitysData=gradientData.velocitys;
			for (var i=0,n=velocitysData.length;i < n;i++){
				var valueData=velocitysData[i];
				gradient.add(valueData.key,valueData.value);
			}
			return gradient;
		}

		/**
		*@private
		*/
		__proto._initParticleColor=function(gradientColorData){
			var gradientColor=new GradientDataColor();
			var alphasData=gradientColorData.alphas;
			var i=0,n=0;
			for (i=0,n=alphasData.length;i < n;i++){
				var alphaData=alphasData[i];
				gradientColor.addAlpha(alphaData.key,alphaData.value);
			};
			var rgbsData=gradientColorData.rgbs;
			for (i=0,n=rgbsData.length;i < n;i++){
				var rgbData=rgbsData[i];
				var rgbValue=rgbData.value;
				gradientColor.addRGB(rgbData.key,new Vector3(rgbValue[0],rgbValue[1],rgbValue[2]));
			}
			return gradientColor;
		}

		/**
		*@private
		*/
		__proto._initParticleSize=function(gradientSizeData){
			var gradientSize=new GradientDataNumber();
			var sizesData=gradientSizeData.sizes;
			for (var i=0,n=sizesData.length;i < n;i++){
				var valueData=sizesData[i];
				gradientSize.add(valueData.key,valueData.value);
			}
			return gradientSize;
		}

		/**
		*@private
		*/
		__proto._initParticleRotation=function(gradientData){
			var gradient=new GradientDataNumber();
			var angularVelocitysData=gradientData.angularVelocitys;
			for (var i=0,n=angularVelocitysData.length;i < n;i++){
				var valueData=angularVelocitysData[i];
				gradient.add(valueData.key,valueData.value / 180.0 *Math.PI);
			}
			return gradient;
		}

		/**
		*@private
		*/
		__proto._initParticleFrame=function(overTimeFramesData){
			var overTimeFrame=new GradientDataInt();
			var framesData=overTimeFramesData.frames;
			for (var i=0,n=framesData.length;i < n;i++){
				var frameData=framesData[i];
				overTimeFrame.add(frameData.key,frameData.value);
			}
			return overTimeFrame;
		}

		/**
		*@inheritDoc
		*/
		__proto._parseCustomProps=function(rootNode,innerResouMap,customProps){
			var anglelToRad=Math.PI / 180.0;
			var i=0,n=0;
			var particleRender=this.particleRender;
			var material;
			var materialData=customProps.material;
			material=Loader.getRes(innerResouMap[materialData.path]);
			particleRender.sharedMaterial=material;
			var meshPath=customProps.meshPath;
			(meshPath)&& (particleRender.mesh=Loader.getRes(innerResouMap[meshPath]));
			particleRender.renderMode=customProps.renderMode;
			particleRender.stretchedBillboardCameraSpeedScale=customProps.stretchedBillboardCameraSpeedScale;
			particleRender.stretchedBillboardSpeedScale=customProps.stretchedBillboardSpeedScale;
			particleRender.stretchedBillboardLengthScale=customProps.stretchedBillboardLengthScale;
			particleRender.sortingFudge=customProps.sortingFudge ? customProps.sortingFudge :0.0;
			var particleSystem=this.particleSystem;
			particleSystem.isPerformanceMode=customProps.isPerformanceMode;
			particleSystem.duration=customProps.duration;
			particleSystem.looping=customProps.looping;
			particleSystem.prewarm=customProps.prewarm;
			particleSystem.startDelayType=customProps.startDelayType;
			particleSystem.startDelay=customProps.startDelay;
			particleSystem.startDelayMin=customProps.startDelayMin;
			particleSystem.startDelayMax=customProps.startDelayMax;
			particleSystem.startLifetimeType=customProps.startLifetimeType;
			particleSystem.startLifetimeConstant=customProps.startLifetimeConstant;
			particleSystem.startLifeTimeGradient=ShuriKenParticle3D._initStartLife(customProps.startLifetimeGradient);
			particleSystem.startLifetimeConstantMin=customProps.startLifetimeConstantMin;
			particleSystem.startLifetimeConstantMax=customProps.startLifetimeConstantMax;
			particleSystem.startLifeTimeGradientMin=ShuriKenParticle3D._initStartLife(customProps.startLifetimeGradientMin);
			particleSystem.startLifeTimeGradientMax=ShuriKenParticle3D._initStartLife(customProps.startLifetimeGradientMax);
			particleSystem.startSpeedType=customProps.startSpeedType;
			particleSystem.startSpeedConstant=customProps.startSpeedConstant;
			particleSystem.startSpeedConstantMin=customProps.startSpeedConstantMin;
			particleSystem.startSpeedConstantMax=customProps.startSpeedConstantMax;
			particleSystem.threeDStartSize=customProps.threeDStartSize;
			particleSystem.startSizeType=customProps.startSizeType;
			particleSystem.startSizeConstant=customProps.startSizeConstant;
			var startSizeConstantSeparateArray=customProps.startSizeConstantSeparate;
			var startSizeConstantSeparateElement=particleSystem.startSizeConstantSeparate.elements;
			startSizeConstantSeparateElement[0]=startSizeConstantSeparateArray[0];
			startSizeConstantSeparateElement[1]=startSizeConstantSeparateArray[1];
			startSizeConstantSeparateElement[2]=startSizeConstantSeparateArray[2];
			particleSystem.startSizeConstantMin=customProps.startSizeConstantMin;
			particleSystem.startSizeConstantMax=customProps.startSizeConstantMax;
			var startSizeConstantMinSeparateArray=customProps.startSizeConstantMinSeparate;
			var startSizeConstantMinSeparateElement=particleSystem.startSizeConstantMinSeparate.elements;
			startSizeConstantMinSeparateElement[0]=startSizeConstantMinSeparateArray[0];
			startSizeConstantMinSeparateElement[1]=startSizeConstantMinSeparateArray[1];
			startSizeConstantMinSeparateElement[2]=startSizeConstantMinSeparateArray[2];
			var startSizeConstantMaxSeparateArray=customProps.startSizeConstantMaxSeparate;
			var startSizeConstantMaxSeparateElement=particleSystem.startSizeConstantMaxSeparate.elements;
			startSizeConstantMaxSeparateElement[0]=startSizeConstantMaxSeparateArray[0];
			startSizeConstantMaxSeparateElement[1]=startSizeConstantMaxSeparateArray[1];
			startSizeConstantMaxSeparateElement[2]=startSizeConstantMaxSeparateArray[2];
			particleSystem.threeDStartRotation=customProps.threeDStartRotation;
			particleSystem.startRotationType=customProps.startRotationType;
			particleSystem.startRotationConstant=customProps.startRotationConstant *anglelToRad;
			var startRotationConstantSeparateArray=customProps.startRotationConstantSeparate;
			var startRotationConstantSeparateElement=particleSystem.startRotationConstantSeparate.elements;
			startRotationConstantSeparateElement[0]=startRotationConstantSeparateArray[0] *anglelToRad;
			startRotationConstantSeparateElement[1]=startRotationConstantSeparateArray[1] *anglelToRad;
			startRotationConstantSeparateElement[2]=startRotationConstantSeparateArray[2] *anglelToRad;
			particleSystem.startRotationConstantMin=customProps.startRotationConstantMin *anglelToRad;
			particleSystem.startRotationConstantMax=customProps.startRotationConstantMax *anglelToRad;
			var startRotationConstantMinSeparateArray=customProps.startRotationConstantMinSeparate;
			var startRotationConstantMinSeparateElement=particleSystem.startRotationConstantMinSeparate.elements;
			startRotationConstantMinSeparateElement[0]=startRotationConstantMinSeparateArray[0] *anglelToRad;
			startRotationConstantMinSeparateElement[1]=startRotationConstantMinSeparateArray[1] *anglelToRad;
			startRotationConstantMinSeparateElement[2]=startRotationConstantMinSeparateArray[2] *anglelToRad;
			var startRotationConstantMaxSeparateArray=customProps.startRotationConstantMaxSeparate;
			var startRotationConstantMaxSeparateElement=particleSystem.startRotationConstantMaxSeparate.elements;
			startRotationConstantMaxSeparateElement[0]=startRotationConstantMaxSeparateArray[0] *anglelToRad;
			startRotationConstantMaxSeparateElement[1]=startRotationConstantMaxSeparateArray[1] *anglelToRad;
			startRotationConstantMaxSeparateElement[2]=startRotationConstantMaxSeparateArray[2] *anglelToRad;
			particleSystem.randomizeRotationDirection=customProps.randomizeRotationDirection;
			particleSystem.startColorType=customProps.startColorType;
			var startColorConstantArray=customProps.startColorConstant;
			var startColorConstantElement=particleSystem.startColorConstant.elements;
			startColorConstantElement[0]=startColorConstantArray[0];
			startColorConstantElement[1]=startColorConstantArray[1];
			startColorConstantElement[2]=startColorConstantArray[2];
			startColorConstantElement[3]=startColorConstantArray[3];
			var startColorConstantMinArray=customProps.startColorConstantMin;
			var startColorConstantMinElement=particleSystem.startColorConstantMin.elements;
			startColorConstantMinElement[0]=startColorConstantMinArray[0];
			startColorConstantMinElement[1]=startColorConstantMinArray[1];
			startColorConstantMinElement[2]=startColorConstantMinArray[2];
			startColorConstantMinElement[3]=startColorConstantMinArray[3];
			var startColorConstantMaxArray=customProps.startColorConstantMax;
			var startColorConstantMaxElement=particleSystem.startColorConstantMax.elements;
			startColorConstantMaxElement[0]=startColorConstantMaxArray[0];
			startColorConstantMaxElement[1]=startColorConstantMaxArray[1];
			startColorConstantMaxElement[2]=startColorConstantMaxArray[2];
			startColorConstantMaxElement[3]=startColorConstantMaxArray[3];
			particleSystem.gravityModifier=customProps.gravityModifier;
			particleSystem.simulationSpace=customProps.simulationSpace;
			particleSystem.scaleMode=customProps.scaleMode;
			particleSystem.playOnAwake=customProps.playOnAwake;
			particleSystem.maxParticles=customProps.maxParticles;
			var autoRandomSeed=customProps.autoRandomSeed;
			(autoRandomSeed !=null)&& (particleSystem.autoRandomSeed=autoRandomSeed);
			var randomSeed=customProps.randomSeed;
			(randomSeed !=null)&& (particleSystem.randomSeed[0]=randomSeed);
			var emissionData=customProps.emission;
			if (emissionData){
				var emission=particleSystem.emission;
				emission.emissionRate=emissionData.emissionRate;
				var burstsData=emissionData.bursts;
				if (burstsData)
					for (i=0,n=burstsData.length;i < n;i++){
					var brust=burstsData[i];
					emission.addBurst(new Burst(brust.time,brust.min,brust.max));
				}
				emission.enbale=emissionData.enable;
				}else {
				emission.enbale=false;
			};
			var shapeData=customProps.shape;
			if (shapeData){
				var shape;
				switch (shapeData.shapeType){
					case 0:;
						var sphereShape;
						shape=sphereShape=new SphereShape();
						sphereShape.radius=shapeData.sphereRadius;
						sphereShape.emitFromShell=shapeData.sphereEmitFromShell;
						sphereShape.randomDirection=shapeData.sphereRandomDirection;
						break ;
					case 1:;
						var hemiSphereShape;
						shape=hemiSphereShape=new HemisphereShape();
						hemiSphereShape.radius=shapeData.hemiSphereRadius;
						hemiSphereShape.emitFromShell=shapeData.hemiSphereEmitFromShell;
						hemiSphereShape.randomDirection=shapeData.hemiSphereRandomDirection;
						break ;
					case 2:;
						var coneShape;
						shape=coneShape=new ConeShape();
						coneShape.angle=shapeData.coneAngle *anglelToRad;
						coneShape.radius=shapeData.coneRadius;
						coneShape.length=shapeData.coneLength;
						coneShape.emitType=shapeData.coneEmitType;
						coneShape.randomDirection=shapeData.coneRandomDirection;
						break ;
					case 3:;
						var boxShape;
						shape=boxShape=new BoxShape();
						boxShape.x=shapeData.boxX;
						boxShape.y=shapeData.boxY;
						boxShape.z=shapeData.boxZ;
						boxShape.randomDirection=shapeData.boxRandomDirection;
						break ;
					case 7:;
						var circleShape;
						shape=circleShape=new CircleShape();
						circleShape.radius=shapeData.circleRadius;
						circleShape.arc=shapeData.circleArc *anglelToRad;
						circleShape.emitFromEdge=shapeData.circleEmitFromEdge;
						circleShape.randomDirection=shapeData.circleRandomDirection;
						break ;
					default :;
						var tempShape;
						shape=tempShape=new CircleShape();
						tempShape.radius=shapeData.circleRadius;
						tempShape.arc=shapeData.circleArc *anglelToRad;
						tempShape.emitFromEdge=shapeData.circleEmitFromEdge;
						tempShape.randomDirection=shapeData.circleRandomDirection;
						break ;
					}
				shape.enable=shapeData.enable;
				particleSystem.shape=shape;
			};
			var velocityOverLifetimeData=customProps.velocityOverLifetime;
			if (velocityOverLifetimeData){
				var velocityData=velocityOverLifetimeData.velocity;
				var velocity;
				switch (velocityData.type){
					case 0:;
						var constantData=velocityData.constant;
						velocity=GradientVelocity.createByConstant(new Vector3(constantData[0],constantData[1],constantData[2]));
						break ;
					case 1:
						velocity=GradientVelocity.createByGradient(this._initParticleVelocity(velocityData.gradientX),this._initParticleVelocity(velocityData.gradientY),this._initParticleVelocity(velocityData.gradientZ));
						break ;
					case 2:;
						var constantMinData=velocityData.constantMin;
						var constantMaxData=velocityData.constantMax;
						velocity=GradientVelocity.createByRandomTwoConstant(new Vector3(constantMinData[0],constantMinData[1],constantMinData[2]),new Vector3(constantMaxData[0],constantMaxData[1],constantMaxData[2]));
						break ;
					case 3:
						velocity=GradientVelocity.createByRandomTwoGradient(this._initParticleVelocity(velocityData.gradientXMin),this._initParticleVelocity(velocityData.gradientXMax),this._initParticleVelocity(velocityData.gradientYMin),this._initParticleVelocity(velocityData.gradientYMax),this._initParticleVelocity(velocityData.gradientZMin),this._initParticleVelocity(velocityData.gradientZMax));
						break ;
					};
				var velocityOverLifetime=new VelocityOverLifetime(velocity);
				velocityOverLifetime.space=velocityOverLifetimeData.space;
				velocityOverLifetime.enbale=velocityOverLifetimeData.enable;
				particleSystem.velocityOverLifetime=velocityOverLifetime;
			};
			var colorOverLifetimeData=customProps.colorOverLifetime;
			if (colorOverLifetimeData){
				var colorData=colorOverLifetimeData.color;
				var color;
				switch (colorData.type){
					case 0:;
						var constColorData=colorData.constant;
						color=GradientColor.createByConstant(new Vector4(constColorData[0],constColorData[1],constColorData[2],constColorData[3]));
						break ;
					case 1:
						color=GradientColor.createByGradient(this._initParticleColor(colorData.gradient));
						break ;
					case 2:;
						var minConstColorData=colorData.constantMin;
						var maxConstColorData=colorData.constantMax;
						color=GradientColor.createByRandomTwoConstant(new Vector4(minConstColorData[0],minConstColorData[1],minConstColorData[2],minConstColorData[3]),new Vector4(maxConstColorData[0],maxConstColorData[1],maxConstColorData[2],maxConstColorData[3]));
						break ;
					case 3:
						color=GradientColor.createByRandomTwoGradient(this._initParticleColor(colorData.gradientMin),this._initParticleColor(colorData.gradientMax));
						break ;
					};
				var colorOverLifetime=new ColorOverLifetime(color);
				colorOverLifetime.enbale=colorOverLifetimeData.enable;
				particleSystem.colorOverLifetime=colorOverLifetime;
			};
			var sizeOverLifetimeData=customProps.sizeOverLifetime;
			if (sizeOverLifetimeData){
				var sizeData=sizeOverLifetimeData.size;
				var size;
				switch (sizeData.type){
					case 0:
						if (sizeData.separateAxes){
							size=GradientSize.createByGradientSeparate(this._initParticleSize(sizeData.gradientX),this._initParticleSize(sizeData.gradientY),this._initParticleSize(sizeData.gradientZ));
							}else {
							size=GradientSize.createByGradient(this._initParticleSize(sizeData.gradient));
						}
						break ;
					case 1:
						if (sizeData.separateAxes){
							var constantMinSeparateData=sizeData.constantMinSeparate;
							var constantMaxSeparateData=sizeData.constantMaxSeparate;
							size=GradientSize.createByRandomTwoConstantSeparate(new Vector3(constantMinSeparateData[0],constantMinSeparateData[1],constantMinSeparateData[2]),new Vector3(constantMaxSeparateData[0],constantMaxSeparateData[1],constantMaxSeparateData[2]));
							}else {
							size=GradientSize.createByRandomTwoConstant(sizeData.constantMin,sizeData.constantMax);
						}
						break ;
					case 2:
						if (sizeData.separateAxes){
							size=GradientSize.createByRandomTwoGradientSeparate(this._initParticleSize(sizeData.gradientXMin),this._initParticleSize(sizeData.gradientYMin),this._initParticleSize(sizeData.gradientZMin),this._initParticleSize(sizeData.gradientXMax),this._initParticleSize(sizeData.gradientYMax),this._initParticleSize(sizeData.gradientZMax));
							}else {
							size=GradientSize.createByRandomTwoGradient(this._initParticleSize(sizeData.gradientMin),this._initParticleSize(sizeData.gradientMax));
						}
						break ;
					};
				var sizeOverLifetime=new SizeOverLifetime(size);
				sizeOverLifetime.enbale=sizeOverLifetimeData.enable;
				particleSystem.sizeOverLifetime=sizeOverLifetime;
			};
			var rotationOverLifetimeData=customProps.rotationOverLifetime;
			if (rotationOverLifetimeData){
				var angularVelocityData=rotationOverLifetimeData.angularVelocity;
				var angularVelocity;
				switch (angularVelocityData.type){
					case 0:
						if (angularVelocityData.separateAxes){
							}else {
							angularVelocity=GradientAngularVelocity.createByConstant(angularVelocityData.constant *anglelToRad);
						}
						break ;
					case 1:
						if (angularVelocityData.separateAxes){
							}else {
							angularVelocity=GradientAngularVelocity.createByGradient(this._initParticleRotation(angularVelocityData.gradient));
						}
						break ;
					case 2:
						if (angularVelocityData.separateAxes){
							var minSep=angularVelocityData.constantMinSeparate;
							var maxSep=angularVelocityData.constantMaxSeparate;
							angularVelocity=GradientAngularVelocity.createByRandomTwoConstantSeparate(new Vector3(minSep[0] *anglelToRad,minSep[1] *anglelToRad,minSep[2] *anglelToRad),new Vector3(maxSep[0] *anglelToRad,maxSep[1] *anglelToRad,maxSep[2] *anglelToRad));
							}else {
							angularVelocity=GradientAngularVelocity.createByRandomTwoConstant(angularVelocityData.constantMin *anglelToRad,angularVelocityData.constantMax *anglelToRad);
						}
						break ;
					case 3:
						if (angularVelocityData.separateAxes){
							}else {
							angularVelocity=GradientAngularVelocity.createByRandomTwoGradient(this._initParticleRotation(angularVelocityData.gradientMin),this._initParticleRotation(angularVelocityData.gradientMax));
						}
						break ;
					};
				var rotationOverLifetime=new RotationOverLifetime(angularVelocity);
				rotationOverLifetime.enbale=rotationOverLifetimeData.enable;
				particleSystem.rotationOverLifetime=rotationOverLifetime;
			};
			var textureSheetAnimationData=customProps.textureSheetAnimation;
			if (textureSheetAnimationData){
				var frameData=textureSheetAnimationData.frame;
				var frameOverTime;
				switch (frameData.type){
					case 0:
						frameOverTime=FrameOverTime.createByConstant(frameData.constant);
						break ;
					case 1:
						frameOverTime=FrameOverTime.createByOverTime(this._initParticleFrame(frameData.overTime));
						break ;
					case 2:
						frameOverTime=FrameOverTime.createByRandomTwoConstant(frameData.constantMin,frameData.constantMax);
						break ;
					case 3:
						frameOverTime=FrameOverTime.createByRandomTwoOverTime(this._initParticleFrame(frameData.overTimeMin),this._initParticleFrame(frameData.overTimeMax));
						break ;
					};
				var startFrameData=textureSheetAnimationData.startFrame;
				var startFrame;
				switch (startFrameData.type){
					case 0:
						startFrame=StartFrame.createByConstant(startFrameData.constant);
						break ;
					case 1:
						startFrame=StartFrame.createByRandomTwoConstant(startFrameData.constantMin,startFrameData.constantMax);
						break ;
					};
				var textureSheetAnimation=new TextureSheetAnimation(frameOverTime,startFrame);
				textureSheetAnimation.enable=textureSheetAnimationData.enable;
				var tilesData=textureSheetAnimationData.tiles;
				textureSheetAnimation.tiles=new Vector2(tilesData[0],tilesData[1]);
				textureSheetAnimation.type=textureSheetAnimationData.type;
				textureSheetAnimation.randomRow=textureSheetAnimationData.randomRow;
				var rowIndex=textureSheetAnimationData.rowIndex;
				(rowIndex!==undefined)&& (textureSheetAnimation.rowIndex=rowIndex);
				textureSheetAnimation.cycles=textureSheetAnimationData.cycles;
				particleSystem.textureSheetAnimation=textureSheetAnimation;
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._activeHierarchy=function(){
			laya.d3.core.Sprite3D.prototype._activeHierarchy.call(this);
			(this.particleSystem.playOnAwake)&& (this.particleSystem.play());
		}

		/**
		*@inheritDoc
		*/
		__proto._inActiveHierarchy=function(){
			laya.d3.core.Sprite3D.prototype._inActiveHierarchy.call(this);
			(this.particleSystem.isAlive)&& (this.particleSystem.simulate(0,true));
		}

		/**
		*@private
		*/
		__proto.cloneTo=function(destObject){
			var destShuriKenParticle3D=destObject;
			var destParticleSystem=destShuriKenParticle3D._particleSystem;
			this._particleSystem.cloneTo(destParticleSystem);
			var destParticleRender=destShuriKenParticle3D._render;
			var particleRender=this._render;
			destParticleRender.sharedMaterials=particleRender.sharedMaterials;
			destParticleRender.enable=particleRender.enable;
			destParticleRender.renderMode=particleRender.renderMode;
			destParticleRender.mesh=particleRender.mesh;
			destParticleRender.stretchedBillboardCameraSpeedScale=particleRender.stretchedBillboardCameraSpeedScale;
			destParticleRender.stretchedBillboardSpeedScale=particleRender.stretchedBillboardSpeedScale;
			destParticleRender.stretchedBillboardLengthScale=particleRender.stretchedBillboardLengthScale;
			destParticleRender.sortingFudge=particleRender.sortingFudge;
			laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
		}

		/**
		*<p>销毁此对象。</p>
		*@param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
		*/
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			if (this.destroyed)
				return;
			_super.prototype.destroy.call(this,destroyChild);
			this._particleSystem._destroy();
			this._particleSystem=null;
		}

		/**
		*获取粒子系统。
		*@return 粒子系统。
		*/
		__getset(0,__proto,'particleSystem',function(){
			return this._particleSystem;
		});

		/**
		*获取粒子渲染器。
		*@return 粒子渲染器。
		*/
		__getset(0,__proto,'particleRender',function(){
			return this._render;
		});

		ShuriKenParticle3D.__init__=function(){
			ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_BILLBOARD=ShuriKenParticle3D.shaderDefines.registerDefine("SPHERHBILLBOARD");
			ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD=ShuriKenParticle3D.shaderDefines.registerDefine("STRETCHEDBILLBOARD");
			ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD=ShuriKenParticle3D.shaderDefines.registerDefine("HORIZONTALBILLBOARD");
			ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD=ShuriKenParticle3D.shaderDefines.registerDefine("VERTICALBILLBOARD");
			ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME=ShuriKenParticle3D.shaderDefines.registerDefine("COLOROVERLIFETIME");
			ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME=ShuriKenParticle3D.shaderDefines.registerDefine("RANDOMCOLOROVERLIFETIME");
			ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT=ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECONSTANT");
			ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE=ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECURVE");
			ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT=ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCONSTANT");
			ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE=ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCURVE");
			ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE=ShuriKenParticle3D.shaderDefines.registerDefine("TEXTURESHEETANIMATIONCURVE");
			ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE=ShuriKenParticle3D.shaderDefines.registerDefine("TEXTURESHEETANIMATIONRANDOMCURVE");
			ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIME");
			ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMESEPERATE");
			ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECONSTANT");
			ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECURVE");
			ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCURVES");
			ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCURVES");
			ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE=ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVE");
			ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE=ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVESEPERATE");
			ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES=ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVES");
			ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE=ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVESSEPERATE");
			ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_MESH=ShuriKenParticle3D.shaderDefines.registerDefine("RENDERMODE_MESH");
			ShuriKenParticle3D.SHADERDEFINE_SHAPE=ShuriKenParticle3D.shaderDefines.registerDefine("SHAPE");
		}

		ShuriKenParticle3D.load=function(url){
			return Laya.loader.create(url,null,null,ShuriKenParticle3D);
		}

		ShuriKenParticle3D._initStartLife=function(gradientData){
			var gradient=new GradientDataNumber();
			var startLifetimesData=gradientData.startLifetimes;
			for (var i=0,n=startLifetimesData.length;i < n;i++){
				var valueData=startLifetimesData[i];
				gradient.add(valueData.key,valueData.value);
			}
			return gradient
		}

		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_BILLBOARD=0;
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD=0;
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD=0;
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD=0;
		ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME=0;
		ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME=0;
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT=0;
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE=0;
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT=0;
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE=0;
		ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE=0;
		ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE=0;
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME=0;
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE=0;
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT=0;
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE=0;
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS=0;
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES=0;
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE=0;
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE=0;
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES=0;
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE=0;
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_MESH=0;
		ShuriKenParticle3D.SHADERDEFINE_SHAPE=0;
		ShuriKenParticle3D.WORLDPOSITION=0;
		ShuriKenParticle3D.WORLDROTATION=1;
		ShuriKenParticle3D.POSITIONSCALE=4;
		ShuriKenParticle3D.SIZESCALE=5;
		ShuriKenParticle3D.SCALINGMODE=6;
		ShuriKenParticle3D.GRAVITY=7;
		ShuriKenParticle3D.THREEDSTARTROTATION=8;
		ShuriKenParticle3D.STRETCHEDBILLBOARDLENGTHSCALE=9;
		ShuriKenParticle3D.STRETCHEDBILLBOARDSPEEDSCALE=10;
		ShuriKenParticle3D.SIMULATIONSPACE=11;
		ShuriKenParticle3D.CURRENTTIME=12;
		ShuriKenParticle3D.VOLVELOCITYCONST=13;
		ShuriKenParticle3D.VOLVELOCITYGRADIENTX=14;
		ShuriKenParticle3D.VOLVELOCITYGRADIENTY=15;
		ShuriKenParticle3D.VOLVELOCITYGRADIENTZ=16;
		ShuriKenParticle3D.VOLVELOCITYCONSTMAX=17;
		ShuriKenParticle3D.VOLVELOCITYGRADIENTXMAX=18;
		ShuriKenParticle3D.VOLVELOCITYGRADIENTYMAX=19;
		ShuriKenParticle3D.VOLVELOCITYGRADIENTZMAX=20;
		ShuriKenParticle3D.VOLSPACETYPE=21;
		ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS=22;
		ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS=23;
		ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTALPHAS=24;
		ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTCOLORS=25;
		ShuriKenParticle3D.SOLSIZEGRADIENT=26;
		ShuriKenParticle3D.SOLSIZEGRADIENTX=27;
		ShuriKenParticle3D.SOLSIZEGRADIENTY=28;
		ShuriKenParticle3D.SOLSizeGradientZ=29;
		ShuriKenParticle3D.SOLSizeGradientMax=30;
		ShuriKenParticle3D.SOLSIZEGRADIENTXMAX=31;
		ShuriKenParticle3D.SOLSIZEGRADIENTYMAX=32;
		ShuriKenParticle3D.SOLSizeGradientZMAX=33;
		ShuriKenParticle3D.ROLANGULARVELOCITYCONST=34;
		ShuriKenParticle3D.ROLANGULARVELOCITYCONSTSEPRARATE=35;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENT=36;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTX=37;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTY=38;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZ=39;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTW=40;
		ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAX=41;
		ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAXSEPRARATE=42;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTMAX=43;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTXMAX=44;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTYMAX=45;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZMAX=46;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTWMAX=47;
		ShuriKenParticle3D.TEXTURESHEETANIMATIONCYCLES=48;
		ShuriKenParticle3D.TEXTURESHEETANIMATIONSUBUVLENGTH=49;
		ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTUVS=50;
		ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTMAXUVS=51;
		__static(ShuriKenParticle3D,
		['shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(RenderableSprite3D.shaderDefines);}
		]);
		return ShuriKenParticle3D;
	})(RenderableSprite3D)


	/**
	*<code>MeshSprite3D</code> 类用于创建网格。
	*/
	//class laya.d3.core.SkinnedMeshSprite3D extends laya.d3.core.RenderableSprite3D
	var SkinnedMeshSprite3D=(function(_super){
		function SkinnedMeshSprite3D(mesh,name){
			this._subMeshOffset=null;
			this._meshFilter=null;
			SkinnedMeshSprite3D.__super.call(this,name);
			this._subMeshOffset=[];
			this._meshFilter=new MeshFilter(this);
			this._render=new SkinnedMeshRender(this,4);
			this._meshFilter.on("meshchanged",this,this._onMeshChanged);
			(mesh)&& (this._meshFilter.sharedMesh=mesh);
		}

		__class(SkinnedMeshSprite3D,'laya.d3.core.SkinnedMeshSprite3D',_super);
		var __proto=SkinnedMeshSprite3D.prototype;
		/**
		*@private
		*/
		__proto._changeRenderObjectByMesh=function(index){
			var renderObjects=this._render._renderElements;
			var renderElement=renderObjects[index];
			(renderElement)|| (renderElement=renderObjects[index]=new SubMeshRenderElement());
			var material=this._render.sharedMaterials[index];
			(material)|| (material=StandardMaterial.defaultMaterial);
			var renderObj=this._meshFilter.sharedMesh._getSubMesh(index);
			renderElement.transform=this._transform;
			renderElement.render=this._render;
			renderElement.geometry=renderObj;
			renderElement.material=material;
			return renderElement;
		}

		/**
		*@private
		*/
		__proto._changeRenderObjectsByMesh=function(){
			var renderElementsCount=this._meshFilter.sharedMesh.subMeshCount;
			this._render._renderElements.length=renderElementsCount;
			for (var i=0;i < renderElementsCount;i++)
			this._changeRenderObjectByMesh(i);
		}

		/**
		*@private
		*/
		__proto._onMeshChanged=function(meshFilter){
			var mesh=meshFilter.sharedMesh;
			if (mesh.loaded)
				this._changeRenderObjectsByMesh();
			else
			mesh.once("loaded",this,this._changeRenderObjectsByMesh);
		}

		/**
		*@inheritDoc
		*/
		__proto._parseCustomProps=function(rootNode,innerResouMap,customProps){
			var render=this.skinnedMeshRender;
			var lightmapIndex=customProps.lightmapIndex;
			(lightmapIndex !=null)&& (render.lightmapIndex=lightmapIndex);
			var lightmapScaleOffsetArray=customProps.lightmapScaleOffset;
			(lightmapScaleOffsetArray)&& (render.lightmapScaleOffset=new Vector4(lightmapScaleOffsetArray[0],lightmapScaleOffsetArray[1],lightmapScaleOffsetArray[2],lightmapScaleOffsetArray[3]));
			var meshPath,mesh;
			meshPath=customProps.meshPath;
			if (meshPath){
				mesh=Loader.getRes(innerResouMap[meshPath]);
				this.meshFilter.sharedMesh=mesh;
			};
			var materials=customProps.materials;
			if (materials){
				var sharedMaterials=render.sharedMaterials;
				var materialCount=materials.length;
				sharedMaterials.length=materialCount;
				for (var i=0;i < materialCount;i++)
				sharedMaterials[i]=Loader.getRes(innerResouMap[materials[i].path]);
				render.sharedMaterials=sharedMaterials;
			};
			var rootBone=customProps.rootBone;
			(rootBone)&& (render._setRootBone(rootBone));
			var boundBox=customProps.boundBox;
			if (boundBox){
				var min=boundBox.min;
				var max=boundBox.max;
				var localBoundBox=new BoundBox(new Vector3(min[0],min[1],min[2]),new Vector3(max[0],max[1],max[2]));
				render.localBoundBox=localBoundBox;
				}else {
				render._hasIndependentBound=false;
			};
			var boundSphere=customProps.boundSphere;
			if (boundSphere){
				var center=boundSphere.center;
				var localBoundSphere=new BoundSphere(new Vector3(center[0],center[1],center[2]),boundSphere.radius);
				render.localBoundSphere=localBoundSphere;
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._changeHierarchyAnimator=function(animator){
			if (animator){
				var render=this.skinnedMeshRender;
				render._setCacheAnimator(animator);
				var avatar=animator.avatar;
				(avatar)&& (render._setCacheAvatar(avatar));
			}
			laya.d3.core.Sprite3D.prototype._changeHierarchyAnimator.call(this,animator);
		}

		/**
		*@inheritDoc
		*/
		__proto.cloneTo=function(destObject){
			var meshSprite3D=destObject;
			meshSprite3D._meshFilter.sharedMesh=this._meshFilter.sharedMesh;
			var meshRender=this._render;
			var destMeshRender=meshSprite3D._render;
			destMeshRender.enable=meshRender.enable;
			destMeshRender.sharedMaterials=meshRender.sharedMaterials;
			destMeshRender.castShadow=meshRender.castShadow;
			var lightmapScaleOffset=meshRender.lightmapScaleOffset;
			lightmapScaleOffset && (destMeshRender.lightmapScaleOffset=lightmapScaleOffset.clone());
			destMeshRender.receiveShadow=meshRender.receiveShadow;
			destMeshRender.sortingFudge=meshRender.sortingFudge;
			destMeshRender._rootBone=meshRender._rootBone;
			var lbp=meshRender.localBoundSphere;
			(lbp)&& (destMeshRender.localBoundSphere=lbp.clone());
			var lbb=meshRender.localBoundBox;
			(lbb)&& (destMeshRender.localBoundBox=lbb.clone());
			destMeshRender._hasIndependentBound=meshRender._hasIndependentBound;
			laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
		}

		/**
		*@inheritDoc
		*/
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			if (this.destroyed)
				return;
			_super.prototype.destroy.call(this,destroyChild);
			this._meshFilter._destroy();
		}

		/**
		*获取网格过滤器。
		*@return 网格过滤器。
		*/
		__getset(0,__proto,'meshFilter',function(){
			return this._meshFilter;
		});

		/**
		*获取网格渲染器。
		*@return 网格渲染器。
		*/
		__getset(0,__proto,'skinnedMeshRender',function(){
			return this._render;
		});

		SkinnedMeshSprite3D.__init__=function(){
			SkinnedMeshSprite3D.SHADERDEFINE_BONE=SkinnedMeshSprite3D.shaderDefines.registerDefine("BONE");
		}

		SkinnedMeshSprite3D.load=function(url){
			return Laya.loader.create(url,null,null,SkinnedMeshSprite3D);
		}

		SkinnedMeshSprite3D.SHADERDEFINE_BONE=0;
		SkinnedMeshSprite3D.BONES=0;
		__static(SkinnedMeshSprite3D,
		['shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(RenderableSprite3D.shaderDefines);}
		]);
		return SkinnedMeshSprite3D;
	})(RenderableSprite3D)


	/**
	*<code>TerrainChunk</code> 类用于创建地块。
	*/
	//class laya.d3.terrain.TerrainChunk extends laya.d3.core.RenderableSprite3D
	var TerrainChunk=(function(_super){
		function TerrainChunk(chunkOffsetX,chunkOffsetZ,girdSize,terrainHeightData,heightDataWidth,heightDataHeight,cameraCoordinateInverse,name){
			this._terrainFilter=null;
			TerrainChunk.__super.call(this,name);
			this._terrainFilter=new TerrainFilter(this,chunkOffsetX,chunkOffsetZ,girdSize,terrainHeightData,heightDataWidth,heightDataHeight,cameraCoordinateInverse);
			this._render=new TerrainRender(this);
		}

		__class(TerrainChunk,'laya.d3.terrain.TerrainChunk',_super);
		var __proto=TerrainChunk.prototype;
		__proto.buildRenderElementAndMaterial=function(detailNum,normalMap,alphaMapUrl,detailUrl1,detailUrl2,detailUrl3,detailUrl4,ambientColor,diffuseColor,specularColor,sx1,sy1,sx2,sy2,sx3,sy3,sx4,sy4){
			(sx1===void 0)&& (sx1=1);
			(sy1===void 0)&& (sy1=1);
			(sx2===void 0)&& (sx2=1);
			(sy2===void 0)&& (sy2=1);
			(sx3===void 0)&& (sx3=1);
			(sy3===void 0)&& (sy3=1);
			(sx4===void 0)&& (sx4=1);
			(sy4===void 0)&& (sy4=1);
			var terrainMaterial=new TerrainMaterial();
			if (diffuseColor)terrainMaterial.diffuseColor=diffuseColor;
			if (ambientColor)terrainMaterial.ambientColor=ambientColor;
			if (specularColor)terrainMaterial.specularColor=specularColor;
			terrainMaterial.splatAlphaTexture=Loader.getRes(alphaMapUrl);
			terrainMaterial.normalTexture=normalMap ? Loader.getRes(normalMap):null;
			terrainMaterial.diffuseTexture1=detailUrl1 ? Loader.getRes(detailUrl1):null;
			terrainMaterial.diffuseTexture2=detailUrl2 ? Loader.getRes(detailUrl2):null;
			terrainMaterial.diffuseTexture3=detailUrl3 ? Loader.getRes(detailUrl3):null;
			terrainMaterial.diffuseTexture4=detailUrl4 ? Loader.getRes(detailUrl4):null;
			terrainMaterial.setDiffuseScale1(sx1,sy1);
			terrainMaterial.setDiffuseScale2(sx2,sy2);
			terrainMaterial.setDiffuseScale3(sx3,sy3);
			terrainMaterial.setDiffuseScale4(sx4,sy4);
			terrainMaterial.setDetailNum(detailNum);
			if (this._render._renderElements.length !=0){
				terrainMaterial.renderMode=2;
			};
			var renderElement=new RenderElement();
			renderElement.transform=this._transform;
			renderElement.render=this._render;
			renderElement.geometry=this._terrainFilter;
			renderElement.material=terrainMaterial;
			this._render._materials.push(terrainMaterial);
			this._render._renderElements.push(renderElement);
		}

		__proto.cloneTo=function(destObject){
			console.log("Terrain Chunk can't clone");
		}

		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			if (this.destroyed)
				return;
			_super.prototype.destroy.call(this,destroyChild);
			this._terrainFilter._destroy();
			this._terrainFilter=null;
		}

		/**
		*获取地形过滤器。
		*@return 地形过滤器。
		*/
		__getset(0,__proto,'terrainFilter',function(){
			return this._terrainFilter;
		});

		/**
		*获取地形渲染器。
		*@return 地形渲染器。
		*/
		__getset(0,__proto,'terrainRender',function(){
			return this._render;
		});

		TerrainChunk.load=function(url){
			return Laya.loader.create(url,null,null,TerrainChunk,null,1,false);
		}

		return TerrainChunk;
	})(RenderableSprite3D)


	Laya.__init([EventDispatcher,LoaderManager,GLCommandEncoder,DrawText,Render,WebGLContext2D,Path,Timer,ShaderCompile]);
	new sceneModule.SceneLoadDemo();

})(window,document,Laya);
